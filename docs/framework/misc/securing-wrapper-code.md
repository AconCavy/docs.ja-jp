---
title: ラッパー コードの保護
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: 3d38a4d4fd33798cf5987f5ce67305725ad9daec
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400933"
---
# <a name="securing-wrapper-code"></a>ラッパー コードの保護
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。 呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。  
  
 呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。 完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。 単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。  
  
## <a name="delegates"></a>デリゲート  
 デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。  このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>.NET Framework バージョン 1.0 および 1.1 の場合  
 .NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
 ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。 デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。 ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>バージョン 2.0 以降のバージョンの .NET Framework では  
 以前のバージョンとは異なり、バージョン 2.0 以降の .NET Framework は、デリゲートが作成され、呼び出されたときに、デリゲートの作成者に対してセキュリティ アクションを実行します。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。  
  
- デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。  次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
## <a name="link-demands-and-wrappers"></a>リンク要求とラッパー  
 リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。  
  
 完全に信頼されたコードが[LinkDemand](link-demands.md)で保護されたプロパティ、イベント、またはメソッドを呼び出すと、呼び出し元の**LinkDemand**アクセス許可チェックが満たされると、呼び出しは成功します。 さらに、完全に信頼されたコードが、リフレクションを使用してプロパティの名前を受け取り、その**get**アクセサーを呼び出すクラスを公開する場合、ユーザー コードにこのプロパティにアクセスする権限がない場合でも **、get**アクセサーの呼び出しは成功します。 これは **、LinkDemand**が、完全に信頼されたコードである直接の呼び出し元のみをチェックするためです。 基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。  
  
 このようなセキュリティ ホールを防ぐために、共通言語ランタイムは **、LinkDemand**で保護されたメソッド、コンストラクター、プロパティ、またはイベントへの間接的な呼び出しに対する完全なスタック ウォーク要求にチェックを拡張します。 この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。  
  
## <a name="assembly-loading-wrappers"></a>アセンブリ読み込みラッパー  
 マネージド コードの読み込みに使用されるいくつかのメソッド (<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> など) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。 これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。 信頼性の低いコードに対して、ラッパーへの呼び出し元のアクセス許可より高いアクセス許可が付与されているコードの読み込みを許可しないでください。  
  
 完全な信頼のあるコード、または潜在的な呼び出し元 (インターネット アクセス許可レベルの呼び出し元など) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。 コードに、バイト配列を受け取って**Assembly.Load**に渡すパブリック メソッドがある場合、呼び出し元の代わりにアセンブリを作成すると、セキュリティが損なわれる可能性があります。  
  
 この問題は、次の API 要素に当てはまります。  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand とLinkDemand  
 宣言型セキュリティには 2 種類のセキュリティ チェックがあり、どちらも似ていますが、実行するチェックがかなり異なります。 選択を誤るとセキュリティの脆弱性やパフォーマンスの低下を招くことがあるため、両方の形式について理解する必要があります。  
  
 宣言型のセキュリティには、次のセキュリティ チェックがあります。  
  
- <xref:System.Security.Permissions.SecurityAction.Demand> はコード アクセス セキュリティのスタック ウォークを指定します。 スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。 スタックに異なる呼び出し元が含まれる可能性があるため、呼び出しごとに**要求**が発生します。 メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。 **需要**は、攻撃を誘致する場合に対する良好な保護です。それを通過しようとする不正なコードが検出されます。  
  
- [リンク要求](link-demands.md)はジャスト イン タイム (JIT) コンパイル時に発生し、直接呼び出し元のみをチェックします。 このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。 このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。 ただし、おびき寄せによる攻撃からの保護機能はありません。 **LinkDemand**を使用すると、テストに合格し、コードを参照できるコードは、承認されたコードを使用して悪意のあるコードを呼び出すことができるため、セキュリティが損なわれる可能性があります。 したがって、考えられるすべての弱点を完全に回避できない限り **、LinkDemand**を使用しないでください。  
  
    > [!NOTE]
    > .NET Framework 4 では、リンク確認要求はアセンブリ<xref:System.Security.SecurityCriticalAttribute>の属性<xref:System.Security.SecurityRuleSet.Level2>に置き換えられました。 完全<xref:System.Security.SecurityCriticalAttribute>信頼のリンク要求と同等です。ただし、継承ルールにも影響します。 この変更の詳細については、「[透過的セキュリティ コード、レベル 2」](security-transparent-code-level-2.md)を参照してください。  
  
 **LinkDemand**を使用する際に必要な特別な注意事項は、個別にプログラムする必要があります。セキュリティシステムは、強制に役立ちます。 どのようなミスもセキュリティを脆弱化します。 作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。  
  
- 呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。  
  
- 呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。 たとえば<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>、指定されたフラグの**LinkDemand**<xref:System.Security.Permissions.SecurityPermission>で保護されているメソッドを呼び出すコードを記述する場合、メソッドは、このアクセス許可に対して**LinkDemand** (またはより強力な**Demand**) を作成する必要があります。 例外は、コード内の他のセキュリティ保護メカニズム (要求など) を考えると、コードが**LinkDemand**で保護されたメソッドを使用する場合に限られた方法で安全であると判断した場合です。 前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。  
  
- 呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。 つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。  
  
### <a name="interfaces-and-link-demands"></a>インターフェイスとリンク要求  
 **LinkDemand**を使用する仮想メソッド、プロパティ、またはイベントが基本クラスのメソッドをオーバーライドする場合、基本クラスのメソッドもオーバーライドされたメソッドに対して同じ**LinkDemand**を持つ必要があります。 悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。 リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。  
  
 インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。 リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。  
  
- インターフェイス メソッドを実装するクラスのパブリック メソッドに**LinkDemand**を配置すると、インターフェイスにキャストしてメソッドを呼び出しても **、LinkDemand**は強制されません。 この場合、インターフェイスに対してリンクしているため、インターフェイスの**LinkDemand**のみが受け入れられます。  
  
 セキュリティの問題に関して次の項目をレビューします。  
  
- インターフェイス メソッドでのリンク要求を明示的に指定します。 こうしたリンク要求が期待どおりの保護を提供することを確認します。 悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。  
  
- リンク要求が適用される仮想メソッド。  
  
- 実装する型とインターフェイス。 一貫してリンク要求を使用する必要があります。  
  
## <a name="see-also"></a>関連項目

- [安全なコーディングのガイドライン](../../standard/security/secure-coding-guidelines.md)
