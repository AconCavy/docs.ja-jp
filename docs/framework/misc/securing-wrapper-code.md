---
title: ラッパー コードの保護
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
author: mairaw
ms.author: mairaw
ms.openlocfilehash: abbc817142ab6906a04b4dc053693f87109922dc
ms.sourcegitcommit: 155012a8a826ee8ab6aa49b1b3a3b532e7b7d9bd
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2019
ms.locfileid: "66487894"
---
# <a name="securing-wrapper-code"></a>ラッパー コードの保護
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。 呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。  
  
 呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。 完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。 単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。  
  
## <a name="delegates"></a>デリゲート  
 デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。  このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>.NET Framework バージョン 1.0 および 1.1 の場合  
 .NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
 ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。 デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。 ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>バージョン 2.0 と .NET Framework の以降のバージョン  
 以前のバージョンとは異なりバージョン 2.0 と .NET Framework の以降のバージョンを実行、デリゲート作成者に対してセキュリティ アクション、デリゲートが作成され、呼び出されるとします。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。  
  
- デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。  次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
## <a name="link-demands-and-wrappers"></a>リンク要求とラッパー  
 リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。  
  
 完全に信頼されたコードは、プロパティ、イベント、またはによって保護されているメソッドを呼び出す場合、 [LinkDemand](../../../docs/framework/misc/link-demands.md)場合、呼び出しが成功すると、 **LinkDemand**呼び出し元のアクセス許可のチェックが満たされています。 さらに、完全に信頼されたコードがクラスを公開している場合を受け取るプロパティと呼び出しの名前、**取得**アクセサーを呼び出すことには、リフレクションを使用して、**取得**場合でも、ユーザー コードでは、アクセサーが成功します。このプロパティにアクセスする権限を持っていません。 これは、ため、 **LinkDemand**のみ、直前の呼び出し元は完全に信頼されたコードを確認します。 基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。  
  
 このようなセキュリティ ホールを防ぐため、共通言語ランタイムに拡張メソッド、コンス トラクター、プロパティ、またはによって保護されているイベントに対する間接呼び出しでは、完全なスタック ウォーク要求時にチェックを**LinkDemand**します。 この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。  
  
## <a name="assembly-loading-wrappers"></a>アセンブリ読み込みラッパー  
 マネージド コードの読み込みに使用されるいくつかのメソッド (<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> など) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。 これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。 信頼性の低いコードに対して、ラッパーへの呼び出し元のアクセス許可より高いアクセス許可が付与されているコードの読み込みを許可しないでください。  
  
 完全な信頼のあるコード、または潜在的な呼び出し元 (インターネット アクセス許可レベルの呼び出し元など) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。 コードをバイト配列を受け取り、それをパブリック メソッドがある場合**Assembly.Load**のため、アセンブリを作成する、呼び出し元の代わりに、セキュリティを解除、可能性があります。  
  
 この問題は、次の API 要素に当てはまります。  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand とLinkDemand  
 宣言型セキュリティには 2 種類のセキュリティ チェックがあり、どちらも似ていますが、実行するチェックがかなり異なります。 選択を誤るとセキュリティの脆弱性やパフォーマンスの低下を招くことがあるため、両方の形式について理解する必要があります。  
  
 宣言型のセキュリティには、次のセキュリティ チェックがあります。  
  
- <xref:System.Security.Permissions.SecurityAction.Demand> はコード アクセス セキュリティのスタック ウォークを指定します。 スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。 **必要に応じて**スタックは異なる呼び出し元を含めることができますので、呼び出しごとに発生します。 メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。 **必要に応じて**おびき寄せによる攻撃; に対して優れた保護とは、未承認のコードを取得しようとしてが検出されます。  
  
- [LinkDemand](../../../docs/framework/misc/link-demands.md)ジャストイン タイム (JIT) コンパイル時に行われ、直前の呼び出し元のみを確認します。 このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。 このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。 ただし、おびき寄せによる攻撃からの保護機能はありません。 **LinkDemand**テストに合格して、コードを参照するすべてのコードを呼び出す権限のあるコードを使用して悪意のあるコードを許可することでセキュリティを中断できます可能性があります。 そのため、使用しないでください**LinkDemand**しない限り、すべての可能な弱点を完全に回避できます。  
  
    > [!NOTE]
    >  リンク確認要求は、.NET Framework 4 でによって置き換えられている、<xref:System.Security.SecurityCriticalAttribute>属性<xref:System.Security.SecurityRuleSet.Level2>アセンブリ。 <xref:System.Security.SecurityCriticalAttribute>は完全信頼のリンク確認要求と同じですが、継承ルールにも影響します。 この変更の詳細については、次を参照してください。[透過的セキュリティ コード、レベル 2](../../../docs/framework/misc/security-transparent-code-level-2.md)します。  
  
 使用する場合に必要な特別な措置**LinkDemand**個別にプログラミングする必要があります。 を実施に役立てセキュリティ システムのことができます。 どのようなミスもセキュリティを脆弱化します。 作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。  
  
- 呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。  
  
- 呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。 メソッドを呼び出すコードを記述する場合は保護など、 **LinkDemand**の<xref:System.Security.Permissions.SecurityPermission>で、<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>メソッドも作成フラグが指定されて、 **LinkDemand** (または**デマンド**より強力な) このアクセス許可。 例外は、コードが使用するかどうか、 **LinkDemand**-と判断した限定された方法で保護されているメソッドは、安全なコードで他のセキュリティ保護メカニズム (demand など) を指定します。 前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。  
  
- 呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。 つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。  
  
### <a name="interfaces-and-link-demands"></a>インターフェイスとリンク要求  
 場合、仮想メソッド、プロパティ、またはイベントを**LinkDemand**基底クラスのメソッドをオーバーライドする基本クラスのメソッドでは、同じが必要も**LinkDemand**有効にするには、オーバーライドされたメソッド。 悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。 リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。  
  
 インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。 リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。  
  
- 配置した場合、 **LinkDemand**インターフェイス メソッドを実装するクラスのパブリック メソッドで、 **LinkDemand**インターフェイスにキャストし、メソッドを呼び出す場合は適用されません。 この場合は、インターフェイスのみに対してリンクされているため、 **LinkDemand**インターフェイスが使用されます。  
  
 セキュリティの問題に関して次の項目をレビューします。  
  
- インターフェイス メソッドでのリンク要求を明示的に指定します。 こうしたリンク要求が期待どおりの保護を提供することを確認します。 悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。  
  
- リンク要求が適用される仮想メソッド。  
  
- 実装する型とインターフェイス。 一貫してリンク要求を使用する必要があります。  
  
## <a name="see-also"></a>関連項目

- [安全なコーディングのガイドライン](../../../docs/standard/security/secure-coding-guidelines.md)
