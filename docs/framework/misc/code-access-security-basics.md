---
title: コード アクセス セキュリティの基礎
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 3c41becaa149b933d46a01f6ada0ea4b29b68fe8
ms.sourcegitcommit: 155012a8a826ee8ab6aa49b1b3a3b532e7b7d9bd
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2019
ms.locfileid: "66488023"
---
# <a name="code-access-security-basics"></a>コード アクセス セキュリティの基礎

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

共通言語ランタイムに対応するすべてのアプリケーション (つまりすべてのマネージド アプリケーション) は、そのランタイムのセキュリティ システムと対話する必要があります。 マネージ アプリケーションのホストは、そのアプリケーションの起動時に、アプリケーションに対して一連のアクセス許可を付与します。 これらのアクセス許可は、ホストのローカル セキュリティ設定、またはアプリケーションが所属するサンドボックスによって決まります。 これらのアクセス許可に応じて、そのアプリケーションが正常に実行されるか、またはセキュリティ例外が生成されます。

デスクトップ アプリケーションの既定のホストでは、コードが完全な信頼を付与されて実行されます。 このため、アプリケーションの実行対象がデスクトップである場合は、アプリケーションに無制限のアクセス許可セットが付与されます。 その他のホストまたはサンドボックスでは、アプリケーションに対して制限付きのアクセス許可セットが付与されます。 アクセス許可セットはホストごとに異なる場合があるため、アプリケーションの設計時には、対象ホストで許可されているアクセス許可だけを使用するように注意する必要があります。

共通言語ランタイムに対応した有効なアプリケーションを作成するためには、次に示すコード アクセス セキュリティの概念を把握しておく必要があります。

- **タイプ セーフ コード**:タイプ セーフ コードでは、明確に定義された、許可されている方法でのみ、型にアクセスするコードを示します。 たとえば、有効なオブジェクト参照を例として考えると、タイプ セーフ コードは、実際のフィールド メンバーに対応する固定オフセットが指すメモリ位置にアクセスできます。 オブジェクトがパブリックに公開するフィールドに属しているメモリの範囲外の、任意のオフセットが指すメモリ位置にアクセスするコードは、タイプ セーフとは言えません。 コードがコード アクセス セキュリティを活用できるようにするには、検証可能なタイプ セーフ コードを生成するコンパイラを使用する必要があります。 詳細については、次を参照してください。、[検証可能なタイプ セーフ コードの記述](#typesafe_code)このトピックで後述します。

- **命令型と宣言型構文**:対象とする、共通言語ランタイムがアクセス許可を要求、呼び出し元が、アクセス許可を指定した要求の厳しいと (十分な特権を付与する) 特定のセキュリティ設定をオーバーライドして、セキュリティ システムとやり取りをコードします。 .NET Framework セキュリティ システムとプログラムによって対話するには、宣言構文および強制構文という 2 つの形式の構文を使用します。 宣言的な呼び出しは属性を使用して実行され、強制的な呼び出しはコード内のクラスの新しいインスタンスを使用して実行されます。 呼び出しには、強制的にだけ実行できるもの、宣言的にだけ実行できるもの、およびどちらの方法でも実行できるものがあります。

- **クラス ライブラリをセキュリティで保護された**:安全なクラス ライブラリでは、セキュリティ要求を使用して、ライブラリの呼び出し元のライブラリが公開するリソースにアクセスするのにためのアクセス許可でいることを確認します。 たとえば、安全なクラス ライブラリにファイルを作成するメソッドがある場合、このメソッドにアクセスする呼び出し元には、ファイルを作成するためのアクセス許可が必要です。 .NET Framework は、安全なクラス ライブラリで構成されています。 作成するコードで使用するすべてのライブラリについて、アクセスするために必要なアクセス許可を確認する必要があります。 詳細については、次を参照してください。、[安全なクラス ライブラリを使用して](#secure_library)このトピックで後述します。

- **透過的なコード**:特定のアクセス許可を識別するだけでなく、.NET Framework 4 以降と、セキュリティ透過的なコードを実行する必要があるかどうかをも判断する必要があります。 セキュリティ透過コードは、セキュリティが重要な型またはメンバーを呼び出すことができません。 この規則は、完全に信頼されているアプリケーションと、部分的に信頼されたアプリケーションの両方に対して適用されます。 詳細については、次を参照してください。[セキュリティ透過的なコード](../../../docs/framework/misc/security-transparent-code.md)します。

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a>検証可能なタイプ セーフ コードの作成

JIT (Just-in-time) コンパイルでは、検証プロセスが実行され、コードが調べられてタイプ セーフかどうかが判断されます。 タイプ セーフであることを確認中には、実績のあるコードが呼び出された*タイプ セーフ コード*します。 検証プロセスやコンパイラに制約があるために検証可能なタイプ セーフ コードではなくても、コードがタイプ セーフである場合があります。 タイプ セーフではない言語もあり、Microsoft Visual C++ などの一部の言語コンパイラは、検証可能なタイプ セーフ マネージ コードを生成できません。 使用している言語コンパイラが検証可能なタイプ セーフ コードを生成するかどうかを確認するには、そのコンパイラのドキュメントを参照してください。 特定の言語構成を使用しない場合にのみ、タイプ セーフ コードを生成する言語コンパイラを使用する場合は、使用する可能性がある、 [PEVerify ツール](../../../docs/framework/tools/peverify-exe-peverify-tool.md)コードがタイプ セーフであるかどうかを確認します。

検証可能なタイプ セーフ コード以外のコードは、セキュリティ ポリシーによって検証を省略することを許可されている場合にだけ、実行を試行できます。 ただし、タイプ セーフは、アセンブリを分離するためのランタイムの機構において重要な要素であるため、コードがタイプ セーフの規則に違反している場合には、信頼度の高いセキュリティを確保することはできません。 既定では、タイプ セーフでないコードは、その発生元がローカル コンピューターである場合にだけ実行できます。 したがって、モバイル コードはタイプ セーフであることが必要です。

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a>安全なクラス ライブラリの使用

作成したコードが、クラス ライブラリにより要求されるアクセス許可を要求し、そのアクセス許可を与えられた場合には、そのコードからライブラリにアクセスでき、ライブラリが公開するリソースは承認されていないアクセスから保護されます。 コードが適切なアクセス許可を持っていない場合には、そのコードはクラス ライブラリにアクセスできないため、悪意のあるコードがそのコードを利用して保護されたリソースに間接的にアクセスすることもできません。 作成したコードを呼び出す他のコードも、ライブラリへのアクセス許可が必要になります。 アクセス許可がない場合は、作成したコードの実行も制限されます。

コード アクセス セキュリティを使用しても開発者によるコードの記述エラーがなくなるわけではありません。 ただし、保護されているリソースにアクセスするときにアプリケーションが安全なクラス ライブラリを使用していれば、クラス ライブラリでセキュリティの問題が発生する可能性がないかどうかが詳しく調べられるため、アプリケーション コードに対するセキュリティ リスクも軽減されます。

## <a name="declarative-security"></a>宣言セキュリティ

宣言セキュリティ構文を使用して[属性](../../../docs/standard/attributes/index.md)にセキュリティ情報を配置する、[メタデータ](../../../docs/standard/metadata-and-self-describing-components.md)コードの。 属性は、アセンブリ、クラス、またはメンバーの各レベルに適用でき、使用する要求、確認要求、オーバーライドの種類を示します。 要求は、共通言語ランタイムに対応するアプリケーションが、そのアプリケーションに必要なアクセス許可または必要ではないアクセス許可をランタイムのセキュリティ システムに通知するために使用します。 確認要求およびオーバーライドは、呼び出し元からリソースを保護できるようにしたり、既定のセキュリティ動作をオーバーライドしたりするために、ライブラリで使用されます。

> [!NOTE]
> .NET Framework 4 で、.NET Framework のセキュリティ モデルと用語に重要な変更があった。 これらの変更の詳細については、次を参照してください。[セキュリティ変更](../../../docs/framework/security/security-changes.md)します。

宣言セキュリティ呼び出しを行う前に、アクセス許可オブジェクトの状態データを、必要な特定形式のアクセス許可を表すように初期化する必要があります。 組み込みの各アクセス許可は、開発者が実行するセキュリティ操作の種類を示す <xref:System.Security.Permissions.SecurityAction> 列挙として渡される属性を持っています。 しかし、アクセス許可は、それぞれに固有のパラメーターも受け入れます。

コードの呼び出し元がカスタム アクセス許可 `MyPermission` を持つことを要求する宣言構文の例を次のコード片に示します。 このアクセス許可は架空のカスタム許可であり、.NET Framework には実在しません。 この例では、宣言呼び出しはクラス定義の直前に配置されており、このカスタム アクセス許可がクラス レベルで適用されることを示しています。 属性が渡される、 **SecurityAction.Demand**構造体を呼び出し元が実行するためにこのアクセス許可を持つ必要がありますを指定します。

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a>強制セキュリティ

強制セキュリティ構文は、呼び出す対象のアクセス許可オブジェクトの新しいインスタンスを作成することによって、セキュリティ呼び出しを実行します。 強制構文を使用して確認要求とオーバーライドは実行できますが、要求は実行できません。

セキュリティ呼び出しを行う前に、アクセス許可オブジェクトの状態データを、必要な特定形式のアクセス許可を表すように初期化する必要があります。 たとえば、作成するときに、<xref:System.Security.Permissions.FileIOPermission>オブジェクトを初期化するために、コンス トラクターを使用することができます、 **FileIOPermission**オブジェクトをすべてのファイルまたはファイルへのアクセスなしに無制限のアクセス権を表すようです。 または、異なるを使用する**FileIOPermission** (つまり、読み取り、追加、または書き込み) を表すと、オブジェクトで保護するファイルに必要なアクセスの種類を示すパラメーター オブジェクトを渡すオブジェクト。

強制セキュリティ構文は、単一のセキュリティ オブジェクトを呼び出す他に、アクセス許可セット内のアクセス許可のグループを初期化するためにも使用できます。 この手法を確実に実行する唯一の方法は、たとえば、[アサート](../../../docs/framework/misc/using-the-assert-method.md)は 1 つのメソッドで複数のアクセス許可を呼び出します。 それには、<xref:System.Security.PermissionSet> クラスと <xref:System.Security.NamedPermissionSet> クラスを使用して、アクセス許可のグループを作成し、適切なメソッドを呼び出して必要なセキュリティ呼び出しを実行します。

強制構文を使用して確認要求とオーバーライドは実行できますが、要求は実行できません。 アクセス許可の状態を初期化するために必要な情報を実行時にしか取得できない場合には、確認要求やオーバーライドを実行するときに、宣言構文の代わりに強制構文を使用します。 たとえば、呼び出し元に特定のファイルを読み取るためのアクセス許可が必要である場合に、読み取り対象のファイルの名前が実行時までわからないときには、強制確認要求を使用します。 また、条件を適用するかどうか、およびテストの結果に基づいてセキュリティ確認要求を実行するかどうかを実行時に決定する必要がある場合にも、宣言チェックの代わりに強制チェックを使用できます。

コードの呼び出し元がカスタム アクセス許可 `MyPermission` を持つことを要求する強制構文の例を次のコード片に示します。 このアクセス許可は架空のカスタム許可であり、.NET Framework には実在しません。 `MyPermission` の新しいインスタンスが `MyMethod` で生成され、このメソッドだけをセキュリティ呼び出しで保護します。

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a>マネージ ラッパー クラスの使用

ほとんどのアプリケーションおよびコンポーネント (安全なライブラリ以外) では、アンマネージ コードを直接呼び出さないでください。 直接呼び出すべきではないいくつかの理由があります。 コードによってアンマネージ コードが直接呼び出されると、多くの状況では実行が許可されません。コードでは、ネイティブ コードを呼び出すための高い信頼レベルが付与されていなければならないためです。 ポリシーに変更が加えられ、こうしたアプリケーションの実行が許可される場合、アプリケーションではほとんどすべての操作を自由に実行できるようになり、システムのセキュリティがかなり脆弱になる恐れがあります。

さらに、アンマネージ コードにアクセスできるアクセス許可があるコードは、アンマネージ API を呼び出すことによってほとんどすべての操作を実行できるようになる可能性もあります。 たとえば、アンマネージ コードを呼び出すアクセス許可を持つコードは必要ありません<xref:System.Security.Permissions.FileIOPermission>; ファイルにアクセスするアンマネージ (Win32) ファイルに管理されたファイルが必要な API をバイパスして、直接 API を呼び出すことができますのみ**FileIOPermission**します。 マネージド コードにアンマネージド コードを呼び出すアクセス許可があり、アンマネージド コードを実際に直接呼び出す場合、セキュリティ システムでは、ランタイムがアンマネージド コードに確実な制限を課すことができないため、セキュリティ制限の適用に信頼性が欠けることになります。

アンマネージ コードにアクセスすることが必要な操作をアプリケーションで実行する場合、必要な機能 をラップする信頼できるマネージ クラス (存在する場合) を使用してそうした操作をアプリケーションで実行しなければなりません。 安全なクラス ライブラリ内のラッパー クラスが既に存在する場合には、独自にラッパー クラスを作成しないでください。 ラッパー クラスでは、アンマネージ コードへの呼び出しが許可されるように高度な信頼が付与される必要があります。呼び出し元に適切なアクセス許可があることを確認要求する責任はラッパー クラスにあります。 ラッパー クラスを使用する場合、作成したコードで必要となるのは、ラッパー クラスが確認要求するアクセス許可を要求して付与することのみです。

## <a name="see-also"></a>関連項目

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [Assert](../../../docs/framework/misc/using-the-assert-method.md)
- [コード アクセス セキュリティ](../../../docs/framework/misc/code-access-security.md)
- [コード アクセス セキュリティの基礎](../../../docs/framework/misc/code-access-security-basics.md)
- [属性](../../../docs/standard/attributes/index.md)
- [メタデータと自己言及的なコンポーネント](../../../docs/standard/metadata-and-self-describing-components.md)
