---
title: コード アクセス セキュリティの基礎
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 08d708e8f98bd2fe06757df3033a512e2fe1f3c2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400993"
---
# <a name="code-access-security-basics"></a>コード アクセス セキュリティの基礎

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

共通言語ランタイムに対応するすべてのアプリケーション (つまりすべてのマネージド アプリケーション) は、そのランタイムのセキュリティ システムと対話する必要があります。 マネージド アプリケーションのホストは、そのアプリケーションの起動時に、アプリケーションに対して一連のアクセス許可を付与します。 これらのアクセス許可は、ホストのローカル セキュリティ設定、またはアプリケーションが所属するサンドボックスによって決まります。 これらのアクセス許可に応じて、そのアプリケーションが正常に実行されるか、またはセキュリティ例外が生成されます。

デスクトップ アプリケーションの既定のホストでは、コードが完全な信頼を付与されて実行されます。 このため、アプリケーションの実行対象がデスクトップである場合は、アプリケーションに無制限のアクセス許可セットが付与されます。 その他のホストまたはサンドボックスでは、アプリケーションに対して制限付きのアクセス許可セットが付与されます。 アクセス許可セットはホストごとに異なる場合があるため、アプリケーションの設計時には、対象ホストで許可されているアクセス許可だけを使用するように注意する必要があります。

共通言語ランタイムに対応した有効なアプリケーションを作成するためには、次に示すコード アクセス セキュリティの概念を把握しておく必要があります。

- **タイプ セーフ コード**: タイプ セーフコードは、適切に定義された、許可された方法でのみ型にアクセスするコードです。 たとえば、有効なオブジェクト参照を例として考えると、タイプ セーフ コードは、実際のフィールド メンバーに対応する固定オフセットが指すメモリ位置にアクセスできます。 オブジェクトがパブリックに公開するフィールドに属しているメモリの範囲外の、任意のオフセットが指すメモリ位置にアクセスするコードは、タイプ セーフとは言えません。 コードがコード アクセス セキュリティを活用できるようにするには、検証可能なタイプ セーフ コードを生成するコンパイラを使用する必要があります。 詳細については、このトピックの後半の「[検証可能なタイプ セーフ コードの記述](#typesafe_code)」を参照してください。

- **強制構文と宣言構文**: 共通言語ランタイムを対象とするコードは、アクセス許可を要求し、呼び出し元にアクセス許可を要求し、特定のセキュリティ設定をオーバーライドすることによってセキュリティ システムとやり取りできます (十分な特権が与えられています)。 .NET Framework セキュリティ システムとプログラムによって対話するには、宣言構文および強制構文という 2 つの形式の構文を使用します。 宣言的な呼び出しは属性を使用して実行され、強制的な呼び出しはコード内のクラスの新しいインスタンスを使用して実行されます。 呼び出しには、強制的にだけ実行できるもの、宣言的にだけ実行できるもの、およびどちらの方法でも実行できるものがあります。

- **セキュリティで保護されたクラス ライブラリ**: セキュリティ保護されたクラス ライブラリは、ライブラリの呼び出し元がライブラリが公開するリソースにアクセスするためのアクセス許可を持っていることを確認するためにセキュリティ要求を使用します。 たとえば、安全なクラス ライブラリにファイルを作成するメソッドがある場合、このメソッドにアクセスする呼び出し元には、ファイルを作成するためのアクセス許可が必要です。 .NET Framework は、安全なクラス ライブラリで構成されています。 作成するコードで使用するすべてのライブラリについて、アクセスするために必要なアクセス許可を確認する必要があります。 詳細については、このトピックの後半の「[セキュリティで保護されたクラス ライブラリの使用」](#secure_library)を参照してください。

- **透過的なコード**: .NET Framework 4 以降、特定のアクセス許可を識別するだけでなく、コードを透過的セキュリティで実行するかどうかを決定する必要もあります。 セキュリティ透過コードは、セキュリティが重要な型またはメンバーを呼び出すことができません。 この規則は、完全に信頼されているアプリケーションと、部分的に信頼されたアプリケーションの両方に対して適用されます。 詳細については、「[セキュリティ透過的なコード](security-transparent-code.md)」を参照してください。

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a>検証可能なタイプ セーフ コードの作成

JIT (Just-in-time) コンパイルでは、検証プロセスが実行され、コードが調べられてタイプ セーフかどうかが判断されます。 タイプ セーフであることが確認の際に証明されたコードは、*検証可能なタイプ セーフ コード*と呼ばれます。 検証プロセスやコンパイラに制約があるために検証可能なタイプ セーフ コードではなくても、コードがタイプ セーフである場合があります。 タイプ セーフではない言語もあり、Microsoft Visual C++ などの一部の言語コンパイラは、検証可能なタイプ セーフ マネージド コードを生成できません。 使用している言語コンパイラが検証可能なタイプ セーフ コードを生成するかどうかを確認するには、そのコンパイラのドキュメントを参照してください。 特定の言語構成要素を回避するときにのみ、検証可能なタイプ セーフ コードを生成する言語コンパイラを使用する場合は[、PEVerify ツール](../tools/peverify-exe-peverify-tool.md)を使用して、コードが検証可能なタイプ セーフかどうかを判断できます。

検証可能なタイプ セーフ コード以外のコードは、セキュリティ ポリシーによって検証を省略することを許可されている場合にだけ、実行を試行できます。 ただし、タイプ セーフは、アセンブリを分離するためのランタイムの機構において重要な要素であるため、コードがタイプ セーフの規則に違反している場合には、信頼度の高いセキュリティを確保することはできません。 既定では、タイプ セーフでないコードは、その発生元がローカル コンピューターである場合にだけ実行できます。 したがって、モバイル コードはタイプ セーフであることが必要です。

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a>安全なクラス ライブラリの使用

作成したコードが、クラス ライブラリにより要求されるアクセス許可を要求し、そのアクセス許可を与えられた場合には、そのコードからライブラリにアクセスでき、ライブラリが公開するリソースは承認されていないアクセスから保護されます。 コードが適切なアクセス許可を持っていない場合には、そのコードはクラス ライブラリにアクセスできないため、悪意のあるコードがそのコードを利用して保護されたリソースに間接的にアクセスすることもできません。 作成したコードを呼び出す他のコードも、ライブラリへのアクセス許可が必要になります。 アクセス許可がない場合は、作成したコードの実行も制限されます。

コード アクセス セキュリティを使用しても開発者によるコードの記述エラーがなくなるわけではありません。 ただし、保護されているリソースにアクセスするときにアプリケーションが安全なクラス ライブラリを使用していれば、クラス ライブラリでセキュリティの問題が発生する可能性がないかどうかが詳しく調べられるため、アプリケーション コードに対するセキュリティ リスクも軽減されます。

## <a name="declarative-security"></a>宣言セキュリティ

宣言セキュリティ構文では[、属性](../../standard/attributes/index.md)を使用して、コードの[メタデータ](../../standard/metadata-and-self-describing-components.md)にセキュリティ情報を配置します。 属性は、アセンブリ、クラス、またはメンバーの各レベルに適用でき、使用する要求、確認要求、オーバーライドの種類を示します。 要求は、共通言語ランタイムに対応するアプリケーションが、そのアプリケーションに必要なアクセス許可または必要ではないアクセス許可をランタイムのセキュリティ システムに通知するために使用します。 確認要求およびオーバーライドは、呼び出し元からリソースを保護できるようにしたり、既定のセキュリティ動作をオーバーライドしたりするために、ライブラリで使用されます。

> [!NOTE]
> .NET Framework 4 では、.NET Framework のセキュリティ モデルと用語に重要な変更が加えられており、この点は変更されました。 これらの変更の詳細については、「[セキュリティの変更](../security/security-changes.md)」を参照してください。

宣言セキュリティ呼び出しを行う前に、アクセス許可オブジェクトの状態データを、必要な特定形式のアクセス許可を表すように初期化する必要があります。 組み込みの各アクセス許可は、開発者が実行するセキュリティ操作の種類を示す <xref:System.Security.Permissions.SecurityAction> 列挙として渡される属性を持っています。 しかし、アクセス許可は、それぞれに固有のパラメーターも受け入れます。

コードの呼び出し元がカスタム アクセス許可 `MyPermission` を持つことを要求する宣言構文の例を次のコード片に示します。 このアクセス許可は架空のカスタム許可であり、.NET Framework には実在しません。 この例では、宣言呼び出しはクラス定義の直前に配置されており、このカスタム アクセス許可がクラス レベルで適用されることを示しています。 この属性には、呼び出し元が実行するためにこのアクセス許可を持っている必要があることを指定する**SecurityAction.Demand**構造体が渡されます。

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a>強制セキュリティ

強制セキュリティ構文は、呼び出す対象のアクセス許可オブジェクトの新しいインスタンスを作成することによって、セキュリティ呼び出しを実行します。 強制構文を使用して確認要求とオーバーライドは実行できますが、要求は実行できません。

セキュリティ呼び出しを行う前に、アクセス許可オブジェクトの状態データを、必要な特定形式のアクセス許可を表すように初期化する必要があります。 たとえば、オブジェクトを<xref:System.Security.Permissions.FileIOPermission>作成するときに、すべてのファイルへの無制限アクセスまたはファイルへのアクセス権を表す**FileIOPermission**オブジェクトを初期化するコンストラクターを使用できます。 または、別の**FileIOPermission**オブジェクトを使用して、オブジェクトが表すアクセスの種類 (読み取り、追加、または書き込み) と、オブジェクトで保護するファイルを示すパラメーターを渡すことができます。

強制セキュリティ構文は、単一のセキュリティ オブジェクトを呼び出す他に、アクセス許可セット内のアクセス許可のグループを初期化するためにも使用できます。 たとえば、この方法は、1 つのメソッドで複数のアクセス許可に対して[アサート](using-the-assert-method.md)呼び出しを確実に実行する唯一の方法です。 それには、<xref:System.Security.PermissionSet> クラスと <xref:System.Security.NamedPermissionSet> クラスを使用して、アクセス許可のグループを作成し、適切なメソッドを呼び出して必要なセキュリティ呼び出しを実行します。

強制構文を使用して確認要求とオーバーライドは実行できますが、要求は実行できません。 アクセス許可の状態を初期化するために必要な情報を実行時にしか取得できない場合には、確認要求やオーバーライドを実行するときに、宣言構文の代わりに強制構文を使用します。 たとえば、呼び出し元に特定のファイルを読み取るためのアクセス許可が必要である場合に、読み取り対象のファイルの名前が実行時までわからないときには、強制確認要求を使用します。 また、条件を適用するかどうか、およびテストの結果に基づいてセキュリティ確認要求を実行するかどうかを実行時に決定する必要がある場合にも、宣言チェックの代わりに強制チェックを使用できます。

コードの呼び出し元がカスタム アクセス許可 `MyPermission` を持つことを要求する強制構文の例を次のコード片に示します。 このアクセス許可は架空のカスタム許可であり、.NET Framework には実在しません。 `MyPermission` の新しいインスタンスが `MyMethod` で生成され、このメソッドだけをセキュリティ呼び出しで保護します。

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a>マネージド ラッパー クラスの使用

ほとんどのアプリケーションおよびコンポーネント (安全なライブラリ以外) では、アンマネージ コードを直接呼び出さないでください。 直接呼び出すべきではないいくつかの理由があります。 コードによってアンマネージ コードが直接呼び出されると、多くの状況では実行が許可されません。コードでは、ネイティブ コードを呼び出すための高い信頼レベルが付与されていなければならないためです。 ポリシーに変更が加えられ、こうしたアプリケーションの実行が許可される場合、アプリケーションではほとんどすべての操作を自由に実行できるようになり、システムのセキュリティがかなり脆弱になる恐れがあります。

さらに、アンマネージ コードにアクセスできるアクセス許可があるコードは、アンマネージ API を呼び出すことによってほとんどすべての操作を実行できるようになる可能性もあります。 たとえば、アンマネージ コードを呼び出すアクセス許可を持<xref:System.Security.Permissions.FileIOPermission>つコードは、ファイルにアクセスする必要はありません。**FileIOPermission**を必要とするマネージ ファイル API をバイパスして、アンマネージ (Win32) ファイル API を直接呼び出すだけです。 マネージド コードにアンマネージド コードを呼び出すアクセス許可があり、アンマネージド コードを実際に直接呼び出す場合、セキュリティ システムでは、ランタイムがアンマネージド コードに確実な制限を課すことができないため、セキュリティ制限の適用に信頼性が欠けることになります。

アンマネージド コードにアクセスすることが必要な操作をアプリケーションで実行する場合、必要な機能 をラップする信頼できるマネージド クラス (存在する場合) を使用してそうした操作をアプリケーションで実行しなければなりません。 安全なクラス ライブラリ内のラッパー クラスが既に存在する場合には、独自にラッパー クラスを作成しないでください。 ラッパー クラスでは、アンマネージ コードへの呼び出しが許可されるように高度な信頼が付与される必要があります。呼び出し元に適切なアクセス許可があることを確認要求する責任はラッパー クラスにあります。 ラッパー クラスを使用する場合、作成したコードで必要となるのは、ラッパー クラスが確認要求するアクセス許可を要求して付与することのみです。

## <a name="see-also"></a>関連項目

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [アサート](using-the-assert-method.md)
- [コード アクセス セキュリティ](code-access-security.md)
- [コード アクセス セキュリティの基礎](code-access-security-basics.md)
- [属性](../../standard/attributes/index.md)
- [メタデータと自己言及的なコンポーネント](../../standard/metadata-and-self-describing-components.md)
