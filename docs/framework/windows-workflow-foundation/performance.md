---
title: Windows Workflow Foundation 4 のパフォーマンス
ms.date: 03/30/2017
ms.assetid: 67d2b3e8-3777-49f8-9084-abbb33b5a766
ms.openlocfilehash: 5fec41baacca0f35618dd5bc409b88ac792ad125
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79182980"
---
# <a name="windows-workflow-foundation-4-performance"></a><span data-ttu-id="60af2-102">Windows Workflow Foundation 4 のパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="60af2-102">Windows Workflow Foundation 4 Performance</span></span>

 <span data-ttu-id="60af2-103">.NET Framework 4 には、パフォーマンスに対する多額の投資を伴う Windows ワークフローファウンデーション (WF) の大幅な改訂が含まれています。</span><span class="sxs-lookup"><span data-stu-id="60af2-103">.NET Framework 4 includes a major revision of the Windows Workflow Foundation (WF) with heavy investments in performance.</span></span> <span data-ttu-id="60af2-104">この新しいリビジョンでは、.NET Framework 3.0 および .NET Framework 3.5 の一部として出荷された以前の[!INCLUDE[wf1](../../../includes/wf1-md.md)]バージョンから大幅な設計変更が導入されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-104">This new revision introduces significant design changes from the previous versions of [!INCLUDE[wf1](../../../includes/wf1-md.md)] that shipped as part of .NET Framework 3.0 and .NET Framework 3.5.</span></span> <span data-ttu-id="60af2-105">プログラミング モデル、ランタイム、およびパフォーマンスと操作性が大幅に向上するツールの基本機能に基づいて再設計されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-105">It has been re-architected from the core of the programming model, runtime, and tooling to greatly improve performance and usability.</span></span> <span data-ttu-id="60af2-106">このトピックでは、これらのリビジョンの重要なパフォーマンス上の特徴を説明し、以前のバージョンと比較します。</span><span class="sxs-lookup"><span data-stu-id="60af2-106">This topic shows the important performance characteristics of these revisions and compares them against those of the previous version.</span></span>

 <span data-ttu-id="60af2-107">WF3 と WF4 を比較すると、個々のワークフロー コンポーネントのパフォーマンスが桁違いに向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-107">Individual workflow component performance has increased by orders of magnitude between WF3 and WF4.</span></span>  <span data-ttu-id="60af2-108">これにより、手作業でコーディングされた Wcf サービスと WCF ワークフロー サービスの間のギャップが非常に小さくなります。</span><span class="sxs-lookup"><span data-stu-id="60af2-108">This leaves the gap between hand-coded Windows Communication Foundation (WCF) services and WCF workflow services to be quite small.</span></span>  <span data-ttu-id="60af2-109">WF4 でワークフローの待機時間は大幅に短縮されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-109">Workflow latency has been significantly reduced in WF4.</span></span>  <span data-ttu-id="60af2-110">永続化のパフォーマンスは 2.5 ～ 3.0 倍向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-110">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="60af2-111">ワークフロー追跡による状態監視のオーバーヘッドも格段に短縮されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-111">Health monitoring by means of workflow tracking has significantly less overhead.</span></span>  <span data-ttu-id="60af2-112">これらの要因はアプリケーション内で WF4 に移行する、または WF4 を導入する理由として説得力があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-112">These are compelling reasons to migrate to or adopt WF4 in your applications.</span></span>

## <a name="terminology"></a><span data-ttu-id="60af2-113">用語</span><span class="sxs-lookup"><span data-stu-id="60af2-113">Terminology</span></span>

 <span data-ttu-id="60af2-114">.NET [!INCLUDE[wf1](../../../includes/wf1-md.md)] Framework 4 で導入されたバージョンは、このトピックの残りの部分では WF4 と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="60af2-114">The version of [!INCLUDE[wf1](../../../includes/wf1-md.md)] introduced in .NET Framework 4 will be referred to as WF4 for the rest of this topic.</span></span> [!INCLUDE[wf1](../../../includes/wf1-md.md)]<span data-ttu-id="60af2-115">は .NET Framework 3.0 で導入され、.NET Framework 3.5 SP1 を通じていくつかのマイナーな改訂が行われました。</span><span class="sxs-lookup"><span data-stu-id="60af2-115">was introduced in .NET Framework 3.0 and had a few minor revisions through .NET Framework 3.5 SP1.</span></span> <span data-ttu-id="60af2-116">このトピックの残りの部分では、.NET Framework 3.5 バージョンのワークフロー基盤を WF3 と呼びます。</span><span class="sxs-lookup"><span data-stu-id="60af2-116">The .NET Framework 3.5 version of Workflow Foundation will be referred to as WF3 for the rest of this topic.</span></span> <span data-ttu-id="60af2-117">WF3 は、WF4 と共に .NET Framework 4 に付属しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-117">WF3 is shipped in .NET Framework 4 side-by-side with WF4.</span></span> <span data-ttu-id="60af2-118">WF3 アーティファクトを WF4 に移行する方法の詳細については[、「Windows ワークフローファウンデーション 4 移行ガイド](migration-guidance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-118">For more information about migrating WF3 artifacts to WF4 see: [Windows Workflow Foundation 4 Migration Guide](migration-guidance.md).</span></span>

 <span data-ttu-id="60af2-119">Wcf (WCF) は、サービス指向アプリケーションを構築するためのマイクロソフトの統合プログラミング モデルです。</span><span class="sxs-lookup"><span data-stu-id="60af2-119">Windows Communication Foundation (WCF) is Microsoft’s unified programming model for building service-oriented applications.</span></span> <span data-ttu-id="60af2-120">これは、WF3 と共に .NET 3.0 の一部として最初に導入され、現在は .NET Framework の主要コンポーネントの 1 つです。</span><span class="sxs-lookup"><span data-stu-id="60af2-120">It was first introduced as part of .NET 3.0 together with WF3 and now is one of the key components of the .NET Framework.</span></span>

 <span data-ttu-id="60af2-121">Windows Server AppFabric はインターネット インフォメーション サービス (IIS) 上で実行する Web アプリケーションおよび複合アプリケーションの構築、拡張、および管理を容易にする一連の統合テクノロジです。</span><span class="sxs-lookup"><span data-stu-id="60af2-121">Windows Server AppFabric is a set of integrated technologies that make it easier to build, scale and manage Web and composite applications that run on IIS.</span></span> <span data-ttu-id="60af2-122">監視およびサービスとワークフローの管理を行うためのツールを提供します。</span><span class="sxs-lookup"><span data-stu-id="60af2-122">It provides tools for monitoring and managing services and workflows.</span></span> <span data-ttu-id="60af2-123">詳細については[、「Windows サーバー アプリケーション ファブリック 1.0](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-123">For more information, see [Windows Server AppFabric 1.0](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10)).</span></span>

## <a name="goals"></a><span data-ttu-id="60af2-124">目標</span><span class="sxs-lookup"><span data-stu-id="60af2-124">Goals</span></span>
 <span data-ttu-id="60af2-125">このトピックの目的は、WF4 のパフォーマンス特性のさまざまな状況での測定データを示し、</span><span class="sxs-lookup"><span data-stu-id="60af2-125">The goal of this topic is to show the performance characteristics of WF4 with data measured for different scenarios.</span></span> <span data-ttu-id="60af2-126">WF4 と WF3 を詳細に比較して、新しいリビジョンでの大幅な機能強化について説明することです。</span><span class="sxs-lookup"><span data-stu-id="60af2-126">It also provides detailed comparisons between WF4 and WF3, and thus shows the great improvements that have been made in this new revision.</span></span> <span data-ttu-id="60af2-127">この記事のシナリオとデータは WF4 と WF3 のさまざまな側面の基本的なコストを定量化しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-127">The scenarios and data presented in this article quantify the underlying cost of different aspects of WF4 and WF3.</span></span> <span data-ttu-id="60af2-128">このデータは WF4 のパフォーマンス特性を理解するうえで役立ちます。また、WF3 から WF4 への移行計画または WF4 を使用したアプリケーション開発に役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-128">This data is useful in understanding the performance characteristics of WF4 and can be helpful in planning migrations from WF3 to WF4 or using WF4 in application development.</span></span> <span data-ttu-id="60af2-129">ただし、この記事に記載されているデータから結論を導き出す場合には注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="60af2-129">However, care should be taken in the conclusions drawn from the data presented in this article.</span></span> <span data-ttu-id="60af2-130">複合ワークフロー アプリケーションのパフォーマンスは、ワークフローの実装方法や異なるコンポーネントの統合方法に大きく依存します。</span><span class="sxs-lookup"><span data-stu-id="60af2-130">The performance of a composite workflow application is highly dependent on how the workflow is implemented and how different components are integrated.</span></span> <span data-ttu-id="60af2-131">アプリケーションのパフォーマンス特性を確認するには、各アプリケーションを測定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-131">One must measure each application to determine the performance characteristics of that application.</span></span>

## <a name="overview-of-wf4-performance-enhancements"></a><span data-ttu-id="60af2-132">WF4 のパフォーマンスの強化の概要</span><span class="sxs-lookup"><span data-stu-id="60af2-132">Overview of WF4 Performance Enhancements</span></span>
 <span data-ttu-id="60af2-133">WF4 は慎重に設計され、高いパフォーマンスとスケーラビリティが実装されています。これらについて、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="60af2-133">WF4 was carefully designed and implemented with high performance and scalability which are described in the following sections.</span></span>

### <a name="wf-runtime"></a><span data-ttu-id="60af2-134">WF ランタイム</span><span class="sxs-lookup"><span data-stu-id="60af2-134">WF Runtime</span></span>
 <span data-ttu-id="60af2-135">[!INCLUDE[wf1](../../../includes/wf1-md.md)] ランタイムの中核は、ワークフロー内のアクティビティを実行する非同期スケジューラです。</span><span class="sxs-lookup"><span data-stu-id="60af2-135">At the core of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime is an asynchronous scheduler that drives the execution of the activities in a workflow.</span></span> <span data-ttu-id="60af2-136">非同期スケジューラはアクティビティに高パフォーマンスで予測可能な実行環境を提供します。</span><span class="sxs-lookup"><span data-stu-id="60af2-136">It provides a performant, predictable execution environment for activities.</span></span> <span data-ttu-id="60af2-137">この環境には実行、継続、完了、キャンセル、例外に関する明確に定義されたコントラクトと予測可能なスレッド モデルがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-137">The environment has a well-defined contract for execution, continuation, completion, cancellation, exceptions, and a predictable threading model.</span></span>

 <span data-ttu-id="60af2-138">WF4 ランタイムのスケジューラは WF3 のスケジューラより効率的です。</span><span class="sxs-lookup"><span data-stu-id="60af2-138">In comparison to WF3, the WF4 runtime has a more efficient scheduler.</span></span> <span data-ttu-id="60af2-139">WCF で使用されるのと同じ I/O スレッド プールを利用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-139">It leverages the same I/O thread pool that is used for WCF, which is very efficient at executing batched work items.</span></span> <span data-ttu-id="60af2-140">内部作業項目のスケジューラ キューは一般的な使用パターンに合わせて最適化されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-140">The internal work item scheduler queue is optimized for most common usage patterns.</span></span> <span data-ttu-id="60af2-141">WF4 ランタイムは、同期とイベント処理ロジックを最小限に抑えて非常に軽量な方法で実行状態を管理しますが、WF3 は、重み付けイベントの登録と呼び出しに依存して、状態遷移の複雑な同期を実行します。</span><span class="sxs-lookup"><span data-stu-id="60af2-141">The WF4 runtime also manages the execution states in a very lightweight way with minimal synchronization and event handling logic, while WF3 depends on heavy-weight event registration and invocation to perform complex synchronization for state transitions.</span></span>

### <a name="data-storage-and-flow"></a><span data-ttu-id="60af2-142">データの格納とフロー</span><span class="sxs-lookup"><span data-stu-id="60af2-142">Data Storage and Flow</span></span>
 <span data-ttu-id="60af2-143">WF3 では、アクティビティに関連付けられたデータは <xref:System.Windows.DependencyProperty> 型によって実装される依存関係プロパティを使用してモデル化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-143">In WF3, data associated with an activity is modeled through dependency properties implemented by the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="60af2-144">依存関係プロパティ パターンは、Windows プレゼンテーション ファウンデーション (WPF) で導入されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-144">The dependency property pattern was introduced in Windows Presentation Foundation (WPF).</span></span> <span data-ttu-id="60af2-145">通常、このパターンはデータ バインディングなどの UI 機能の簡単な操作をサポートするための高度な柔軟性を備えています。</span><span class="sxs-lookup"><span data-stu-id="60af2-145">In general, this pattern is very flexible to support easy data binding and other UI features.</span></span> <span data-ttu-id="60af2-146">ただし、パターンを使用するには、ワークフロー定義にプロパティを静的フィールドとして定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-146">However, the pattern requires the properties to be defined as static fields in the workflow definition.</span></span> <span data-ttu-id="60af2-147">[!INCLUDE[wf1](../../../includes/wf1-md.md)] ランタイムがプロパティ値を設定または取得するたびに、高負荷の検索ロジックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-147">Whenever the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime sets or gets the property values, it involves heavily-weighted look-up logic.</span></span>

 <span data-ttu-id="60af2-148">WF4 では、明確なデータ スコープ設定ロジックを使用することでワークフロー内のデータ処理方法が大幅に向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-148">WF4 uses clear data scoping logic to greatly improve how data is handled in a workflow.</span></span> <span data-ttu-id="60af2-149">WF4 は、変数と引数という 2 つの異なる概念を使用して、アクティビティに保存されたデータとアクティビティ境界間を移動するデータを区別します。</span><span class="sxs-lookup"><span data-stu-id="60af2-149">It separates the data stored in an activity from the data that is flowing across the activity boundaries by using two different concepts: variables and arguments.</span></span> <span data-ttu-id="60af2-150">変数と "In/Out/InOut" 引数に明確な階層スコープを使用することで、アクティビティのデータ使用の複雑さが大幅に削減され、データの有効期間も自動的にスコープ化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-150">By using a clear hierarchical scope for variables and "In/Out/InOut" arguments, the data usage complexity for activities is dramatically reduced and the lifetime of the data is also automatically scoped.</span></span> <span data-ttu-id="60af2-151">アクティビティには、引数によって表されるシグネチャが適切に定義されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-151">Activities have a well-defined signature described by its arguments.</span></span> <span data-ttu-id="60af2-152">アクティビティを検査するだけで、予想される受け取りデータとアクティビティの実行結果として生成されるデータを知ることができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-152">By simply inspecting an activity you can determine what data it expects to receive and what data will be produced by it as the result of its execution.</span></span>

 <span data-ttu-id="60af2-153">アクティビティは、WF3 ではワークフローの作成時に初期化されますが、</span><span class="sxs-lookup"><span data-stu-id="60af2-153">In WF3 activities were initialized when a workflow was created.</span></span> <span data-ttu-id="60af2-154">WF4 では実行時にのみ初期化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-154">In WF 4 activities are initialized only when the corresponding activities are executing.</span></span> <span data-ttu-id="60af2-155">これにより、新規ワークフローのインスタンスの作成時に初期化/非初期化を行わずにアクティビティのライフサイクルを簡素化できるため、実行が効率化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-155">This allows a simpler activity lifecycle without performing Initialize/Uninitialize operations when a new workflow instance is created, and thus has achieved more efficiency</span></span>

### <a name="control-flow"></a><span data-ttu-id="60af2-156">制御フロー</span><span class="sxs-lookup"><span data-stu-id="60af2-156">Control Flow</span></span>
 <span data-ttu-id="60af2-157">他のプログラミング言語と同様、[!INCLUDE[wf1](../../../includes/wf1-md.md)] はシーケンス、ループ、分岐などのパターンに関する一連の制御フロー アクティビティを導入することによりワークフロー定義の制御フローをサポートします。</span><span class="sxs-lookup"><span data-stu-id="60af2-157">Just as in any programming language, [!INCLUDE[wf1](../../../includes/wf1-md.md)] provides support for control flows for workflow definitions by introducing a set of control flow activities for sequencing, looping, branching and other patterns.</span></span> <span data-ttu-id="60af2-158">WF3 では、同じアクティビティを再実行する必要がある場合に、新規の <xref:System.Workflow.ComponentModel.ActivityExecutionContext> を作成し、<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> に基づく高負荷のシリアル化および逆シリアル化ロジックでアクティビティを複製します。</span><span class="sxs-lookup"><span data-stu-id="60af2-158">In WF3, when the same activity needs to be re-executed, a new <xref:System.Workflow.ComponentModel.ActivityExecutionContext> is created and the activity is cloned through a heavy-weight serialization and deserialization logic based on <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span></span> <span data-ttu-id="60af2-159">通常、反復制御フローはアクティビティを順次実行する場合より時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="60af2-159">Usually the performance for iterative control flows is much slower than executing a sequence of activities.</span></span>

 <span data-ttu-id="60af2-160">WF4 の処理方法はまったく異なります。</span><span class="sxs-lookup"><span data-stu-id="60af2-160">WF4 handles this quite differently.</span></span> <span data-ttu-id="60af2-161">WF4 ではアクティビティ テンプレートを取得し、新規の ActivityInstance オブジェクトを作成してスケジューラ キューに追加します。</span><span class="sxs-lookup"><span data-stu-id="60af2-161">It takes the activity template, creates a new ActivityInstance object, and adds it to the scheduler queue.</span></span> <span data-ttu-id="60af2-162">このプロセス全体は、明示的なオブジェクトの作成のみを伴い、非常に軽量です。</span><span class="sxs-lookup"><span data-stu-id="60af2-162">This whole process only involves explicit object creation and is very lightweight.</span></span>

### <a name="asynchronous-programming"></a><span data-ttu-id="60af2-163">非同期プログラミング</span><span class="sxs-lookup"><span data-stu-id="60af2-163">Asynchronous Programming</span></span>
 <span data-ttu-id="60af2-164">通常、I/O や分散コンピューティング処理などの実行時間の長いブロッキング操作に非同期プログラミングを使用することにより、アプリケーションのパフォーマンスとスケーラビリティは向上します。</span><span class="sxs-lookup"><span data-stu-id="60af2-164">Applications usually have better performance and scalability with asynchronous programming for long running blocking operations such as I/O or distributed computing operations.</span></span> <span data-ttu-id="60af2-165">WF4 は基本アクティビティ型 <xref:System.Activities.AsyncCodeActivity>、<xref:System.Activities.AsyncCodeActivity%601> で非同期をサポートします。</span><span class="sxs-lookup"><span data-stu-id="60af2-165">WF4 provides asynchronous support through base activity types <xref:System.Activities.AsyncCodeActivity>, <xref:System.Activities.AsyncCodeActivity%601>.</span></span> <span data-ttu-id="60af2-166">ランタイムは非同期アクティビティをネイティブに認識するため、非同期操作が保留状態の場合にインスタンスを自動的に非永続化ゾーンに配置できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-166">The runtime natively understands asynchronous activities and therefore can automatically put the instance in a no-persist zone while the asynchronous work is outstanding.</span></span> <span data-ttu-id="60af2-167">カスタム アクティビティをこれらの型から派生させることで、ワークフローのスケジューラ スレッドを保持したり、並行して実行される可能性があるすべてのアクティビティをブロックしたりすることなく、非同期操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-167">Custom activities can derive from these types to perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span>

### <a name="messaging"></a><span data-ttu-id="60af2-168">メッセージング</span><span class="sxs-lookup"><span data-stu-id="60af2-168">Messaging</span></span>
 <span data-ttu-id="60af2-169">当初、WF3 のメッセージングのサポートは、外部イベントまたは Web サービスの呼び出しによるきわめて限定的なものでした。</span><span class="sxs-lookup"><span data-stu-id="60af2-169">Initially WF3 had very limited messaging support through external events or web services invocations.</span></span> <span data-ttu-id="60af2-170">NET 3.5 では、ワークフローを WCF クライアントとして実装するか、 および を<xref:System.Workflow.Activities.SendActivity>介<xref:System.Workflow.Activities.ReceiveActivity>して WCF サービスとして公開できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-170">In .NET 3.5, workflows could be implemented as WCF clients or exposed as WCF services through <xref:System.Workflow.Activities.SendActivity> and <xref:System.Workflow.Activities.ReceiveActivity>.</span></span> <span data-ttu-id="60af2-171">WF4 では、ワークフロー ベースのメッセージング プログラミングの概念は、WCF メッセージング ロジックを WF に緊密に統合することで、さらに強化されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-171">In WF4, the concept of workflow-based messaging programming has been further strengthened through the tight integration of WCF messaging logic into WF.</span></span>

 <span data-ttu-id="60af2-172">WCF で提供される統一されたメッセージ処理パイプラインを .NET 4 で提供 WF4 サービスは、WF3 よりもパフォーマンスとスケーラビリティを大幅に向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-172">The unified message processing pipeline provided in WCF in .NET 4 helps WF4 services to have significantly better performance and scalability than WF3.</span></span> <span data-ttu-id="60af2-173">WF4 ではメッセージング プログラミングのサポートも強化され、複雑なメッセージ交換パターン (MEP) をモデル化できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-173">WF4 also provides richer messaging programming support that can model complex Message Exchange Patterns (MEPs).</span></span> <span data-ttu-id="60af2-174">開発者は、型指定されたサービス コントラクトを使用することで、プログラミングを簡素化できます。また、型指定されないサービス コントラクトを使用することで、シリアル化のコストをなくしてパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-174">Developers can use either typed service contracts to achieve easy programming or un-typed service contracts to achieve better performance without paying serialization costs.</span></span> <span data-ttu-id="60af2-175">WF4 の <xref:System.ServiceModel.Activities.SendMessageChannelCache> クラスを使用したクライアント側チャネルのキャッシュのサポートにより、少ない手間で短時間にアプリケーションを作成できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-175">The client-side channel caching support through the <xref:System.ServiceModel.Activities.SendMessageChannelCache> class in WF4 helps developers build fast applications with minimal effort.</span></span> <span data-ttu-id="60af2-176">詳細については、「[送信アクティビティのキャッシュ共有レベルの変更](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-176">For more information, see [Changing the Cache Sharing Levels for Send Activities](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md).</span></span>

### <a name="declarative-programming"></a><span data-ttu-id="60af2-177">宣言型プログラミング</span><span class="sxs-lookup"><span data-stu-id="60af2-177">Declarative Programming</span></span>
 <span data-ttu-id="60af2-178">WF4 にはビジネス プロセスおよびサービスをモデル化するための単純明快な宣言型プログラミング フレームワークがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-178">WF4 provides a clean and simple declarative programming framework to model business processes and services.</span></span> <span data-ttu-id="60af2-179">このプログラミング モデルは、完全な宣言型のアクティビティの作成をサポートし、コードの記述をなくしてワークフローの作成を大幅に簡素化します。</span><span class="sxs-lookup"><span data-stu-id="60af2-179">The programming model supports fully declarative composition of activities, with no code-beside, greatly simplifying workflow authoring.</span></span> <span data-ttu-id="60af2-180">.NET Framework 4 では、XAML ベースの宣言型プログラミング フレームワークが単一アセンブリ System.Xaml.dll に統合され、WPF と WF の両方をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="60af2-180">In .NET Framework 4, the XAML-based declarative programming framework has been unified into the single assembly System.Xaml.dll to support both WPF and WF.</span></span>

 <span data-ttu-id="60af2-181">WF4 では、XAML で完全な宣言型の記述を行い、ワークフローの定義全体を XML マークアップに定義して、.NET を使用して作成したアクティビティや型を参照できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-181">In WF4, XAML provides a truly declarative experience and allows for the entire definition of the workflow to be defined in XML markup, referencing activities and types built using .NET.</span></span> <span data-ttu-id="60af2-182">WF3 の XOML 形式の場合、この操作をカスタム分離コード ロジックなしで行うことは困難です。</span><span class="sxs-lookup"><span data-stu-id="60af2-182">This was difficult to do in WF3 with XOML format without involving custom code-behind logic.</span></span> <span data-ttu-id="60af2-183">.NET 4 の新しい XAML スタックは、ワークフロー アイテムのシリアル化/逆シリアル化のパフォーマンスが大幅に向上し、宣言型プログラミングをより魅力的で確実なものにします。</span><span class="sxs-lookup"><span data-stu-id="60af2-183">The new XAML-stack in .NET 4 has much better performance in serializing/deserializing workflow artifacts and makes declarative programming more attractive and solid.</span></span>

### <a name="workflow-designer"></a><span data-ttu-id="60af2-184">ワークフロー デザイナー</span><span class="sxs-lookup"><span data-stu-id="60af2-184">Workflow Designer</span></span>
 <span data-ttu-id="60af2-185">WF4 の完全な宣言型プログラミングのサポートでは、大規模なワークフローのデザイン時のパフォーマンスに関して、より高い要件を明示的に指定します。</span><span class="sxs-lookup"><span data-stu-id="60af2-185">Fully declarative programming support for WF4 explicitly imposes higher requirements for design time performance for large workflows.</span></span> <span data-ttu-id="60af2-186">WF4 のワークフロー デザイナーは、WF3 のワークフロー デザイナーと比べて大規模なワークフローのスケーラビリティがはるかに向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-186">The Workflow designer in WF4 has much better scalability for large workflows than that for WF3.</span></span> <span data-ttu-id="60af2-187">UI 仮想化のサポートにより、WF4 のデザイナーは 1,000 のアクティビティがある大規模なワークフローを数秒で簡単に読み込むことができますが、WF3 のデザイナーは数百のアクティビティがあるワークフローを読み込むこともほぼ不可能です。</span><span class="sxs-lookup"><span data-stu-id="60af2-187">With UI virtualization support, the designer can easily load a large workflow of 1000 activities in a few seconds, while it is almost impossible to load a workflow of a few hundred activities with the WF3 designer.</span></span>

## <a name="component-level-performance-comparisons"></a><span data-ttu-id="60af2-188">コンポーネント レベルのパフォーマンス比較</span><span class="sxs-lookup"><span data-stu-id="60af2-188">Component-level Performance Comparisons</span></span>
 <span data-ttu-id="60af2-189">このセクションでは、WF3 ワークフローと WF4 ワークフローの個別のアクティビティを直接比較したデータについて説明します。</span><span class="sxs-lookup"><span data-stu-id="60af2-189">This section contains data on direct comparisons between individual activities in WF3 and WF4 workflows.</span></span>  <span data-ttu-id="60af2-190">永続性などの主要分野は、個々のアクティビティのコンポーネントよりパフォーマンスに重大な影響をもたらします。</span><span class="sxs-lookup"><span data-stu-id="60af2-190">Key areas like persistence have a more profound impact on performance than the individual activity components.</span></span>  <span data-ttu-id="60af2-191">それでも、WF4 ではコンポーネントが手動コーディングによる調整ロジックと比肩するほど高速になっているため、個別コンポーネントのパフォーマンスの向上は重要です。</span><span class="sxs-lookup"><span data-stu-id="60af2-191">The performance improvements in individual components in WF4 are important though because the components are now fast enough to be compared against hand-coded orchestration logic.</span></span>  <span data-ttu-id="60af2-192">その例は、次のセクション「サービス構成シナリオ」で説明します。</span><span class="sxs-lookup"><span data-stu-id="60af2-192">An example of which is covered in the next section: "Service Composition Scenario."</span></span>

### <a name="environment-setup"></a><span data-ttu-id="60af2-193">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-193">Environment Setup</span></span>
 ![ワークフローパフォーマンス測定のための環境設定](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="60af2-195">上の図は、コンポーネント レベルのパフォーマンス測定に使用するコンピューター構成を示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-195">The above figure shows the machine configuration used for component-level performance measurement.</span></span> <span data-ttu-id="60af2-196">1 台のサーバーと 5 台のクライアントを 1 つの 1 Gbps イーサネット ネットワーク インターフェイスで接続します。</span><span class="sxs-lookup"><span data-stu-id="60af2-196">A single server and five clients connected over one 1-Gbps Ethernet network interface.</span></span> <span data-ttu-id="60af2-197">測定を簡素化するため、サーバーは Windows Server 2008 x86 を実行するデュアル プロセッサ/クアッド コア サーバーの 1 つのコアを使用する構成にします。</span><span class="sxs-lookup"><span data-stu-id="60af2-197">For easy measurements, the server is configured to use a single core of a dual-proc/quad-core server  running Windows Server 2008 x86.</span></span> <span data-ttu-id="60af2-198">システムの CPU 利用状況はほぼ 100% で推移します。</span><span class="sxs-lookup"><span data-stu-id="60af2-198">The system CPU utilization is maintained at nearly 100%.</span></span>

### <a name="test-details"></a><span data-ttu-id="60af2-199">テストの詳細</span><span class="sxs-lookup"><span data-stu-id="60af2-199">Test Details</span></span>
 <span data-ttu-id="60af2-200">WF3 <xref:System.Workflow.Activities.CodeActivity> は WF3 ワークフローで使用可能な最も単純なアクティビティであると考えられます。</span><span class="sxs-lookup"><span data-stu-id="60af2-200">The WF3 <xref:System.Workflow.Activities.CodeActivity> is likely the simplest activity that can be used in a WF3 workflow.</span></span>  <span data-ttu-id="60af2-201">アクティビティは、ワークフローのプログラマがカスタム コードを配置できる分離コード内のメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="60af2-201">The activity calls a method in the code-behind that the workflow programmer can put custom code into.</span></span>  <span data-ttu-id="60af2-202">WF4 には、同様の機能を提供する WF3 の <xref:System.Workflow.Activities.CodeActivity> に直接匹敵する機能はありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-202">In WF4, there is no direct analog to the WF3 <xref:System.Workflow.Activities.CodeActivity> that provides the same functionality.</span></span>  <span data-ttu-id="60af2-203">WF4 の <xref:System.Activities.CodeActivity> 基本クラスは WF3 の <xref:System.Workflow.Activities.CodeActivity> とは関連がありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-203">Note that there is a <xref:System.Activities.CodeActivity> base class in WF4 that is not related to the WF3 <xref:System.Workflow.Activities.CodeActivity>.</span></span>  <span data-ttu-id="60af2-204">ワークフロー作成者には、カスタム アクティビティを作成し、XAML のみのワークフローを構築することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="60af2-204">Workflow authors are encouraged to create custom activities and build XAML-only workflows.</span></span>  <span data-ttu-id="60af2-205">以下のテストでは、WF4 ワークフローで `Comment` という名前のアクティビティが空の <xref:System.Workflow.Activities.CodeActivity> の代わりに使用されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-205">In the tests below, an activity called `Comment` is used in place of an empty <xref:System.Workflow.Activities.CodeActivity> in WF4 workflows.</span></span>  <span data-ttu-id="60af2-206">`Comment` アクティビティのコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-206">The code in the `Comment` activity is as follows:</span></span>

```csharp
[ContentProperty("Body")]
    public sealed class Comment : CodeActivity
    {
        public Comment()
            : base()
        {
        }

        [DefaultValue(null)]
        public Activity Body
        {
            get;
            set;
        }

        protected override void Execute(CodeActivityContext context)
        {
        }
    }
```

### <a name="empty-workflow"></a><span data-ttu-id="60af2-207">空のワークフロー</span><span class="sxs-lookup"><span data-stu-id="60af2-207">Empty Workflow</span></span>
 <span data-ttu-id="60af2-208">このテストでは、子アクティビティがないシーケンス ワークフローを使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-208">This test uses a sequence workflow with no child activities.</span></span>

### <a name="single-activity"></a><span data-ttu-id="60af2-209">1 つのアクティビティ</span><span class="sxs-lookup"><span data-stu-id="60af2-209">Single Activity</span></span>
 <span data-ttu-id="60af2-210">ワークフローは子アクティビティを 1 つ含むシーケンス ワークフローです。</span><span class="sxs-lookup"><span data-stu-id="60af2-210">The workflow is a sequence workflow containing one child activity.</span></span>  <span data-ttu-id="60af2-211">アクティビティは、WF3 の場合はコードなしの <xref:System.Workflow.Activities.CodeActivity>、WF4 の場合は `Comment` アクティビティです。</span><span class="sxs-lookup"><span data-stu-id="60af2-211">The activity is a <xref:System.Workflow.Activities.CodeActivity> with no code in the WF3 case and a `Comment` activity in the WF4 case.</span></span>

### <a name="while-with-1000-iterations"></a><span data-ttu-id="60af2-212">While の 1,000 回反復</span><span class="sxs-lookup"><span data-stu-id="60af2-212">While with 1000 Iterations</span></span>
 <span data-ttu-id="60af2-213">このシーケンス ワークフローには 1 つの <xref:System.Activities.Statements.While> アクティビティが含まれ、ループ内に何も処理しない 1 つの子アクティビティを含みます。</span><span class="sxs-lookup"><span data-stu-id="60af2-213">The sequence workflow contains one <xref:System.Activities.Statements.While> activity with one child activity in the loop that does not perform any work.</span></span>

### <a name="replicator-compared-to-parallelforeach"></a><span data-ttu-id="60af2-214">Replicator と ParallelForEach の比較</span><span class="sxs-lookup"><span data-stu-id="60af2-214">Replicator compared to ParallelForEach</span></span>
 <span data-ttu-id="60af2-215">WF3 の <xref:System.Workflow.Activities.ReplicatorActivity> には順次実行モードと並列実行モードがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-215"><xref:System.Workflow.Activities.ReplicatorActivity> in WF3 has sequential and parallel execution modes.</span></span>  <span data-ttu-id="60af2-216">順次モードのアクティビティのパフォーマンスは <xref:System.Workflow.Activities.WhileActivity> と同様です。</span><span class="sxs-lookup"><span data-stu-id="60af2-216">In sequential mode, the activity’s performance is similar to the <xref:System.Workflow.Activities.WhileActivity>.</span></span>  <span data-ttu-id="60af2-217">並列実行で特に便利なアクティビティは <xref:System.Workflow.Activities.ReplicatorActivity> です。</span><span class="sxs-lookup"><span data-stu-id="60af2-217">The <xref:System.Workflow.Activities.ReplicatorActivity> is most useful for parallel execution.</span></span>  <span data-ttu-id="60af2-218">このアクティビティに類似した WF4 のアクティビティは <xref:System.Activities.Statements.ParallelForEach%601> です。</span><span class="sxs-lookup"><span data-stu-id="60af2-218">The WF4 analog for this is the <xref:System.Activities.Statements.ParallelForEach%601> activity.</span></span>

 <span data-ttu-id="60af2-219">次の図は、このテストに使用するワークフローを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-219">The following diagram shows the workflows used for this test.</span></span> <span data-ttu-id="60af2-220">左側が WF3 ワークフロー、右側が WF4 ワークフローです。</span><span class="sxs-lookup"><span data-stu-id="60af2-220">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

 ![WF3 ReplicatorActivity および WF4 ParallelForEach](./media/performance/replicator-parallel-wf3-wf4.gif)

### <a name="sequential-workflow-with-five-activities"></a><span data-ttu-id="60af2-222">5 つのアクティビティがあるシーケンシャル ワークフロー</span><span class="sxs-lookup"><span data-stu-id="60af2-222">Sequential Workflow with Five Activities</span></span>
 <span data-ttu-id="60af2-223">このテストは、複数のアクティビティを順番に実行した場合の効果を示すことを目的としています。</span><span class="sxs-lookup"><span data-stu-id="60af2-223">This test is meant to show the effect of having several activities execute in sequence.</span></span>  <span data-ttu-id="60af2-224">シーケンス内には 5 つのアクティビティがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-224">There are five activities in the sequence.</span></span>

### <a name="transaction-scope"></a><span data-ttu-id="60af2-225">トランザクション スコープ</span><span class="sxs-lookup"><span data-stu-id="60af2-225">Transaction Scope</span></span>
 <span data-ttu-id="60af2-226">トランザクション スコープ テストはその他のテストと若干異なり、反復のたびに新しいワークフロー インスタンスを作成するのではなく、</span><span class="sxs-lookup"><span data-stu-id="60af2-226">The transaction scope test differs from the other tests slightly in that a new workflow instance is not created for every iteration.</span></span>  <span data-ttu-id="60af2-227">ワークフローは処理のない 1 つのアクティビティを含む <xref:System.Activities.Statements.TransactionScope> アクティビティを含む while ループで構造化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-227">Instead, the workflow is structured with a while loop containing a <xref:System.Activities.Statements.TransactionScope> activity containing a single activity that does no work.</span></span>  <span data-ttu-id="60af2-228">while ループで 50 回反復するバッチを 1 回実行するたびに 1 つの操作としてカウントされます。</span><span class="sxs-lookup"><span data-stu-id="60af2-228">Each run of a batch of 50 iterations through the while loop is counted as a single operation.</span></span>

### <a name="compensation"></a><span data-ttu-id="60af2-229">補正</span><span class="sxs-lookup"><span data-stu-id="60af2-229">Compensation</span></span>
 <span data-ttu-id="60af2-230">WF3 ワークフローには `WorkScope` という名前の補正可能アクティビティが 1 つあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-230">The WF3 workflow has a single compensatable activity named `WorkScope`.</span></span>  <span data-ttu-id="60af2-231">このアクティビティは単純に <xref:System.Workflow.ComponentModel.ICompensatableActivity> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="60af2-231">The activity simply implements the <xref:System.Workflow.ComponentModel.ICompensatableActivity> interface:</span></span>

```csharp
class WorkScope :
        CompositeActivity, ICompensatableActivity
    {
        public WorkScope() : base() { }

        public WorkScope(string name)
        {
            this.Name = name;
        }

        public ActivityExecutionStatus Compensate(
            ActivityExecutionContext executionContext)
        {
            return ActivityExecutionStatus.Closed;
        }
    }
```

 <span data-ttu-id="60af2-232">障害ハンドラはアクティビティを`WorkScope`ターゲットにします。</span><span class="sxs-lookup"><span data-stu-id="60af2-232">The fault handler targets the `WorkScope` activity.</span></span> <span data-ttu-id="60af2-233">WF4 ワークフローも同様に単純化されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-233">The WF4 workflow is equally simplistic.</span></span>  <span data-ttu-id="60af2-234"><xref:System.Activities.Statements.CompensableActivity> には本文と補正ハンドラーがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-234">A <xref:System.Activities.Statements.CompensableActivity> has a body and a compensation handler.</span></span>  <span data-ttu-id="60af2-235">明示的な補正はシーケンスの次に来ます。</span><span class="sxs-lookup"><span data-stu-id="60af2-235">An explicit compensate is next in the sequence.</span></span>  <span data-ttu-id="60af2-236">本文アクティビティと補正ハンドラー アクティビティはどちらも空の実装です。</span><span class="sxs-lookup"><span data-stu-id="60af2-236">The body activity and compensation handler activity are both empty implementations:</span></span>

```csharp
public sealed class CompensableActivityEmptyCompensation : CodeActivity
    {
        public CompensableActivityEmptyCompensation()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
    public sealed class CompensableActivityEmptyBody : CodeActivity
    {
        public CompensableActivityEmptyBody()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
```

<span data-ttu-id="60af2-237">次の図は、基本的な報酬ワークフローを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-237">The following diagram shows the basic compensation workflow.</span></span> <span data-ttu-id="60af2-238">左側が WF3 ワークフロー、右側が WF4 ワークフローです。</span><span class="sxs-lookup"><span data-stu-id="60af2-238">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

![WF3 および WF4 基本報酬ワークフロー](./media/performance/basic-compensation-workflows-wf3-wf4.gif)

### <a name="performance-test-results"></a><span data-ttu-id="60af2-240">パフォーマンスのテスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-240">Performance Test Results</span></span>

 ![パフォーマンス テストの結果データを示す表](./media/performance/performance-test-data.gif)

 ![WF3 と WF4 のパフォーマンス テスト データを比較した縦棒グラフ](./media/performance/performance-test-chart.gif)

 <span data-ttu-id="60af2-243">トランザクション スコープ テスト以外のすべてのテストは 1 秒あたりのワークフローで測定されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-243">All tests are measured in workflows per second with the exception of the transaction scope test.</span></span>  <span data-ttu-id="60af2-244">上で説明したように、[!INCLUDE[wf1](../../../includes/wf1-md.md)] ランタイムのパフォーマンスは全体的に向上しました。while ループのような同じアクティビティの複数の実行を必要とする分野では特に向上が顕著でした。</span><span class="sxs-lookup"><span data-stu-id="60af2-244">As can be seen above, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime performance has improved across the board, especially in areas that require multiple executions of the same activity like the while loop.</span></span>

## <a name="service-composition-scenario"></a><span data-ttu-id="60af2-245">サービス構成シナリオ</span><span class="sxs-lookup"><span data-stu-id="60af2-245">Service Composition Scenario</span></span>
 <span data-ttu-id="60af2-246">前のセクション「コンポーネントレベルのパフォーマンス比較」で示したように、WF3 と WF4 の間のオーバーヘッドが大幅に削減されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-246">As is shown in the previous section, "Component-level Performance Comparisons," there has been a significant reduction in overhead between WF3 and WF4.</span></span>  <span data-ttu-id="60af2-247">WCF ワークフロー サービスは、手作業でコーディングされた WCF サービスのパフォーマンスとほぼ一致するようになりましたが[!INCLUDE[wf1](../../../includes/wf1-md.md)]、ランタイムのすべての利点を持っています。</span><span class="sxs-lookup"><span data-stu-id="60af2-247">WCF workflow services can now almost match the performance of hand-coded WCF services but still have all the benefits of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="60af2-248">このテスト シナリオでは、WF4 の WCF ワークフロー サービスと WCF サービスを比較します。</span><span class="sxs-lookup"><span data-stu-id="60af2-248">This test scenario compares a WCF service against a WCF workflow service in WF4.</span></span>

### <a name="online-store-service"></a><span data-ttu-id="60af2-249">オンライン ストア サービス</span><span class="sxs-lookup"><span data-stu-id="60af2-249">Online Store Service</span></span>
 <span data-ttu-id="60af2-250">Windows ワークフローファンデーションの強みの 1 つは、複数のサービスを使用してプロセスを構成できることです。</span><span class="sxs-lookup"><span data-stu-id="60af2-250">One of the strengths of Windows Workflow Foundation is the ability to compose processes using several services.</span></span>  <span data-ttu-id="60af2-251">この例として、2 つのサービスの呼び出しを調整して発注するオンライン ストア サービスがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-251">For this example, there is an online store service that orchestrates two service calls to purchase an order.</span></span>  <span data-ttu-id="60af2-252">まず、注文検証サービスを使用して注文を検証します。</span><span class="sxs-lookup"><span data-stu-id="60af2-252">The first step is to validate the order using an Order Validating Service.</span></span>  <span data-ttu-id="60af2-253">次に、ウェアハウス サービスを使用して注文を受け付けます。</span><span class="sxs-lookup"><span data-stu-id="60af2-253">The second step is to fill the order using a Warehouse Service.</span></span>

 <span data-ttu-id="60af2-254">注文検証サービスとウェアハウス サービスの 2 つのバックエンド サービスは両方のテストで不変です。</span><span class="sxs-lookup"><span data-stu-id="60af2-254">The two backend services, Order Validating Service and Warehouse Service, remain the same for both tests.</span></span>  <span data-ttu-id="60af2-255">変更する部分は、調整を行うオンライン ストア サービスです。</span><span class="sxs-lookup"><span data-stu-id="60af2-255">The part that changes is the Online Store Service that performs the orchestration.</span></span>  <span data-ttu-id="60af2-256">ある場合、サービスは WCF サービスとして手でコーディングされます。</span><span class="sxs-lookup"><span data-stu-id="60af2-256">In one case, the service is hand-coded as a WCF service.</span></span>  <span data-ttu-id="60af2-257">もう 1 つのケースでは、サービスは WF4 で WCF ワークフロー サービスとして記述されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-257">For the other case, the service is written as a WCF workflow service in WF4.</span></span> <span data-ttu-id="60af2-258">追跡や永続化などの [!INCLUDE[wf1](../../../includes/wf1-md.md)] 固有の機能はこのテストでは無効にします。</span><span class="sxs-lookup"><span data-stu-id="60af2-258">[!INCLUDE[wf1](../../../includes/wf1-md.md)]-specific features like tracking and persistence are turned off for this test.</span></span>

### <a name="environment"></a><span data-ttu-id="60af2-259">環境</span><span class="sxs-lookup"><span data-stu-id="60af2-259">Environment</span></span>
![パフォーマンス測定のための環境設定](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="60af2-261">クライアントは複数のコンピューターから HTTP 経由でオンライン ストア サービスを要求します。</span><span class="sxs-lookup"><span data-stu-id="60af2-261">Client requests are made to the Online Store Service via HTTP from multiple computers.</span></span>  <span data-ttu-id="60af2-262">1 台のコンピューターで 3 つのサービスのすべてをホストします。</span><span class="sxs-lookup"><span data-stu-id="60af2-262">A single computer hosts all three services.</span></span>  <span data-ttu-id="60af2-263">オンライン ストア サービスとバックエンド サービスの間にあるトランスポート層は TCP または HTTP です。</span><span class="sxs-lookup"><span data-stu-id="60af2-263">The transport layer between the Online Store Service and the backend services is TCP or HTTP.</span></span>  <span data-ttu-id="60af2-264">1 秒あたりの操作は、オンライン ストア サービスに対する `PurchaseOrder` の呼び出しが完了した件数に基づいて測定されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-264">The measurement of operations/second is based on the number of completed `PurchaseOrder` calls made to the Online Store Service.</span></span>  <span data-ttu-id="60af2-265">チャネル プールは WF4 で導入された新機能です。</span><span class="sxs-lookup"><span data-stu-id="60af2-265">Channel pooling is a new feature available in WF4.</span></span>  <span data-ttu-id="60af2-266">このテスト チャネル プールの WCF 部分では、簡単なプール技術の手コーディングされた実装がオンライン ストア サービスで使用されていたので、用意されていません。</span><span class="sxs-lookup"><span data-stu-id="60af2-266">In the WCF portion of this test channel pooling is not provided out of the box so a hand-coded implementation of a simple pooling technique was used in the Online Store Service.</span></span>

### <a name="performance"></a><span data-ttu-id="60af2-267">パフォーマンス</span><span class="sxs-lookup"><span data-stu-id="60af2-267">Performance</span></span>
![オンライン ストア サービスのパフォーマンスを示す縦棒グラフ](./media/performance/online-store-performance-graph.gif)

 <span data-ttu-id="60af2-269">チャネル プールなしでバックエンド TCP サービスに接続した場合、[!INCLUDE[wf1](../../../includes/wf1-md.md)] サービスはスループットに 17.2% 影響します。</span><span class="sxs-lookup"><span data-stu-id="60af2-269">Connecting to backend TCP services without channel pooling, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] service has a 17.2% impact on throughput.</span></span>  <span data-ttu-id="60af2-270">チャネル プールを使用した場合、スループットは 23.8% 低下します。</span><span class="sxs-lookup"><span data-stu-id="60af2-270">With channel pooling, the penalty is about 23.8%.</span></span>  <span data-ttu-id="60af2-271">HTTP では影響ははるかに小さく、プールなしの場合で 4.3%、プールを使用した場合で 8.1% の影響があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-271">For HTTP, the impact is much less: 4.3% without pooling and 8.1% with pooling.</span></span>  <span data-ttu-id="60af2-272">HTTP を使用する場合はチャネル プールのメリットがきわめて少ないことも重要な点です。</span><span class="sxs-lookup"><span data-stu-id="60af2-272">It is also important to note that the channel pooling provides very little benefit when using HTTP.</span></span>

 <span data-ttu-id="60af2-273">WF4 ランタイムからオーバーヘッドは、このテストで手でコーディングされた WCF サービスと比較されますが、最悪のシナリオと考えられます。</span><span class="sxs-lookup"><span data-stu-id="60af2-273">While there is overhead from the WF4 runtime compared with a hand-coded WCF service in this test, it could be considered a worst-case scenario.</span></span>  <span data-ttu-id="60af2-274">このテストの 2 つのバックエンド サービスはほとんど処理を行いません。</span><span class="sxs-lookup"><span data-stu-id="60af2-274">The two backend services in this test do very little work.</span></span>  <span data-ttu-id="60af2-275">実際のエンド ツー エンドのシナリオでは、これらのサービスでデータベースの呼び出しなどの高負荷の操作を行うため、トランスポート層のパフォーマンスへの影響の重要性は低下します。</span><span class="sxs-lookup"><span data-stu-id="60af2-275">In a real end-to-end scenario, these services would perform more expensive operations like database calls, making the performance impact of the transport layer less important.</span></span>  <span data-ttu-id="60af2-276">また、WF4 で提供されている機能の長所により、Workflow Foundation はオーケストレーション サービスの作成に有効な選択肢になります。</span><span class="sxs-lookup"><span data-stu-id="60af2-276">This plus the benefits of the features available in WF4 makes Workflow Foundation a viable choice for creating orchestration services.</span></span>

## <a name="key-performance-considerations"></a><span data-ttu-id="60af2-277">パフォーマンスに関する重要な考慮事項</span><span class="sxs-lookup"><span data-stu-id="60af2-277">Key Performance Considerations</span></span>
 <span data-ttu-id="60af2-278">WF4 では、このセクションの相互運用機能以外の機能分野は WF3 から大幅に変更されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-278">The feature areas in this section, with the exception of interop, have dramatically changed between WF3 and WF4.</span></span>  <span data-ttu-id="60af2-279">この変更はワークフロー アプリケーションのデザインおよびパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="60af2-279">This affects the design of workflow applications as well as the performance.</span></span>

#### <a name="workflow-activation-latency"></a><span data-ttu-id="60af2-280">ワークフローのアクティブ化にかかる待機時間</span><span class="sxs-lookup"><span data-stu-id="60af2-280">Workflow Activation Latency</span></span>
 <span data-ttu-id="60af2-281">WCF ワークフロー サービス アプリケーションでは、新しいワークフローを開始したり、既存のワークフローを読み込んだりするための待機時間が重要です。</span><span class="sxs-lookup"><span data-stu-id="60af2-281">In a WCF workflow service application, the latency for starting a new workflow or loading an existing workflow is important as it can be blocking.</span></span>  <span data-ttu-id="60af2-282">このテスト ケースでは、一般的なシナリオで WF3 XOML ホストを WF4 XAMLX ホストと比較して測定します。</span><span class="sxs-lookup"><span data-stu-id="60af2-282">This test case measures a WF3 XOML host against a WF4 XAMLX host in a typical scenario.</span></span>

##### <a name="environment-setup"></a><span data-ttu-id="60af2-283">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-283">Environment Setup</span></span>
 ![待機時間の環境設定およびスループット テスト](./media/performance/latency-throughput-environment-setup.gif)

##### <a name="test-setup"></a><span data-ttu-id="60af2-285">テストの設定</span><span class="sxs-lookup"><span data-stu-id="60af2-285">Test Setup</span></span>
 <span data-ttu-id="60af2-286">シナリオでは、クライアント コンピューターは、コンテキスト ベースの相関関係を使用して WCF ワークフロー サービスに接続します。</span><span class="sxs-lookup"><span data-stu-id="60af2-286">In the scenario, a client computer contacts a WCF workflow service using context-based correlation.</span></span>  <span data-ttu-id="60af2-287">コンテキスト相関関係は特殊なコンテキスト バインドを必要とし、コンテキスト ヘッダーまたはクッキーを使用してメッセージを適切なワークフロー インスタンスに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="60af2-287">Context correlation requires a special context binding and uses a context header or cookie to relate messages to the correct workflow instance.</span></span>  <span data-ttu-id="60af2-288">相関 ID がメッセージ ヘッダーに存在するため、メッセージ本文を解析する必要がないというパフォーマンス上の利点があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-288">It has a performance benefit in that the correlation Id is located in the message header so the message body does not need to be parsed.</span></span>

 <span data-ttu-id="60af2-289">サービスは要求を行う新しいワークフローを作成し、ワークフローの実行にかかった時間が待機時間の測定に含まれないように、すぐに応答を送信します。</span><span class="sxs-lookup"><span data-stu-id="60af2-289">The service will create a new workflow with the request and send an immediate response so that the measurement of latency does not include the time spent running the workflow.</span></span>  <span data-ttu-id="60af2-290">WF3 のワークフローは XOML と分離コードで構成され、WF4 のワークフローは全体が XAML で構成されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-290">The WF3 workflow is XOML with a code-behind and the WF4 workflow is entirely XAML.</span></span>  <span data-ttu-id="60af2-291">WF4 のワークフローは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="60af2-291">The WF4 workflow looks like this:</span></span>

 ![WF4 相関スコープ ワークフロー](./media/performance/wf4-correlationscope-workflow.gif)

 <span data-ttu-id="60af2-293"><xref:System.ServiceModel.Activities.Receive> アクティビティはワークフロー インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="60af2-293">The <xref:System.ServiceModel.Activities.Receive> activity creates the workflow instance.</span></span>  <span data-ttu-id="60af2-294">受信メッセージに渡した値は応答メッセージにエコーされます。</span><span class="sxs-lookup"><span data-stu-id="60af2-294">A value passed in the received message is echoed in the reply message.</span></span>  <span data-ttu-id="60af2-295">応答の後のシーケンスにはワークフローの残りの部分が含まれます。</span><span class="sxs-lookup"><span data-stu-id="60af2-295">A sequence following the reply contains the rest of the workflow.</span></span>  <span data-ttu-id="60af2-296">前の例では 1 つの Comment アクティビティのみを示しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-296">In the above case, only one comment activity is shown.</span></span>  <span data-ttu-id="60af2-297">ワークフローの複雑さをシミュレーションするには、Comment アクティビティの数を変更します。</span><span class="sxs-lookup"><span data-stu-id="60af2-297">The number of comment activities is changed to simulate workflow complexity.</span></span>  <span data-ttu-id="60af2-298">comment アクティビティは何も処理しない WF3 の <xref:System.Workflow.Activities.CodeActivity> と同等です。</span><span class="sxs-lookup"><span data-stu-id="60af2-298">A comment activity is equivalent to a WF3 <xref:System.Workflow.Activities.CodeActivity> that performs no work.</span></span> <span data-ttu-id="60af2-299">コメントアクティビティの詳細については、この資料の「コンポーネント レベルのパフォーマンス比較」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-299">For more information about the comment activity, see the "Component-level Performance Comparison" section earlier in this article.</span></span>

##### <a name="test-results"></a><span data-ttu-id="60af2-300">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-300">Test Results</span></span>

 <span data-ttu-id="60af2-301">WCF ワークフロー サービスのコールド および ウォーム遅延:</span><span class="sxs-lookup"><span data-stu-id="60af2-301">Cold and warm latency for WCF workflow services:</span></span>

 ![WF3 と WF4 を使用する WCF ワークフロー サービスのコールド および ウォーム遅延を示す縦棒グラフ](./media/performance/latency-results-graph.gif)

 <span data-ttu-id="60af2-303">前のチャートでは、cold は、指定されたワークフローに対して存在<xref:System.ServiceModel.WorkflowServiceHost>しない場合を指します。</span><span class="sxs-lookup"><span data-stu-id="60af2-303">In the previous chart, cold refers to the case where there is not an existing <xref:System.ServiceModel.WorkflowServiceHost> for the given workflow.</span></span>  <span data-ttu-id="60af2-304">つまり、コールド待機時間は、ワークフローが初めて使用され、XOML または XAML をコンパイルする必要がある場合の待機時間です。</span><span class="sxs-lookup"><span data-stu-id="60af2-304">In other words, cold latency is when the workflow is being used for the first time and the XOML or XAML needs to be compiled.</span></span>  <span data-ttu-id="60af2-305">ウォーム待機時間は、ワークフロー型が既にコンパイル済みの場合に新規ワークフロー インスタンスを作成する時間です。</span><span class="sxs-lookup"><span data-stu-id="60af2-305">Warm latency is the time to create a new workflow instance when the workflow type has already been compiled.</span></span>  <span data-ttu-id="60af2-306">WF4 ではワークフローの複雑さによって大きな差は生じませんが、WF3 ではワークフローの複雑さに応じて時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="60af2-306">The complexity of the workflow makes very little difference in the WF4 case but has a linear progression in the WF3 case.</span></span>

#### <a name="correlation-throughput"></a><span data-ttu-id="60af2-307">相関スループット</span><span class="sxs-lookup"><span data-stu-id="60af2-307">Correlation Throughput</span></span>
 <span data-ttu-id="60af2-308">WF4 では新しいコンテンツ ベースの相関関係機能が導入されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-308">WF4 introduces a new content-based correlation feature.</span></span>  <span data-ttu-id="60af2-309">WF3 ではコンテキスト ベースの相関関係のみが提供されていました。</span><span class="sxs-lookup"><span data-stu-id="60af2-309">WF3 provided only context-based correlation.</span></span>  <span data-ttu-id="60af2-310">コンテキスト ベースの相関関係は、特定の WCF チャネル バインディングに対してのみ行うことができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-310">Context-based correlation could only be done over specific WCF channel bindings.</span></span>  <span data-ttu-id="60af2-311">チャネル バインドを使用する際に、ワークフロー ID がメッセージ ヘッダーに挿入されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-311">The workflow Id is inserted into the message header when using these bindings.</span></span>  <span data-ttu-id="60af2-312">WF3 ランタイムは、その ID によってのみワークフローを識別できます。 コンテンツベースの相関関係を使用すると、ワークフロー作成者は、取引先番号や顧客 ID などの関連データから関連キーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-312">The WF3 runtime could only identify a workflow by its Id.  With content-based correlation, the workflow author can create a correlation key out of a relevant piece of data like an account number or customer Id.</span></span>

 <span data-ttu-id="60af2-313">コンテキスト ベースの相関関係には、相関関係キーがメッセージ ヘッダーに存在するというパフォーマンス上の利点があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-313">Context-based correlation has a performance advantage in that the correlation key is located in the message header.</span></span>  <span data-ttu-id="60af2-314">逆シリアル化やメッセージのコピーを行わずに相関関係キーをメッセージから読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-314">The key can be read from the message without de-serialization/message-copying.</span></span>  <span data-ttu-id="60af2-315">コンテンツ ベースの相関関係では、相関関係キーはメッセージ本文に格納されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-315">In content-based correlation, the correlation key is stored in the message body.</span></span>  <span data-ttu-id="60af2-316">キーの検索には XPath 式を使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-316">An XPath expression is used to locate the key.</span></span>  <span data-ttu-id="60af2-317">この余分な処理のコストは、メッセージのサイズ、本文のキーの深さ、キーの数によって決まります。</span><span class="sxs-lookup"><span data-stu-id="60af2-317">The cost of this extra processing depends on the size of the message, depth of the key in the body, and the number of keys.</span></span>  <span data-ttu-id="60af2-318">このテストでは、コンテキスト ベースの相関関係とコンテンツ ベースの相関関係を比較し、複数のキーを使用した場合のパフォーマンス低下を示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-318">This test compares context- and content-based correlation and also shows the performance degradation when using multiple keys.</span></span>

#### <a name="environment-setup"></a><span data-ttu-id="60af2-319">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-319">Environment Setup</span></span>
![ワークフロー パフォーマンス テストの環境セットアップ](./media/performance/performance-test-environment.gif)

#### <a name="test-setup"></a><span data-ttu-id="60af2-321">テストの設定</span><span class="sxs-lookup"><span data-stu-id="60af2-321">Test Setup</span></span>
<span data-ttu-id="60af2-322">![相関スループットのワークフロー テスト](./media/performance/correlation-throughput-workflow.gif "相関スループット ワークフロー テストのセットアップ")</span><span class="sxs-lookup"><span data-stu-id="60af2-322">![Correlation Throughput Workflow Test](./media/performance/correlation-throughput-workflow.gif "Correlation throughput workflow test setup")</span></span>

 <span data-ttu-id="60af2-323">前のワークフローは[、[永続性](#persistence)] セクションで使用したものと同じです。</span><span class="sxs-lookup"><span data-stu-id="60af2-323">The previous workflow is the same one used in the [Persistence](#persistence) section.</span></span> <span data-ttu-id="60af2-324">永続性のない相関テストの場合、ランタイムに永続性プロバイダーはインストールされません。</span><span class="sxs-lookup"><span data-stu-id="60af2-324">For the correlation tests without persistence, there is no persistence provider installed in the runtime.</span></span> <span data-ttu-id="60af2-325">相関関係は CreateOrder と CompleteOrder の 2 か所で発生します。</span><span class="sxs-lookup"><span data-stu-id="60af2-325">Correlation occurs in two places: CreateOrder and CompleteOrder.</span></span>

#### <a name="test-results"></a><span data-ttu-id="60af2-326">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-326">Test Results</span></span>
<span data-ttu-id="60af2-327">![相関スループット](./media/performance/correlation-throughput-graph.gif "相関スループットグラフ")</span><span class="sxs-lookup"><span data-stu-id="60af2-327">![Correlation Throughput](./media/performance/correlation-throughput-graph.gif "Correlation throughput graph")</span></span>

 <span data-ttu-id="60af2-328">この図は、コンテンツ ベースの相関関係で使用するキーの数が増えた場合のパフォーマンスの低下を示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-328">This graph shows a decrease in performance as the number of keys used in content-based correlation increases.</span></span>  <span data-ttu-id="60af2-329">TCP と HTTP の曲線の類似性は、これらのプロトコルに関連するオーバーヘッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-329">The similarity in the curves between TCP and HTTP indicates the overhead associated with these protocols.</span></span>

#### <a name="correlation-with-persistence"></a><span data-ttu-id="60af2-330">永続化を伴う相関関係</span><span class="sxs-lookup"><span data-stu-id="60af2-330">Correlation with Persistence</span></span>
 <span data-ttu-id="60af2-331">永続化されたワークフローでは、コンテンツ ベースの相関関係からの CPU 圧迫はワークフロー ランタイムから SQL データベースに移行します。</span><span class="sxs-lookup"><span data-stu-id="60af2-331">With a persisted workflow, the CPU pressure from content-based correlation shifts from the workflow runtime to the SQL database.</span></span>  <span data-ttu-id="60af2-332">SQL 永続化プロバイダー内のストアド プロシージャは、適切なワークフローを検索するためにキーの照合作業を実行します。</span><span class="sxs-lookup"><span data-stu-id="60af2-332">The stored procedures in the SQL persistence provider do the work of matching the keys to locate the appropriate workflow.</span></span>

 ![相関と持続性の結果を示す折れ線グラフ](./media/performance/correlation-persistence-graph.gif)

 <span data-ttu-id="60af2-334">コンテキスト ベースの相関関係は、コンテンツ ベースの相関関係よりも高速です。</span><span class="sxs-lookup"><span data-stu-id="60af2-334">Context-based correlation is still faster than content-based correlation.</span></span>  <span data-ttu-id="60af2-335">ただし、永続化の方が相関関係よりパフォーマンスへの影響が大きいため、違いはあまり顕著ではありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-335">However, the difference is less pronounced as persistence has more impact on performance than correlation.</span></span>

### <a name="complex-workflow-throughput"></a><span data-ttu-id="60af2-336">複合ワークフローのスループット</span><span class="sxs-lookup"><span data-stu-id="60af2-336">Complex Workflow Throughput</span></span>
 <span data-ttu-id="60af2-337">ワークフローの複雑さを測定する要素はアクティビティの数だけではありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-337">The complexity of a workflow is not measured only by the number of activities.</span></span>  <span data-ttu-id="60af2-338">複合アクティビティに複数の子が含まれ、その子も複合アクティビティである場合があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-338">Composite activities can contain many children and those children can also be composite activities.</span></span>  <span data-ttu-id="60af2-339">入れ子のレベルの数が増えるほど、現在実行中の状態になり得るアクティビティの数と変数の数も増えます。</span><span class="sxs-lookup"><span data-stu-id="60af2-339">As the number of levels of nesting increases, so does the number of activities that can be currently in the executing state and the number of variables that can be in state.</span></span>  <span data-ttu-id="60af2-340">このテストでは、複合ワークフローを実行する場合の WF3 と WF4 のスループットを比較します。</span><span class="sxs-lookup"><span data-stu-id="60af2-340">This test compares throughput between WF3 and WF4 when executing complex workflows.</span></span>

### <a name="test-setup"></a><span data-ttu-id="60af2-341">テストの設定</span><span class="sxs-lookup"><span data-stu-id="60af2-341">Test Setup</span></span>
 <span data-ttu-id="60af2-342">これらのテストは、4 GB の RAM を搭載した Intel Xeon X5355 @ 2.66 GHz 4 ウェイのコンピューターで Windows Server 2008 x64 を使用して実行されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-342">These tests were executed on an Intel Xeon X5355 @ 2.66GHz 4-way computer with 4GB RAM running Windows Server 2008 x64.</span></span>  <span data-ttu-id="60af2-343">テスト コードは、CPU 使用率が 100% に達するように、1 コアあたり 1 つのスレッドを使用する 1 つのプロセスで実行します。</span><span class="sxs-lookup"><span data-stu-id="60af2-343">The test code runs in a single process with one thread per core to reach 100% CPU utilization.</span></span>

 <span data-ttu-id="60af2-344">このテスト用に生成されたワークフローには、各シーケンスのアクティビティの深さと数という 2 つの主な変数があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-344">The workflows generated for this test have two main variables: depth and number of activities in each sequence.</span></span>  <span data-ttu-id="60af2-345">各深さレベルには Parallel アクティビティ、while ループ、判断、割り当て、シーケンスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="60af2-345">Each depth level includes a parallel activity, while loop, decisions, assignments, and sequences.</span></span>  <span data-ttu-id="60af2-346">下図の WF4 のデザイナーは、トップレベルのフローチャートを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-346">In the WF4 designer pictured below, the top-level flow chart is pictured.</span></span>  <span data-ttu-id="60af2-347">各フローチャートのアクティビティはメイン フローチャートと相似しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-347">Each flowchart activity resembles the main flowchart.</span></span>  <span data-ttu-id="60af2-348">深さがテストのパラメーターに制限されるこのワークフローを図示する場合、フラクタルを考慮すると役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-348">It may be helpful to think of a fractal when picturing this workflow, where the depth is limited to the parameters of the test.</span></span>

 <span data-ttu-id="60af2-349">特定のテストのアクティビティの数は、1 シーケンスあたりのアクティビティの深さと数によって決まります。</span><span class="sxs-lookup"><span data-stu-id="60af2-349">The number of activities in a given test is determined by the depth and number of activities per sequence.</span></span>  <span data-ttu-id="60af2-350">WF4 のテストのアクティビティの数は、次の数式によって計算します。</span><span class="sxs-lookup"><span data-stu-id="60af2-350">The following equation computes the number of activities in the WF4 test:</span></span>

 ![アクティビティ数の計算式](./media/performance/number-activities-equation.gif)

 <span data-ttu-id="60af2-352">WF3 のテストには追加シーケンスがあるため、アクティビティの数を計算する数式が多少異なります。</span><span class="sxs-lookup"><span data-stu-id="60af2-352">The WF3 test’s activity count can be computed with a slightly different equation due to an extra sequence:</span></span>

 ![WF3 アクティビティの数を計算する式](./media/performance/wf3-number-activities-equation.gif)

 <span data-ttu-id="60af2-354">d は 1 シーケンスあたりのアクティビティの深さ、a は 1 シーケンスあたりのアクティビティの数を表します。</span><span class="sxs-lookup"><span data-stu-id="60af2-354">Where d is the depth and a is the number of activities per sequence.</span></span>  <span data-ttu-id="60af2-355">これらの数式では、最初の定数 × a はシーケンスの数を表し、2 番目の定数は現在のレベルのアクティビティの静的な数を表します。</span><span class="sxs-lookup"><span data-stu-id="60af2-355">The logic behind these equations is that the first constant, multiplied by a, is the number of sequences and the second constant is the static number of activities in the current level.</span></span>  <span data-ttu-id="60af2-356">各フローチャートに 3 つのフローチャート子アクティビティがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-356">There are three flowchart child activities in each flowchart.</span></span>  <span data-ttu-id="60af2-357">ボトム レベルの深さのフローチャートは空で、それ以外のレベルにはメイン フローチャートのコピーがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-357">At the bottom depth level, these flowcharts are empty but at the other levels they are copies of the main flowchart.</span></span>  <span data-ttu-id="60af2-358">各テスト バリエーションのワークフロー定義内のアクティビティの数を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-358">The number of activities in each test variation’s workflow definition is indicated in the following table:</span></span>

 ![各テストで使用されるアクティビティの数を示すテーブル](./media/performance/workflow-variation-compare-table.gif)

 <span data-ttu-id="60af2-360">ワークフロー定義内のアクティビティの数は、各深さレベルに従って急激に増加します。</span><span class="sxs-lookup"><span data-stu-id="60af2-360">The number of activities in the workflow definition increases sharply with each depth level.</span></span>  <span data-ttu-id="60af2-361">ただし、特定のワークフロー インスタンスで実行されるパスは判断ポイントごとに 1 つのみであるため、実際のアクティビティのごく小規模なサブセットのみが実行されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-361">But only one path per decision point is executed in a given workflow instance, so only a small subset of the actual activities are executed.</span></span>

 ![複雑なスループット ワークフローのフローチャート](./media/performance/complex-workflow-throughput-workflow.gif)

 <span data-ttu-id="60af2-363">同等のワークフローが WF3 用にも作成されました。</span><span class="sxs-lookup"><span data-stu-id="60af2-363">An equivalent workflow was created for WF3.</span></span> <span data-ttu-id="60af2-364">WF3 デザイナーは入れ子ではなく、ワークフロー全体をデザイン領域に表示するので、このトピックの表示内容としては大きすぎます。</span><span class="sxs-lookup"><span data-stu-id="60af2-364">The WF3 designer shows the entire workflow in the design area instead of nesting, therefore it is too big to display in this topic.</span></span> <span data-ttu-id="60af2-365">ワークフローのスニペットを以下に示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-365">A snippet of the workflow is shown below.</span></span>

 ![WF3 ワークフローのフローチャート スニペット](./media/performance/wf3-workflow-snippet.gif)

 <span data-ttu-id="60af2-367">入れ子の極端なケースを実行するため、このテストの一部となるもう 1 つのワークフローでは 100 回入れ子になったシーケンスを使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-367">To exercise nesting in an extreme case, another workflow that is part of this test uses 100 nested sequences.</span></span>  <span data-ttu-id="60af2-368">最も内側のシーケンスには 1 つの `Comment` または <xref:System.Workflow.Activities.CodeActivity> があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-368">In the innermost sequence is a single `Comment` or <xref:System.Workflow.Activities.CodeActivity>.</span></span>

 ![ネストされたシーケンスのフローチャート](./media/performance/nested-sequence-workflow.gif)

 <span data-ttu-id="60af2-370">追跡および永続化はこのテストに含まれません。</span><span class="sxs-lookup"><span data-stu-id="60af2-370">Tracking and persistence are not used as part of this test.</span></span>

### <a name="test-results"></a><span data-ttu-id="60af2-371">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-371">Test Results</span></span>
 ![スループット パフォーマンスの結果を示す縦棒グラフ](./media/performance/throughput-performance-results.gif)

 <span data-ttu-id="60af2-373">アクティビティの深さと数が多い複合ワークフローの場合でも、パフォーマンス結果は前述した他のスループット数値と整合しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-373">Even with complex workflows with lots of depth and a high number of activities, the performance results are consistent with other throughput numbers shown earlier in this article.</span></span>  <span data-ttu-id="60af2-374">WF4 のスループットは桁違いに高速なため、対数スケールで比較する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-374">WF4’s throughput is orders of magnitude faster and has to be compared on a logarithmic scale.</span></span>

### <a name="memory"></a><span data-ttu-id="60af2-375">メモリ</span><span class="sxs-lookup"><span data-stu-id="60af2-375">Memory</span></span>
 <span data-ttu-id="60af2-376">Windows Workflow Foundation のメモリ オーバーヘッドは、2 つの重要な要素であるワークフローの複雑さとワークフロー定義の数で測定されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-376">The memory overhead of Windows Workflow Foundation is measured in two key areas: workflow complexity and number of workflow definitions.</span></span>  <span data-ttu-id="60af2-377">メモリの測定は Windows 7 の 64 ビット ワークステーションで行われました。</span><span class="sxs-lookup"><span data-stu-id="60af2-377">Memory measurements were taken on a Windows 7 64-bit workstation.</span></span>  <span data-ttu-id="60af2-378">パフォーマンス カウンターの監視、環境.WorkingSet のポーリング[、VMMap](/sysinternals/downloads/vmmap)で使用可能な VMMap などのツールの使用など、ワーキング セットのサイズの測定方法は多数あります。</span><span class="sxs-lookup"><span data-stu-id="60af2-378">There are many ways to obtain the measurement of working set size such as monitoring performance counters, polling Environment.WorkingSet, or using a tool like VMMap available from [VMMap](/sysinternals/downloads/vmmap).</span></span> <span data-ttu-id="60af2-379">ここでは複数の方法を組み合わせて各テストの結果を取得し、検証しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-379">A combination of methods was used to obtain and verify the results of each test.</span></span>

### <a name="workflow-complexity-test"></a><span data-ttu-id="60af2-380">ワークフローの複雑さテスト</span><span class="sxs-lookup"><span data-stu-id="60af2-380">Workflow Complexity Test</span></span>
 <span data-ttu-id="60af2-381">ワークフローの複雑さテストでは、ワークフローの複雑さに基づいてワーキング セットの違いを測定します。</span><span class="sxs-lookup"><span data-stu-id="60af2-381">The workflow complexity test measures the working set difference based on the complexity of the workflow.</span></span>  <span data-ttu-id="60af2-382">前のセクションで使用した複合ワークフローの他に、1 つのアクティビティ ワークフローと 1,000 のアクティビティがあるシーケンスという 2 つの基本ケースを取り入れるための新しいバリエーションを追加します。</span><span class="sxs-lookup"><span data-stu-id="60af2-382">In addition to the complex workflows used in the previous section, new variations are added to cover two basic cases: a single activity workflow and a sequence with 1000 activities.</span></span>  <span data-ttu-id="60af2-383">これらのテストでは、ワークフローを初期化し、1 分間の単一シリアル ループ内で完了するまで実行します。</span><span class="sxs-lookup"><span data-stu-id="60af2-383">For these tests the workflows are initialized and executed to completion in a single serial loop for a period of one minute.</span></span>  <span data-ttu-id="60af2-384">各テスト バリエーションを 3 回実行し、その平均データを記録しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-384">Each test variation is run three times and the data recorded is the average of those three runs.</span></span>

 <span data-ttu-id="60af2-385">新しい 2 つの基本テストには次のようなワークフローがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-385">The two new basic tests have workflows that look like those shown below:</span></span>

 ![WF3 と WF4 の両方の複雑なワークフロー](./media/performance/complex-workflow-wf3-wf4.gif)

 <span data-ttu-id="60af2-387">前の WF3 のワークフローでは、空の <xref:System.Workflow.Activities.CodeActivity> アクティビティを使用しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-387">In the WF3 workflow shown above, empty <xref:System.Workflow.Activities.CodeActivity> activities are used.</span></span>  <span data-ttu-id="60af2-388">前の WF4 ワークフローでは `Comment` アクティビティを使用しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-388">The WF4 workflow above uses `Comment` activities.</span></span>  <span data-ttu-id="60af2-389">`Comment` アクティビティについては前の「コンポーネント レベルのパフォーマンス比較」で説明しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-389">The `Comment` activity was described in the Component-level Performance Comparisons section earlier in this article.</span></span>

 ![WF3 および WF4 ワークフローの複雑なワークフロー メモリ使用量を示す縦棒グラフ](./media/performance/complex-memory-usage-wf3-wf4.gif)

 <span data-ttu-id="60af2-391">この図で注目すべき明白な傾向の 1 つは、WF3 および WF4 のいずれの場合も入れ子がメモリ使用量に与える影響が比較的小さいことです。</span><span class="sxs-lookup"><span data-stu-id="60af2-391">One of the clear trends to notice in this graph is that nesting has relatively minimal impact on memory usage in both WF3 and WF4.</span></span>  <span data-ttu-id="60af2-392">メモリに最も重大な影響をもたらす要因はワークフロー内のアクティビティの数です。</span><span class="sxs-lookup"><span data-stu-id="60af2-392">The most significant memory impact comes from the number of activities in a given workflow.</span></span>  <span data-ttu-id="60af2-393">シーケンス 1,000、複合深さ 5 シーケンス 5、複合深さ 7 シーケンス 1 (バリエーションあり) の各データから、アクティビティの数が千単位になるとメモリ使用量の増加が顕著になることが明らかです。</span><span class="sxs-lookup"><span data-stu-id="60af2-393">Given the data from the sequence 1000, complex depth 5 sequence 5, and complex depth 7 sequence 1 variations, it is clear that as the number of activities enters the thousands, the memory usage increase becomes more noticeable.</span></span>  <span data-ttu-id="60af2-394">最大 29 K のアクティビティが存在する極端なケース (深さ 7 シーケンス 1) では、WF4 のメモリ使用量は WF3 より約 79% 少なくなっています。</span><span class="sxs-lookup"><span data-stu-id="60af2-394">In the extreme case (depth 7 sequence 1) where there are ~29K activities, WF4 is using almost 79% less memory than WF3.</span></span>

### <a name="multiple-workflow-definitions-test"></a><span data-ttu-id="60af2-395">複数のワークフロー定義のテスト</span><span class="sxs-lookup"><span data-stu-id="60af2-395">Multiple Workflow Definitions Test</span></span>
 <span data-ttu-id="60af2-396">ワークフロー定義ごとのメモリの測定は、WF3 と WF4 でワークフローのホスティングに使用できるオプションが原因で 2 つの異なるテストに分かれています。</span><span class="sxs-lookup"><span data-stu-id="60af2-396">Measuring memory per workflow definition is divided into two different tests because of the available options for hosting workflows in WF3 and WF4.</span></span>  <span data-ttu-id="60af2-397">このテストでは、ワークフローの複雑さテストと異なり、指定されたワークフローのインスタンス化と実行を定義ごとに 1 回だけ行います。</span><span class="sxs-lookup"><span data-stu-id="60af2-397">The tests are run in a different manner than the workflow complexity test in that a given workflow is instanced and executed only once per definition.</span></span>  <span data-ttu-id="60af2-398">これは、ワークフロー定義とそのホストは AppDomain の有効期間中はメモリ内に保持されるためです。</span><span class="sxs-lookup"><span data-stu-id="60af2-398">This is because the workflow definition and its host remain in memory for the lifetime of the AppDomain.</span></span>  <span data-ttu-id="60af2-399">指定されたワークフロー インスタンスの実行によって使用されたメモリは、ガベージ コレクション中にクリーンアップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-399">The memory used by running a given workflow instance should be cleaned up during garbage collection.</span></span>  <span data-ttu-id="60af2-400">WF4 の移行ガイドラインに、ホスト オプションの詳細が記載されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-400">The migration guidance for WF4 contains more detailed information on the hosting options.</span></span> <span data-ttu-id="60af2-401">詳細については、「 [WF 移行クックブック : ワークフロー ホスティング 」を参照してください。](migration-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="60af2-401">For more information, see [WF Migration Cookbook: Workflow Hosting](migration-guidance.md).</span></span>

 <span data-ttu-id="60af2-402">ワークフロー定義テスト用に多数のワークフロー定義を作成するには、いくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-402">Creating many workflow definitions for a workflow definition test can be done in several ways.</span></span>  <span data-ttu-id="60af2-403">たとえば、コード生成を使用して、名前以外は同一の 1,000 のワークフローを作成し、各ワークフローを個別のファイルに保存します。</span><span class="sxs-lookup"><span data-stu-id="60af2-403">For instance, one could use code generation to create a set of 1000 workflows that are identical except in name and save each of those workflows into separate files.</span></span>  <span data-ttu-id="60af2-404">この方法はコンソール ホストのテストで使用しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-404">This approach was taken for the console-hosted test.</span></span>  <span data-ttu-id="60af2-405">WF3 では、ワークフロー定義の実行に <xref:System.Workflow.Runtime.WorkflowRuntime> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-405">In WF3, the <xref:System.Workflow.Runtime.WorkflowRuntime> class was used to run the workflow definitions.</span></span>  <span data-ttu-id="60af2-406">WF4 は <xref:System.Activities.WorkflowApplication> を使用して単一ワークフローのインスタンスを作成するか、直接 <xref:System.Activities.WorkflowInvoker> を使用してアクティビティがメソッドに呼び出された場合のように実行できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-406">WF4 can either use <xref:System.Activities.WorkflowApplication> to create a single workflow instance or directly use <xref:System.Activities.WorkflowInvoker> to run the activity as if it were a method call.</span></span>  <span data-ttu-id="60af2-407"><xref:System.Activities.WorkflowApplication> は単一ワークフローのインスタンスのホストで、<xref:System.Workflow.Runtime.WorkflowRuntime> に類似した機能を持つため、このテストで使用しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-407"><xref:System.Activities.WorkflowApplication> is a host of a single workflow instance and has closer feature parity to <xref:System.Workflow.Runtime.WorkflowRuntime> so that was used in this test.</span></span>

 <span data-ttu-id="60af2-408">IIS でワークフローをホストする場合、<xref:System.Web.Hosting.VirtualPathProvider> を使用することで、すべての XAMLX または XOML ファイルを生成するのではなく、新しい <xref:System.ServiceModel.WorkflowServiceHost> を作成することができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-408">When hosting workflows in IIS it is possible to use a <xref:System.Web.Hosting.VirtualPathProvider> to create a new <xref:System.ServiceModel.WorkflowServiceHost> instead of generating all of the XAMLX or XOML files.</span></span>  <span data-ttu-id="60af2-409">受信<xref:System.Web.Hosting.VirtualPathProvider>要求を処理し、データベースから読み込むことができる (この場合は、その場で生成される) 「仮想ファイル」で応答します。</span><span class="sxs-lookup"><span data-stu-id="60af2-409">The <xref:System.Web.Hosting.VirtualPathProvider> handles the incoming request and responds with a "virtual file" that can be loaded from a database or, in this case, generated on the fly.</span></span>  <span data-ttu-id="60af2-410">したがって、1,000 個の物理ファイルを作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-410">It is therefore unnecessary to create 1000 physical files.</span></span>

 <span data-ttu-id="60af2-411">コンソール テストで使用したワークフロー定義はアクティビティが 1 つの単純なシーケンシャル ワークフローです。</span><span class="sxs-lookup"><span data-stu-id="60af2-411">The workflow definitions used in the console test were simple sequential workflows with a single activity.</span></span>  <span data-ttu-id="60af2-412">1 つのアクティビティは、WF3 の場合は空の <xref:System.Workflow.Activities.CodeActivity>、WF4 の場合は `Comment` アクティビティでした。</span><span class="sxs-lookup"><span data-stu-id="60af2-412">The single activity was an empty <xref:System.Workflow.Activities.CodeActivity> for the WF3 case and a `Comment` activity for the WF4 case.</span></span>  <span data-ttu-id="60af2-413">IIS でホストするケースでは、メッセージの受信で開始し、応答の送信で終了するワークフローを使用しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-413">The IIS-hosted case used workflows that start on receiving a message and end on sending a reply:</span></span>

<span data-ttu-id="60af2-414">次の図は、ReceiveActivity を持つ WF3 ワークフローと、要求/応答パターンを持つ WF4 ワークフローを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-414">The following image shows a WF3 workflow with ReceiveActivity and a WF4 workflow with request/response pattern:</span></span>

 ![WF3 および WF4 でのワークフロー サービス](./media/performance/workflow-receive-activity.gif)

 <span data-ttu-id="60af2-416">次の表は、単一ワークフロー定義と 1001 定義の間のワーキング セットのデルタを示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-416">The following table shows the delta in working set between a single workflow definition and 1001 definitions:</span></span>

|<span data-ttu-id="60af2-417">ホスト オプション</span><span class="sxs-lookup"><span data-stu-id="60af2-417">Hosting Options</span></span>|<span data-ttu-id="60af2-418">WF3 のワーキング セット デルタ</span><span class="sxs-lookup"><span data-stu-id="60af2-418">WF3 Working Set Delta</span></span>|<span data-ttu-id="60af2-419">WF4 のワーキング セット デルタ</span><span class="sxs-lookup"><span data-stu-id="60af2-419">WF4 Working Set Delta</span></span>|
|---------------------|---------------------------|---------------------------|
|<span data-ttu-id="60af2-420">コンソール アプリケーションでホストされるワークフロー</span><span class="sxs-lookup"><span data-stu-id="60af2-420">Console Application Hosted Workflows</span></span>|<span data-ttu-id="60af2-421">18 MB</span><span class="sxs-lookup"><span data-stu-id="60af2-421">18 MB</span></span>|<span data-ttu-id="60af2-422">9 MB</span><span class="sxs-lookup"><span data-stu-id="60af2-422">9 MB</span></span>|
|<span data-ttu-id="60af2-423">IIS でホストされるワークフロー サービス</span><span class="sxs-lookup"><span data-stu-id="60af2-423">IIS Hosted Workflow Services</span></span>|<span data-ttu-id="60af2-424">446 MB</span><span class="sxs-lookup"><span data-stu-id="60af2-424">446 MB</span></span>|<span data-ttu-id="60af2-425">364 MB</span><span class="sxs-lookup"><span data-stu-id="60af2-425">364 MB</span></span>|

 <span data-ttu-id="60af2-426">IIS でワークフロー定義をホストすると<xref:System.ServiceModel.WorkflowServiceHost>、詳細な WCF サービス の成果物、およびホストに関連付けられたメッセージ処理ロジックが原因で、より多くのメモリが消費されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-426">Hosting workflow definitions in IIS consumes much more memory due to the <xref:System.ServiceModel.WorkflowServiceHost>, detailed WCF service artifacts, and the message processing logic associated with the host.</span></span>

 <span data-ttu-id="60af2-427">WF3 のコンソール ホストでは、ワークフローは XOML ではなくコードで実装されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-427">For console hosting in WF3 the workflows were implemented in code instead of XOML.</span></span>  <span data-ttu-id="60af2-428">WF4 では既定で XAML を使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-428">In WF4 the default is to use XAML.</span></span>  <span data-ttu-id="60af2-429">XAML は埋め込みリソースとしてアセンブリに格納され、実行時にコンパイルされてワークフローの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="60af2-429">The XAML is stored as an embedded resource in the assembly and compiled during runtime to provide the implementation of the workflow.</span></span>  <span data-ttu-id="60af2-430">このプロセスにはある程度のオーバーヘッドが伴います。</span><span class="sxs-lookup"><span data-stu-id="60af2-430">There is some overhead associated with this process.</span></span>  <span data-ttu-id="60af2-431">WF3 と WF4 を公正に比較するため、XAML ではなくコード化されたワークフローを使用しました。</span><span class="sxs-lookup"><span data-stu-id="60af2-431">In order to make a fair comparison between WF3 and WF4, coded workflows were used instead of XAML.</span></span>  <span data-ttu-id="60af2-432">WF4 ワークフローの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-432">An example of one of the WF4 workflows is shown below:</span></span>

```csharp
public class Workflow1 : Activity
{
    protected override Func<Activity> Implementation
    {
        get
        {
            return new Func<Activity>(() =>
            {
                return new Sequence
                {
                    Activities = {
                        new Comment()
                    }
                };
            });
        }
        set
        {
            base.Implementation = value;
        }
    }
}
```

 <span data-ttu-id="60af2-433">その他にもメモリ消費量に影響を与えるさまざまな要因があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-433">There are many other factors that can affect memory consumption.</span></span> <span data-ttu-id="60af2-434">すべてのマネージド プログラムに対しても同じアドバイスが当てはまります。</span><span class="sxs-lookup"><span data-stu-id="60af2-434">The same advice for all managed programs still applies.</span></span>  <span data-ttu-id="60af2-435">IIS ホスト環境では、ワークフロー定義に対して作成された <xref:System.ServiceModel.WorkflowServiceHost> オブジェクトはアプリケーション プールがリサイクルされるまでメモリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-435">In IIS-hosted environments, the <xref:System.ServiceModel.WorkflowServiceHost> object created for a workflow definition stays in memory until the application pool is recycled.</span></span>  <span data-ttu-id="60af2-436">拡張を書き込むときは、この点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-436">This should be kept in mind when writing extensions.</span></span>  <span data-ttu-id="60af2-437">また、"グローバル" 変数 (ワークフロー全体のスコープを指定した変数) を避け、可能な限り変数のスコープを制限することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="60af2-437">Also, it is best to avoid "global" variables (variables scoped to the whole workflow) and limit the scope of variables wherever possible.</span></span>

## <a name="workflow-runtime-services"></a><span data-ttu-id="60af2-438">ワークフロー ランタイムのサービス</span><span class="sxs-lookup"><span data-stu-id="60af2-438">Workflow Runtime Services</span></span>

### <a name="persistence"></a><span data-ttu-id="60af2-439">永続化</span><span class="sxs-lookup"><span data-stu-id="60af2-439">Persistence</span></span>
 <span data-ttu-id="60af2-440">WF3 と WF4 には SQL 永続化プロバイダーが付属しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-440">WF3 and WF4 both ship with a SQL persistence provider.</span></span>  <span data-ttu-id="60af2-441">WF3 の SQL 永続化プロバイダーはワークフロー インスタンスをシリアル化して BLOB に格納する単純な実装です。</span><span class="sxs-lookup"><span data-stu-id="60af2-441">The WF3 SQL persistence provider is a simple implementation that serializes the workflow instance and stores it in a blob.</span></span>  <span data-ttu-id="60af2-442">そのため、このプロバイダーのパフォーマンスはワークフロー インスタンスのサイズに大きく依存します。</span><span class="sxs-lookup"><span data-stu-id="60af2-442">For this reason, the performance of this provider depends heavily on the size of the workflow instance.</span></span>  <span data-ttu-id="60af2-443">WF3 では、前述したさまざまな理由からインスタンスのサイズは大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-443">In WF3, the instance size could increase for many reasons, as is discussed previously in this paper.</span></span>  <span data-ttu-id="60af2-444">シリアル化されたインスタンスをデータベースに格納するとワークフローの状態を視認できないため、多くの場合に顧客は既定の SQL 永続化プロバイダーを使用しません。</span><span class="sxs-lookup"><span data-stu-id="60af2-444">Many customers choose not to use the default SQL persistence provider because storing a serialized instance in a database gives no visibility into the state of the workflow.</span></span>  <span data-ttu-id="60af2-445">ワークフロー ID が不明な場合、特定のワークフローを探すには、永続化された各インスタンスを逆シリアル化して内容を確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-445">In order to find a particular workflow without knowing the workflow id, one would have to deserialize each persisted instance and examine the contents.</span></span>  <span data-ttu-id="60af2-446">多くの開発者は、この不都合を解消するために独自の永続化プロバイダーを作成することを選択します。</span><span class="sxs-lookup"><span data-stu-id="60af2-446">Many developers prefer to write their own persistence providers to overcome this obstacle.</span></span>

 <span data-ttu-id="60af2-447">WF4 の SQL 永続化プロバイダーでは、この問題の一部に対処することを試みました。</span><span class="sxs-lookup"><span data-stu-id="60af2-447">The WF4 SQL persistence provider has tried to address some of these concerns.</span></span>  <span data-ttu-id="60af2-448">永続化テーブルは、アクティブなブックマークや昇格可能なプロパティなどの一定の情報を公開します。</span><span class="sxs-lookup"><span data-stu-id="60af2-448">The persistence tables expose certain information such as the active bookmarks and promotable properties.</span></span>  <span data-ttu-id="60af2-449">WF4 の新しいコンテンツ ベースの相関関係機能は WF3 の SQL 永続化手法では適切に機能せず、永続化されたワークフロー インスタンスの構成に変更が生じます。</span><span class="sxs-lookup"><span data-stu-id="60af2-449">The new content-based correlation feature in WF4 would not perform well using the WF3 SQL persistence approach, which has driven some change in the organization of the persisted workflow instance.</span></span>  <span data-ttu-id="60af2-450">これにより永続化プロバイダーの処理が複雑化し、データベースに余分な負荷がかかります。</span><span class="sxs-lookup"><span data-stu-id="60af2-450">This makes the job of the persistence provider more complex and puts extra stress on the database.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="60af2-451">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-451">Environment Setup</span></span>
![ワークフロー パフォーマンス テストの環境セットアップ](./media/performance/performance-test-environment.gif)

### <a name="test-setup"></a><span data-ttu-id="60af2-453">テストの設定</span><span class="sxs-lookup"><span data-stu-id="60af2-453">Test Setup</span></span>
 <span data-ttu-id="60af2-454">機能セットを向上させ、コンカレンシー処理の設定を改善した場合でも、WF4 の SQL 永続化プロバイダーは WF3 のプロバイダーより高速です。</span><span class="sxs-lookup"><span data-stu-id="60af2-454">Even with an improved feature set and better concurrency handling, the SQL persistence provider in WF4 is faster than the provider in WF3.</span></span>  <span data-ttu-id="60af2-455">このことを示すため、WF3 と WF4 で同じ操作をする 2 つのワークフローの比較を次に示します。</span><span class="sxs-lookup"><span data-stu-id="60af2-455">To showcase this, two workflows that perform essentially the same operations in WF3 and WF4 are compared below.</span></span>

 ![左側の WF3 の永続化ワークフロー、右側に WF4](./media/performance/persist-workflow-wf3-wf4.gif)

 <span data-ttu-id="60af2-457">2 つのワークフローは、いずれも受信したメッセージによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-457">The two workflows are both created by a received message.</span></span>  <span data-ttu-id="60af2-458">最初に応答を送信すると、ワークフローが永続化されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-458">After sending an initial reply, the workflow is persisted.</span></span>  <span data-ttu-id="60af2-459">WF3 の場合は、空の <xref:System.Workflow.ComponentModel.TransactionScopeActivity> を使用して永続化を開始します。</span><span class="sxs-lookup"><span data-stu-id="60af2-459">In the WF3 case, an empty <xref:System.Workflow.ComponentModel.TransactionScopeActivity> is used to initiate the persistence.</span></span>  <span data-ttu-id="60af2-460">WF3でも、アクティビティを「閉じる時に持続する」とマークすることで、同じことが実現できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-460">The same could be achieved in WF3 by marking an activity as "persist on close."</span></span>  <span data-ttu-id="60af2-461">2 番目の、関連付けられたメッセージによってワークフローを完了します。</span><span class="sxs-lookup"><span data-stu-id="60af2-461">A second, correlated message completes the workflow.</span></span>  <span data-ttu-id="60af2-462">ワークフローは永続化されますが、アンロードされません。</span><span class="sxs-lookup"><span data-stu-id="60af2-462">The workflows are persisted but not unloaded.</span></span>

### <a name="test-results"></a><span data-ttu-id="60af2-463">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-463">Test Results</span></span>
 ![スループットの持続性を示す縦棒グラフ](./media/performance/throughput-persistence-graph.gif)

 <span data-ttu-id="60af2-465">クライアントと中間層とのトランスポートが HTTP の場合、WF4 の永続化ではパフォーマンスが 2.6 倍向上し、</span><span class="sxs-lookup"><span data-stu-id="60af2-465">When the transport between client and middle tier is HTTP, persistence in WF4 shows an improvement of 2.6 times.</span></span>  <span data-ttu-id="60af2-466">TCP トランスポートの場合では 3.0 倍向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-466">The TCP transport increases that factor to 3.0 times.</span></span>  <span data-ttu-id="60af2-467">いずれの場合も、中間層の CPU 使用率は 98% 以上です。</span><span class="sxs-lookup"><span data-stu-id="60af2-467">In all cases, CPU utilization on the middle tier is 98% or higher.</span></span>  <span data-ttu-id="60af2-468">WF4 の方がスループットが高い理由はワークフロー ランタイムが高速であるためです。</span><span class="sxs-lookup"><span data-stu-id="60af2-468">The reason that WF4 throughput is greater is due to the faster workflow runtime.</span></span>  <span data-ttu-id="60af2-469">シリアル化されたインスタンスのサイズはどちらの場合も小さく、ここでは大きな要因になりません。</span><span class="sxs-lookup"><span data-stu-id="60af2-469">The size of the serialized instance is low for both cases and is not a major contributing element in this situation.</span></span>

 <span data-ttu-id="60af2-470">このテストでは、WF3 と WF4 の両方のワークフローに、永続化するときを明示的に示すアクティビティを使用します。</span><span class="sxs-lookup"><span data-stu-id="60af2-470">Both the WF3 and WF4 workflows in this test use an activity to explicitly indicate when persistence should occur.</span></span>  <span data-ttu-id="60af2-471">この方法にはワークフローをアンロードせずに永続化できるという利点があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-471">This has the benefit of persisting the workflow without unloading it.</span></span>  <span data-ttu-id="60af2-472">WF3 では <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 機能を使用して永続化することもできますが、この機能はワークフロー インスタンスをメモリからアンロードします。</span><span class="sxs-lookup"><span data-stu-id="60af2-472">In WF3, it is also possible to persist using the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> feature, but this unloads the workflow instance from memory.</span></span>  <span data-ttu-id="60af2-473">WF3 では、特定の時点でワークフローが永続化されていることを確認する場合、ワークフロー定義を変更するか、ワークフロー インスタンスをアンロードして再読み込みする必要があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-473">If a developer using WF3 wants to make sure a workflow persists at certain points, they either have to alter the workflow definition or pay the cost for unloading and re-loading the workflow instance.</span></span>  <span data-ttu-id="60af2-474">WF4 の新機能 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A> を使用すると、アンロードせずに永続化することができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-474">A new feature in WF4 makes it possible to persist without unloading: <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>.</span></span>  <span data-ttu-id="60af2-475">この機能ではワークフロー インスタンスをアイドル状態で永続化することが可能で、<xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> のしきい値に達するか、実行が再開されるまでワークフロー インスタンスがメモリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-475">This feature allows the workflow instance to be persisted on idle but stay in memory until the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> threshold is met or execution is resumed.</span></span>

 <span data-ttu-id="60af2-476">WF4 の SQL 永続化プロバイダーはデータベース層でより多くの作業を実行することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-476">Note that the WF4 SQL persistence provider performs more work in the database tier.</span></span>  <span data-ttu-id="60af2-477">SQL データベースはボトルネックになる可能性があるため、CPU およびディスクの使用量を監視することが重要です。</span><span class="sxs-lookup"><span data-stu-id="60af2-477">The SQL database can become a bottleneck so it is important to monitor the CPU and disk usage there.</span></span>  <span data-ttu-id="60af2-478">ワークフロー アプリケーションのパフォーマンス テストを行う場合、必ず SQL データベースから次のパフォーマンス カウンターを含めてください。</span><span class="sxs-lookup"><span data-stu-id="60af2-478">Be sure to include the following performance counters from the SQL database when performance testing workflow applications:</span></span>

- <span data-ttu-id="60af2-479">物理ディスク\\%ディスク読み取り時間</span><span class="sxs-lookup"><span data-stu-id="60af2-479">PhysicalDisk\\%Disk Read Time</span></span>

- <span data-ttu-id="60af2-480">物理ディスク\\%ディスク時間</span><span class="sxs-lookup"><span data-stu-id="60af2-480">PhysicalDisk\\% Disk Time</span></span>

- <span data-ttu-id="60af2-481">物理ディスク\\%ディスク書き込み時間</span><span class="sxs-lookup"><span data-stu-id="60af2-481">PhysicalDisk\\% Disk Write Time</span></span>

- <span data-ttu-id="60af2-482">物理ディスク\\の %平均ディスク キューの長さ</span><span class="sxs-lookup"><span data-stu-id="60af2-482">PhysicalDisk\\% Avg. Disk Queue Length</span></span>

- <span data-ttu-id="60af2-483">物理ディスク\平均 ディスク読み取りキューの長さ</span><span class="sxs-lookup"><span data-stu-id="60af2-483">PhysicalDisk\Avg. Disk Read Queue Length</span></span>

- <span data-ttu-id="60af2-484">物理ディスク\Avg ディスク書き込みキューの長さ</span><span class="sxs-lookup"><span data-stu-id="60af2-484">PhysicalDisk\Avg. Disk Write Queue Length</span></span>

- <span data-ttu-id="60af2-485">PhysicalDisk\Current Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="60af2-485">PhysicalDisk\Current Disk Queue Length</span></span>

- <span data-ttu-id="60af2-486">プロセッサ情報\\% プロセッサ時間</span><span class="sxs-lookup"><span data-stu-id="60af2-486">Processor Information\\% Processor Time</span></span>

- <span data-ttu-id="60af2-487">SQLServer:Latches\Average Latch Wait Time (ms)</span><span class="sxs-lookup"><span data-stu-id="60af2-487">SQLServer:Latches\Average Latch Wait Time (ms)</span></span>

- <span data-ttu-id="60af2-488">SQLServer:Latches\Latch Waits/sec</span><span class="sxs-lookup"><span data-stu-id="60af2-488">SQLServer:Latches\Latch Waits/sec</span></span>

### <a name="tracking"></a><span data-ttu-id="60af2-489">追跡</span><span class="sxs-lookup"><span data-stu-id="60af2-489">Tracking</span></span>
 <span data-ttu-id="60af2-490">ワークフロー追跡機能を使用して、ワークフローの進行状況を管理できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-490">Workflow tracking can be used to track the progress of a workflow.</span></span>  <span data-ttu-id="60af2-491">追跡イベントに含まれる情報は追跡プロファイルによって決まります。</span><span class="sxs-lookup"><span data-stu-id="60af2-491">The information that is included in the tracking events is determined by a tracking profile.</span></span>  <span data-ttu-id="60af2-492">追跡プロファイルが複雑になるほど、追跡の負荷が大きくなります。</span><span class="sxs-lookup"><span data-stu-id="60af2-492">The more complex the tracking profile, the more expensive tracking becomes.</span></span>

 <span data-ttu-id="60af2-493">WF3 には SQL ベースの追跡サービスが付属しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-493">WF3 shipped with a SQL-based tracking service.</span></span>  <span data-ttu-id="60af2-494">このサービスはバッチ モードと非バッチ モードで動作します。</span><span class="sxs-lookup"><span data-stu-id="60af2-494">This service could work in batched and non-batched modes.</span></span>  <span data-ttu-id="60af2-495">非バッチ モードでは、イベントの追跡はデータベースに直接書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="60af2-495">In non-batched mode, tracking events are written directly to the database.</span></span>  <span data-ttu-id="60af2-496">バッチ モードでは、追跡イベントは同じバッチ内にワークフロー インスタンスの状態として収集されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-496">In batched mode, tracking events are collected into the same batch as the workflow instance state.</span></span>  <span data-ttu-id="60af2-497">バッチ モードは多様なワークフロー デザインを高パフォーマンスで処理します。</span><span class="sxs-lookup"><span data-stu-id="60af2-497">The batched mode has the best performance for the widest range of workflow designs.</span></span>  <span data-ttu-id="60af2-498">ただし、ワークフローが永続化せずに多数のアクティビティを実行し、そのアクティビティを追跡する場合、バッチ処理によってパフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-498">However, batching can have a negative performance impact if the workflow runs many activities without persisting and those activities are tracked.</span></span>  <span data-ttu-id="60af2-499">このような状態は一般にループで発生するので、大規模なループに永続化ポイントを含めることが最善の回避策になります。</span><span class="sxs-lookup"><span data-stu-id="60af2-499">This would commonly happen in loops and the best way to avoid this scenario is to design large loops to contain a persistence point.</span></span>  <span data-ttu-id="60af2-500">ループに永続化ポイントを導入することによってもパフォーマンスが低下する可能性があるので、両者のコストを測定してバランスを考慮することが重要です。</span><span class="sxs-lookup"><span data-stu-id="60af2-500">Introducing a persistence point into a loop can negatively affect performance as well so it is important to measure the costs of each and come up with a balance.</span></span>

 <span data-ttu-id="60af2-501">WF4 には SQL 追跡サービスは付属していません。</span><span class="sxs-lookup"><span data-stu-id="60af2-501">WF4 is not shipped with a SQL tracking service.</span></span>  <span data-ttu-id="60af2-502">追跡情報を SQL データベースに記録する方法は、.NET Framework に組み込まれるのではなく、アプリケーション サーバーから処理する方が適切です。</span><span class="sxs-lookup"><span data-stu-id="60af2-502">Recording tracking information to a SQL database can be handled better from an application server rather than built into the .NET Framework.</span></span> <span data-ttu-id="60af2-503">SQL 追跡は AppFabric によって処理するようになりました。</span><span class="sxs-lookup"><span data-stu-id="60af2-503">Therefore SQL tracking is now handled by AppFabric.</span></span>  <span data-ttu-id="60af2-504">WF4 の標準追跡プロバイダーは Event Tracing for Windows (ETW) に基づいています。</span><span class="sxs-lookup"><span data-stu-id="60af2-504">The out-of-the-box tracking provider in WF4 is based on Event Tracing for Windows (ETW).</span></span>

 <span data-ttu-id="60af2-505">ETW は Windows に組み込まれた、カーネル レベルの待機時間が短いイベント システムです。</span><span class="sxs-lookup"><span data-stu-id="60af2-505">ETW is a kernel-level, low-latency event system built into Windows.</span></span>  <span data-ttu-id="60af2-506">このシステムは、実際に使用したときにのみイベント追跡のコストが発生するようにすることが可能なプロバイダー/コンシューマー モデルを使用しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-506">It uses a provider/consumer model that makes it possible to only incur the penalty for event tracing when there is actually a consumer.</span></span>  <span data-ttu-id="60af2-507">プロセッサ、ディスク、メモリ、ネットワーク使用量などのカーネル イベント以外にも、多くのアプリケーションが ETW を利用しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-507">In addition to kernel events such as processor, disk, memory, and network usage, many applications leverage ETW as well.</span></span>  <span data-ttu-id="60af2-508">ETW イベントは、イベントをアプリケーションに応じてカスタマイズできるという点でパフォーマンス カウンターより高機能です。</span><span class="sxs-lookup"><span data-stu-id="60af2-508">ETW events are more powerful than performance counters in that events can be customized to the application.</span></span>  <span data-ttu-id="60af2-509">イベントにワークフロー ID や情報メッセージなどのテキストを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="60af2-509">An event can contain text such as a workflow ID or an informational message.</span></span>  <span data-ttu-id="60af2-510">また、すべてのイベントをキャプチャするより一定のイベントのサブセットを使用した方がパフォーマンスへの影響が少ないため、イベントはビットマスクを使用して分類されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-510">Also, events are categorized with bitmasks so that consuming a certain subset of events will have less performance impact than capturing all events.</span></span>

 <span data-ttu-id="60af2-511">追跡に SQL ではなく ETW を使用する方法には次の利点があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-511">Benefits to the approach of using ETW for tracking instead of SQL include:</span></span>

- <span data-ttu-id="60af2-512">追跡イベントの収集を別のプロセスに分離できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-512">Collection of tracking events can be separated to another process.</span></span>  <span data-ttu-id="60af2-513">これによりイベントの記録方法の柔軟性が高まります。</span><span class="sxs-lookup"><span data-stu-id="60af2-513">This gives greater flexibility in how the events are recorded.</span></span>

- <span data-ttu-id="60af2-514">ETW 追跡イベントは、WCF ETW イベントや SQL Server やカーネル プロバイダーなどの他の ETW プロバイダーと簡単に組み合わせられます。</span><span class="sxs-lookup"><span data-stu-id="60af2-514">ETW tracking events are easily combined with the WCF ETW events or other ETW providers such as a SQL Server or kernel provider.</span></span>

- <span data-ttu-id="60af2-515">ワークフローの作成者は、WF3 の SQL 追跡サービスのバッチ モードなど、特定の追跡の実装を改良するためにワークフローを変更する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-515">Workflow authors do not need to alter a workflow to work better with a particular tracking implementation, such as the WF3 SQL tracking service’s batch mode.</span></span>

- <span data-ttu-id="60af2-516">管理者はホスト プロセスをリサイクルすることなく追跡をオンまたはオフにできます。</span><span class="sxs-lookup"><span data-stu-id="60af2-516">An administrator can turn tracking on or off without recycling the host process.</span></span>

 <span data-ttu-id="60af2-517">ETW による追跡にはパフォーマンス上の利点と同時に欠点もあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-517">The performance benefits to ETW tracking come with a drawback.</span></span>  <span data-ttu-id="60af2-518">システムが極度のリソース圧迫にさらされると、ETW イベントは失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-518">ETW events can be lost if the system is under intense resource pressure.</span></span>  <span data-ttu-id="60af2-519">イベントの処理は通常のプログラムの実行をブロックすることを目的としていないため、すべての ETW イベントがサブスクライバーにブロードキャストされることは保証されません。</span><span class="sxs-lookup"><span data-stu-id="60af2-519">The processing of events is not meant to block normal program execution and therefore it is not guaranteed that all ETW events will be broadcast to their subscribers.</span></span>  <span data-ttu-id="60af2-520">そのため、ETW 追跡は状態監視に適していますが、監査には適しません。</span><span class="sxs-lookup"><span data-stu-id="60af2-520">This makes ETW tracking great for health monitoring but not suitable for auditing.</span></span>

 <span data-ttu-id="60af2-521">WF4 には SQL 追跡プロバイダーはありませんが、AppFabric に SQL 追跡プロバイダーがあります。</span><span class="sxs-lookup"><span data-stu-id="60af2-521">While WF4 does not have a SQL tracking provider, AppFabric does.</span></span>  <span data-ttu-id="60af2-522">AppFabric の SQL 追跡では、クイック挿入用にイベントをバッチ処理して SQL テーブルに書き込む Windows サービスを使用して、ETW イベントに定期受信します。</span><span class="sxs-lookup"><span data-stu-id="60af2-522">AppFabric’s SQL tracking approach is to subscribe to ETW events with a Windows Service that batches the events and writes them to a SQL table designed for quick inserts.</span></span>  <span data-ttu-id="60af2-523">別のジョブでこのテーブルからデータを排出し、形式を変更して AppFabric ダッシュボードに表示可能なレポート テーブルに格納します。</span><span class="sxs-lookup"><span data-stu-id="60af2-523">A separate job drains the data from this table and reforms it into reporting tables that can be viewed on the AppFabric dashboard.</span></span>  <span data-ttu-id="60af2-524">追跡イベントのバッチは元になるワークフローとは独立して処理されるため、永続化ポイントを待機せずに記録されます。</span><span class="sxs-lookup"><span data-stu-id="60af2-524">This means that a batch of tracking events is handled independent of the workflow it came from and therefore does not have to wait for a persistence point before being recorded.</span></span>

 <span data-ttu-id="60af2-525">ETW イベントの記録には logman や xperf などのツールを使用できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-525">ETW events can be recorded with tools such as logman or xperf.</span></span>  <span data-ttu-id="60af2-526">小規模な ETL ファイルは xperfview などのツールで表示できます。または、tracerpt を使用して XML などのわかりやすい形式に変換することもできます。</span><span class="sxs-lookup"><span data-stu-id="60af2-526">The compact ETL file can be viewed with a tool like xperfview or converted to a more readable format, such as XML, with tracerpt.</span></span>  <span data-ttu-id="60af2-527">WF3 では、SQL データベースなしで追跡イベントを取得する唯一の方法は、カスタム追跡サービスを作成することです。</span><span class="sxs-lookup"><span data-stu-id="60af2-527">In WF3, the only option for getting tracking events without a SQL database is to create a custom tracking service.</span></span> <span data-ttu-id="60af2-528">ETW の詳細については、「 [WCF サービスと Windows およびイベント トレース -](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) [Windows アプリケーションのイベント トレース](/windows/desktop/etw/event-tracing-portal)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-528">For more information about ETW, see [WCF Services and Event Tracing for Windows](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) and [Event Tracing - Windows applications](/windows/desktop/etw/event-tracing-portal).</span></span>

 <span data-ttu-id="60af2-529">ワークフロー追跡を有効にした場合のパフォーマンスへの影響の程度はさまざまです。</span><span class="sxs-lookup"><span data-stu-id="60af2-529">Enabling workflow tracking will impact performance in varying degrees.</span></span>  <span data-ttu-id="60af2-530">次のベンチマークでは、logman ツールを使用し、ETW 追跡イベントを使用してそのイベントを ETL ファイルに記録します。</span><span class="sxs-lookup"><span data-stu-id="60af2-530">The benchmark below uses the logman tool to consume the ETW tracking events and record them to an ETL file.</span></span>  <span data-ttu-id="60af2-531">AppFabric の SQL 追跡のコストについてはこの記事の対象外です。</span><span class="sxs-lookup"><span data-stu-id="60af2-531">The cost of the SQL tracking in AppFabric is not in the scope of this article.</span></span>  <span data-ttu-id="60af2-532">このベンチマークには AppFabric でも使用される基本的な追跡プロファイルが示されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-532">The basic tracking profile, also used in AppFabric, is shown in this benchmark.</span></span>  <span data-ttu-id="60af2-533">状態監視イベントのみを追跡した場合のコストも含まれています。</span><span class="sxs-lookup"><span data-stu-id="60af2-533">Also included is the cost of tracking only health monitoring events.</span></span>  <span data-ttu-id="60af2-534">これらのイベントは問題をトラブルシューティングし、システムの平均スループットを確認するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="60af2-534">These events are useful for troubleshooting problems and determining the average throughput of the system.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="60af2-535">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-535">Environment Setup</span></span>
 ![ワークフロー パフォーマンス テストの環境セットアップ](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="60af2-537">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-537">Test Results</span></span>

 ![ワークフロー追跡コストを示す縦棒グラフ](./media/performance/workflow-tracking-costs.gif)

 <span data-ttu-id="60af2-539">状態監視はスループットに約 3% の影響をもたらしています。</span><span class="sxs-lookup"><span data-stu-id="60af2-539">Health monitoring has roughly a 3% impact on throughput.</span></span>  <span data-ttu-id="60af2-540">基本プロファイルのコストは約 8% です。</span><span class="sxs-lookup"><span data-stu-id="60af2-540">The basic profile’s cost is around 8%.</span></span>

## <a name="interop"></a><span data-ttu-id="60af2-541">Interop</span><span class="sxs-lookup"><span data-stu-id="60af2-541">Interop</span></span>
 <span data-ttu-id="60af2-542">WF4 では [!INCLUDE[wf1](../../../includes/wf1-md.md)] をほぼ全面的に変更しているため、WF3 のワークフローおよびアクティビティは WF4 とは直接互換性がありません。</span><span class="sxs-lookup"><span data-stu-id="60af2-542">WF4 is almost a complete rewrite of [!INCLUDE[wf1](../../../includes/wf1-md.md)] and therefore WF3 workflows and activities are not directly compatible with WF4.</span></span>  <span data-ttu-id="60af2-543">Windows ワークフロー ファウンデーションを早期に採用した多くのお客様は、WF3 の社内またはサードパーティのワークフロー定義とカスタム アクティビティを使用しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-543">Many customers that adopted Windows Workflow Foundation early will have in-house or third-party workflow definitions and custom activities for WF3.</span></span>  <span data-ttu-id="60af2-544">WF4 への移行を簡素化するには、Interop アクティビティを使用する方法があります。この方法により WF4 ワークフロー内から WF3 アクティビティを実行できます。</span><span class="sxs-lookup"><span data-stu-id="60af2-544">One way to ease the transition to WF4 is to use the Interop activity, which can execute WF3 activities from within a WF4 workflow.</span></span>  <span data-ttu-id="60af2-545"><xref:System.Activities.Statements.Interop> アクティビティは必要な場合にのみ使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="60af2-545">It is recommended that the <xref:System.Activities.Statements.Interop> activity only be used when necessary.</span></span> <span data-ttu-id="60af2-546">WF4 への移行の詳細については、「 [WF4 移行ガイダンス](migration-guidance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60af2-546">For more information about migrating to WF4 check out the [WF4 Migration Guidance](migration-guidance.md).</span></span>

### <a name="environment-setup"></a><span data-ttu-id="60af2-547">環境のセットアップ</span><span class="sxs-lookup"><span data-stu-id="60af2-547">Environment Setup</span></span>
 ![ワークフロー パフォーマンス テストの環境セットアップ](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="60af2-549">テスト結果</span><span class="sxs-lookup"><span data-stu-id="60af2-549">Test Results</span></span>

<span data-ttu-id="60af2-550">次の表は、さまざまな構成でシーケンス内の 5 つのアクティビティを含むワークフローを実行した結果を示しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-550">The following table shows the results of running a workflow containing five activities in a sequence in various configurations.</span></span>

|<span data-ttu-id="60af2-551">テスト</span><span class="sxs-lookup"><span data-stu-id="60af2-551">Test</span></span>|<span data-ttu-id="60af2-552">スループット (ワークフロー/秒)</span><span class="sxs-lookup"><span data-stu-id="60af2-552">Throughput (workflows/sec)</span></span>|
|----------|-----------------------------------|
|<span data-ttu-id="60af2-553">WF3 ランタイムの WF3 シーケンス</span><span class="sxs-lookup"><span data-stu-id="60af2-553">WF3 Sequence in WF3 runtime</span></span>|<span data-ttu-id="60af2-554">1,576</span><span class="sxs-lookup"><span data-stu-id="60af2-554">1,576</span></span>|
|<span data-ttu-id="60af2-555">Interop を使用した WF4 ランタイムの WF3 シーケンス</span><span class="sxs-lookup"><span data-stu-id="60af2-555">WF3 Sequence in WF4 runtime using Interop</span></span>|<span data-ttu-id="60af2-556">2,745</span><span class="sxs-lookup"><span data-stu-id="60af2-556">2,745</span></span>|
|<span data-ttu-id="60af2-557">WF4 シーケンス</span><span class="sxs-lookup"><span data-stu-id="60af2-557">WF4 Sequence</span></span>|<span data-ttu-id="60af2-558">153,582</span><span class="sxs-lookup"><span data-stu-id="60af2-558">153,582</span></span>|

 <span data-ttu-id="60af2-559">Interop を使用した場合の方が直接 WF3 を使用した場合よりパフォーマンスが顕著に高くなっていますが、</span><span class="sxs-lookup"><span data-stu-id="60af2-559">There is a notable performance increase to using Interop over straight WF3.</span></span>  <span data-ttu-id="60af2-560">WF4 アクティビティと比較した場合、パフォーマンスの向上はごくわずかです。</span><span class="sxs-lookup"><span data-stu-id="60af2-560">However, when compared against WF4 activities, the increase is negligible.</span></span>

## <a name="summary"></a><span data-ttu-id="60af2-561">まとめ</span><span class="sxs-lookup"><span data-stu-id="60af2-561">Summary</span></span>
 <span data-ttu-id="60af2-562">WF4 のパフォーマンスに対する多大な投資は多くの重要な面で成果をもたらしました。</span><span class="sxs-lookup"><span data-stu-id="60af2-562">Heavy investments in performance for WF4 have paid off in many crucial areas.</span></span>  <span data-ttu-id="60af2-563">個々のワークフロー コンポーネントのパフォーマンスは、[!INCLUDE[wf1](../../../includes/wf1-md.md)] ランタイムが効率的になることにより、WF4 が WF3 と比較して数百倍高速になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="60af2-563">Individual workflow component performance is in some cases hundreds of times faster in WF4 compared to WF3 due to a leaner [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="60af2-564">待機時間の数値も大幅に向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-564">Latency numbers are significantly better as well.</span></span>  <span data-ttu-id="60af2-565">つまり、WCF オーケストレーション サービス[!INCLUDE[wf1](../../../includes/wf1-md.md)]の使用によるパフォーマンスの低下は、 を使用[!INCLUDE[wf1](../../../includes/wf1-md.md)]する利点が増えることを考慮すると、非常に小さいです。</span><span class="sxs-lookup"><span data-stu-id="60af2-565">This means the performance penalty for using [!INCLUDE[wf1](../../../includes/wf1-md.md)] as opposed to hand-coding WCF orchestration services is very small considering the added benefits of using [!INCLUDE[wf1](../../../includes/wf1-md.md)].</span></span>  <span data-ttu-id="60af2-566">永続化のパフォーマンスは 2.5 ～ 3.0 倍向上しています。</span><span class="sxs-lookup"><span data-stu-id="60af2-566">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="60af2-567">ワークフロー追跡による状態監視のオーバーヘッドもごくわずかになりました。</span><span class="sxs-lookup"><span data-stu-id="60af2-567">Health monitoring by means of workflow tracking now has very little overhead.</span></span>  <span data-ttu-id="60af2-568">WF3 から WF4 への移行を検討する場合の包括的な移行ガイドも提供されています。</span><span class="sxs-lookup"><span data-stu-id="60af2-568">A comprehensive set of migration guides are available for those that are considering moving from WF3 to WF4.</span></span>  <span data-ttu-id="60af2-569">これらのあらゆる要素を考慮すると、WF4 は複雑なアプリケーションの作成において魅力的な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="60af2-569">All of this should make WF4 an attractive option for writing complex applications.</span></span>
