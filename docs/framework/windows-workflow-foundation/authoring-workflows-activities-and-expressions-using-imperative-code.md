---
title: 命令型コードを使用してワークフロー、アクティビティ、および式を作成する方法
ms.date: 03/30/2017
ms.assetid: cefc9cfc-2882-4eb9-8c94-7a6da957f2b2
ms.openlocfilehash: 97f57067e72be2ed2fb6b3846e2ab876c13e049f
ms.sourcegitcommit: 32a575bf4adccc901f00e264f92b759ced633379
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/04/2019
ms.locfileid: "74802701"
---
# <a name="authoring-workflows-activities-and-expressions-using-imperative-code"></a><span data-ttu-id="0fa42-102">命令型コードを使用してワークフロー、アクティビティ、および式を作成する方法</span><span class="sxs-lookup"><span data-stu-id="0fa42-102">Authoring Workflows, Activities, and Expressions Using Imperative Code</span></span>
<span data-ttu-id="0fa42-103">ワークフロー定義は、構成済みのアクティビティ オブジェクトのツリーです。</span><span class="sxs-lookup"><span data-stu-id="0fa42-103">A workflow definition is a tree of configured activity objects.</span></span> <span data-ttu-id="0fa42-104">このアクティビティ ツリーは、手動で XAML を編集したり、ワークフロー デザイナーを使用して XAML を生成したりするなど、多くの方法で定義することができます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-104">This tree of activities can be defined many ways, including by hand-editing XAML or by using the Workflow Designer to produce XAML.</span></span> <span data-ttu-id="0fa42-105">ただし、XAML の使用は必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-105">Use of XAML, however, is not a requirement.</span></span> <span data-ttu-id="0fa42-106">ワークフロー定義は、プログラムで作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-106">Workflow definitions can also be created programmatically.</span></span> <span data-ttu-id="0fa42-107">このトピックでは、コードを使用したワークフローの定義、アクティビティ、および式の作成の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-107">This topic provides an overview of creating workflow definitions, activities, and expressions by using code.</span></span> <span data-ttu-id="0fa42-108">コードを使用した XAML ワークフローの使用例については、「 [xaml との間でのワークフローとアクティビティのシリアル](serializing-workflows-and-activities-to-and-from-xaml.md)化」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-108">For examples of working with XAML workflows using code, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
## <a name="creating-workflow-definitions"></a><span data-ttu-id="0fa42-109">ワークフロー定義の作成</span><span class="sxs-lookup"><span data-stu-id="0fa42-109">Creating Workflow Definitions</span></span>  
 <span data-ttu-id="0fa42-110">アクティビティ型のインスタンスをインスタンス化して、アクティビティ オブジェクトのプロパティを構成することで、ワークフロー定義を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-110">A workflow definition can be created by instantiating an instance of an activity type and configuring the activity object’s properties.</span></span> <span data-ttu-id="0fa42-111">子アクティビティを含まないアクティビティの場合、数行のコードを使用してこれを作成できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-111">For activities that do not contain child activities, this can be accomplished using a few lines of code.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#47](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#47)]  
  
> [!NOTE]
> <span data-ttu-id="0fa42-112">このトピックの例では、<xref:System.Activities.WorkflowInvoker> を使用してサンプル ワークフローを実行します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-112">The examples in this topic use <xref:System.Activities.WorkflowInvoker> to run the sample workflows.</span></span> <span data-ttu-id="0fa42-113">ワークフローの呼び出し、引数の引き渡し、および使用可能なさまざまなホスティングの選択の詳細については、「 [WorkflowInvoker 元と WorkflowApplication の使用](using-workflowinvoker-and-workflowapplication.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-113">For more information about invoking workflows, passing arguments, and the different hosting choices that are available, see [Using WorkflowInvoker and WorkflowApplication](using-workflowinvoker-and-workflowapplication.md).</span></span>  
  
 <span data-ttu-id="0fa42-114">次の例では、1 つの <xref:System.Activities.Statements.WriteLine> アクティビティから成るワークフローを作成します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-114">In this example, a workflow that consists of a single <xref:System.Activities.Statements.WriteLine> activity is created.</span></span> <span data-ttu-id="0fa42-115"><xref:System.Activities.Statements.WriteLine> アクティビティの <xref:System.Activities.Statements.WriteLine.Text%2A> 引数が設定され、ワークフローが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-115">The <xref:System.Activities.Statements.WriteLine> activity’s <xref:System.Activities.Statements.WriteLine.Text%2A> argument is set, and the workflow is invoked.</span></span> <span data-ttu-id="0fa42-116">アクティビティに子アクティビティが含まれる場合も、作成のメソッドは同じです。</span><span class="sxs-lookup"><span data-stu-id="0fa42-116">If an activity contains child activities, the method of construction is similar.</span></span> <span data-ttu-id="0fa42-117">次の例では、2 つの <xref:System.Activities.Statements.Sequence> アクティビティを含む <xref:System.Activities.Statements.WriteLine> アクティビティを使用します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-117">The following example uses a <xref:System.Activities.Statements.Sequence> activity that contains two <xref:System.Activities.Statements.WriteLine> activities.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#48](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#48)]  
  
### <a name="using-object-initializers"></a><span data-ttu-id="0fa42-118">オブジェクト初期化子の使用</span><span class="sxs-lookup"><span data-stu-id="0fa42-118">Using Object Initializers</span></span>  
 <span data-ttu-id="0fa42-119">このトピックの例では、オブジェクトの初期化の構文を使用します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-119">The examples in this topic use object initialization syntax.</span></span> <span data-ttu-id="0fa42-120">オブジェクトの初期化の構文は、コードでワークフロー定義を作成する場合に便利な方法です。これは、ワークフローのアクティビティの階層ビューが提供され、アクティビティ間の関係が示されるためです。</span><span class="sxs-lookup"><span data-stu-id="0fa42-120">Object initialization syntax can be a useful way to create workflow definitions in code because it provides a hierarchical view of the activities in the workflow and shows the relationship between the activities.</span></span> <span data-ttu-id="0fa42-121">プログラムからワークフローを作成する場合に、オブジェクトの初期化の構文を使用しなければならないという要件はありません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-121">There is no requirement to use object initialization syntax when you programmatically create workflows.</span></span> <span data-ttu-id="0fa42-122">次の例は、機能的には前のサンプルと同じです。</span><span class="sxs-lookup"><span data-stu-id="0fa42-122">The following example is functionally equivalent to the previous example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#49](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#49)]  
  
 <span data-ttu-id="0fa42-123">オブジェクト初期化子の詳細については、「[方法: コンストラクターを呼び出さずC#にオブジェクトを初期化する (プログラミングガイド)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) 」および「[方法: オブジェクト初期化子を使用してオブジェクトを宣言](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-123">For more information about object initializers, see [How to: Initialize Objects without Calling a Constructor (C# Programming Guide)](../../csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer.md) and [How to: Declare an Object by Using an Object Initializer](../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-declare-an-object-by-using-an-object-initializer.md).</span></span>  
  
### <a name="working-with-variables-literal-values-and-expressions"></a><span data-ttu-id="0fa42-124">変数、リテラル値、および式の使用</span><span class="sxs-lookup"><span data-stu-id="0fa42-124">Working with Variables, Literal Values, and Expressions</span></span>  
 <span data-ttu-id="0fa42-125">コードを使用してワークフロー定義を作成する場合は、ワークフロー定義の作成の一部としてコードが実行する内容、およびそのワークフローのインスタンスの実行の一部としてコードが実行する内容に注意してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-125">When creating a workflow definition using code, be aware of what code executes as part of the creation of the workflow definition and what code executes as part of the execution of an instance of that workflow.</span></span> <span data-ttu-id="0fa42-126">たとえば、次のワークフローはランダムな数値を生成し、それをコンソールに出力します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-126">For example, the following workflow is intended to generate a random number and write it to the console.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#50)]  
  
 <span data-ttu-id="0fa42-127">このワークフロー定義のコードが実行されると、`Random.Next` への呼び出しが実行され、その結果がリテラル値としてワークフロー定義に保存されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-127">When this workflow definition code is executed, the call to `Random.Next` is made and the result is stored in the workflow definition as a literal value.</span></span> <span data-ttu-id="0fa42-128">このワークフローの多くのインスタンスを呼び出すことができ、そのすべてに同じ数字が表示されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-128">Many instances of this workflow can be invoked, and all would display the same number.</span></span> <span data-ttu-id="0fa42-129">ワークフローの実行中にランダムな数値を生成するには、ワークフローを実行するたびに評価する式を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-129">To have the random number generation occur during workflow execution, an expression must be used that is evaluated each time the workflow runs.</span></span> <span data-ttu-id="0fa42-130">次の例では、<xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> で Visual Basic 式を使用します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-130">In the following example, a Visual Basic expression is used with a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="0fa42-131">前の例にある式は、<xref:Microsoft.CSharp.Activities.CSharpValue%601> と C# 式を使用して実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-131">The expression in the previous example could also be implemented using a <xref:Microsoft.CSharp.Activities.CSharpValue%601> and a C# expression.</span></span>  
  
```csharp  
new Assign<int>  
{  
    To = n,  
    Value = new CSharpValue<int>("new Random().Next(1, 101)")  
}  
```  
  
 <span data-ttu-id="0fa42-132">C# 式は、その式を含むワークフローが呼び出される前にコンパイルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-132">C# expressions must be compiled before the workflow containing them is invoked.</span></span> <span data-ttu-id="0fa42-133">C# 式がコンパイルされていない場合、ワークフローが呼び出されると <xref:System.NotSupportedException> がスローされ、"``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.``" のようなメッセージが表示されます。Visual Studio で作成されたワークフローが関連するほとんどのシナリオでは、C# 式が自動的にコンパイルされますが、コード ワークフローなどの一部のシナリオでは、C# 式を手動でコンパイルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-133">If the C# expressions are not compiled, a <xref:System.NotSupportedException> is thrown when the workflow is invoked with a message similar to the following: ``Expression Activity type 'CSharpValue`1' requires compilation in order to run.  Please ensure that the workflow has been compiled.`` In most scenarios involving workflows created in Visual Studio the C# expressions are compiled automatically, but in some scenarios, such as code workflows, the C# expressions must be manually compiled.</span></span> <span data-ttu-id="0fa42-134">式をコンパイルC#する方法の例については、「 [ C#式](csharp-expressions.md)」トピックの「[コードワークフローでの式の使用C# ](csharp-expressions.md#CodeWorkflows) 」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-134">For an example of how to compile C# expressions, see the [Using C# expressions in code workflows](csharp-expressions.md#CodeWorkflows) section of the [C# Expressions](csharp-expressions.md) topic.</span></span>  
  
 <span data-ttu-id="0fa42-135"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> は式の右辺値として使用できる Visual Basic 構文の式を表し、<xref:Microsoft.CSharp.Activities.CSharpValue%601> は式の右辺値として使用できる C# 構文の式を表します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-135">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> represents an expression in Visual Basic syntax that can be used as an r-value in an expression, and a <xref:Microsoft.CSharp.Activities.CSharpValue%601> represents an expression in C# syntax that can be used as an r-value in an expression.</span></span> <span data-ttu-id="0fa42-136">これらの式は、含まれるアクティビティが実行されるたびに評価されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-136">These expressions are evaluated each time the containing activity is executed.</span></span> <span data-ttu-id="0fa42-137">式の結果はワークフローの変数 `n` に代入され、これらの結果はワークフローの次のアクティビティによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-137">The result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="0fa42-138">実行時にワークフローの変数 `n` の値にアクセスするには、<xref:System.Activities.ActivityContext> が必要です。</span><span class="sxs-lookup"><span data-stu-id="0fa42-138">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="0fa42-139">次のようなラムダ式を使用するとアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-139">This can be accessed by using the following lambda expression.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0fa42-140">この 2 つのコードはプログラミング言語として C# を使用している例ですが、1 つは <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> を使用し、もう 1 つは <xref:Microsoft.CSharp.Activities.CSharpValue%601> を使用しています。</span><span class="sxs-lookup"><span data-stu-id="0fa42-140">Note that both of these code are examples are using C# as the programming language, but one uses a <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and one uses a <xref:Microsoft.CSharp.Activities.CSharpValue%601>.</span></span> <span data-ttu-id="0fa42-141"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> および <xref:Microsoft.CSharp.Activities.CSharpValue%601> は、Visual Basic と C# の両方のプロジェクトで使用できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-141"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> and <xref:Microsoft.CSharp.Activities.CSharpValue%601> can be used in both Visual Basic and C# projects.</span></span> <span data-ttu-id="0fa42-142">既定では、ワークフロー デザイナーで作成された式は、ホスティング プロジェクトの言語に一致します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-142">By default, expressions created in the workflow designer match the language of the hosting project.</span></span> <span data-ttu-id="0fa42-143">ワークフローをコードで作成する場合、必要な言語はワークフロー作成者の判断に委ねられます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-143">When creating workflows in code, the desired language is at the discretion of the workflow author.</span></span>  
  
 <span data-ttu-id="0fa42-144">これらの例では、式の結果がワークフロー変数 `n` に代入され、その結果がワークフロー内の次のアクティビティで使用されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-144">In these examples the result of the expression is assigned to the workflow variable `n`, and these results are used by the next activity in the workflow.</span></span> <span data-ttu-id="0fa42-145">実行時にワークフローの変数 `n` の値にアクセスするには、<xref:System.Activities.ActivityContext> が必要です。</span><span class="sxs-lookup"><span data-stu-id="0fa42-145">To access the value of the workflow variable `n` at runtime, the <xref:System.Activities.ActivityContext> is required.</span></span> <span data-ttu-id="0fa42-146">次のようなラムダ式を使用するとアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-146">This can be accessed by using the following lambda expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#52](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#52)]  
  
 <span data-ttu-id="0fa42-147">ラムダ式の詳細については、「[ラムダC#式 (プログラミングガイド)](../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) 」または「ラムダ[式 (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-147">For more information about lambda expressions, see [Lambda Expressions (C# Programming Guide)](../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md) or [Lambda Expressions (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/lambda-expressions.md).</span></span>  
  
 <span data-ttu-id="0fa42-148">ラムダ式は XAML 形式にシリアル化できません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-148">Lambda expressions are not serializable to XAML format.</span></span> <span data-ttu-id="0fa42-149">ラムダ式を使用してワークフローのシリアル化を試みると、<xref:System.Activities.Expressions.LambdaSerializationException> がスローされ、"このワークフローには、コードで指定されたラムダ式が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0fa42-149">If an attempt to serialize a workflow with lambda expressions is made, a <xref:System.Activities.Expressions.LambdaSerializationException> is thrown with the following message: "This workflow contains lambda expressions specified in code.</span></span> <span data-ttu-id="0fa42-150">これらの式は XAML にシリアル化できません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-150">These expressions are not XAML serializable.</span></span> <span data-ttu-id="0fa42-151">このワークフローを XAML にシリアル化できるようにするには、VisualBasicValue/VisualBasicReference を使用するか、ExpressionServices.Convert(lambda) を使用します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-151">In order to make your workflow XAML-serializable, either use VisualBasicValue/VisualBasicReference or ExpressionServices.Convert(lambda).</span></span> <span data-ttu-id="0fa42-152">これにより、ラムダ式が式アクティビティに変換されます。" というメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-152">This will convert your lambda expressions into expression activities."</span></span> <span data-ttu-id="0fa42-153">この式に XAML との互換性を持たせるには、次の例に示すように <xref:System.Activities.Expressions.ExpressionServices> および <xref:System.Activities.Expressions.ExpressionServices.Convert%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-153">To make this expression compatible with XAML, use <xref:System.Activities.Expressions.ExpressionServices> and <xref:System.Activities.Expressions.ExpressionServices.Convert%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#53](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#53)]  
  
 <span data-ttu-id="0fa42-154"><xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-154">A <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> could also be used.</span></span> <span data-ttu-id="0fa42-155">Visual Basic 式を使用する場合はラムダ式が不要であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-155">Note that no lambda expression is required when using a Visual Basic expression.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#54](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#54)]  
  
 <span data-ttu-id="0fa42-156">実行時に、Visual Basic 式は LINQ 式にコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-156">At run time, Visual Basic expressions are compiled into LINQ expressions.</span></span> <span data-ttu-id="0fa42-157">前の例はいずれも XAML にシリアル化できますが、シリアル化された XAML をワークフロー デザイナーで表示および編集することを目的としている場合は、式に <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> を使用してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-157">Both of the previous examples are serializable to XAML, but if the serialized XAML is intended to be viewed and edited in the workflow designer, use <xref:Microsoft.VisualBasic.Activities.VisualBasicValue%601> for your expressions.</span></span> <span data-ttu-id="0fa42-158">`ExpressionServices.Convert` を使用するシリアル化されたワークフローはデザイナーで開くことができますが、式の値は空白になります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-158">Serialized workflows that use `ExpressionServices.Convert` can be opened in the designer, but the value of the expression will be blank.</span></span> <span data-ttu-id="0fa42-159">ワークフローを XAML にシリアル化する方法の詳細については、「 [xaml との間でのワークフローとアクティビティのシリアル](serializing-workflows-and-activities-to-and-from-xaml.md)化」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-159">For more information about serializing workflows to XAML, see [Serializing Workflows and Activities to and from XAML](serializing-workflows-and-activities-to-and-from-xaml.md).</span></span>  
  
#### <a name="literal-expressions-and-reference-types"></a><span data-ttu-id="0fa42-160">リテラル式と参照型</span><span class="sxs-lookup"><span data-stu-id="0fa42-160">Literal Expressions and Reference Types</span></span>  
 <span data-ttu-id="0fa42-161">リテラル式は、ワークフロー内では <xref:System.Activities.Expressions.Literal%601> アクティビティによって表されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-161">Literal expressions are represented in workflows by the <xref:System.Activities.Expressions.Literal%601> activity.</span></span> <span data-ttu-id="0fa42-162">次の <xref:System.Activities.Statements.WriteLine> アクティビティは機能的には同じです。</span><span class="sxs-lookup"><span data-stu-id="0fa42-162">The following <xref:System.Activities.Statements.WriteLine> activities are functionally equivalent.</span></span>  
  
```csharp  
new WriteLine  
{  
    Text = "Hello World."  
},  
new WriteLine  
{  
    Text = new Literal<string>("Hello World.")  
}  
```  
  
 <span data-ttu-id="0fa42-163"><xref:System.String> 以外の参照型を使用してリテラル式を初期化することはできません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-163">It is invalid to initialize a literal expression with any reference type except <xref:System.String>.</span></span> <span data-ttu-id="0fa42-164">次の例では、<xref:System.Activities.Statements.Assign> アクティビティの <xref:System.Activities.Statements.Assign.Value%2A> プロパティは `List<string>` を使用したリテラル式で初期化されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-164">In the following example, an <xref:System.Activities.Statements.Assign> activity's <xref:System.Activities.Statements.Assign.Value%2A> property is initialized with a literal expression using a `List<string>`.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new List<string>())  
},  
```  
  
 <span data-ttu-id="0fa42-165">このアクティビティを含むワークフローを検証すると、"リテラルは、値の型と変更不可の型 System.String のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="0fa42-165">When the workflow containing this activity is validated, the following validation error is returned: "Literal only supports value types and the immutable type System.String.</span></span> <span data-ttu-id="0fa42-166">型 System.Collections.Generic.List\`1[System.String] はリテラルとして使用できません。" という検証エラーが返されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-166">The type System.Collections.Generic.List\`1[System.String] cannot be used as a literal."</span></span> <span data-ttu-id="0fa42-167">ワークフローが呼び出されると、検証エラーのテキストを含む <xref:System.Activities.InvalidWorkflowException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-167">If the workflow is invoked, an <xref:System.Activities.InvalidWorkflowException> is thrown that contains the text of the validation error.</span></span> <span data-ttu-id="0fa42-168">参照型のリテラル式を作成しても、ワークフローの各インスタンスに対して参照型の新しいインスタンスが作成されないため、これは検証エラーとなります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-168">This is a validation error because creating a literal expression with a reference type does not create a new instance of the reference type for each instance of the workflow.</span></span> <span data-ttu-id="0fa42-169">このエラーを解決するには、リテラル式を、参照型の新しいインスタンスを作成して返すリテラル式に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-169">To resolve this, replace the literal expression with one that creates and returns a new instance of the reference type.</span></span>  
  
```csharp  
new Assign  
{  
    To = new OutArgument<List<string>>(items),  
    Value = new InArgument<List<string>>(new VisualBasicValue<List<string>>("New List(Of String)"))  
},  
```  
  
 <span data-ttu-id="0fa42-170">式の詳細については、「[式](expressions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-170">For more information about expressions, see [Expressions](expressions.md).</span></span>  
  
#### <a name="invoking-methods-on-objects-using-expressions-and-the-invokemethod-activity"></a><span data-ttu-id="0fa42-171">式と InvokeMethod アクティビティを使用したオブジェクトのメソッド呼び出し</span><span class="sxs-lookup"><span data-stu-id="0fa42-171">Invoking Methods on Objects using Expressions and the InvokeMethod Activity</span></span>  
 <span data-ttu-id="0fa42-172"><xref:System.Activities.Expressions.InvokeMethod%601> アクティビティを使用すると、.NET Framework のクラスの静的メソッドとインスタンス メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-172">The <xref:System.Activities.Expressions.InvokeMethod%601> activity can be used to invoke static and instance methods of classes in the .NET Framework.</span></span> <span data-ttu-id="0fa42-173">このトピックの前の例では、乱数が <xref:System.Random> クラスを使用して生成されました。</span><span class="sxs-lookup"><span data-stu-id="0fa42-173">In a previous example in this topic, a random number was generated using the <xref:System.Random> class.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#51)]  
  
 <span data-ttu-id="0fa42-174">また <xref:System.Activities.Expressions.InvokeMethod%601> アクティビティは、<xref:System.Random.Next%2A> クラスの <xref:System.Random> メソッドの呼び出しにも使用されました。</span><span class="sxs-lookup"><span data-stu-id="0fa42-174">The <xref:System.Activities.Expressions.InvokeMethod%601> activity could also have been used to call the <xref:System.Random.Next%2A> method of the <xref:System.Random> class.</span></span>  
  
```csharp  
new InvokeMethod<int>  
{  
    TargetObject = new InArgument<Random>(new VisualBasicValue<Random>("New Random()")),  
    MethodName = "Next",  
    Parameters =   
    {  
        new InArgument<int>(1),  
        new InArgument<int>(101)  
    },  
    Result = n  
}  
```  
  
 <span data-ttu-id="0fa42-175"><xref:System.Random.Next%2A> は静的メソッドではないので、<xref:System.Random> プロパティには <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> クラスのインスタンスが指定されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-175">Since <xref:System.Random.Next%2A> is not a static method, an instance of the <xref:System.Random> class is supplied for the <xref:System.Activities.Expressions.InvokeMethod%601.TargetObject%2A> property.</span></span> <span data-ttu-id="0fa42-176">この例では、新しいインスタンスが Visual Basic 式を使用して作成されますが、これまでも作成されてワークフロー変数に格納されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-176">In this example a new instance is created using a Visual Basic expression, but it could also have been created previously and stored in a workflow variable.</span></span> <span data-ttu-id="0fa42-177">この例では、<xref:System.Activities.Statements.Assign%601> アクティビティの代わりに、<xref:System.Activities.Expressions.InvokeMethod%601> アクティビティをより簡単に使用しています。</span><span class="sxs-lookup"><span data-stu-id="0fa42-177">In this example, it would be simpler to use the <xref:System.Activities.Statements.Assign%601> activity instead of the <xref:System.Activities.Expressions.InvokeMethod%601> activity.</span></span> <span data-ttu-id="0fa42-178"><xref:System.Activities.Statements.Assign%601> アクティビティまたは <xref:System.Activities.Expressions.InvokeMethod%601> アクティビティで最終的に呼び出されるメソッド呼び出しが長時間実行されている場合、<xref:System.Activities.Expressions.InvokeMethod%601> には <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> プロパティがあるため、効果があります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-178">If the method call ultimately invoked by either the <xref:System.Activities.Statements.Assign%601> or <xref:System.Activities.Expressions.InvokeMethod%601> activities is long running, <xref:System.Activities.Expressions.InvokeMethod%601> has an advantage since it has a <xref:System.Activities.Expressions.InvokeMethod%601.RunAsynchronously%2A> property.</span></span> <span data-ttu-id="0fa42-179">このプロパティが `true` に設定されると、呼び出されるメソッドはワークフローに対して非同期に実行されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-179">When this property is set to `true`, the invoked method will run asynchronously with regard to the workflow.</span></span> <span data-ttu-id="0fa42-180">他のアクティビティが並列実行される場合、そのメソッドは非同期に実行され、それらのアクティビティはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-180">If other activities are in parallel, they will not be blocked while the method is asynchronously executing.</span></span> <span data-ttu-id="0fa42-181">また、呼び出すメソッドに戻り値がない場合、<xref:System.Activities.Expressions.InvokeMethod%601> はメソッドを呼び出すための適切な手段となります。</span><span class="sxs-lookup"><span data-stu-id="0fa42-181">Also, if the method to be invoked has no return value, then <xref:System.Activities.Expressions.InvokeMethod%601> is the appropriate way to invoke the method.</span></span>  
  
## <a name="arguments-and-dynamic-activities"></a><span data-ttu-id="0fa42-182">引数と動的なアクティビティ</span><span class="sxs-lookup"><span data-stu-id="0fa42-182">Arguments and Dynamic Activities</span></span>  
 <span data-ttu-id="0fa42-183">アクティビティをアクティビティ ツリーにまとめてプロパティと引数を構成すると、コードでワークフロー定義を作成できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-183">A workflow definition is created in code by assembling activities into an activity tree and configuring any properties and arguments.</span></span> <span data-ttu-id="0fa42-184">既存の引数を見つけることはできますが、新しい引数をアクティビティに追加することはできません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-184">Existing arguments can be bound, but new arguments cannot be added to activities.</span></span> <span data-ttu-id="0fa42-185">これには、ルート アクティビティに渡されるワークフロー引数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-185">This includes workflow arguments passed to the root activity.</span></span> <span data-ttu-id="0fa42-186">ワークフロー引数は、命令型コードでは新しい CLR 型のプロパティとして指定され、XAML では `x:Class` および `x:Member` を使用して宣言されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-186">In imperative code, workflow arguments are specified as properties on a new CLR type, and in XAML they are declared by using `x:Class` and `x:Member`.</span></span> <span data-ttu-id="0fa42-187">ワークフロー定義がメモリ内オブジェクトのツリーとして作成された場合は新しい CRL 型が作成されないため、引数を追加できません。</span><span class="sxs-lookup"><span data-stu-id="0fa42-187">Because there is no new CLR type created when a workflow definition is created as a tree of in-memory objects, arguments cannot be added.</span></span> <span data-ttu-id="0fa42-188">ただし、<xref:System.Activities.DynamicActivity> に引数を追加することはできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-188">However, arguments can be added to a <xref:System.Activities.DynamicActivity>.</span></span> <span data-ttu-id="0fa42-189">次の例では、2 つの整数の引数を取り、それを一緒に追加して結果を返す <xref:System.Activities.DynamicActivity%601> を作成します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-189">In this example, a <xref:System.Activities.DynamicActivity%601> is created that takes two integer arguments, adds them together, and returns the result.</span></span> <span data-ttu-id="0fa42-190">各引数に対して <xref:System.Activities.DynamicActivityProperty> が作成され、操作の結果が <xref:System.Activities.DynamicActivity%601> の <xref:System.Activities.Activity%601.Result%2A> 引数に代入されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-190">A <xref:System.Activities.DynamicActivityProperty> is created for each argument, and the result of the operation is assigned to the <xref:System.Activities.Activity%601.Result%2A> argument of the <xref:System.Activities.DynamicActivity%601>.</span></span>  
  
 [!code-csharp[CFX_WorkflowApplicationExample#55](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#55)]  
  
 <span data-ttu-id="0fa42-191">動的アクティビティの詳細については、「[実行時のアクティビティの作成](creating-an-activity-at-runtime-with-dynamicactivity.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-191">For more information about dynamic activities, see [Creating an Activity at Runtime](creating-an-activity-at-runtime-with-dynamicactivity.md).</span></span>  
  
## <a name="compiled-activities"></a><span data-ttu-id="0fa42-192">コンパイルされたアクティビティ</span><span class="sxs-lookup"><span data-stu-id="0fa42-192">Compiled Activities</span></span>  
 <span data-ttu-id="0fa42-193">動的アクティビティは、コードを使用して引数を格納するアクティビティを定義するための 1 つの方法ですが、アクティビティをコードで作成して型にコンパイルすることもできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-193">Dynamic activities are one way to define an activity that contains arguments using code, but activities can also be created in code and compiled into types.</span></span> <span data-ttu-id="0fa42-194"><xref:System.Activities.CodeActivity> から派生する単純なアクティビティと、<xref:System.Activities.AsyncCodeActivity> から派生する非同期アクティビティを作成できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-194">Simple activities can be created that derive from <xref:System.Activities.CodeActivity>, and asynchronous activities that derive from <xref:System.Activities.AsyncCodeActivity>.</span></span> <span data-ttu-id="0fa42-195">これらのアクティビティは、引数を保持し、値を返して、命令型コードを使用してロジックを定義できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-195">These activities can have arguments, return values, and define their logic using imperative code.</span></span> <span data-ttu-id="0fa42-196">これらの種類のアクティビティを作成する例については、「 [CodeActivity Base Class](workflow-activity-authoring-using-the-codeactivity-class.md) 」と「[非同期アクティビティの作成](creating-asynchronous-activities-in-wf.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-196">For examples of creating these types of activities, see [CodeActivity Base Class](workflow-activity-authoring-using-the-codeactivity-class.md) and [Creating Asynchronous Activities](creating-asynchronous-activities-in-wf.md).</span></span>  
  
 <span data-ttu-id="0fa42-197"><xref:System.Activities.NativeActivity> から派生するアクティビティは、命令型コードを使用してロジックを定義できるだけでなく、ロジックを定義する子アクティビティを含むこともできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-197">Activities that derive from <xref:System.Activities.NativeActivity> can define their logic using imperative code and they can also contain child activities that define the logic.</span></span> <span data-ttu-id="0fa42-198">これらのアクティビティは、ブックマークの作成など、ランタイムの機能をすべて利用できます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-198">They also have full access to the features of the runtime such as creating bookmarks.</span></span> <span data-ttu-id="0fa42-199"><xref:System.Activities.NativeActivity>ベースのアクティビティを作成する例については、「 [NativeActivity 基底クラス](nativeactivity-base-class.md)」、「[方法: アクティビティを作成する](how-to-create-an-activity.md)」、および「[ネイティブアクティビティを使用したカスタム複合](./samples/custom-composite-using-native-activity.md)アクティビティのサンプル」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0fa42-199">For examples of creating a <xref:System.Activities.NativeActivity>-based activity, see [NativeActivity Base Class](nativeactivity-base-class.md), [How to: Create an Activity](how-to-create-an-activity.md), and the [Custom Composite using Native Activity](./samples/custom-composite-using-native-activity.md) sample.</span></span>  
  
 <span data-ttu-id="0fa42-200"><xref:System.Activities.Activity> から派生するアクティビティは、子アクティビティを使用してロジックだけを定義します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-200">Activities that derive from <xref:System.Activities.Activity> define their logic solely through the use of child activities.</span></span> <span data-ttu-id="0fa42-201">これらのアクティビティは、通常、ワークフロー デザイナーを使用して作成されますが、コードを使用して定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-201">These activities are typically created by using the workflow designer, but can also be defined by using code.</span></span> <span data-ttu-id="0fa42-202">次の例では、`Square` から派生する `Activity<int>` アクティビティが定義されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-202">In the following example, a `Square` activity is defined that derives from `Activity<int>`.</span></span> <span data-ttu-id="0fa42-203">`Square` アクティビティには <xref:System.Activities.InArgument%601> という名前の 1 つの `Value` があり、そのロジックが <xref:System.Activities.Statements.Sequence> プロパティを使用して <xref:System.Activities.Activity.Implementation%2A> アクティビティを指定してロジックを定義します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-203">The `Square` activity has a single <xref:System.Activities.InArgument%601> named `Value`, and defines its logic by specifying a <xref:System.Activities.Statements.Sequence> activity using the <xref:System.Activities.Activity.Implementation%2A> property.</span></span> <span data-ttu-id="0fa42-204"><xref:System.Activities.Statements.Sequence> アクティビティには、<xref:System.Activities.Statements.WriteLine> アクティビティと <xref:System.Activities.Statements.Assign%601> アクティビティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="0fa42-204">The <xref:System.Activities.Statements.Sequence> activity contains a <xref:System.Activities.Statements.WriteLine> activity and an <xref:System.Activities.Statements.Assign%601> activity.</span></span> <span data-ttu-id="0fa42-205">この 3 つのアクティビティは、`Square` アクティビティのロジックを実装します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-205">Together, these three activities implement the logic of the `Square` activity.</span></span>  
  
```csharp  
class Square : Activity<int>  
{  
    [RequiredArgument]  
    public InArgument<int> Value { get; set; }  
  
    public Square()  
    {  
        this.Implementation = () => new Sequence  
        {  
            Activities =  
            {  
                new WriteLine  
                {  
                    Text = new InArgument<string>((env) => "Squaring the value: " + this.Value.Get(env))  
                },  
                new Assign<int>  
                {  
                    To = new OutArgument<int>((env) => this.Result.Get(env)),  
                    Value = new InArgument<int>((env) => this.Value.Get(env) * this.Value.Get(env))  
                }  
            }  
        };  
    }  
}  
```  
  
 <span data-ttu-id="0fa42-206">次の例では、単一の `Square` アクティビティで構成されるワークフロー定義を <xref:System.Activities.WorkflowInvoker> を使用して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0fa42-206">In the following example, a workflow definition consisting of a single `Square` activity is invoked using <xref:System.Activities.WorkflowInvoker>.</span></span>  
  
```csharp  
Dictionary<string, object> inputs = new Dictionary<string, object> {{ "Value", 5}};  
int result = WorkflowInvoker.Invoke(new Square(), inputs);  
Console.WriteLine("Result: {0}", result);  
```  
  
 <span data-ttu-id="0fa42-207">このワークフローが呼び出されると、次の出力がコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="0fa42-207">When the workflow is invoked, the following output is displayed to the console:</span></span>  
  
 <span data-ttu-id="0fa42-208">**2乗の値: 5**</span><span class="sxs-lookup"><span data-stu-id="0fa42-208">**Squaring the value: 5**</span></span>  
<span data-ttu-id="0fa42-209">**結果:25**</span><span class="sxs-lookup"><span data-stu-id="0fa42-209">**Result: 25**</span></span>
