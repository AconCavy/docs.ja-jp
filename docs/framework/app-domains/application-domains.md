---
title: アプリケーション ドメイン
ms.date: 03/30/2017
helpviewer_keywords:
- process boundaries for isolation
- application isolation
- application domains, about
- common language runtime, application domains
- application domains
- runtime, application domains
- isolation between applications
- code, verification process
- verification testing code
ms.assetid: 113a8bbf-6875-4a72-a49d-ca2d92e19cc8
ms.openlocfilehash: a5c9f4248e060d231941269f39cadbc7147ce27f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400909"
---
# <a name="application-domains"></a><span data-ttu-id="76f6f-102">アプリケーション ドメイン</span><span class="sxs-lookup"><span data-stu-id="76f6f-102">Application domains</span></span>

<span data-ttu-id="76f6f-103">オペレーティング システムやランタイム環境では、通常、複数のアプリケーションがなんらかの形で分離されています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-103">Operating systems and runtime environments typically provide some form of isolation between applications.</span></span> <span data-ttu-id="76f6f-104">たとえば、Windows ではプロセスを使用してアプリケーションが分離されています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-104">For example, Windows uses processes to isolate applications.</span></span> <span data-ttu-id="76f6f-105">このような分離は、あるアプリケーションで実行されているコードが、関係のない別のアプリケーションに悪影響をもたらさないようにするために必要です。</span><span class="sxs-lookup"><span data-stu-id="76f6f-105">This isolation is necessary to ensure that code running in one application cannot adversely affect other, unrelated applications.</span></span>  
  
 <span data-ttu-id="76f6f-106">アプリケーション ドメインは、セキュリティ、信頼性、バージョン管理のための、またアセンブリをアンロードするための分離の境界を提供します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-106">Application domains provide an isolation boundary for security, reliability, and versioning, and for unloading assemblies.</span></span> <span data-ttu-id="76f6f-107">通常、アプリケーション ドメインは、アプリケーションの実行前に共通言語ランタイムの起動を行うランタイム ホストによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-107">Application domains are typically created by runtime hosts, which are responsible for bootstrapping the common language runtime before an application is run.</span></span>  
  
## <a name="the-benefits-of-isolating-applications"></a><span data-ttu-id="76f6f-108">アプリケーションを分離する利点</span><span class="sxs-lookup"><span data-stu-id="76f6f-108">The benefits of isolating applications</span></span>

 <span data-ttu-id="76f6f-109">これまで、同じコンピューター上で実行される複数のアプリケーションを分離するためには、プロセス境界が使用されていました。</span><span class="sxs-lookup"><span data-stu-id="76f6f-109">Historically, process boundaries have been used to isolate applications running on the same computer.</span></span> <span data-ttu-id="76f6f-110">この場合、各アプリケーションが独立のプロセスに読み込まれることで、アプリケーションは同じコンピューター上で実行されるほかのアプリケーションから分離されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-110">Each application is loaded into a separate process, which isolates the application from other applications running on the same computer.</span></span>  
  
 <span data-ttu-id="76f6f-111">アプリケーションが分離されるのは、メモリ アドレスがプロセスごとの相対アドレスになっていたためです。つまり、メモリ ポインターをあるプロセスから別のプロセスに渡しても、そのポインターが渡された側のプロセスでは機能しませんでした。</span><span class="sxs-lookup"><span data-stu-id="76f6f-111">The applications are isolated because memory addresses are process-relative; a memory pointer passed from one process to another cannot be used in any meaningful way in the target process.</span></span> <span data-ttu-id="76f6f-112">また、2 つのプロセス間で直接呼び出しを行うこともできませんでした。</span><span class="sxs-lookup"><span data-stu-id="76f6f-112">In addition, you cannot make direct calls between two processes.</span></span> <span data-ttu-id="76f6f-113">代わりに間接的な呼び出しを行う場合は、プロキシを使用する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="76f6f-113">Instead, you must use proxies, which provide a level of indirection.</span></span>  
  
 <span data-ttu-id="76f6f-114">マネージド コードは、実行される前に必ず検査プロセスに渡されます (管理者が検査を省略する許可をコードに与えた場合は除きます)。</span><span class="sxs-lookup"><span data-stu-id="76f6f-114">Managed code must be passed through a verification process before it can be run (unless the administrator has granted permission to skip the verification).</span></span> <span data-ttu-id="76f6f-115">検査プロセスでは、そのコードが無効なメモリ アドレスにアクセスしたり、コードが実行されるプロセスの正常実行を妨げる原因となる動作を実行したりすることがないかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-115">The verification process determines whether the code can attempt to access invalid memory addresses or perform some other action that could cause the process in which it is running to fail to operate properly.</span></span> <span data-ttu-id="76f6f-116">検査テストを通過したコードは、タイプ セーフであると言われます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-116">Code that passes the verification test is said to be type-safe.</span></span> <span data-ttu-id="76f6f-117">コードがタイプ セーフかどうかを検査するこのような機能があるため、共通言語ランタイムでは、プロセス境界と同等の高度な分離レベルを実現しながら、パフォーマンスへの影響は大幅に低く抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-117">The ability to verify code as type-safe enables the common language runtime to provide as great a level of isolation as the process boundary, at a much lower performance cost.</span></span>  
  
 <span data-ttu-id="76f6f-118">アプリケーション ドメインは、共通言語ランタイムがアプリケーション間を分離するために使用できる、より安全で柔軟性に富んだ処理単位となります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-118">Application domains provide a more secure and versatile unit of processing that the common language runtime can use to provide isolation between applications.</span></span> <span data-ttu-id="76f6f-119">個別のプロセスを使用する場合と同じ分離レベルを実現しながら、しかしプロセス間での呼び出しやプロセスの切り替えによるオーバーヘッドを生じることもなく、1 つのプロセス内で複数のアプリケーション ドメインを実行できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-119">You can run several application domains in a single process with the same level of isolation that would exist in separate processes, but without incurring the additional overhead of making cross-process calls or switching between processes.</span></span> <span data-ttu-id="76f6f-120">1 つのプロセス内で複数のアプリケーションを実行できるため、サーバーのスケーラビリティが飛躍的に向上します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-120">The ability to run multiple applications within a single process dramatically increases server scalability.</span></span>  
  
 <span data-ttu-id="76f6f-121">アプリケーションの分離は、アプリケーションのセキュリティを考えるうえでも重要です。</span><span class="sxs-lookup"><span data-stu-id="76f6f-121">Isolating applications is also important for application security.</span></span> <span data-ttu-id="76f6f-122">たとえば、複数のコントロールが互いのデータやリソースにアクセスできないようにして、1 つのブラウザー プロセスで複数の Web アプリケーションのコントロールを実行できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-122">For example, you can run controls from several Web applications in a single browser process in such a way that the controls cannot access each other's data and resources.</span></span>  
  
 <span data-ttu-id="76f6f-123">アプリケーション ドメインによる分離には、次の利点があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-123">The isolation provided by application domains has the following benefits:</span></span>  
  
- <span data-ttu-id="76f6f-124">1 つのアプリケーションで発生したエラーが、ほかのアプリケーションに影響することはありません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-124">Faults in one application cannot affect other applications.</span></span> <span data-ttu-id="76f6f-125">タイプ セーフなコードではメモリ フォールトが発生しないため、アプリケーション ドメインを使用することで、1 つのドメインで実行されているコードが同じプロセス内のほかのアプリケーションに影響することが確実になくなります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-125">Because type-safe code cannot cause memory faults, using application domains ensures that code running in one domain cannot affect other applications in the process.</span></span>  
  
- <span data-ttu-id="76f6f-126">プロセス全体を停止せずに、個々のアプリケーションを停止できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-126">Individual applications can be stopped without stopping the entire process.</span></span> <span data-ttu-id="76f6f-127">アプリケーション ドメインを使用すると、1 つのアプリケーション内で実行されているコードをアンロードできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-127">Using application domains enables you to unload the code running in a single application.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="76f6f-128">個々のアセンブリや型はアンロードできません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-128">You cannot unload individual assemblies or types.</span></span> <span data-ttu-id="76f6f-129">アンロードできるのはドメイン全体だけです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-129">Only a complete domain can be unloaded.</span></span>  
  
- <span data-ttu-id="76f6f-130">1 つのアプリケーションで実行されているコードは、ほかのアプリケーションのコードやリソースに直接アクセスできません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-130">Code running in one application cannot directly access code or resources from another application.</span></span> <span data-ttu-id="76f6f-131">共通言語ランタイムでは、異なるアプリケーション ドメインにあるオブジェクト間での直接呼び出しを禁止することで分離を実現しています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-131">The common language runtime enforces this isolation by preventing direct calls between objects in different application domains.</span></span> <span data-ttu-id="76f6f-132">ドメイン間で渡されるオブジェクトは、コピーされるか、またはプロキシ経由でアクセスされます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-132">Objects that pass between domains are either copied or accessed by proxy.</span></span> <span data-ttu-id="76f6f-133">オブジェクトがコピーされる場合、オブジェクトの呼び出しはローカル呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-133">If the object is copied, the call to the object is local.</span></span> <span data-ttu-id="76f6f-134">つまり、呼び出し元と参照先オブジェクトの両方が、同じアプリケーション ドメイン内にあります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-134">That is, both the caller and the object being referenced are in the same application domain.</span></span> <span data-ttu-id="76f6f-135">オブジェクトがプロキシ経由でアクセスされる場合は、オブジェクトの呼び出しはリモート呼び出しです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-135">If the object is accessed through a proxy, the call to the object is remote.</span></span> <span data-ttu-id="76f6f-136">この場合は、呼び出し元と参照先オブジェクトが別のアプリケーション ドメイン内にあります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-136">In this case, the caller and the object being referenced are in different application domains.</span></span> <span data-ttu-id="76f6f-137">ドメイン間呼び出しでは、2 つのプロセス間や 2 台のコンピューター間での呼び出しと同じリモート呼び出しインフラストラクチャが使用されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-137">Cross-domain calls use the same remote call infrastructure as calls between two processes or between two machines.</span></span> <span data-ttu-id="76f6f-138">そのため、メソッドの呼び出しが正しく JIT コンパイルされるように、参照先オブジェクトのメタデータが両方のアプリケーション ドメインから利用できることが必要です。</span><span class="sxs-lookup"><span data-stu-id="76f6f-138">As such, the metadata for the object being referenced must be available to both application domains to allow the method call to be JIT-compiled properly.</span></span> <span data-ttu-id="76f6f-139">呼び出し元のドメインが呼び出し先オブジェクトのメタデータにアクセスできない場合、コンパイルは <xref:System.IO.FileNotFoundException> という例外が発生して失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-139">If the calling domain does not have access to the metadata for the object being called, the compilation might fail with an exception of type <xref:System.IO.FileNotFoundException>.</span></span> <span data-ttu-id="76f6f-140">詳細については、「 [Remote Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="76f6f-140">For more information, see [Remote Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100)).</span></span> <span data-ttu-id="76f6f-141">ドメイン間でオブジェクトにアクセスする方法は、アクセス対象のオブジェクトによって決まります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-141">The mechanism for determining how objects can be accessed across domains is determined by the object.</span></span> <span data-ttu-id="76f6f-142">詳細については、「<xref:System.MarshalByRefObject?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="76f6f-142">For more information, see <xref:System.MarshalByRefObject?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="76f6f-143">コードが影響する範囲は、そのコードが実行されるアプリケーションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-143">The behavior of code is scoped by the application in which it runs.</span></span> <span data-ttu-id="76f6f-144">つまり、アプリケーション ドメインは、アプリケーションのバージョン ポリシー、アクセス対象となるリモート アセンブリの位置、ドメインに読み込まれるアセンブリの場所に関する情報などの構成設定を提供します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-144">In other words, the application domain provides configuration settings such as application version policies, the location of any remote assemblies it accesses, and information about where to locate assemblies that are loaded into the domain.</span></span>  
  
- <span data-ttu-id="76f6f-145">コードに与えられるアクセス許可は、そのコードが実行されるアプリケーション ドメインによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-145">Permissions granted to code can be controlled by the application domain in which the code is running.</span></span>  
  
## <a name="application-domains-and-assemblies"></a><span data-ttu-id="76f6f-146">アプリケーション ドメインとアセンブリ</span><span class="sxs-lookup"><span data-stu-id="76f6f-146">Application domains and assemblies</span></span>

 <span data-ttu-id="76f6f-147">このセクションでは、アプリケーション ドメインとアセンブリの関係について説明します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-147">This section describes the relationship between application domains and assemblies.</span></span> <span data-ttu-id="76f6f-148">アセンブリに含まれるコードを実行する前に、そのアセンブリをアプリケーション ドメインに読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-148">You must load an assembly into an application domain before you can execute the code it contains.</span></span> <span data-ttu-id="76f6f-149">通常のアプリケーションを実行すると、複数のアセンブリがアプリケーション ドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-149">Running a typical application causes several assemblies to be loaded into an application domain.</span></span>  
  
 <span data-ttu-id="76f6f-150">アセンブリが読み込まれる方法によって、そのアセンブリの Just-In-Time (JIT) コンパイル コードをプロセス内の複数のアプリケーション ドメインで共有できるかどうか、およびアセンブリをプロセスからアンロードできるかどうかが決まります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-150">The way an assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process, and whether the assembly can be unloaded from the process.</span></span>  
  
- <span data-ttu-id="76f6f-151">アセンブリがドメインに中立として読み込まれる場合は、同じセキュリティ許可セットを共有するすべてのアプリケーション ドメインが同じ JIT コンパイル コードを共有できるため、アプリケーションに必要なメモリを削減できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-151">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code, which reduces the memory required by the application.</span></span> <span data-ttu-id="76f6f-152">ただし、アセンブリをプロセスからアンロードできなくなります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-152">However, the assembly can never be unloaded from the process.</span></span>  
  
- <span data-ttu-id="76f6f-153">アセンブリがドメインに中立として読み込まれない場合は、そのアセンブリが読み込まれる各アプリケーション ドメインで、そのアセンブリを JIT でコンパイルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-153">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded.</span></span> <span data-ttu-id="76f6f-154">ただし、アセンブリが読み込まれているアプリケーション ドメインをすべてアンロードすることで、プロセスからアセンブリをアンロードできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-154">However, the assembly can be unloaded from the process by unloading all the application domains in which it is loaded.</span></span>  
  
 <span data-ttu-id="76f6f-155">ランタイム ホストは、ランタイムをプロセスに読み込むときに、アセンブリをドメインに中立なアセンブリとして読み込むかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-155">The runtime host determines whether to load assemblies as domain-neutral when it loads the runtime into a process.</span></span> <span data-ttu-id="76f6f-156">マネージド アプリケーションの場合は、<xref:System.LoaderOptimizationAttribute> 属性をプロセスのエントリ ポイント メソッドに適用し、関連付けられた <xref:System.LoaderOptimization> 列挙体から値を指定します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-156">For managed applications, apply the <xref:System.LoaderOptimizationAttribute> attribute to the entry-point method for the process, and specify a value from the associated <xref:System.LoaderOptimization> enumeration.</span></span> <span data-ttu-id="76f6f-157">共通言語ランタイムをホストするアンマネージ アプリケーションの場合は、[CorBindToRuntimeEx 関数](../unmanaged-api/hosting/corbindtoruntimeex-function.md)メソッドを呼び出すときに適切なフラグを指定します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-157">For unmanaged applications that host the common language runtime, specify the appropriate flag when you call the [CorBindToRuntimeEx Function](../unmanaged-api/hosting/corbindtoruntimeex-function.md) method.</span></span>  
  
 <span data-ttu-id="76f6f-158">アセンブリをドメインに中立として読み込むかどうかに関して、次の 3 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-158">There are three options for loading domain-neutral assemblies:</span></span>  
  
- <span data-ttu-id="76f6f-159"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType> では、常にドメインに中立として読み込まれる Mscorlib を除き、どのアセンブリもドメインに中立として読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-159"><xref:System.LoaderOptimization.SingleDomain?displayProperty=nameWithType> loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="76f6f-160">この設定は、ホストがプロセス内で 1 つのアプリケーションだけを実行する場合に一般的に使用されるため、シングル ドメインと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-160">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>

- <span data-ttu-id="76f6f-161"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType> では、すべてのアセンブリがドメインに中立として読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-161"><xref:System.LoaderOptimization.MultiDomain?displayProperty=nameWithType> loads all assemblies as domain-neutral.</span></span> <span data-ttu-id="76f6f-162">この設定は、同じコードを実行する複数のアプリケーション ドメインが 1 つのプロセス内に存在する場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-162">Use this setting when there are multiple application domains in the process, all of which run the same code.</span></span>

- <span data-ttu-id="76f6f-163"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType> では、厳密な名前が付いたアセンブリとそのすべての依存関係がグローバル アセンブリ キャッシュにインストールされている場合に、それらのアセンブリがドメインに中立として読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-163"><xref:System.LoaderOptimization.MultiDomainHost?displayProperty=nameWithType> loads strong-named assemblies as domain-neutral, if they and all their dependencies have been installed in the global assembly cache.</span></span> <span data-ttu-id="76f6f-164">その他のアセンブリは、それらが読み込まれる各アプリケーション ドメインで個別に読み込まれ、JIT でコンパイルされるため、プロセスからアンロードできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-164">Other assemblies are loaded and JIT-compiled separately for each application domain in which they are loaded, and thus can be unloaded from the process.</span></span> <span data-ttu-id="76f6f-165">この設定は、同じプロセスで複数のアプリケーションが実行されている場合、または多数のアプリケーション ドメインで共有されているアセンブリと、プロセスからアンロードする必要があるアセンブリが混在している場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-165">Use this setting when running more than one application in the same process, or if you have a mixture of assemblies that are shared by many application domains and assemblies that need to be unloaded from the process.</span></span>
  
 <span data-ttu-id="76f6f-166"><xref:System.Reflection.Assembly.LoadFrom%2A> クラスの <xref:System.Reflection.Assembly> メソッドを使用して読み込み元を指定して読み込まれたアセンブリ、またはバイト配列を指定する <xref:System.Reflection.Assembly.Load%2A> メソッドのオーバーロードを使用してイメージから読み込まれたアセンブリについては、JIT コンパイル コードを共有できません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-166">JIT-compiled code cannot be shared for assemblies loaded into the load-from context, using the <xref:System.Reflection.Assembly.LoadFrom%2A> method of the <xref:System.Reflection.Assembly> class, or loaded from images using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify byte arrays.</span></span>  
  
 <span data-ttu-id="76f6f-167">[Ngen.exe (ネイティブ イメージ ジェネレーター)](../tools/ngen-exe-native-image-generator.md) を使用してネイティブ コードにコンパイルされたアセンブリは、プロセスに最初に読み込まれるときにドメインに中立として読み込まれていれば、アプリケーション ドメイン間で共有できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-167">Assemblies that have been compiled to native code by using the [Ngen.exe (Native Image Generator)](../tools/ngen-exe-native-image-generator.md) can be shared between application domains, if they are loaded domain-neutral the first time they are loaded into a process.</span></span>  
  
 <span data-ttu-id="76f6f-168">アプリケーションのエントリ ポイントを含むアセンブリの JIT コンパイル コードは、そのすべての依存関係を共有できる場合にだけ共有されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-168">JIT-compiled code for the assembly that contains the application entry point is shared only if all its dependencies can be shared.</span></span>  
  
 <span data-ttu-id="76f6f-169">ドメインに中立なアセンブリは、JIT で複数回コンパイルできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-169">A domain-neutral assembly can be JIT-compiled more than once.</span></span> <span data-ttu-id="76f6f-170">たとえば、2 つのアプリケーション ドメインのセキュリティ許可セットが異なっている場合、それらのドメインは同じ JIT コンパイル コードを共有できません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-170">For example, when the security grant sets of two application domains are different, they cannot share the same JIT-compiled code.</span></span> <span data-ttu-id="76f6f-171">ただし、JIT コンパイル アセンブリの各コピーは、同じ許可セットを持つ他のアプリケーション ドメインと共有できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-171">However, each copy of the JIT-compiled assembly can be shared with other application domains that have the same grant set.</span></span>  
  
 <span data-ttu-id="76f6f-172">アセンブリをドメインに中立として読み込むかどうかを判断する場合は、メモリ使用量の削減とその他のパフォーマンス要因とのトレードオフを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-172">When you decide whether to load assemblies as domain-neutral, you must make a tradeoff between reducing memory use and other performance factors.</span></span>  
  
- <span data-ttu-id="76f6f-173">ドメインに中立のアセンブリでは、アセンブリを分離する必要があることから、静的データおよびメソッドにアクセスする速度が遅くなります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-173">Access to static data and methods is slower for domain-neutral assemblies because of the need to isolate assemblies.</span></span> <span data-ttu-id="76f6f-174">静的フィールド内のオブジェクトがドメイン境界を越えて参照されることがないように、アセンブリにアクセスする各アプリケーション ドメインが、静的データのコピーを個別に保持する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-174">Each application domain that accesses the assembly must have a separate copy of the static data, to prevent references to objects in static fields from crossing domain boundaries.</span></span> <span data-ttu-id="76f6f-175">その結果、ランタイムには、呼び出し元が静的データまたは静的メソッドの適切なコピーにアクセスできるようにするための追加のロジックが必要となります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-175">As a result, the runtime contains additional logic to direct a caller to the appropriate copy of the static data or method.</span></span> <span data-ttu-id="76f6f-176">この追加のロジックのために、呼び出しの処理速度が低下します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-176">This extra logic slows down the call.</span></span>  
  
- <span data-ttu-id="76f6f-177">アセンブリがドメインに中立で読み込まれるときに、アセンブリのすべての依存関係を探し出して読み込む必要があります。これは、ドメインに中立として読み込むことのできない依存関係があると、アセンブリをドメインに中立として読み込むことができなくなるからです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-177">All the dependencies of an assembly must be located and loaded when the assembly is loaded domain-neutral, because a dependency that cannot be loaded domain-neutral prevents the assembly from being loaded domain-neutral.</span></span>  
  
## <a name="application-domains-and-threads"></a><span data-ttu-id="76f6f-178">アプリケーション ドメインとスレッド</span><span class="sxs-lookup"><span data-stu-id="76f6f-178">Application domains and threads</span></span>

 <span data-ttu-id="76f6f-179">アプリケーション ドメインは、セキュリティ、バージョン管理、信頼性のための、またマネージド コードをアンロードするための分離の境界を形成します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-179">An application domain forms an isolation boundary for security, versioning, reliability, and unloading of managed code.</span></span> <span data-ttu-id="76f6f-180">スレッドは、共通言語ランタイムがコードを実行するために使用する、オペレーティング システムの構成です。</span><span class="sxs-lookup"><span data-stu-id="76f6f-180">A thread is the operating system construct used by the common language runtime to execute code.</span></span> <span data-ttu-id="76f6f-181">実行時には、すべてのマネージド コードがアプリケーション ドメインに読み込まれ、1 つまたは複数のマネージド スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-181">At run time, all managed code is loaded into an application domain and is run by one or more managed threads.</span></span>  
  
 <span data-ttu-id="76f6f-182">アプリケーション ドメインとスレッドとの関係は一対一ではありません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-182">There is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="76f6f-183">1 つのアプリケーション ドメイン内で一度に複数のスレッドが実行される場合があり、また 1 つのスレッドが 1 つのアプリケーション ドメインに限定されることもありません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-183">Several threads can execute in a single application domain at any given time, and a particular thread is not confined to a single application domain.</span></span> <span data-ttu-id="76f6f-184">つまり、スレッドはアプリケーション ドメイン境界を自由に越えることができ、アプリケーション ドメインごとに新しいスレッドが生成されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-184">That is, threads are free to cross application domain boundaries; a new thread is not created for each application domain.</span></span>  
  
 <span data-ttu-id="76f6f-185">特定の時点に限って見ると、どのスレッドも 1 つのアプリケーション ドメイン内で実行されています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-185">At any given time, every thread executes in an application domain.</span></span> <span data-ttu-id="76f6f-186">特定のアプリケーション ドメインでゼロ、1 つ、または複数のスレッドを実行できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-186">Zero, one, or multiple threads might be executing in any given application domain.</span></span> <span data-ttu-id="76f6f-187">ランタイムは、どのスレッドがどのアプリケーション ドメインで実行されているかを追跡しています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-187">The runtime keeps track of which threads are running in which application domains.</span></span> <span data-ttu-id="76f6f-188">任意の時点で、あるスレッドが実行されているドメインを特定するには、<xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-188">You can locate the domain in which a thread is executing at any time by calling the <xref:System.Threading.Thread.GetDomain%2A?displayProperty=nameWithType> method.</span></span>

### <a name="application-domains-and-cultures"></a><span data-ttu-id="76f6f-189">アプリケーション ドメインとカルチャ</span><span class="sxs-lookup"><span data-stu-id="76f6f-189">Application domains and cultures</span></span>

 <span data-ttu-id="76f6f-190"><xref:System.Globalization.CultureInfo> オブジェクトによって表されるカルチャは、スレッドに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-190">Culture, which is represented by a <xref:System.Globalization.CultureInfo> object, is associated with threads.</span></span> <span data-ttu-id="76f6f-191"><xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティを使用すると、現在実行しているスレッドに関連付けられているカルチャを取得できます。<xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> プロパティを使用すると、現在実行しているスレッドに関連付けられているカルチャを取得または設定できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-191">You can get the culture that is associated with the currently executing thread by using the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property, and you can get or set the culture that is associated with the currently executing thread by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="76f6f-192">スレッドに関連付けられているカルチャが <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> プロパティを使用して明示的に設定されている場合、スレッドがアプリケーション ドメインの境界を越えても、そのスレッドとの関連付けが維持されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-192">If the culture that is associated with a thread has been explicitly set by using the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> property, it continues to be associated with that thread when the thread crosses application domain boundaries.</span></span> <span data-ttu-id="76f6f-193">それ以外の場合、スレッドに関連付けられるカルチャは、任意の時点でスレッドが実行されているアプリケーション ドメインの <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> プロパティの値によって決まります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-193">Otherwise, the culture that is associated with the thread at any given time is determined by the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> property in the application domain in which the thread is executing:</span></span>  
  
- <span data-ttu-id="76f6f-194">プロパティの値が `null` でない場合、プロパティによって返されるカルチャはスレッドに関連付けられます (したがって <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> プロパティと <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティによって返されます)。</span><span class="sxs-lookup"><span data-stu-id="76f6f-194">If the value of the property is not `null`, the culture that is returned by the property is associated with the thread (and therefore returned by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties).</span></span>  
  
- <span data-ttu-id="76f6f-195">プロパティの値が `null` の場合は、現在のシステム カルチャがスレッドに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-195">If the value of the property is `null`, the current system culture is associated with the thread.</span></span>  
  
## <a name="programming-with-application-domains"></a><span data-ttu-id="76f6f-196">アプリケーション ドメインを使用したプログラミング</span><span class="sxs-lookup"><span data-stu-id="76f6f-196">Programming with application domains</span></span>

 <span data-ttu-id="76f6f-197">通常、アプリケーション ドメインは、ランタイム ホストによってプログラムで作成および操作されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-197">Application domains are usually created and manipulated programmatically by runtime hosts.</span></span> <span data-ttu-id="76f6f-198">しかし、アプリケーション プログラムでもアプリケーション ドメインを操作する必要が生じる場合があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-198">However, sometimes an application program might also want to work with application domains.</span></span> <span data-ttu-id="76f6f-199">たとえば、アプリケーション プログラムはアプリケーション コンポーネントをドメインに読み込むことができるため、アプリケーション全体を停止せずにドメイン (およびコンポーネント) をアンロードできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-199">For example, an application program could load an application component into a domain to be able to unload the domain (and the component) without having to stop the entire application.</span></span>  
  
 <span data-ttu-id="76f6f-200"><xref:System.AppDomain>は、アプリケーション ドメインに対するプログラム インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="76f6f-200">The <xref:System.AppDomain> is the programmatic interface to application domains.</span></span> <span data-ttu-id="76f6f-201">このクラスには、ドメインを作成およびアンロードするメソッド、型のインスタンスをドメイン内に作成するメソッド、およびアプリケーション ドメインのアンロードなどの各種通知に登録するメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-201">This class includes methods to create and unload domains, to create instances of types in domains, and to register for various notifications such as application domain unloading.</span></span> <span data-ttu-id="76f6f-202">一般的に使用される <xref:System.AppDomain> メソッドを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-202">The following table lists commonly used <xref:System.AppDomain> methods.</span></span>  
  
|<span data-ttu-id="76f6f-203">AppDomain メソッド</span><span class="sxs-lookup"><span data-stu-id="76f6f-203">AppDomain Method</span></span>|<span data-ttu-id="76f6f-204">説明</span><span class="sxs-lookup"><span data-stu-id="76f6f-204">Description</span></span>|  
|----------------------|-----------------|  
|<xref:System.AppDomain.CreateDomain%2A>|<span data-ttu-id="76f6f-205">新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-205">Creates a new application domain.</span></span> <span data-ttu-id="76f6f-206"><xref:System.AppDomainSetup> オブジェクトを指定するこのメソッドのオーバーロードを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="76f6f-206">It is recommended that you use an overload of this method that specifies an <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="76f6f-207">これは、アプリケーション ベース (アプリケーションのルート ディレクトリ)、ドメインの構成ファイルの場所、ドメインにアセンブリを読み込むときに共通言語ランタイムが使用する検索パスなど、新しいドメインのプロパティを設定する場合に望ましい方法です。</span><span class="sxs-lookup"><span data-stu-id="76f6f-207">This is the preferred way to set the properties of a new domain, such as the application base, or root directory for the application; the location of the configuration file for the domain; and the search path that the common language runtime is to use to load assemblies into the domain.</span></span>|  
|<span data-ttu-id="76f6f-208"><xref:System.AppDomain.ExecuteAssembly%2A> および <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="76f6f-208"><xref:System.AppDomain.ExecuteAssembly%2A> and <xref:System.AppDomain.ExecuteAssemblyByName%2A></span></span>|<span data-ttu-id="76f6f-209">アプリケーション ドメインでアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-209">Executes an assembly in the application domain.</span></span> <span data-ttu-id="76f6f-210">これはインスタンス メソッドであるため、参照先の別のアプリケーション ドメインでコードを実行する場合に使用できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-210">This is an instance method, so it can be used to execute code in another application domain to which you have a reference.</span></span>|  
|<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>|<span data-ttu-id="76f6f-211">指定した型のインスタンスをアプリケーション ドメイン内に作成し、プロキシを返します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-211">Creates an instance of a specified type in the application domain, and returns a proxy.</span></span> <span data-ttu-id="76f6f-212">このメソッドを使用することで、作成された型を含むアセンブリが呼び出し元のアセンブリに読み込まれることを回避できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-212">Use this method to avoid loading the assembly containing the created type into the calling assembly.</span></span>|  
|<xref:System.AppDomain.Unload%2A>|<span data-ttu-id="76f6f-213">ドメインを正常にシャットダウンします。</span><span class="sxs-lookup"><span data-stu-id="76f6f-213">Performs a graceful shutdown of the domain.</span></span> <span data-ttu-id="76f6f-214">アプリケーション ドメインは、ドメイン内で実行されているすべてのスレッドが停止するか、またはドメイン内に存在しなくなるまで、アンロードされません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-214">The application domain is not unloaded until all threads running in the domain have either stopped or are no longer in the domain.</span></span>|  
  
> [!NOTE]
> <span data-ttu-id="76f6f-215">共通言語ランタイムはグローバル メソッドのシリアル化をサポートしないため、デリゲートを使用して他のアプリケーション ドメインでグローバル メソッドを実行できません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-215">The common language runtime does not support serialization of global methods, so delegates cannot be used to execute global methods in other application domains.</span></span>  
  
 <span data-ttu-id="76f6f-216">共通言語ランタイムの仕様、「Hosting Interfaces」で説明されているアンマネージ インターフェイスも、アプリケーション ドメインへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="76f6f-216">The unmanaged interfaces described in the common language runtime Hosting Interfaces Specification also provide access to application domains.</span></span> <span data-ttu-id="76f6f-217">ランタイム ホストは、アンマネージ コードのインターフェイスを使用して、プロセス内にアプリケーション ドメインを作成し、そのドメインにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-217">Runtime hosts can use interfaces from unmanaged code to create and gain access to the application domains within a process.</span></span>  
  
## <a name="the-complus_loaderoptimization-environment-variable"></a><span data-ttu-id="76f6f-218">COMPLUS_LoaderOptimization 環境変数</span><span class="sxs-lookup"><span data-stu-id="76f6f-218">The COMPLUS_LoaderOptimization environment variable</span></span>

 <span data-ttu-id="76f6f-219">実行可能アプリケーションの既定のローダーの最適化ポリシーを設定する環境変数。</span><span class="sxs-lookup"><span data-stu-id="76f6f-219">An environment variable that sets the default loader optimization policy of an executable application.</span></span>  
  
### <a name="syntax"></a><span data-ttu-id="76f6f-220">構文</span><span class="sxs-lookup"><span data-stu-id="76f6f-220">Syntax</span></span>  
  
```env  
COMPLUS_LoaderOptimization = 1  
```  
  
### <a name="remarks"></a><span data-ttu-id="76f6f-221">Remarks</span><span class="sxs-lookup"><span data-stu-id="76f6f-221">Remarks</span></span>

 <span data-ttu-id="76f6f-222">一般的なアプリケーションでは、アプリケーション ドメインに複数のアセンブリが読み込まれてから、それに含まれるコードが実行されます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-222">A typical application loads several assemblies into an application domain before the code they contain can be executed.</span></span>  
  
 <span data-ttu-id="76f6f-223">アセンブリが読み込まれる方法によって、そのアセンブリの Just-In-Time (JIT) コンパイル コードをプロセス内の複数のアプリケーション ドメインで共有できるかどうかが決まります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-223">The way the assembly is loaded determines whether its just-in-time (JIT) compiled code can be shared by multiple application domains in the process.</span></span>  
  
- <span data-ttu-id="76f6f-224">アセンブリがドメイン中立として読み込まれる場合は、同じセキュリティ許可セットを共有するすべてのアプリケーション ドメインが同じ JIT コンパイル コードを共有できます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-224">If an assembly is loaded domain-neutral, all application domains that share the same security grant set can share the same JIT-compiled code.</span></span> <span data-ttu-id="76f6f-225">このため、アプリケーションが必要とするメモリを抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-225">This reduces the memory required by the application.</span></span>  
  
- <span data-ttu-id="76f6f-226">アセンブリがドメイン中立として読み込まれない場合、読み込まれるすべてのアプリケーション ドメインで JIT コンパイル済みである必要があり、またローダーはアプリケーション ドメイン間で内部リソースを共有できません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-226">If an assembly is not loaded domain-neutral, it must be JIT-compiled in every application domain in which it is loaded and the loader must not share internal resources across application domains.</span></span>  
  
 <span data-ttu-id="76f6f-227">COMPLUS_LoaderOptimization 環境フラグを 1 に設定すると、ランタイム ホストは強制的にすべてのアセンブリを SingleDomain と呼ばれるドメイン中立でない方法で読み込みます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-227">When set to 1, the COMPLUS_LoaderOptimization environment flag forces the runtime host to load all assemblies in non-domain-neutral way known as SingleDomain.</span></span> <span data-ttu-id="76f6f-228">SingleDomain では、常にドメインに中立として読み込まれる Mscorlib を除き、どのアセンブリもドメインに中立として読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="76f6f-228">SingleDomain loads no assemblies as domain-neutral, except Mscorlib, which is always loaded domain-neutral.</span></span> <span data-ttu-id="76f6f-229">この設定は、ホストがプロセス内で 1 つのアプリケーションだけを実行する場合に一般的に使用されるため、シングル ドメインと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-229">This setting is called single domain because it is commonly used when the host is running only a single application in the process.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="76f6f-230">COMPLUS_LoaderOptimization 環境フラグは診断およびテストのシナリオで使用するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="76f6f-230">The COMPLUS_LoaderOptimization environment flag was designed to be used in diagnostic and test scenarios.</span></span> <span data-ttu-id="76f6f-231">このフラグをオンにすることにより、速度の大幅な低下と使用メモリの増大が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="76f6f-231">Having the flag turned on can cause severe slow-down and increase in memory usage.</span></span>  
  
### <a name="code-example"></a><span data-ttu-id="76f6f-232">コード例</span><span class="sxs-lookup"><span data-stu-id="76f6f-232">Code example</span></span>

 <span data-ttu-id="76f6f-233">環境の HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN キーの複数文字列値に `COMPLUS_LoaderOptimization=1` を追加することにより、強制的にすべてのアセンブリを IISADMIN サービスにドメイン中立として読み込まないようにできます。</span><span class="sxs-lookup"><span data-stu-id="76f6f-233">To force all assemblies not to be loaded as domain-neutral for the IISADMIN service can be achieved by appending `COMPLUS_LoaderOptimization=1` to the Environment’s Multi-String Value in the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN key.</span></span>  
  
```env  
Key = HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\IISADMIN  
Name = Environment  
Type = REG_MULTI_SZ  
Value (to append) = COMPLUS_LoaderOptimization=1  
```  
  
## <a name="see-also"></a><span data-ttu-id="76f6f-234">関連項目</span><span class="sxs-lookup"><span data-stu-id="76f6f-234">See also</span></span>

- <xref:System.AppDomain?displayProperty=nameWithType>
- <xref:System.MarshalByRefObject?displayProperty=nameWithType>
- [<span data-ttu-id="76f6f-235">アプリケーション ドメインとアセンブリを使用したプログラミング</span><span class="sxs-lookup"><span data-stu-id="76f6f-235">Programming with Application Domains and Assemblies</span></span>](index.md)
- [<span data-ttu-id="76f6f-236">アプリケーション ドメインの使用</span><span class="sxs-lookup"><span data-stu-id="76f6f-236">Using Application Domains</span></span>](use.md)
