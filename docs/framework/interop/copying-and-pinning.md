---
title: コピーと固定
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: f6db7d37293015911c1285d39e19bf7542a7ac59
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73123642"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="a6e57-102">コピーと固定</span><span class="sxs-lookup"><span data-stu-id="a6e57-102">Copying and Pinning</span></span>

<span data-ttu-id="a6e57-103">データをマーシャリングするときに、相互運用マーシャラーはマーシャリングされるデータをコピーまたは固定できます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-103">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="a6e57-104">データをコピーすると、あるメモリ位置のデータのコピーが別のメモリ位置に配置されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-104">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="a6e57-105">マネージド メモリからアンマネージド メモリへの値型のコピーと、参照渡しされる型のコピーの違いを次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-105">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![値型と参照型がどのようにコピーされるかを示す図。](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="a6e57-107">値渡しされるメソッド引数は、スタック上の値としてアンマネージ コードにマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-107">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="a6e57-108">コピーのプロセスは直接的です。</span><span class="sxs-lookup"><span data-stu-id="a6e57-108">The copying process is direct.</span></span> <span data-ttu-id="a6e57-109">参照渡しされる引数は、ポインターとしてスタック上に渡されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-109">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="a6e57-110">参照型も値渡しと参照渡しが行われます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-110">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="a6e57-111">次の図に示されているように、値渡しされる参照型はコピーまたは固定されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-111">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![値渡しされる参照型と参照渡しされる参照型を示す図。](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="a6e57-113">固定では一時的に現在のメモリ位置でデータをロックします。したがって、共通言語ランタイムのガベージ コレクターによって、そのデータが再配置されることを回避できます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-113">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="a6e57-114">マーシャラーはデータを固定することでコピーのオーバーヘッドを減らし、パフォーマンスを向上させます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-114">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="a6e57-115">マーシャリング プロセス中にデータがコピーされるか固定されるかは、そのデータの型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-115">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="a6e57-116">固定は <xref:System.String> などのオブジェクトのマーシャリング中に自動的に実行されますが、<xref:System.Runtime.InteropServices.GCHandle> クラスを使用して手動でメモリを固定することもできます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-116">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="a6e57-117">書式指定された blittable クラス</span><span class="sxs-lookup"><span data-stu-id="a6e57-117">Formatted Blittable Classes</span></span>

<span data-ttu-id="a6e57-118">書式指定された [blittable](blittable-and-non-blittable-types.md) クラスは、マネージド メモリとアンマネージド メモリの両方で、固定レイアウト (書式指定されている) と共通のデータ表現を持ちます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-118">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="a6e57-119">このような型でマーシャリングが必要な場合は、ヒープ内のオブジェクトへのポインターが呼び出し先に直接渡されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-119">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="a6e57-120">呼び出し先はポインターによって参照されるメモリ位置の内容を変更できます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-120">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="a6e57-121">パラメーターに Out または In/Out のマークが付いている場合、呼び出し先はメモリの内容を変更できます。逆に、In としてマーシャリングするようにパラメーターが設定されている場合、呼び出し先は内容の変更を避ける必要があります。In は書式指定された blittable 型に対する既定の設定です。</span><span class="sxs-lookup"><span data-stu-id="a6e57-121">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="a6e57-122">同じクラスをタイプ ライブラリにエクスポートし、アパートメント間呼び出しのために使用した場合に、In オブジェクトを変更すると問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-122">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="a6e57-123">書式指定された blittable でないクラス</span><span class="sxs-lookup"><span data-stu-id="a6e57-123">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="a6e57-124">書式指定された [blittable でない](blittable-and-non-blittable-types.md)クラスは、固定レイアウト (書式指定されている) を持ちますが、マネージド メモリとアンマネージド メモリではデータ表現が異なります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-124">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="a6e57-125">次の状況では、データの変換が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-125">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="a6e57-126">blittable でないクラスを値でマーシャリングする場合、呼び出し先はデータ構造体のコピーへのポインターを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-126">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="a6e57-127">blittable でないクラスを参照でマーシャリングする場合、呼び出し先はデータ構造体のコピーへのポインターを指すポインターを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-127">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="a6e57-128"><xref:System.Runtime.InteropServices.InAttribute> 属性が設定されている場合、このコピーは常にインスタンスの状態に初期化され、必要に応じてマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-128">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="a6e57-129"><xref:System.Runtime.InteropServices.OutAttribute> 属性が設定されている場合、制御が返されるときに常に状態がインスタンスにコピーされ、必要に応じてマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-129">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="a6e57-130">**InAttribute** と **OutAttribute** の両方が設定されている場合は、両方のコピーが必要になります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-130">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="a6e57-131">いずれか一方の属性が省略された場合、マーシャラーは一方のコピーを削除して、処理を最適化できます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-131">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="a6e57-132">参照型</span><span class="sxs-lookup"><span data-stu-id="a6e57-132">Reference Types</span></span>

<span data-ttu-id="a6e57-133">参照型は値渡しまたは参照渡しできます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-133">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="a6e57-134">値渡しする場合は、型へのポインターがスタック上に渡されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-134">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="a6e57-135">参照渡しする場合、型へのポインターを指すポインターがスタック上に渡されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-135">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="a6e57-136">参照型は、次のように条件付きで動作します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-136">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="a6e57-137">参照型が値渡しされ、その参照型のメンバーのいずれかが非 blittable 型の場合、その型は次のように 2 回変換されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-137">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="a6e57-138">引数をアンマネージ側に渡すとき。</span><span class="sxs-lookup"><span data-stu-id="a6e57-138">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="a6e57-139">呼び出しから制御が返されるとき。</span><span class="sxs-lookup"><span data-stu-id="a6e57-139">On return from the call.</span></span>

  <span data-ttu-id="a6e57-140">不要なコピーと変換を避けるために、これらの型は In パラメーターとしてマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-140">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="a6e57-141">呼び出し先による変更内容を呼び出し元が確認する必要がある場合には、引数に対して明示的に **InAttribute** および **OutAttribute** 属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-141">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="a6e57-142">参照型が値渡しされ、その参照型のメンバーがすべて blittable 型の場合は、マーシャリング中にその参照型を固定できます。また、呼び出し先による型のメンバーへの変更内容は呼び出し元で確認されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-142">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="a6e57-143">このような動作が必要な場合は、**InAttribute** と **OutAttribute** を明示的に適用してください。</span><span class="sxs-lookup"><span data-stu-id="a6e57-143">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="a6e57-144">これらの方向属性を使用しない場合は、相互運用マーシャラーが方向情報をタイプ ライブラリにエクスポートしない (既定の In としてエクスポートする) ため、COM のアパートメント間マーシャリングで問題が生じることがあります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-144">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="a6e57-145">参照型を参照渡しする場合は、既定でその型が In/Out としてマーシャリングされます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-145">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="a6e57-146">System.String と System.Text.StringBuilder</span><span class="sxs-lookup"><span data-stu-id="a6e57-146">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="a6e57-147">アンマネージ コードにデータを値渡しまたは参照渡しでマーシャリングする場合、一般に、マーシャラーはデータを 2 次バッファーにコピーし (可能な場合には、コピー中に文字セットを変換)、そのバッファーへの参照を呼び出し先に渡します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-147">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="a6e57-148">この参照が **SysAllocString** によって割り当てられた **BSTR** である場合を除き、参照は常に **CoTaskMemAlloc** で割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-148">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="a6e57-149">いずれかの文字列型 (Unicode 文字列など) を値渡しでマーシャリングするときの最適化処理として、マーシャラーは新しいバッファーに文字列型をコピーする代わりに、呼び出し先に対して内部 Unicode バッファー内のマネージド文字列への直接ポインターを渡します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-149">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="a6e57-150">文字列を値渡しする場合には、マーシャラーから渡された参照を呼び出し先で変更しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="a6e57-150">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="a6e57-151">変更した場合はマネージド ヒープが破損することがあります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-151">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="a6e57-152"><xref:System.String?displayProperty=nameWithType> を参照渡しする場合、マーシャラーは呼び出しを行う前にその文字列の内容を 2 次バッファーにコピーします。</span><span class="sxs-lookup"><span data-stu-id="a6e57-152">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="a6e57-153">その後、呼び出しから制御が返されるときにバッファーの内容を新しい文字列にコピーします。</span><span class="sxs-lookup"><span data-stu-id="a6e57-153">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="a6e57-154">この手法により、変更不可のマネージド文字列が変更されないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-154">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="a6e57-155"><xref:System.Text.StringBuilder?displayProperty=nameWithType> を値渡しする場合、マーシャラーは **StringBuilder** の内部バッファーへの参照を直接呼び出し元に渡します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-155">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="a6e57-156">呼び出し元と呼び出し先は、バッファーのサイズに同意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-156">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="a6e57-157">呼び出し元は、適切な長さの **StringBuilder** を作成します。</span><span class="sxs-lookup"><span data-stu-id="a6e57-157">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="a6e57-158">呼び出し先は、バッファーのオーバーランが発生しないように必要な予防措置をとる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a6e57-158">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="a6e57-159">**StringBuilder** は、値渡しされる参照型は既定で In パラメーターとして渡される、という規則の例外です。</span><span class="sxs-lookup"><span data-stu-id="a6e57-159">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="a6e57-160">StringBuilder は常に In/Out として渡されます。</span><span class="sxs-lookup"><span data-stu-id="a6e57-160">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="a6e57-161">関連項目</span><span class="sxs-lookup"><span data-stu-id="a6e57-161">See also</span></span>

- [<span data-ttu-id="a6e57-162">既定のマーシャリング動作</span><span class="sxs-lookup"><span data-stu-id="a6e57-162">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="a6e57-163">[方向属性](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="a6e57-163">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="a6e57-164">相互運用マーシャリング</span><span class="sxs-lookup"><span data-stu-id="a6e57-164">Interop Marshaling</span></span>](interop-marshaling.md)
