---
title: TypeConverters および XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187291"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="dbf1f-102">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="dbf1f-102">TypeConverters and XAML</span></span>
<span data-ttu-id="dbf1f-103">ここでは、文字列からの型変換の目的を XAML 言語の一般的な機能として紹介します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="dbf1f-104">.NET Framework では、<xref:System.ComponentModel.TypeConverter>クラスは、XAML 属性の使用方法でプロパティ値として使用できるマネージ カスタム クラスの実装の一部として、特定の目的を果たします。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="dbf1f-105">カスタム クラスを記述し、クラスのインスタンスを XAML 設定可能な属性値として使用できるようにする場合は、クラスに a を<xref:System.ComponentModel.TypeConverterAttribute>適用するか、カスタム<xref:System.ComponentModel.TypeConverter>クラスを記述するか、またはその両方を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="dbf1f-106">型変換の概念</span><span class="sxs-lookup"><span data-stu-id="dbf1f-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="dbf1f-107">XAML と文字列値</span><span class="sxs-lookup"><span data-stu-id="dbf1f-107">XAML and String Values</span></span>  
 <span data-ttu-id="dbf1f-108">XAML ファイルで属性値を設定すると、その値の初期型は純粋なテキストの文字列になります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="dbf1f-109">XAML プロセッサに対する<xref:System.Double>最初のテキスト文字列など、他のプリミティブも同様です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="dbf1f-110">XAML プロセッサでは、属性値を処理するために 2 つの情報が必要です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="dbf1f-111">第 1 の情報は、設定しようとしているプロパティの値の型です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="dbf1f-112">属性値を定義するすべての文字列は、XAML で処理され、最終的にはその型の値に変換 (解決) される必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="dbf1f-113">値が、XAML パーサーで認識できるプリミティブ (数値など) である場合は、文字列の直接的な変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="dbf1f-114">値が列挙型の場合、文字列を使用して、その列挙体の名前付き定数と一致する名前を確認します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="dbf1f-115">値がパーサーが理解できるプリミティブでも列挙型でもない場合、問題の型は、変換された文字列に基づいて型のインスタンスまたは値を提供できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="dbf1f-116">これは、型コンバーター クラスを示すことによって行われます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="dbf1f-117">型コンバーターは、XAML シナリオと .NET コードのコード呼び出しの両方に対して、別のクラスの値を提供するためのヘルパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="dbf1f-118">XAML での既存の型変換動作の使用</span><span class="sxs-lookup"><span data-stu-id="dbf1f-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="dbf1f-119">基になる XAML の概念に精通している場合は、基本アプリケーション XAML で型変換動作を使用している場合もあります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="dbf1f-120">たとえば、WPF では、type の値を受け取る<xref:System.Windows.Point>プロパティを文字通り何百ものプロパティを定義しています。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="dbf1f-121">A<xref:System.Windows.Point>は 2 次元座標空間で座標を記述する値で、実際には 2 つの重要なプロパティ<xref:System.Windows.Point.X%2A>と<xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="dbf1f-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="dbf1f-122">XAML でポイントを指定する場合は、 と の間<xref:System.Windows.Point.X%2A><xref:System.Windows.Point.Y%2A>に区切り記号 (通常はコンマ) を含む文字列として指定します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="dbf1f-123">例: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="dbf1f-124">この単純な型の<xref:System.Windows.Point>XAML での単純な使用方法にも、型コンバーターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="dbf1f-125">この場合、それはクラス<xref:System.Windows.PointConverter>です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="dbf1f-126">クラス レベルで<xref:System.Windows.Point>定義される型コンバーターを使用すると、を受け取る<xref:System.Windows.Point>すべてのプロパティのマークアップの使用が効率化されます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="dbf1f-127">ここで型コンバーターを使用しない場合は、前に示した同じ例に対して、次の詳細なマークアップが必要になります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="dbf1f-128">型変換文字列を使用するか、より詳細な同等の構文を使用するかは、一般的にコーディング スタイルの選択肢です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="dbf1f-129">XAML ツールワークフローは、値の設定方法にも影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="dbf1f-130">XAML ツールの中には、デザイナー ビューや独自のシリアル化機構へのラウンド トリップが簡単であるため、マークアップの最も詳細な形式を生成する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="dbf1f-131">既存の型コンバーターは、通常、WPF 型および .NET Framework 型で、適用<xref:System.ComponentModel.TypeConverterAttribute>されているクラス (またはプロパティ) をチェックすることによって検出できます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="dbf1f-132">この属性は、XAML の目的と、その他の目的のために、その型の値のサポート型コンバーターであるクラスに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="dbf1f-133">型コンバーターとマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="dbf1f-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="dbf1f-134">マークアップ拡張機能と型コンバーターは、XAML プロセッサの動作と適用されるシナリオの観点から直交する役割を満たします。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="dbf1f-135">マークアップ拡張機能の使用時にはコンテキストを利用できますが、マークアップ拡張機能が値を提供するプロパティの型変換動作は一般にマークアップ拡張機能の実装ではチェックされません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="dbf1f-136">つまり、マークアップ拡張機能が出力としてテキスト文字列を`ProvideValue`返す場合でも、特定のプロパティまたはプロパティ値型に適用される文字列の型変換動作は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="dbf1f-137">型コンバーターではなくマークアップ拡張機能が必要な一般的な状況の 1 つは、既に存在するオブジェクトへの参照を作成することです。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="dbf1f-138">ステートレス型コンバーターは、新しいインスタンスしか生成できなかったので、望ましくない場合があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="dbf1f-139">マークアップ拡張機能の詳細については、「[マークアップ拡張機能と WPF XAML](markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="dbf1f-140">ネイティブな型コンバーター</span><span class="sxs-lookup"><span data-stu-id="dbf1f-140">Native Type Converters</span></span>  
 <span data-ttu-id="dbf1f-141">XAML パーサーの WPF および .NET Framework の実装では、ネイティブ型変換処理を持つ型がありますが、従来はプリミティブと考えられる型ではありません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="dbf1f-142">このような型の例として、 <xref:System.DateTime>が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="dbf1f-143">この理由は、.NET Framework アーキテクチャのしくみに基づいています。 <xref:System.DateTime></span><span class="sxs-lookup"><span data-stu-id="dbf1f-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="dbf1f-144"><xref:System.DateTime>は、依存関係<xref:System.ComponentModel.TypeConverterAttribute>を導入する別のアセンブリ (System からのもの) からの属性を持つ属性を使用することは許可されていないので、属性による通常の型コンバーター検出メカニズムはサポートできません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="dbf1f-145">代わりに、XAML パーサーには、このようなネイティブ処理を必要とする型のリストがあり、実際のプリミティブの処理方法と同様に処理されます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="dbf1f-146">(<xref:System.DateTime>この場合、呼び出しが含<xref:System.DateTime.Parse%2A>まれます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="dbf1f-147">型コンバーターの実装</span><span class="sxs-lookup"><span data-stu-id="dbf1f-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="dbf1f-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="dbf1f-148">TypeConverter</span></span>  
 <span data-ttu-id="dbf1f-149">前に<xref:System.Windows.Point>示した例では、クラス<xref:System.Windows.PointConverter>が言及されました。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="dbf1f-150">XAML の .NET 実装では、XAML の目的で使用されるすべての型コンバーターは、基本クラス<xref:System.ComponentModel.TypeConverter>から派生するクラスです。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="dbf1f-151">クラス<xref:System.ComponentModel.TypeConverter>は、XAML の存在に先立つ .NET Framework のバージョンに存在します。元の使用方法の 1 つは、ビジュアル デザイナーでプロパティ ダイアログに文字列変換を提供することでした。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="dbf1f-152">XAML のロールは、<xref:System.ComponentModel.TypeConverter>文字列属性値の解析を可能にする文字列変換と文字列変換元の変換の基本クラスであること、および特定のオブジェクト プロパティの実行時の値を属性としてシリアル化する文字列に戻すなどの役割を含むように拡張されます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="dbf1f-153"><xref:System.ComponentModel.TypeConverter>XAML 処理のために文字列との変換に関連する 4 つのメンバーを定義します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="dbf1f-154">このうち、最も重要な方法<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>は です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="dbf1f-155">このメソッドは、入力文字列を必要なオブジェクト型に変換します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="dbf1f-156">厳密に言うと<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>、このメソッドは、より広い範囲の型をコンバーターの目的の型に変換し、ランタイム変換をサポートするなど XAML 以外にも拡張する目的を果たすように実装できますが、XAML の目的では<xref:System.String>、重要な入力を処理できるコード パスにすぎません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="dbf1f-157">次に重要な方法は<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>です。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="dbf1f-158">アプリケーションがマークアップ表現に変換される場合 (たとえば、XAML にファイルとして保存される場合)、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>マークアップ表現を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="dbf1f-159">この場合、XAML にとって重要なコード パスは、 のを`destinationType`渡<xref:System.String>すときです。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="dbf1f-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> と <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> は、サービスが <xref:System.ComponentModel.TypeConverter> の実装の機能を照会する時に使用されるサポート メソッドです。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="dbf1f-161">これらのメソッドは、その型について、相当する変換メソッドをコンバーターがサポートしている場合に `true` を返すように実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="dbf1f-162">XAML の目的では、通常、 <xref:System.String> 型であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="dbf1f-163">カルチャ情報と XAML の型コンバーター</span><span class="sxs-lookup"><span data-stu-id="dbf1f-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="dbf1f-164">各<xref:System.ComponentModel.TypeConverter>実装は、変換に有効な文字列を構成するものの独自の解釈を持ち、パラメーターとして渡される型の説明を使用または無視することもできます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="dbf1f-165">カルチャと XAML 型変換に関しては、重要な考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="dbf1f-166">ローカライズ可能な文字列を属性値として使用することは、XAML で完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="dbf1f-167">ただし、XAML 属性値の型コンバーターにはカルチャを使用した必ずしも固定言語解析動作が含まれるため、特定のカルチャ要件を持つ型コンバーター入力としてそのローカライズ`en-US`可能な文字列を使用することはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="dbf1f-168">この制限の設計上の理由の詳細については、XAML 言語仕様 ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="dbf1f-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="dbf1f-169">カルチャが問題になる例として、カルチャによっては、数値の小数点区切り記号としてコンマを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="dbf1f-170">これは、多くの WPF XAML 型コンバーターが持つ動作と競合します( 一般的な X、Y フォーム、コンマ区切りリストなどの履歴判例に基づいて) コンマを区切り文字として使用します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="dbf1f-171">周辺の XAML でカルチャを渡す`Language`場合`xml:lang`でも`sl-SI`(設定またはカルチャに、この方法で小数点にコンマを使用するカルチャの例)、問題は解決しません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="dbf1f-172">ConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="dbf1f-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="dbf1f-173">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装としてコンバーターを使用できるようにするためには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドが `value` パラメーターとして文字列を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="dbf1f-174">文字列が有効な形式で、<xref:System.ComponentModel.TypeConverter>実装によって変換できる場合、返されるオブジェクトは、プロパティで予期される型へのキャストをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="dbf1f-175">それ以外の場合、 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 実装は `null`を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="dbf1f-176">各<xref:System.ComponentModel.TypeConverter>実装は、変換に有効な文字列を構成するものの独自の解釈を持ち、パラメーターとして渡される型の説明またはカルチャ コンテキストを使用または無視することもできます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="dbf1f-177">ただし、WPF XAML 処理では、型の説明コンテキストに値を渡さない場合や、 に基づくカルチャを`xml:lang`渡さない場合があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="dbf1f-178">文字列形式の要素として、中かっこ ({) を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="dbf1f-179">これらの文字は、マークアップ拡張シーケンスの開始および終了を示す文字として予約されています。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="dbf1f-180">ConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="dbf1f-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="dbf1f-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> は、シリアル化のサポートで使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="dbf1f-182">カスタム型およびその型コンバーターに対して <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> によるシリアル化をサポートすることは、絶対要件ではありません。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="dbf1f-183">ただし、コントロールを実装する場合、またはクラスの機能または設計の一部としてシリアル化を使用する場合は、 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="dbf1f-184">XAML をサポートする<xref:System.ComponentModel.TypeConverter>実装として使用できるようにするには、そのコンバーター<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>のメソッドがパラメーターとしてサポートされている型 (または値) のインスタンスを`value`受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="dbf1f-185">パラメーターが`destinationType`type<xref:System.String>の場合、返されるオブジェクトは<xref:System.String>としてキャストできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="dbf1f-186">返される文字列は、 `value`のシリアル化された値を表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="dbf1f-187">理想的には、選択したシリアル化形式は、同じコンバーターの<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>実装に文字列が渡された場合、情報を大幅に失うことなく同じ値を生成できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="dbf1f-188">値をシリアル化できない場合、またはコンバーターがシリアル化をサポートしていない場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>実装はを`null`返す必要があり、この場合は例外をスローできます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="dbf1f-189">ただし、例外をスローする場合は、例外を回避するために<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>最初にチェックするベスト プラクティスがサポートされるように、その変換を実装の一部として使用できないことを報告する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="dbf1f-190">パラメータ`destinationType`が型<xref:System.String>でない場合は、独自のコンバータ処理を選択できます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="dbf1f-191">通常は、基本の実装処理に戻しますが、その処理は、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>最も基本的に特定の例外を発生させます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="dbf1f-192">CanConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="dbf1f-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="dbf1f-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装は、 `true` が `destinationType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="dbf1f-194">CanConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="dbf1f-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="dbf1f-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> の実装は、 `true` が `sourceType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="dbf1f-196">TypeConverterAttribute の適用</span><span class="sxs-lookup"><span data-stu-id="dbf1f-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="dbf1f-197">カスタム型コンバーターを XAML プロセッサによってカスタム クラスの代理型コンバーターとして使用するには、 を<xref:System.ComponentModel.TypeConverterAttribute>クラス定義に適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="dbf1f-198">属性を通して指定する <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> は、カスタム型コンバーターの型名である必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="dbf1f-199">この属性を適用すると、プロパティ型がカスタム クラス型を使用する値を XAML プロセッサが処理するときに、文字列を入力してオブジェクト インスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="dbf1f-200">また、プロパティごとに型コンバーターを提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="dbf1f-201">を<xref:System.ComponentModel.TypeConverterAttribute>クラス定義に適用するのではなく、プロパティ定義 (その中の`get`/`set`実装ではなく、メイン定義) に適用します。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="dbf1f-202">プロパティの型は、カスタム型コンバーターによって処理される型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="dbf1f-203">この属性を適用すると、プロパティの値を XAML プロセッサが処理する際に、入力文字列を処理して、オブジェクトのインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="dbf1f-204">プロパティごとの型コンバーターの手法は、Microsoft .NET Framework またはクラス定義を制御できず、そのライブラリからプロパティ型を使用する場合に特に便利です<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="dbf1f-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dbf1f-205">関連項目</span><span class="sxs-lookup"><span data-stu-id="dbf1f-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="dbf1f-206">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="dbf1f-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="dbf1f-207">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="dbf1f-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="dbf1f-208">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="dbf1f-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
