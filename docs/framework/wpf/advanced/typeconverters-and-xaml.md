---
title: TypeConverters および XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 6b8b58228e94ed12557e97406e55cc4165753076
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095087"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="50db5-102">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="50db5-102">TypeConverters and XAML</span></span>
<span data-ttu-id="50db5-103">このトピックでは、一般的な XAML 言語機能としての文字列からの型変換の目的について説明します。</span><span class="sxs-lookup"><span data-stu-id="50db5-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="50db5-104">.NET Framework では、<xref:System.ComponentModel.TypeConverter> クラスは、XAML 属性の使用でプロパティ値として使用できるマネージカスタムクラスの実装の一部として特定の目的を果たします。</span><span class="sxs-lookup"><span data-stu-id="50db5-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="50db5-105">カスタムクラスを作成し、クラスのインスタンスを XAML 設定可能な属性値として使用できるようにする場合は、クラスに <xref:System.ComponentModel.TypeConverterAttribute> を適用したり、カスタム <xref:System.ComponentModel.TypeConverter> クラス、またはその両方を記述したりすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="50db5-106">型変換の概念</span><span class="sxs-lookup"><span data-stu-id="50db5-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="50db5-107">XAML と文字列値</span><span class="sxs-lookup"><span data-stu-id="50db5-107">XAML and String Values</span></span>  
 <span data-ttu-id="50db5-108">XAML ファイルで属性値を設定すると、その値の最初の型は純粋テキストの文字列になります。</span><span class="sxs-lookup"><span data-stu-id="50db5-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="50db5-109"><xref:System.Double> などの他のプリミティブも、最初に XAML プロセッサのテキスト文字列です。</span><span class="sxs-lookup"><span data-stu-id="50db5-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="50db5-110">XAML プロセッサは、属性値を処理するために2つの情報を必要とします。</span><span class="sxs-lookup"><span data-stu-id="50db5-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="50db5-111">第 1 の情報は、設定しようとしているプロパティの値の型です。</span><span class="sxs-lookup"><span data-stu-id="50db5-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="50db5-112">属性値を定義するすべての文字列は、XAML で処理され、最終的にはその型の値に変換 (解決) される必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="50db5-113">値が、XAML パーサーで認識できるプリミティブ (数値など) である場合は、文字列の直接的な変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="50db5-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="50db5-114">値が列挙型の場合、文字列は、その列挙体の名前付き定数に一致する名前があるかどうかを確認するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="50db5-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="50db5-115">値がパーサーで認識されるプリミティブでも列挙でもない場合、問題の型は、変換後の文字列に基づいて、型のインスタンスまたは値を提供できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="50db5-116">これを行うには、型コンバータークラスを指定します。</span><span class="sxs-lookup"><span data-stu-id="50db5-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="50db5-117">型コンバーターは、実際には、XAML シナリオに対しても、.NET コードのコード呼び出しの場合でも、別のクラスの値を提供するためのヘルパークラスです。</span><span class="sxs-lookup"><span data-stu-id="50db5-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="50db5-118">XAML での既存の型変換動作の使用</span><span class="sxs-lookup"><span data-stu-id="50db5-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="50db5-119">基になる XAML の概念に関する知識によっては、基本的なアプリケーション XAML で型変換の動作を使用していることがわかっていない場合があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="50db5-120">たとえば、WPF では、<xref:System.Windows.Point>型の値を受け取る文字どおり数百のプロパティが定義されています。</span><span class="sxs-lookup"><span data-stu-id="50db5-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="50db5-121"><xref:System.Windows.Point> は、2次元の座標空間内の座標を表す値であり、実際には <xref:System.Windows.Point.X%2A> と <xref:System.Windows.Point.Y%2A>の2つの重要なプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="50db5-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="50db5-122">XAML でポイントを指定する場合は、指定した <xref:System.Windows.Point.X%2A> と <xref:System.Windows.Point.Y%2A> の値の間に区切り記号 (通常はコンマ) を含む文字列として指定します。</span><span class="sxs-lookup"><span data-stu-id="50db5-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="50db5-123">(例: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`)。</span><span class="sxs-lookup"><span data-stu-id="50db5-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="50db5-124">この単純型の <xref:System.Windows.Point> と XAML での単純な使用についても、型コンバーターが必要です。</span><span class="sxs-lookup"><span data-stu-id="50db5-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="50db5-125">この場合は、<xref:System.Windows.PointConverter>クラスです。</span><span class="sxs-lookup"><span data-stu-id="50db5-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="50db5-126">クラスレベルで定義されている <xref:System.Windows.Point> の型コンバーターは、<xref:System.Windows.Point>を受け取るすべてのプロパティのマークアップの使用を効率化します。</span><span class="sxs-lookup"><span data-stu-id="50db5-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="50db5-127">ここでは型コンバーターを使用しない場合、前に示したのと同じ例について、より詳細なマークアップが必要になります。</span><span class="sxs-lookup"><span data-stu-id="50db5-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="50db5-128">型変換文字列を使用するか、より詳細な同等の構文を使用するかは、通常、コーディングスタイルとして選択します。</span><span class="sxs-lookup"><span data-stu-id="50db5-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="50db5-129">XAML ツールワークフローは、値の設定方法にも影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="50db5-130">XAML ツールによっては、デザイナービューや独自のシリアル化機構にラウンドトリップしやすくなるため、最も詳細なマークアップ形式が生成される傾向があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="50db5-131">既存の型コンバーターは、通常、クラス (またはプロパティ) で適用された <xref:System.ComponentModel.TypeConverterAttribute>が存在するかどうかをチェックすることによって、WPF および .NET Framework 型で検出できます。</span><span class="sxs-lookup"><span data-stu-id="50db5-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="50db5-132">この属性は、XAML の目的だけでなく、他の目的でも、その型の値に対してサポートされている型コンバーターであるクラスに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="50db5-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="50db5-133">型コンバーターとマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="50db5-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="50db5-134">マークアップ拡張機能と型コンバーターは、XAML プロセッサの動作と、それらが適用されるシナリオに関して直交ロールを設定します。</span><span class="sxs-lookup"><span data-stu-id="50db5-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="50db5-135">マークアップ拡張機能の使用時にはコンテキストを利用できますが、マークアップ拡張機能が値を提供するプロパティの型変換動作は一般にマークアップ拡張機能の実装ではチェックされません。</span><span class="sxs-lookup"><span data-stu-id="50db5-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="50db5-136">つまり、マークアップ拡張機能が `ProvideValue` 出力としてテキスト文字列を返す場合でも、特定のプロパティまたはプロパティ値型に適用される、その文字列に対する型変換動作は呼び出されません。一般に、マークアップ拡張機能の目的は、文字列を処理し、型コンバーターを含まないオブジェクトを返すことです。</span><span class="sxs-lookup"><span data-stu-id="50db5-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="50db5-137">型コンバーターではなく、マークアップ拡張機能が必要となる一般的な状況の1つは、既に存在するオブジェクトへの参照を作成することです。</span><span class="sxs-lookup"><span data-stu-id="50db5-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="50db5-138">最良の場合、ステートレスな型コンバーターは新しいインスタンスを生成するだけで、望ましくない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="50db5-139">マークアップ拡張機能の詳細については、「[マークアップ拡張機能」および「WPF XAML](markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50db5-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="50db5-140">ネイティブな型コンバーター</span><span class="sxs-lookup"><span data-stu-id="50db5-140">Native Type Converters</span></span>  
 <span data-ttu-id="50db5-141">XAML パーサーの WPF および .NET Framework 実装では、ネイティブ型の変換処理を持つ特定の型がありますが、プリミティブとして考えられる型ではありません。</span><span class="sxs-lookup"><span data-stu-id="50db5-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="50db5-142">このような型の例として、 <xref:System.DateTime>が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="50db5-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="50db5-143">この理由は、.NET Framework アーキテクチャの動作に基づいています。型 <xref:System.DateTime> は、.NET の最も基本的なライブラリである mscorlib で定義されています。</span><span class="sxs-lookup"><span data-stu-id="50db5-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="50db5-144"><xref:System.DateTime> は、依存関係が導入された別のアセンブリからの属性 (システムからの<xref:System.ComponentModel.TypeConverterAttribute> である) を使用して属性を設定することは許可されていないため、属性による通常の型コンバーターの検出メカニズムはサポートされません。</span><span class="sxs-lookup"><span data-stu-id="50db5-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="50db5-145">代わりに、XAML パーサーには、このようなネイティブ処理を必要とする型のリストがあり、これらは真のプリミティブの処理方法と同様に処理されます。</span><span class="sxs-lookup"><span data-stu-id="50db5-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="50db5-146">(<xref:System.DateTime> 場合は、<xref:System.DateTime.Parse%2A>を呼び出す必要があります)。</span><span class="sxs-lookup"><span data-stu-id="50db5-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="50db5-147">型コンバーターの実装</span><span class="sxs-lookup"><span data-stu-id="50db5-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="50db5-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="50db5-148">TypeConverter</span></span>  
 <span data-ttu-id="50db5-149">前に示した <xref:System.Windows.Point> の例では、クラス <xref:System.Windows.PointConverter> について説明しました。</span><span class="sxs-lookup"><span data-stu-id="50db5-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="50db5-150">XAML の .NET 実装では、XAML の目的で使用されるすべての型コンバーターは、<xref:System.ComponentModel.TypeConverter>基底クラスから派生するクラスです。</span><span class="sxs-lookup"><span data-stu-id="50db5-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="50db5-151"><xref:System.ComponentModel.TypeConverter> クラスは、XAML の存在前に .NET Framework のバージョンに存在しています。最初の使用方法の1つは、ビジュアルデザイナーのプロパティダイアログに文字列変換を提供することでした。</span><span class="sxs-lookup"><span data-stu-id="50db5-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="50db5-152">XAML の場合、<xref:System.ComponentModel.TypeConverter> のロールが拡張され、文字列属性値の解析を有効にし、場合によっては特定のオブジェクトプロパティの実行時の値を属性としてシリアル化するために文字列に変換することができます。</span><span class="sxs-lookup"><span data-stu-id="50db5-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="50db5-153"><xref:System.ComponentModel.TypeConverter> は、XAML 処理のために文字列との間の変換に関連する4つのメンバーを定義します。</span><span class="sxs-lookup"><span data-stu-id="50db5-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="50db5-154">これらのうち、最も重要な方法は <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>です。</span><span class="sxs-lookup"><span data-stu-id="50db5-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="50db5-155">このメソッドは、入力文字列を必要なオブジェクト型に変換します。</span><span class="sxs-lookup"><span data-stu-id="50db5-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="50db5-156">厳密に言えば、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドを実装して、より広範な型をコンバーターの目的の型に変換することができます。これにより、実行時の変換をサポートするなど、XAML を超えて拡張できるようになりますが、XAML の目的では、重要な <xref:System.String> 入力を処理できるコードパスにすぎません。</span><span class="sxs-lookup"><span data-stu-id="50db5-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="50db5-157">次に重要なメソッドは <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>です。</span><span class="sxs-lookup"><span data-stu-id="50db5-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="50db5-158">アプリケーションがマークアップ表現に変換された場合 (たとえば、ファイルとして XAML に保存されている場合)、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> はマークアップ表現の生成を行います。</span><span class="sxs-lookup"><span data-stu-id="50db5-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="50db5-159">この場合、XAML にとって重要なコードパスは、<xref:System.String> の `destinationType` を渡すときに使用されます。</span><span class="sxs-lookup"><span data-stu-id="50db5-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="50db5-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> と <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> は、サービスが <xref:System.ComponentModel.TypeConverter> の実装の機能を照会する時に使用されるサポート メソッドです。</span><span class="sxs-lookup"><span data-stu-id="50db5-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="50db5-161">これらのメソッドは、その型について、相当する変換メソッドをコンバーターがサポートしている場合に `true` を返すように実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="50db5-162">XAML の目的では、通常、 <xref:System.String> 型であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="50db5-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="50db5-163">カルチャ情報と XAML の型コンバーター</span><span class="sxs-lookup"><span data-stu-id="50db5-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="50db5-164">各 <xref:System.ComponentModel.TypeConverter> 実装では、変換の有効な文字列を構成する内容を独自に解釈できます。また、パラメーターとして渡される型の説明を使用したり無視したりすることもできます。</span><span class="sxs-lookup"><span data-stu-id="50db5-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="50db5-165">カルチャと XAML の型変換に関しては、重要な考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="50db5-166">属性値としてローカライズ可能な文字列を使用することは、XAML で完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="50db5-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="50db5-167">ただし、このローカライズ可能な文字列を特定のカルチャ要件での型コンバーター入力として使用することはサポートされていません。これは、XAML 属性値の型コンバーターは、`en-US` カルチャを使用して、必ずしも固定言語の解析動作を行うためです。</span><span class="sxs-lookup"><span data-stu-id="50db5-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="50db5-168">この制限の設計上の理由の詳細については、「XAML 言語仕様 ([\[\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50db5-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="50db5-169">カルチャが問題になる可能性のある例として、一部のカルチャでは、数値の小数点の区切り記号としてコンマを使用しています。</span><span class="sxs-lookup"><span data-stu-id="50db5-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="50db5-170">これは、WPF XAML 型コンバーターの多くが持つ動作と競合します。これは、コンマを区切り記号として使用します。これは、共通の X、Y 形式、またはコンマ区切りの一覧などの履歴の参照元に基づいています。</span><span class="sxs-lookup"><span data-stu-id="50db5-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="50db5-171">周囲の XAML でカルチャを渡すこともできます (`Language` または `xml:lang` を `sl-SI` カルチャに設定します。この方法では、10進数にコンマを使用するカルチャの例) では問題は解決されません。</span><span class="sxs-lookup"><span data-stu-id="50db5-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="50db5-172">ConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="50db5-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="50db5-173">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装としてコンバーターを使用できるようにするためには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドが `value` パラメーターとして文字列を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="50db5-174">文字列が有効な形式であり、<xref:System.ComponentModel.TypeConverter> の実装で変換できる場合、返されるオブジェクトは、プロパティで想定される型へのキャストをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="50db5-175">それ以外の場合、 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 実装は `null`を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="50db5-176">各 <xref:System.ComponentModel.TypeConverter> 実装では、変換のために有効な文字列を構成する内容を独自に解釈できます。また、パラメーターとして渡される型の説明またはカルチャコンテキストを使用したり無視したりすることもできます。</span><span class="sxs-lookup"><span data-stu-id="50db5-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="50db5-177">ただし、WPF XAML 処理では、常に型の説明のコンテキストに値を渡さないことがあります。また、`xml:lang`に基づいてカルチャを渡さない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="50db5-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="50db5-178">中かっこ文字 (特に {) は、文字列形式の可能な要素として使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="50db5-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="50db5-179">これらの文字は、マークアップ拡張シーケンスの開始および終了を示す文字として予約されています。</span><span class="sxs-lookup"><span data-stu-id="50db5-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="50db5-180">ConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="50db5-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="50db5-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> は、シリアル化のサポートで使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="50db5-182">カスタム型およびその型コンバーターに対して <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> によるシリアル化をサポートすることは、絶対要件ではありません。</span><span class="sxs-lookup"><span data-stu-id="50db5-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="50db5-183">ただし、コントロールを実装する場合、またはクラスの機能または設計の一部としてシリアル化を使用する場合は、 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="50db5-184">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装として使用できるようにするには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> メソッドが、`value` パラメーターとしてサポートされている型のインスタンス (または値) を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="50db5-185">`destinationType` パラメーターが <xref:System.String>型の場合、返されるオブジェクトは <xref:System.String>としてキャストできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="50db5-186">返される文字列は、 `value`のシリアル化された値を表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="50db5-187">理想的には、選択したシリアル化形式で、同じコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> の実装にその文字列が渡された場合に、情報が大幅に失われることなく、同じ値を生成できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="50db5-188">値をシリアル化できない場合、またはコンバーターがシリアル化をサポートしていない場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A> の実装は `null`を返す必要があり、この場合は例外をスローすることが許可されます。</span><span class="sxs-lookup"><span data-stu-id="50db5-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="50db5-189">ただし、例外をスローする場合は、<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 実装の一部としてその変換を使用できないことを報告して、例外を回避するために <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 最初に確認することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="50db5-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="50db5-190">`destinationType` パラメーターの型が <xref:System.String>でない場合は、独自のコンバーター処理を選択できます。</span><span class="sxs-lookup"><span data-stu-id="50db5-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="50db5-191">通常は、基本実装の処理に戻します。これは、basemost によって特定の例外が発生します。<xref:System.ComponentModel.TypeConverter.ConvertTo%2A></span><span class="sxs-lookup"><span data-stu-id="50db5-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="50db5-192">CanConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="50db5-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="50db5-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装は、 `true` が `destinationType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="50db5-194">CanConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="50db5-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="50db5-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> の実装は、 `true` が `sourceType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="50db5-196">TypeConverterAttribute の適用</span><span class="sxs-lookup"><span data-stu-id="50db5-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="50db5-197">カスタム型コンバーターを XAML プロセッサによってカスタムクラスの動作する型コンバーターとして使用するには、<xref:System.ComponentModel.TypeConverterAttribute> をクラス定義に適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="50db5-198">属性を通して指定する <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> は、カスタム型コンバーターの型名である必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="50db5-199">この属性を適用すると、プロパティ型がカスタムクラス型を使用する値を XAML プロセッサが処理するときに、入力文字列を入力して、オブジェクトインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="50db5-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="50db5-200">また、プロパティごとに型コンバーターを提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="50db5-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="50db5-201">クラス定義に <xref:System.ComponentModel.TypeConverterAttribute> を適用する代わりに、プロパティ定義に適用します (`get`/`set` の実装ではなく、メイン定義)。</span><span class="sxs-lookup"><span data-stu-id="50db5-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="50db5-202">プロパティの型は、カスタム型コンバーターによって処理される型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50db5-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="50db5-203">この属性を適用すると、プロパティの値を XAML プロセッサが処理する際に、入力文字列を処理して、オブジェクトのインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="50db5-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="50db5-204">プロパティごとの型コンバーターの手法は、Microsoft .NET Framework から、またはクラス定義を制御できない他のライブラリからプロパティ型を使用する場合に特に便利であり、そこに <xref:System.ComponentModel.TypeConverterAttribute> を適用することはできません。</span><span class="sxs-lookup"><span data-stu-id="50db5-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="50db5-205">参照</span><span class="sxs-lookup"><span data-stu-id="50db5-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="50db5-206">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="50db5-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="50db5-207">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="50db5-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="50db5-208">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="50db5-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
