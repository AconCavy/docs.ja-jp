---
title: XAML 構文の詳細
description: XAML を利用する Windows Presentation Foundation およびその他のフレームワークでの XAML 構文の要素を表すために使用されている用語について説明します。
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 6ef217a646b14f02c0b812f6316ec84f26d4b660
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168347"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="aae1f-103">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="aae1f-103">XAML Syntax In Detail</span></span>
<span data-ttu-id="aae1f-104">このトピックでは、XAML 構文の要素について説明するために使用される用語を定義します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-104">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="aae1f-105">これらの用語は、このドキュメントの他の部分で頻繁に使用されます。WPF のドキュメントと、System.Xaml レベルでの XAML 言語サポートによって有効にされる XAML および XAML の基本的な概念を使用する他のフレームワークの両方で使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-105">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="aae1f-106">このトピックは、[XAML の概要 (WPF)](../../../desktop-wpf/fundamentals/xaml.md) に関するトピックで説明されている基本的な用語を拡充したものです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-106">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="aae1f-107">XAML 言語仕様</span><span class="sxs-lookup"><span data-stu-id="aae1f-107">The XAML Language Specification</span></span>  
 <span data-ttu-id="aae1f-108">ここで定義されている XAML 構文の用語は、XAML 言語仕様でも定義または参照されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-108">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="aae1f-109">XAML は XML に基づく言語であり、XML 構造ルールに従うか、それを拡張しています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-109">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="aae1f-110">一部の用語は、XML 言語または XML ドキュメント オブジェクト モデルを説明するときに一般的に使用される用語と共通であるか、またはそれが基になっています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-110">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="aae1f-111">XAML 言語仕様の詳細については、Microsoft ダウンロード センターから [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) をダウンロードしてください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-111">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="aae1f-112">XAML と CLR</span><span class="sxs-lookup"><span data-stu-id="aae1f-112">XAML and CLR</span></span>  
 <span data-ttu-id="aae1f-113">XAML はマークアップ言語です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-113">XAML is a markup language.</span></span> <span data-ttu-id="aae1f-114">名前のとおり、共通言語ランタイム (CLR) によってランタイムを実行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-114">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="aae1f-115">XAML 自体は、CLR ランタイムによって直接使用される共通言語の 1 つではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-115">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="aae1f-116">そうではなく、XAML は独自の型システムをサポートするものと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-116">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="aae1f-117">WPF によって使用される特定の XAML 解析システムは、CLR と CLR 型システムが基になっています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-117">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="aae1f-118">XAML の型は、WPF の XAML が解析されるときに、実行時の表現をインスタンス化するために、CLR の型にマップされます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-118">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="aae1f-119">このため、このドキュメントの構文に関する残りの部分には、CLR 型システムへの参照が含まれています。ただし、XAML 言語仕様での同等の構文の説明には含まれません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-119">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="aae1f-120">(XAML 言語仕様レベルによると、XAML 型は他の任意の型システムにマップでき、それは CLR である必要はありませんが、それには別の XAML パーサーを作成して使用する必要があります)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-120">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="aae1f-121">型のメンバーとクラスの継承</span><span class="sxs-lookup"><span data-stu-id="aae1f-121">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="aae1f-122">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 型の XAML メンバーであるプロパティとイベントは、多くの場合、基本型から継承されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-122">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="aae1f-123">たとえば、`<Button Background="Blue" .../>` について考えてみます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-123">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="aae1f-124">クラス定義、リフレクション結果、またはドキュメントを見ると、<xref:System.Windows.Controls.Control.Background%2A> プロパティは、<xref:System.Windows.Controls.Button> クラスで直接宣言されているプロパティではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-124">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="aae1f-125">そうではなく、<xref:System.Windows.Controls.Control.Background%2A> は基底クラス <xref:System.Windows.Controls.Control> から継承されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-125">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="aae1f-126">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の XAML 要素のクラス継承動作は、XML マークアップのスキーマで適用される解釈とは大きく異なります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-126">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="aae1f-127">クラスの継承は複雑になる可能性があります。中間の基底クラスが抽象型の場合、またはインターフェイスが関係している場合は特にそうです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-127">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="aae1f-128">これは、DTD 形式や XSD 形式などの XML プログラミングで通常使用されるスキーマ型を使用して、XAML の要素とその使用可能な属性のセットを正確かつ完全に表現することが困難な理由の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-128">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="aae1f-129">もう 1 つの理由は、XAML 言語自体の機能拡張および型マッピング機能により、許容される型とメンバーを完全かつ一意的に表現することが不可能なためです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-129">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="aae1f-130">オブジェクト要素構文</span><span class="sxs-lookup"><span data-stu-id="aae1f-130">Object Element Syntax</span></span>  
 <span data-ttu-id="aae1f-131">"*オブジェクト要素構文*" は、XML 要素を宣言することで CLR のクラスまたは構造体をインスタンス化する XAML マークアップ構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-131">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="aae1f-132">この構文は、HTML などの他のマークアップ言語の要素構文に似ています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-132">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="aae1f-133">オブジェクト要素構文は、左山かっこ (\<) で始まり、インスタンス化されるクラスまたは構造体の型名が続きます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-133">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="aae1f-134">型名の後には、0 個以上の空白を挿入できます。また、0 個以上の属性をオブジェクト要素で宣言することもできます。属性名 = "値" のペアを区切るには、1 つ以上のスペースを使用します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-134">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="aae1f-135">最後に、次のいずれかが満たされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-135">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="aae1f-136">要素とタグは、スラッシュ (/) とその直後の右山かっこ (>) によって閉じられる必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-136">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="aae1f-137">開始タグは、右山かっこ (>) によって終了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-137">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="aae1f-138">開始タグの後には、他のオブジェクト要素、プロパティ要素、または内部テキストを記述できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-138">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="aae1f-139">厳密にここに含めることができる内容については、通常、要素のオブジェクト モデルによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-139">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="aae1f-140">適切な入れ子および他の開始および終了タグのペアとのバランスのため、オブジェクト要素に対応する終了タグが存在する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-140">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="aae1f-141">.NET によって実装される XAML には、オブジェクト要素から型、属性からプロパティまたはイベント、および XAML 名前空間から CLR 名前空間とアセンブリへのマップに関する一連の規則があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-141">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="aae1f-142">WPF と .NET では、XAML オブジェクト要素は参照されているアセンブリで定義されている .NET 型にマップされ、属性はそれらの型のメンバーにマップされます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-142">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="aae1f-143">XAML で CLR 型を参照する場合は、その型の継承されたメンバーにもアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-143">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="aae1f-144">たとえば、次の例は、<xref:System.Windows.Controls.Button> クラスの新しいインスタンスをインスタンス化し、<xref:System.Windows.FrameworkElement.Name%2A> 属性とその属性の値を指定するオブジェクト要素構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-144">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="aae1f-145">次の例は、XAML コンテンツ プロパティ構文も含まれるオブジェクト要素構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-145">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="aae1f-146">中に含まれる内部テキストは、<xref:System.Windows.Controls.TextBox> の XAML コンテンツ プロパティ <xref:System.Windows.Controls.TextBox.Text%2A> を設定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-146">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="aae1f-147">コンテンツ モデル</span><span class="sxs-lookup"><span data-stu-id="aae1f-147">Content Models</span></span>  
 <span data-ttu-id="aae1f-148">クラスでは構文に関して XAML オブジェクト要素としての使用がサポートされている場合がありますが、その要素がアプリケーションまたはページで正しく機能するのは、コンテンツ モデルまたは要素ツリー全体の予想される位置に配置されている場合だけです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-148">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="aae1f-149">たとえば、<xref:System.Windows.Controls.MenuItem> は通常、<xref:System.Windows.Controls.Menu> などの <xref:System.Windows.Controls.Primitives.MenuBase> 派生クラスの子としてのみ配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-149">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="aae1f-150">特定の要素のコンテンツ モデルは、XAML 要素として使用できるコントロールおよび他の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスのクラス ページの解説の一部として説明されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-150">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="aae1f-151">オブジェクト要素のプロパティ</span><span class="sxs-lookup"><span data-stu-id="aae1f-151">Properties of Object Elements</span></span>  
 <span data-ttu-id="aae1f-152">XAML のプロパティは、さまざまな構文で設定できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-152">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="aae1f-153">特定のプロパティに使用できる構文は、設定するプロパティの基になる型システムの特性によって異なります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-153">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="aae1f-154">プロパティの値を設定することにより、オブジェクトが実行時オブジェクト グラフに存在するときの機能または特性が追加されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-154">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="aae1f-155">オブジェクト要素から作成されるオブジェクトの初期状態は、パラメーターなしのコンストラクターの動作に基づきます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-155">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="aae1f-156">通常、アプリケーションでは、特定のオブジェクトの完全に既定のインスタンス以外のものを使用します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-156">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="aae1f-157">属性構文 (プロパティ)</span><span class="sxs-lookup"><span data-stu-id="aae1f-157">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="aae1f-158">属性構文は、既存のオブジェクト要素の属性を宣言することによってプロパティの値を設定する XAML マークアップ構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-158">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="aae1f-159">属性名は、関連するオブジェクト要素の基になっているクラスのプロパティの CLR メンバー名と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-159">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="aae1f-160">属性名の後に代入演算子 (=) を記述します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-160">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="aae1f-161">属性値は、引用符で囲まれた文字列である必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-161">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="aae1f-162">代替引用符を使用することにより、属性内でリテラルの引用符を使用できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-162">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="aae1f-163">たとえば、二重引用符が含まれる文字列を宣言する手段として、単一引用符を使用できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-163">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="aae1f-164">単一引用符と二重引用符のどちらを使用する場合でも、属性値の文字列の開始と終了には、一致するペアを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-164">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="aae1f-165">また、特定の XAML 構文での文字制限を回避するために使用できるエスケープ シーケンスやその他の手法もあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-165">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="aae1f-166">「[XML 文字エンティティと XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-166">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="aae1f-167">属性構文を使用して設定するには、プロパティはパブリックで、書き込み可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-167">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="aae1f-168">バッキング型システムでのプロパティの値は、値型であるか、または関連するバッキング型にアクセスするときに XAML プロセッサによってインスタンス化または参照できる参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-168">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="aae1f-169">WPF XAML イベントの場合、属性名として参照されるイベントはパブリックであり、パブリック デリゲートを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-169">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="aae1f-170">プロパティまたはイベントは、含む側のオブジェクト要素によってインスタンス化されるクラスまたは構造体のメンバーである必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-170">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="aae1f-171">属性値の処理</span><span class="sxs-lookup"><span data-stu-id="aae1f-171">Processing of Attribute Values</span></span>  
 <span data-ttu-id="aae1f-172">開始と終了の引用符に含まれる文字列値は、XAML プロセッサによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-172">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="aae1f-173">プロパティの既定の処理動作は、基になる CLR プロパティの型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-173">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="aae1f-174">属性値は、次のいずれかの方法により、この処理順序で設定されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-174">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="aae1f-175">XAML プロセッサで、中かっこまたは <xref:System.Windows.Markup.MarkupExtension> から派生したオブジェクト要素が検出された場合は、値を文字列として処理するのではなく、参照されているマークアップ拡張が最初に評価され、マークアップ拡張によって返されるオブジェクトが値として使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-175">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="aae1f-176">多くの場合、マークアップ拡張によって返されるオブジェクトは、既存のオブジェクトへの参照、または実行時まで評価が延期される式であり、新しくインスタンス化されたオブジェクトではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-176">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="aae1f-177">プロパティが属性付きの <xref:System.ComponentModel.TypeConverter> で宣言されている場合、またはプロパティの値の型が属性付きの <xref:System.ComponentModel.TypeConverter> で宣言されている場合は、属性の文字列値が変換入力として型コンバーターに送信され、コンバーターからは新しいオブジェクト インスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-177">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="aae1f-178"><xref:System.ComponentModel.TypeConverter> がない場合は、プロパティ型への直接変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-178">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="aae1f-179">この最終的なレベルは、XAML 言語プリミティブ型間のパーサー ネイティブ値での直接変換、または列挙型の名前付き定数の名前のチェック (その場合、パーサーは一致した値にアクセスします) です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-179">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="aae1f-180">列挙属性の値</span><span class="sxs-lookup"><span data-stu-id="aae1f-180">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="aae1f-181">XAML の列挙は、本質的に XAML パーサーによって処理され、列挙型のメンバーは、列挙型の名前付き定数の 1 つの文字列名を指定することによって指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-181">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="aae1f-182">フラグ以外の列挙値に対するネイティブな動作では、属性値の文字列が処理されて、列挙値のいずれかに解決されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-182">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="aae1f-183">コードでのように <*列挙型*>.<*値*> の形式で列挙型を指定することはありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-183">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="aae1f-184">代わりに "*値*" だけを指定し、"*列挙型*" は設定するプロパティの型によって推論されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-184">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="aae1f-185"><*列挙型*>.<*値*> の形式で属性を指定した場合は、正しく解決されません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-185">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="aae1f-186">フラグ列挙型の動作は、<xref:System.Enum.Parse%2A?displayProperty=nameWithType> メソッドに基づきます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-186">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aae1f-187">各値をコンマで区切ることにより、フラグ列挙型に複数の値を指定できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-187">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="aae1f-188">ただし、フラグではない列挙値を組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-188">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="aae1f-189">たとえば、コンマ構文を使用して、非フラグ列挙型の複数の条件に対して動作する <xref:System.Windows.Trigger> を作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-189">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="aae1f-190">XAML で設定可能な属性をサポートするフラグ列挙型は、WPF ではほとんど使用されません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-190">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="aae1f-191">ただし、そのような列挙型の 1 つは <xref:System.Windows.Media.StyleSimulations> です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-191">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="aae1f-192">たとえば、コンマ区切りのフラグ属性構文を使用して、<xref:System.Windows.Documents.Glyphs> クラスの解説に記載されている例を変更することができます。`StyleSimulations = "BoldSimulation"` を `StyleSimulations = "BoldSimulation,ItalicSimulation"` にすることができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-192">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="aae1f-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> は、複数の列挙値を指定できるもう 1 つのプロパティです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="aae1f-194">ただし、このプロパティは、<xref:System.Windows.Input.ModifierKeys> 列挙型で独自の型コンバーターがサポートされているため、特別なケースになります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-194">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="aae1f-195">修飾子の型コンバーターでは、コンマ (,) ではなくプラス記号 (+) が区切り記号として使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-195">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="aae1f-196">この変換では、"Ctrl + Alt" など、Microsoft Windows プログラミングでキーの組み合わせを表す従来の構文がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-196">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="aae1f-197">プロパティとイベント メンバー名の参照</span><span class="sxs-lookup"><span data-stu-id="aae1f-197">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="aae1f-198">属性を指定するときは、含む側のオブジェクト要素に対してインスタンス化した CLR 型のメンバーとして存在する任意のプロパティまたはイベントを参照できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-198">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="aae1f-199">または、含む側のオブジェクト要素とは無関係に、添付プロパティまたは添付イベントを参照できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-199">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="aae1f-200">(添付プロパティについては、次のセクションで説明します)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-200">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="aae1f-201"><*型名*>.<*イベント*> という部分修飾名を使用して、既定の名前空間でアクセスできる任意のオブジェクトから、任意のイベントを指定することもできます。この構文では、子要素からのイベント ルーティングをハンドラーで処理することが想定されているにも関わらず、親要素のメンバー テーブルにそのイベントがない場合の、ルーティング イベントに対するハンドラーのアタッチがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-201">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="aae1f-202">この構文は添付イベントの構文に似ていますが、ここでのイベントは添付イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-202">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="aae1f-203">この場合は、修飾名を持つイベントを参照しています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-203">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="aae1f-204">詳細については、「[ルーティング イベントの概要](routed-events-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-204">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="aae1f-205">一部のシナリオでは、属性の値として属性名ではなくプロパティ名が指定されることがあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-205">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="aae1f-206">そのプロパティ名には、<*所有者の型*>.<*依存プロパティ名*> の形式で指定されたプロパティなど、修飾子が含まれる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-206">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="aae1f-207">このシナリオは、XAML でスタイルやテンプレートを作成する場合によく見られます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-207">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="aae1f-208">属性値として指定されたプロパティ名の処理規則は異なり、設定されているプロパティの型、または特定の WPF サブシステムの動作によって管理されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-208">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="aae1f-209">詳細については、「[スタイルとテンプレート](../../../desktop-wpf/fundamentals/styles-templates-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-209">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="aae1f-210">プロパティ名のもう 1 つの使用方法は、属性値でプロパティとプロパティの関係が記述されている場合です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-210">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="aae1f-211">この機能は、データ バインディングとストーリーボード ターゲットに対して使用され、<xref:System.Windows.PropertyPath> クラスとその型コンバーターによって有効になります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-211">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="aae1f-212">参照セマンティクスの詳細については、「[PropertyPath の XAML 構文](propertypath-xaml-syntax.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-212">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="aae1f-213">プロパティ要素の構文</span><span class="sxs-lookup"><span data-stu-id="aae1f-213">Property Element Syntax</span></span>  
 <span data-ttu-id="aae1f-214">"*プロパティ要素の構文*" は、要素の基本的な XML 構文規則とは少し異なる構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-214">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="aae1f-215">XML では、属性の値は事実上は文字列であり、唯一可能なバリエーションは、使用される文字列エンコード形式です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-215">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="aae1f-216">XAML では、プロパティの値として他のオブジェクト要素を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-216">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="aae1f-217">この機能は、プロパティ要素の構文によって有効になります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-217">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="aae1f-218">プロパティは、要素タグ内の属性として指定されるのではなく、<*要素型名*>.<*プロパティ名*> という形式の開始要素タグを使用して指定され、プロパティの値がその中で指定されて、プロパティ要素が閉じられます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-218">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="aae1f-219">具体的には、構文は左山かっこ (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>) で始まります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-219">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="aae1f-220">属性構文と同様に、そのプロパティは、指定された型の宣言されたパブリック メンバー内に存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="aae1f-221">プロパティに割り当てられる値は、プロパティ要素内に格納されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="aae1f-222">プロパティ要素の構文では値として指定されたオブジェクトを処理することが想定されているため、通常、値は 1 つ以上のオブジェクト要素として指定します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="aae1f-223">最後に、同じ <*要素型名*>.<*プロパティ名*> の組み合わせを指定する同等の終了タグを指定し、適切な入れ子および他の要素タグとのバランスにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="aae1f-224">たとえば、次に示すのは、<xref:System.Windows.Controls.Button> の <xref:System.Windows.FrameworkElement.ContextMenu%2A> プロパティに対するプロパティ要素の構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="aae1f-225">また、指定されるプロパティの型が <xref:System.String> などのプリミティブ値の型である場合、または名前が指定された列挙型である場合は、プロパティ要素内の値を内部テキストとして指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="aae1f-226">これらの 2 つの使用方法は、いずれの場合もさらに単純な属性構文を使用できるため、あまり一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="aae1f-227">文字列でプロパティ要素を指定する 1 つのシナリオは、XAML コンテンツ プロパティではなくても、UI テキストの表現に使用され、ラインフィードなどの特定の空白文字要素をその UI テキストで表示する必要があるプロパティの場合です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="aae1f-228">属性の構文では改行を保持できませんが、プロパティ要素の構文では、重要な空白の保持がアクティブになっている場合は保持できます (詳細については、「[XAML での空白の処理](../../../desktop-wpf/xaml-services/white-space-processing.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="aae1f-229">もう 1 つのシナリオは、[x:Uid ディレクティブ](../../../desktop-wpf/xaml-services/xuid-directive.md)をプロパティ要素に適用し、その中の値を、WPF 出力 BAML または他の手法でローカライズする必要がある値としてマークできるようにする場合です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="aae1f-230">プロパティ要素は、WPF 論理ツリーでは表されません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="aae1f-231">プロパティ要素は、プロパティを設定するための特定の構文であり、その基になるインスタンスまたはオブジェクトがある要素ではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="aae1f-232">(論理ツリーの概念の詳細については、「[WPF のツリー](trees-in-wpf.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="aae1f-233">属性とプロパティ要素の両方の構文がサポートされているプロパティの場合は、通常、2 つの構文は同じ結果になりますが、空白文字の処理などの微妙な点は構文によって多少異なります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="aae1f-234">コレクションの構文</span><span class="sxs-lookup"><span data-stu-id="aae1f-234">Collection Syntax</span></span>  
 <span data-ttu-id="aae1f-235">XAML の仕様では、値の型がコレクションであるプロパティを XAML プロセッサの実装で識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="aae1f-236">.NET での一般的な XAML プロセッサの実装は、マネージド コードと CLR に基づいており、次のいずれかを使用してコレクション型を識別します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="aae1f-237">型で <xref:System.Collections.IList> が実装されている。</span><span class="sxs-lookup"><span data-stu-id="aae1f-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="aae1f-238">型で <xref:System.Collections.IDictionary> が実装されている。</span><span class="sxs-lookup"><span data-stu-id="aae1f-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="aae1f-239">型が <xref:System.Array> から派生している (XAML での配列の詳細については、「[x:Array のマークアップ拡張機能](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="aae1f-240">プロパティの型がコレクションである場合、推論されるコレクション型を、マークアップでオブジェクト要素として指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="aae1f-241">代わりに、コレクションの項目になることが予想される要素を、プロパティ要素の 1 つ以上の子要素として指定します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="aae1f-242">そのような各項目は、読み込み中にオブジェクトに対して評価され、暗黙的なコレクションの `Add` メソッドを呼び出すことによってコレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="aae1f-243">たとえば、<xref:System.Windows.Style> の <xref:System.Windows.Style.Triggers%2A> プロパティは特殊なコレクション型 <xref:System.Windows.TriggerCollection> になり、その型では <xref:System.Collections.IList> が実装されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="aae1f-244">マークアップで <xref:System.Windows.TriggerCollection> オブジェクト要素をインスタンス化する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="aae1f-245">代わりに、1 つ以上の <xref:System.Windows.Trigger> 項目を `Style.Triggers` プロパティ要素内の要素として指定します。ここで、<xref:System.Windows.Trigger> (または派生クラス) は、厳密に型指定された暗黙の <xref:System.Windows.TriggerCollection> に対する項目型として想定される型です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="aae1f-246">プロパティは、コレクション型と、その型および派生型に対する XAML コンテンツ プロパティの両方にすることができます。詳細については、このトピックの次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="aae1f-247">暗黙的なコレクション要素では、マークアップに要素として出現しない場合でも、論理ツリー表現にメンバーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="aae1f-248">通常、親の型のコンストラクターでは、そのプロパティの 1 つであるコレクションのインスタンス化が実行され、初期状態が空のコレクションがオブジェクト ツリーの一部になります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="aae1f-249">リストとディクショナリのジェネリック インターフェイス (<xref:System.Collections.Generic.IList%601> および <xref:System.Collections.Generic.IDictionary%602>) は、コレクションの検出に対してはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="aae1f-250">ただし、<xref:System.Collections.Generic.List%601> を基底クラスとして使用するか (<xref:System.Collections.IList> が直接実装されているため)、<xref:System.Collections.Generic.Dictionary%602> を基底クラスとして使用すること (<xref:System.Collections.IDictionary> が直接実装されているため) ができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="aae1f-251">コレクション型に関する .NET のリファレンス ページでは、コレクションのオブジェクト要素を意図的に省略したこの構文が、XAML 構文のセクションで暗黙のコレクション構文として示されていることがあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="aae1f-252">ルート要素を除き、別の要素の子要素として入れ子になっている XAML ファイル内のすべてのオブジェクト要素は、実際には、その親要素の暗黙的なコレクション プロパティのメンバー、または親要素の XAML コンテンツ プロパティの値を指定する要素の、どちらか一方または両方です (XAML コンテンツ プロパティについては、次のセクションで説明します)。</span><span class="sxs-lookup"><span data-stu-id="aae1f-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="aae1f-253">つまり、マークアップ ページでの親要素と子要素の関係は、実際には、ルートに 1 つのオブジェクトがあり、ルートの下にあるすべてのオブジェクト要素は、親のプロパティ値を提供する単一のインスタンスであるか、または親のコレクション型プロパティ値でもあるコレクション内の項目の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="aae1f-254">この単一ルートの概念は XML に共通しており、多くの場合、<xref:System.Windows.Markup.XamlReader.Load%2A> などの XAML を読み込む API の動作で強化されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="aae1f-255">次に示すのは、明示的に指定されているコレクション (<xref:System.Windows.Media.GradientStopCollection>) に対するオブジェクト要素の構文の例です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="aae1f-256">コレクションを明示的に宣言することが常に可能なわけではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="aae1f-257">たとえば、前に示した <xref:System.Windows.Style.Triggers%2A> の例で <xref:System.Windows.TriggerCollection> を明示的に宣言しようとすると、失敗します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="aae1f-258">コレクションを明示的に宣言するには、コレクション クラスでパラメーターなしのコンストラクターがサポートされていて、<xref:System.Windows.TriggerCollection> にパラメーターなしのコンストラクターが存在していない必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="aae1f-259">XAML コンテンツのプロパティ</span><span class="sxs-lookup"><span data-stu-id="aae1f-259">XAML Content Properties</span></span>  
 <span data-ttu-id="aae1f-260">XAML コンテンツの構文は、クラス宣言の一部として <xref:System.Windows.Markup.ContentPropertyAttribute> が指定されているクラスでのみ有効な構文です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="aae1f-261"><xref:System.Windows.Markup.ContentPropertyAttribute> では、その型の要素 (派生クラスを含む) に対するコンテンツ プロパティであるプロパティ名が参照されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="aae1f-262">XAML プロセッサによって処理される場合、オブジェクト要素の開始タグと終了タグの間にある子要素または内部テキストは、そのオブジェクトの XAML コンテンツ プロパティの値として割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="aae1f-263">コンテンツ プロパティに対して明示的なプロパティ要素を指定することは許可されていますが、一般に、.NET リファレンスの XAML 構文のセクションでは、この使用方法は示されていません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="aae1f-264">明示的で詳細な手法は、マークアップのわかりやすさやマークアップのスタイルに関して場合によっては価値がありますが、通常、コンテンツ プロパティの目的は、直感的に親子として関連付けられる要素を直接入れ子にできるように、マークアップを効率化することです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="aae1f-265">要素の他のプロパティに対するプロパティ要素タグは、XAML 言語の厳密な定義では "コンテンツ" として割り当てられません。これらは、XAML パーサーの処理順序でそれより前に処理され、"コンテンツ" とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="aae1f-266">XAML コンテンツ プロパティの値は連続している必要がある</span><span class="sxs-lookup"><span data-stu-id="aae1f-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="aae1f-267">XAML コンテンツ プロパティの値は、そのオブジェクト要素の他のプロパティ要素の完全に前または完全に後のいずれかに指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="aae1f-268">これは、XAML コンテンツ プロパティの値が文字列として指定されているか、または 1 つ以上のオブジェクトとして指定されているに関わらず当てはまります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="aae1f-269">たとえば、次のようなマークアップは解析されません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="aae1f-270">コンテンツ プロパティのプロパティ要素構文を使用してこの構文が明示的に作成されている場合、コンテンツ プロパティが 2 回設定されるため、これは基本的に無効です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="aae1f-271">同じように無効な例は、コンテンツ プロパティがコレクションであり、子要素とプロパティ要素が混在している場合です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="aae1f-272">コンテンツ プロパティとコレクション構文の組み合わせ</span><span class="sxs-lookup"><span data-stu-id="aae1f-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="aae1f-273">複数のオブジェクト要素をコンテンツとして受け入れるには、コンテンツ プロパティの型が明示的なコレクション型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="aae1f-274">コレクション型に対するプロパティ要素の構文と同様に、XAML プロセッサではコレクション型である型を識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="aae1f-275">要素に XAML コンテンツ プロパティがあり、XAML コンテンツ プロパティの型がコレクションである場合は、暗黙的なコレクション型をオブジェクト要素としてマークアップで指定する必要はなく、XAML コンテンツ プロパティをプロパティ要素として指定する必要もありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="aae1f-276">そのため、マークアップの明白なコンテンツ モデルでは、複数の子要素をコンテンツとして割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="aae1f-277"><xref:System.Windows.Controls.Panel> 派生クラスのコンテンツ構文を次に示します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="aae1f-278">すべての <xref:System.Windows.Controls.Panel> 派生クラスでは、XAML コンテンツ プロパティは <xref:System.Windows.Controls.Panel.Children%2A> として設定され、これには <xref:System.Windows.Controls.UIElementCollection> 型の値が必要です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="aae1f-279">マークアップには <xref:System.Windows.Controls.Panel.Children%2A> のプロパティ要素も <xref:System.Windows.Controls.UIElementCollection> の要素も必要ないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="aae1f-280">これは XAML の設計機能であり、これにより、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] を定義する再帰的包含要素が、プロパティ要素タグやコレクション オブジェクトを介在させることなく、直接的な親子要素関係を持つ入れ子になった要素のツリーとして表現されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="aae1f-281">実際には、設計上、<xref:System.Windows.Controls.UIElementCollection> をマークアップでオブジェクト要素として明示的に指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="aae1f-282">唯一の用途が暗黙のコレクションである <xref:System.Windows.Controls.UIElementCollection> では、パラメーターなしのパブリック コンストラクターは公開されず、オブジェクト要素としてインスタンス化することはできません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="aae1f-283">コンテンツ プロパティがあるオブジェクトでのプロパティ要素とオブジェクト要素の混合</span><span class="sxs-lookup"><span data-stu-id="aae1f-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="aae1f-284">XAML の仕様では、オブジェクト要素内の XAML コンテンツ プロパティを格納するために使用されるオブジェクト要素は連続している必要があり、混合されていてはならない、ということを XAML プロセッサで適用できることが宣言されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="aae1f-285">プロパティ要素とコンテンツの混合に対するこの制限は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の XAML プロセッサによって適用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="aae1f-286">オブジェクト要素内の最初の即時マークアップとして、子オブジェクト要素を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="aae1f-287">その後、プロパティ要素を導入できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-287">Then you can introduce property elements.</span></span> <span data-ttu-id="aae1f-288">または、1 つ以上のプロパティ要素を指定し、次にコンテンツを指定し、さらにプロパティ要素を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="aae1f-289">ただし、コンテンツの後でプロパティ要素を指定したら、それ以上コンテンツを指定することはできず、追加できるのはプロパティ要素だけです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="aae1f-290">このコンテンツとプロパティ要素の順序に関する要件は、コンテンツとして使用される内部テキストには適用されません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="aae1f-291">ただし、プロパティ要素と内部テキストが混在している場合、大きな空白をマークアップで視覚的に検出するのは困難であるため、内部テキストを連続させるのは、やはり適切なマークアップ スタイルです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="aae1f-292">XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="aae1f-292">XAML Namespaces</span></span>  
 <span data-ttu-id="aae1f-293">これまでの構文の例では、既定の XAML 名前空間以外の XAML 名前空間は指定されていません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="aae1f-294">一般的な [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションでは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 名前空間が既定の XAML 名前空間として指定されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="aae1f-295">既定の XAML 名前空間以外の XAML 名前空間を指定した場合でも、同様の構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="aae1f-296">ただし、その場合は、既定の XAML 名前空間内でアクセスできないクラスの名前を指定するすべての場所で、そのクラス名の前に、対応する CLR 名前空間にマップされる XAML 名前空間のプレフィックスを付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="aae1f-297">たとえば、`<custom:Example/>` は、`Example` クラスのインスタンスをインスタンス化するためのオブジェクト要素構文です。そのクラス (および場合によっては、バッキング型を含む外部アセンブリ情報) を含む CLR 名前空間は、これより前に `custom` プレフィックスにマップされています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="aae1f-298">XAML 名前空間の詳細については、「[XAML 名前空間および WPF XAML の名前空間の割り当て](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="aae1f-299">マークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="aae1f-299">Markup Extensions</span></span>  
 <span data-ttu-id="aae1f-300">XAML で定義されているマークアップ拡張のプログラミング エンティティを使用すると、文字列属性値またはオブジェクト要素の通常の XAML プロセッサ処理をエスケープして、処理をバッキング クラスに延期することができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="aae1f-301">属性構文を使用するときに XAML プロセッサに対してマークアップ拡張を示す文字は左中かっこ ({) で、その後に右中かっこ (}) 以外の任意の文字が続きます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="aae1f-302">左中かっこの後の最初の文字列では、特定の拡張機能の動作を提供するクラスを参照する必要があります。部分文字列 "Extension" が真のクラス名の一部である場合、参照ではその部分文字列を省略できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="aae1f-303">その後には 1 つのスペースを使用でき、それ以降は、右中かっこが検出されるまで、各文字が拡張機能の実装により入力として使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="aae1f-304">.NET XAML の実装では、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] および他のフレームワークやテクノロジによってサポートされているすべてのマークアップ拡張の基底として、<xref:System.Windows.Markup.MarkupExtension> 抽象クラスが使用されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="aae1f-305">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] で明示的に実装されているマークアップ拡張の目的は、多くの場合、他の既存のオブジェクトを参照する手段を提供すること、または実行時に評価されるオブジェクトへの遅延参照を行うことです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="aae1f-306">たとえば、特定のプロパティが通常受け取る値の代わりに `{Binding}` マークアップ拡張を指定することにより、簡単な WPF データ バインディングが実現されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="aae1f-307">WPF マークアップ拡張の多くでは、通常は属性構文を使用できない場所で、プロパティに対して属性構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="aae1f-308">たとえば、<xref:System.Windows.Style> オブジェクトは、入れ子になった一連のオブジェクトとプロパティが含まれる比較的複雑な型です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="aae1f-309">WPF のスタイルは、通常、<xref:System.Windows.ResourceDictionary> のリソースとして定義された後、リソースを要求する 2 つの WPF マークアップ拡張のいずれかを使用して参照されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="aae1f-310">マークアップ拡張では、プロパティ値の評価がリソース参照まで延期され、次の例に示すように、属性構文で <xref:System.Windows.Style> 型を使用して <xref:System.Windows.FrameworkElement.Style%2A> プロパティの値を提供できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="aae1f-311">ここで、`StaticResource` は、マークアップ拡張の実装を提供する <xref:System.Windows.StaticResourceExtension> クラスを示します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="aae1f-312">次の文字列 `MyStyle` は、既定以外の <xref:System.Windows.StaticResourceExtension> コンストラクターに対する入力として使用されます。この場合、拡張文字列から取得されるパラメーターでは、要求される <xref:System.Windows.ResourceKey> が宣言されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="aae1f-313">`MyStyle` は、リソースとして定義されている <xref:System.Windows.Style> の [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) 値であると想定されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="aae1f-314">[StaticResource マークアップ拡張](staticresource-markup-extension.md)を使用すると、読み込み時に静的リソース参照ロジックを使用して、<xref:System.Windows.Style> プロパティ値を提供するためにリソースを使用することが要求されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="aae1f-315">マークアップ拡張機能の詳細については、 「[マークアップ拡張機能と WPF XAML](markup-extensions-and-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="aae1f-316">一般的な .NET XAML の実装で有効になるマークアップ拡張と他の XAML プログラミング機能のリファレンスについては、「[XAML 名前空間 (x:) 言語機能](../../../desktop-wpf/xaml-services/namespace-language-features.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="aae1f-317">WPF 固有のマークアップ拡張については、「[WPF XAML 拡張機能](wpf-xaml-extensions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="aae1f-318">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="aae1f-318">Attached Properties</span></span>  
 <span data-ttu-id="aae1f-319">添付プロパティは XAML で導入されたプログラミング概念であり、プロパティを特定の型で所有および定義しながら、任意の要素の属性またはプロパティ要素として設定できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="aae1f-320">添付プロパティで想定されている主なシナリオは、すべての要素で広範にオブジェクト モデルを共有する必要なしに、マークアップ構造内の子要素で、親要素に情報を報告できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="aae1f-321">逆に、親要素で添付プロパティを使用すると、子要素に情報を報告できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="aae1f-322">添付プロパティの目的と、独自の添付プロパティを作成する方法の詳細については、「[添付プロパティの概要](attached-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="aae1f-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="aae1f-323">添付プロパティで使用する構文は、<*型名*>.<*プロパティ名*> の組み合わせをやはり指定する点では、プロパティ要素の構文と一見似ています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="aae1f-324">次の 2 つの重要な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="aae1f-325">属性構文を使用して添付プロパティを設定する場合でも、<*型名*>.<*プロパティ名*> の組み合わせを使用できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="aae1f-326">属性構文でプロパティ名を修飾する必要があるのは、添付プロパティの場合だけです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="aae1f-327">プロパティ要素構文を添付プロパティに対して使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="aae1f-328">ただし、一般的なプロパティ要素構文で指定する <*型名*> は、プロパティ要素が含まれるオブジェクト要素です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="aae1f-329">添付プロパティを参照している場合の <*型名*> は、添付プロパティが定義されているクラスであり、それを含んでいるオブジェクト要素ではありません。</span><span class="sxs-lookup"><span data-stu-id="aae1f-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="aae1f-330">アタッチされるイベント</span><span class="sxs-lookup"><span data-stu-id="aae1f-330">Attached Events</span></span>  
 <span data-ttu-id="aae1f-331">添付イベントは、XAML で導入されたもう 1 つのプログラミング概念であり、特定の型でイベントを定義しながら、任意のオブジェクト要素にハンドラーを添付できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="aae1f-332">WOF の実装では、多くの場合、添付イベントが定義される型は、サービスが定義されている静的な型であり、それらの添付イベントは、サービスを公開する型のルーティング イベント エイリアスによって公開されることがあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="aae1f-333">添付イベントのハンドラーは、属性の構文によって指定されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="aae1f-334">添付イベントと同様に、属性構文も添付イベントで <*型名*>.<*イベント名*> を使用できるように拡張されています。ここで、<*型名*> は添付イベントのインフラストラクチャに対して `Add` および `Remove` イベント ハンドラー アクセサーを提供するクラスであり、<*イベント名*> はイベントの名前です。</span><span class="sxs-lookup"><span data-stu-id="aae1f-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="aae1f-335">XAML ルート要素の構造</span><span class="sxs-lookup"><span data-stu-id="aae1f-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="aae1f-336">次の表は、一般的な XAML ルート要素の内容です。ルート要素の特定の属性が示されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="aae1f-337">ルート要素のオブジェクト要素の開始</span><span class="sxs-lookup"><span data-stu-id="aae1f-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="aae1f-338">既定の ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="aae1f-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="aae1f-339">XAML 言語の XAML 名前空間</span><span class="sxs-lookup"><span data-stu-id="aae1f-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="aae1f-340">部分クラスに対して定義されているコードビハインドにマークアップを接続する部分クラスの宣言</span><span class="sxs-lookup"><span data-stu-id="aae1f-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="aae1f-341">ルートのオブジェクト要素の終了。</span><span class="sxs-lookup"><span data-stu-id="aae1f-341">End of object element for the root.</span></span> <span data-ttu-id="aae1f-342">要素に子要素が含まれているため、オブジェクトはまだ閉じられません</span><span class="sxs-lookup"><span data-stu-id="aae1f-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="aae1f-343">XAML のオプションの使用方法と推奨されない使用方法</span><span class="sxs-lookup"><span data-stu-id="aae1f-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="aae1f-344">以下のセクションで説明する XAML の使用方法は、XAML プロセッサによって技術的にはサポートされていますが、冗長さや他の審美的問題が発生し、XAML ソースが含まれるアプリケーションを開発するときに、ユーザーが XAML ファイルを読みにくくなります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="aae1f-345">プロパティ要素のオプションの使用方法</span><span class="sxs-lookup"><span data-stu-id="aae1f-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="aae1f-346">プロパティ要素のオプションの使用方法には、XAML プロセッサによって暗黙的に考慮される要素コンテンツ プロパティの明示的な記述が含まれます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="aae1f-347">たとえば、<xref:System.Windows.Controls.Menu> のコンテンツを宣言する場合、XAML プロセッサの暗黙の動作 (<xref:System.Windows.Controls.Menu> のすべての子要素は <xref:System.Windows.Controls.MenuItem> である必要があり、<xref:System.Windows.Controls.ItemsControl.Items%2A> コレクションに配置される) を使用する代わりに、<xref:System.Windows.Controls.Menu> の <xref:System.Windows.Controls.ItemsControl.Items%2A> コレクションを `<Menu.Items>` プロパティ要素タグとして明示的に宣言し、各 <xref:System.Windows.Controls.MenuItem> を `<Menu.Items>` 内に配置することができます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="aae1f-348">このオプションの使用方法は、場合によっては、マークアップで表されるオブジェクト構造を視覚的に明確にするのに、役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="aae1f-349">または、場合によっては、プロパティ要素を明示的に使用すると、属性値内の入れ子になったマークアップ拡張のように、技術的には機能するものの、視覚的にはわかりにくいマークアップを回避できます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="aae1f-350">typeName.memberName の完全修飾属性</span><span class="sxs-lookup"><span data-stu-id="aae1f-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="aae1f-351">属性の <*型名*>.<*メンバー名*> の形式は、実際には単なるルーティング イベントのケースより汎用的に機能します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="aae1f-352">ただし、マークアップのスタイルと読みやすさだけが理由の場合は、他の状況では、その形式は過剰であり、回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="aae1f-353">次の例の <xref:System.Windows.Controls.Control.Background%2A> 属性に対する 3 つの参照は、まったく同じになります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="aae1f-354">`Button.Background` は、<xref:System.Windows.Controls.Button> でのそのプロパティに対する修飾された参照が正常であり (<xref:System.Windows.Controls.Control.Background%2A> は Control から継承されています)、<xref:System.Windows.Controls.Button> はオブジェクト要素または基底クラスのクラスであるため、機能します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="aae1f-355">`Control.Background` は、<xref:System.Windows.Controls.Control> クラスで実際に <xref:System.Windows.Controls.Control.Background%2A> が定義されていて、<xref:System.Windows.Controls.Control> は <xref:System.Windows.Controls.Button> 基底クラスであるため、機能します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="aae1f-356">ただし、その次の <*型名*>.<*メンバー名*> の形式の例は機能せず、そのため次のようにコメントされています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="aae1f-357"><xref:System.Windows.Controls.Label> は <xref:System.Windows.Controls.Control> のもう 1 つの派生クラスであり、<xref:System.Windows.Controls.Label> オブジェクト要素内で `Label.Background` を指定してあれば、この使用方法は動作したはずです。</span><span class="sxs-lookup"><span data-stu-id="aae1f-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="aae1f-358">しかし、<xref:System.Windows.Controls.Label> は <xref:System.Windows.Controls.Button> のクラスまたは基底クラスではないため、指定された XAML プロセッサの動作では、`Label.Background` は添付プロパティとして処理されます。</span><span class="sxs-lookup"><span data-stu-id="aae1f-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="aae1f-359">`Label.Background` は使用可能な添付プロパティではないため、この使用方法は失敗します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="aae1f-360">baseTypeName.memberName プロパティ要素</span><span class="sxs-lookup"><span data-stu-id="aae1f-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="aae1f-361">属性構文に対して <*型名*>.<*メンバー名*> の形式が動作するのと同じように、プロパティ要素構文に対しては <*基底型名*>.<*メンバー名*> という構文が機能します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="aae1f-362">たとえば、次のような構文は機能します。</span><span class="sxs-lookup"><span data-stu-id="aae1f-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="aae1f-363">ここでは、プロパティ要素は `Button` に含まれていますが、`Control.Background` として指定されています。</span><span class="sxs-lookup"><span data-stu-id="aae1f-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="aae1f-364">ただし、属性に対する <*型名*>.<*メンバー名*> の形式と同じように、<*基底型名*>.<*メンバー名*> はマークアップのスタイルとして不適切であるため、回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="aae1f-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aae1f-365">関連項目</span><span class="sxs-lookup"><span data-stu-id="aae1f-365">See also</span></span>

- [<span data-ttu-id="aae1f-366">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="aae1f-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="aae1f-367">XAML 名前空間 (x:) 言語機能</span><span class="sxs-lookup"><span data-stu-id="aae1f-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="aae1f-368">WPF XAML 拡張機能</span><span class="sxs-lookup"><span data-stu-id="aae1f-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="aae1f-369">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="aae1f-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="aae1f-370">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="aae1f-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="aae1f-371">WPF における XAML とカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="aae1f-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
