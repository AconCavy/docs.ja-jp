---
title: ツリー
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: d4b17c34fb33f73ca1c173bebc8f94ddac5b1942
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2020
ms.locfileid: "76746567"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="d6cd6-102">WPF のツリー</span><span class="sxs-lookup"><span data-stu-id="d6cd6-102">Trees in WPF</span></span>
<span data-ttu-id="d6cd6-103">多くのテクノロジでは、要素とコンポーネントはツリー構造で構成されており、開発者はツリー内のオブジェクトノードを直接操作して、アプリケーションのレンダリングや動作に影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> <span data-ttu-id="d6cd6-104">また [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] は、複数のツリー構造のメタファを使用して、プログラム要素間の関係を定義します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-104">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="d6cd6-105">ほとんどの場合、WPF 開発者は、オブジェクトツリーの比喩について概念的に考えると同時に、コードでアプリケーションを作成したり、アプリケーションの一部を XAML で定義したりできますが、特定の API を呼び出すか、特定のマークアップを使用して汎用的なものではありません。などのオブジェクトツリー操作 API は、XML DOM でを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="d6cd6-106">WPF は、ツリーの比喩ビュー、<xref:System.Windows.LogicalTreeHelper> および <xref:System.Windows.Media.VisualTreeHelper>を提供する2つのヘルパークラスを公開します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="d6cd6-107">これらの同じツリーが特定の主要な WPF 機能の動作を理解するのに役立ちます。そのため、ビジュアルツリーと論理ツリーは WPF ドキュメントでも使用されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="d6cd6-108">このトピックでは、ビジュアルツリーと論理ツリーが表す内容を定義し、そのようなツリーが全体的なオブジェクトツリーの概念とどのように関連しているかについて説明し、<xref:System.Windows.LogicalTreeHelper> と <xref:System.Windows.Media.VisualTreeHelper>を紹介します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a><span data-ttu-id="d6cd6-109">WPF のツリー</span><span class="sxs-lookup"><span data-stu-id="d6cd6-109">Trees in WPF</span></span>  
 <span data-ttu-id="d6cd6-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 内の最も完全なツリー構造は、オブジェクトツリーです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="d6cd6-111">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] でアプリケーションページを定義し、その後 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]を読み込むと、マークアップ内の要素の入れ子の関係に基づいてツリー構造が作成されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="d6cd6-112">アプリケーションまたはアプリケーションの一部をコードで定義した場合、特定のオブジェクトのコンテンツモデルを実装するプロパティのプロパティ値の割り当て方法に基づいて、ツリー構造が作成されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="d6cd6-113">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]には、2つの方法で、完全なオブジェクトツリーを概念化し、そのパブリック API (論理ツリーおよびビジュアルツリー) にレポートできます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="d6cd6-114">論理ツリーとビジュアルツリーの違いは必ずしも重要であるとは限りませんが、特定の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] サブシステムで問題が発生し、マークアップまたはコードで行った選択に影響することがあります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="d6cd6-115">論理ツリーまたはビジュアルツリーを直接操作しているわけではありませんが、ツリーの相互作用の概念を理解することは、WPF をテクノロジとして理解するうえで役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="d6cd6-116">WPF は、ある種のツリーの比喩と考えることも、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]でのプロパティの継承とイベントルーティングのしくみを理解する上で重要です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d6cd6-117">オブジェクトツリーは実際の API よりも概念が多いため、概念を考えるもう1つの方法はオブジェクトグラフです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="d6cd6-118">実際には、ツリーの比喩が分割される、実行時のオブジェクト間のリレーションシップがあります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="d6cd6-119">それにもかかわらず、特に XAML で定義された UI の場合、ツリーの比喩は、この一般的な概念を参照するときにほとんどの WPF ドキュメントがオブジェクトツリーという用語を使用することに関係しています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a><span data-ttu-id="d6cd6-120">論理ツリー</span><span class="sxs-lookup"><span data-stu-id="d6cd6-120">The Logical Tree</span></span>  
 <span data-ttu-id="d6cd6-121">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]では、これらの要素を返すオブジェクトのプロパティを設定することによって、UI 要素にコンテンツを追加します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="d6cd6-122">たとえば、<xref:System.Windows.Controls.ListBox> コントロールに項目を追加するには、<xref:System.Windows.Controls.ItemsControl.Items%2A> プロパティを操作します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="d6cd6-123">これにより、<xref:System.Windows.Controls.ItemsControl.Items%2A> プロパティ値である <xref:System.Windows.Controls.ItemCollection> に項目を配置します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="d6cd6-124">同様に、オブジェクトを <xref:System.Windows.Controls.DockPanel>に追加するには、その <xref:System.Windows.Controls.Panel.Children%2A> プロパティ値を操作します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="d6cd6-125">ここでは、<xref:System.Windows.Controls.UIElementCollection>にオブジェクトを追加します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="d6cd6-126">コード例については、「[方法: 要素を動的に追加する](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-126">For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).</span></span>  
  
 <span data-ttu-id="d6cd6-127">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]では、<xref:System.Windows.Controls.DockPanel>内の <xref:System.Windows.Controls.ListBox> またはコントロールなどの UI 要素にリスト項目を配置するときに、次の例のように、明示的または暗黙的に <xref:System.Windows.Controls.ItemsControl.Items%2A> および <xref:System.Windows.Controls.Panel.Children%2A> のプロパティも使用します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="d6cd6-128">この XAML をドキュメントオブジェクトモデルの下で XML として処理した場合、(有効な) 暗黙的にコメントアウトされたタグを含めると、結果の XML DOM ツリーには `<ListBox.Items>` とその他の暗黙的な項目の要素が含まれます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="d6cd6-129">ただし、XAML では、マークアップを読み取ってオブジェクトに書き込むときに、このような処理は行われません。結果として得られるオブジェクトグラフには、`ListBox.Items`は含まれません。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="d6cd6-130">ただし、<xref:System.Windows.Controls.ItemCollection>を含む `Items` という名前の <xref:System.Windows.Controls.ListBox> プロパティがあり、<xref:System.Windows.Controls.ListBox> XAML が処理されると <xref:System.Windows.Controls.ItemCollection> は初期化されますが、空になります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="d6cd6-131">次に、<xref:System.Windows.Controls.ListBox> のコンテンツとして存在する各子オブジェクト要素が、`ItemCollection.Add`のパーサー呼び出しによって <xref:System.Windows.Controls.ItemCollection> に追加されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="d6cd6-132">このように、XAML をオブジェクトツリーに処理する例では、作成されたオブジェクトツリーが基本的に論理ツリーであるという一見のように見えます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="d6cd6-133">ただし、論理ツリーは、XAML の暗黙的な構文項目が考慮されていない場合でも、実行時にアプリケーション UI に存在するオブジェクトグラフ全体ではありません。主な理由は、ビジュアルとテンプレートです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="d6cd6-134">たとえば、<xref:System.Windows.Controls.Button>について考えてみます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="d6cd6-135">論理ツリーは、<xref:System.Windows.Controls.Button> オブジェクトとその文字列 `Content`を報告します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="d6cd6-136">ただし、実行時のオブジェクトツリーには、このボタンが追加されています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="d6cd6-137">特に、特定の <xref:System.Windows.Controls.Button> コントロールテンプレートが適用されたため、ボタンは画面に表示されるだけです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="d6cd6-138">適用されたテンプレート <xref:System.Windows.Controls.Border> (表示されている UI からの入力イベントの処理、論理ツリーの読み取りなど) で論理ツリーを参照している場合でも、論理ツリー内ではそのビジュアルは報告されません。これは、実行時に論理ツリーを見ている場合でも同様です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="d6cd6-139">テンプレートビジュアルを検索するには、代わりにビジュアルツリーを調べる必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="d6cd6-140">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 構文を、作成されたオブジェクトグラフにマップする方法、および XAML で暗黙的な構文を使用する方法の詳細については、「 [Xaml 構文の詳細](xaml-syntax-in-detail.md)」または「 [xaml の概要 (WPF)](xaml-overview-wpf.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="d6cd6-141">論理ツリーの目的</span><span class="sxs-lookup"><span data-stu-id="d6cd6-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="d6cd6-142">論理ツリーは、コンテンツモデルが可能な子オブジェクトを簡単に反復処理できるようにし、コンテンツモデルを拡張できるようにするためのものです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="d6cd6-143">また、論理ツリーは、論理ツリー内のすべてのオブジェクトが読み込まれるときなど、特定の通知のためのフレームワークを提供します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="d6cd6-144">基本的に、論理ツリーは、フレームワークレベルでの実行時のオブジェクトグラフの近似値です。ビジュアルは除外されますが、独自の実行時アプリケーションの構成に対する多くのクエリ操作には適しています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="d6cd6-145">さらに、静的リソース参照と動的リソース参照の両方が解決されます。そのためには、最初に要求しているオブジェクトの <xref:System.Windows.FrameworkElement.Resources%2A> コレクションの論理ツリーを上方向に検索し、その後、論理ツリーを処理してから、そのキーを含む可能性のある <xref:System.Windows.ResourceDictionary>を含む別の `Resources` 値 (または <xref:System.Windows.FrameworkContentElement>) を <xref:System.Windows.FrameworkElement> 確認します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="d6cd6-146">論理ツリーは、論理ツリーとビジュアルツリーの両方が存在する場合に、リソース検索に使用されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="d6cd6-147">リソースディクショナリと参照の詳細については、「 [XAML リソース](../../../desktop-wpf/fundamentals/xaml-resources-define.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="d6cd6-148">論理ツリーの構成</span><span class="sxs-lookup"><span data-stu-id="d6cd6-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="d6cd6-149">論理ツリーは WPF フレームワークレベルで定義されます。これは、論理ツリー操作に最も関連する WPF 基本要素が <xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement>であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="d6cd6-150">ただし、実際に <xref:System.Windows.LogicalTreeHelper> API を使用しているかどうかを確認できるように、論理ツリーには <xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement>ないノードが含まれる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="d6cd6-151">たとえば、論理ツリーは、<xref:System.Windows.Controls.TextBlock>の <xref:System.Windows.Controls.TextBlock.Text%2A> 値 (文字列) を報告します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="d6cd6-152">論理ツリーの上書き</span><span class="sxs-lookup"><span data-stu-id="d6cd6-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="d6cd6-153">高度なコントロールの作成者は、一般的なオブジェクトまたはコンテンツモデルが論理ツリー内のオブジェクトを追加または削除する方法を定義するいくつかの Api をオーバーライドすることにより、論理ツリーをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-153">Advanced control authors can override the logical tree by overriding several APIs that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="d6cd6-154">論理ツリーを上書きする方法の例については、「[論理ツリーの上書き](how-to-override-the-logical-tree.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-154">For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a><span data-ttu-id="d6cd6-155">プロパティ値の継承</span><span class="sxs-lookup"><span data-stu-id="d6cd6-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="d6cd6-156">プロパティ値の継承は、ハイブリッドツリーを介して動作します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="d6cd6-157">プロパティの継承を有効にする <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> プロパティを含む実際のメタデータは、WPF フレームワークレベルの <xref:System.Windows.FrameworkPropertyMetadata> クラスです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="d6cd6-158">したがって、元の値を保持する親とその値を継承する子オブジェクトは両方とも <xref:System.Windows.FrameworkElement> か <xref:System.Windows.FrameworkContentElement>である必要があり、両方とも論理ツリーの一部である必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="d6cd6-159">ただし、プロパティの継承をサポートする既存の WPF プロパティについては、プロパティ値の継承は、論理ツリーに存在しない介在するオブジェクトを介して perpetuate できます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="d6cd6-160">これは主に、テンプレート要素で、テンプレート化されたインスタンスで設定されている継承されたプロパティ値を使用する場合、またはより高いレベルのページレベルの構成で、論理ツリー内で上位に設定する場合に関連します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="d6cd6-161">プロパティ値の継承をこのような境界を越えて一貫して機能させるには、継承プロパティを添付プロパティとして登録する必要があります。また、プロパティを使用してカスタム依存関係プロパティを定義する場合は、このパターンに従う必要があります。継承動作。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="d6cd6-162">プロパティの継承に使用される正確なツリーは、実行時でも、ヘルパークラスのユーティリティメソッドで完全には期待できません。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="d6cd6-163">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-163">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a><span data-ttu-id="d6cd6-164">ビジュアルツリー</span><span class="sxs-lookup"><span data-stu-id="d6cd6-164">The Visual Tree</span></span>  
 <span data-ttu-id="d6cd6-165">論理ツリーの概念に加えて、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]にビジュアルツリーの概念もあります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="d6cd6-166">ビジュアルツリーには、<xref:System.Windows.Media.Visual> 基底クラスによって表されるビジュアルオブジェクトの構造が記述されています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="d6cd6-167">コントロールのテンプレートを作成するときは、そのコントロールに適用されるビジュアルツリーを定義または再定義します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="d6cd6-168">ビジュアルツリーは、パフォーマンスと最適化の理由により、描画を低レベルで制御する開発者にとっても重要です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="d6cd6-169">従来の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションプログラミングの一部としてビジュアルツリーが公開されると、ルーティングイベントのイベントルートは、論理ツリーではなく、ほとんどの場合、ビジュアルツリーに沿って移動します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="d6cd6-170">このはらみのルーティングイベントの動作は、コントロールの作成者でない限り、すぐには表示されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="d6cd6-171">ビジュアルツリーを介してイベントをルーティングすると、ビジュアルレベルでコンポジションを実装するコントロールによって、イベントを処理したり、イベントセッターを作成したりできます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="d6cd6-172">ツリー、コンテンツ要素、およびコンテンツホスト</span><span class="sxs-lookup"><span data-stu-id="d6cd6-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="d6cd6-173">コンテンツ要素 (<xref:System.Windows.ContentElement>から派生したクラス) は、ビジュアルツリーの一部ではありません。これらは、<xref:System.Windows.Media.Visual> から継承せず、視覚表現も持ちません。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="d6cd6-174">UI に表示されるようにするには、<xref:System.Windows.ContentElement> を <xref:System.Windows.Media.Visual> と論理ツリーの両方の参加要素であるコンテンツホストでホストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="d6cd6-175">通常、このようなオブジェクトは <xref:System.Windows.FrameworkElement>です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="d6cd6-176">コンテンツホストがコンテンツの "ブラウザー" のようなものであり、ホストが制御する画面領域内にそのコンテンツを表示する方法を選択するという概念があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="d6cd6-177">コンテンツがホストされている場合、ビジュアルツリーに通常関連付けられている特定のツリープロセスでコンテンツを参加させることができます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="d6cd6-178">一般に、<xref:System.Windows.FrameworkElement> ホストクラスには、ホストされているコンテンツが true ビジュアルツリーの一部ではない場合でも、ホストされている <xref:System.Windows.ContentElement> をコンテンツ論理ツリーのサブノードを介してイベントルートに追加する実装コードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="d6cd6-179">これは、<xref:System.Windows.ContentElement> がそれ自体以外の任意の要素にルーティングするルーティングイベントをソースに送信できるようにするために必要です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a><span data-ttu-id="d6cd6-180">ツリートラバーサル</span><span class="sxs-lookup"><span data-stu-id="d6cd6-180">Tree Traversal</span></span>  
 <span data-ttu-id="d6cd6-181"><xref:System.Windows.LogicalTreeHelper> クラスには、論理ツリートラバーサルの <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>、<xref:System.Windows.LogicalTreeHelper.GetParent%2A>、および <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> の各メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="d6cd6-182">ほとんどの場合、既存のコントロールの論理ツリーを走査する必要はありません。これらのコントロールは、ほとんどの場合、論理上の子要素を、`Add`、インデクサーなどのコレクションアクセスをサポートする専用のコレクションプロパティとして公開するためです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="d6cd6-183">ツリートラバーサルは、主に、<xref:System.Windows.Controls.Panel> <xref:System.Windows.Controls.ItemsControl> などの目的のコントロールパターンからの派生を選択せず、コレクションプロパティが既に定義されている場合や、独自のコレクションプロパティサポートを提供する場合に使用する、コントロールの作成者によって使用されるシナリオです。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="d6cd6-184">ビジュアルツリーでは、ビジュアルツリートラバーサル、<xref:System.Windows.Media.VisualTreeHelper>のヘルパークラスもサポートされています。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="d6cd6-185">ビジュアルツリーは、コントロール固有のプロパティによって簡単に公開されないため、プログラミングシナリオに必要な場合は、<xref:System.Windows.Media.VisualTreeHelper> クラスを使用してビジュアルツリーを走査することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="d6cd6-186">詳しくは、「[WPF グラフィックス レンダリングの概要](../graphics-multimedia/wpf-graphics-rendering-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-186">For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d6cd6-187">適用されているテンプレートのビジュアルツリーを調べることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="d6cd6-188">この手法を使用する場合は注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-188">You should be careful when using this technique.</span></span> <span data-ttu-id="d6cd6-189">テンプレートを定義するコントロールのビジュアルツリーを走査している場合でも、コントロールのコンシューマーはインスタンスの <xref:System.Windows.Controls.Control.Template%2A> プロパティを設定することによっていつでもテンプレートを変更できます。また、エンドユーザーは、システムテーマを変更することによって、適用されているテンプレートにも影響を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="d6cd6-190">"ツリー" としてのルーティングイベントのルート</span><span class="sxs-lookup"><span data-stu-id="d6cd6-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="d6cd6-191">前述のように、特定のルーティングイベントのルートは、ビジュアルおよび論理ツリー表現をハイブリッドにした、ツリーの1つの事前に定義されたパスに沿って移動します。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="d6cd6-192">イベントルートは、ルーティングイベントとバブルルーティングイベントのどちらであるかに応じて、ツリー内の上下方向に移動できます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="d6cd6-193">イベントルートの概念には、実際にルーティングするイベントを発生させずにイベントルートを "ウォーク" するために使用できるヘルパークラスが直接サポートされていません。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="d6cd6-194">ルート (<xref:System.Windows.EventRoute>) を表すクラスがありますが、そのクラスのメソッドは一般に内部でのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="d6cd6-195">リソースディクショナリとツリー</span><span class="sxs-lookup"><span data-stu-id="d6cd6-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="d6cd6-196">ページで定義されているすべての `Resources` のリソースディクショナリの参照は、基本的に論理ツリーになります。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="d6cd6-197">論理ツリーに含まれていないオブジェクトは、キー付きリソースを参照できますが、リソース参照シーケンスは、そのオブジェクトが論理ツリーに接続されているポイントから開始されます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="d6cd6-198">WPF では、論理ツリーノードだけが <xref:System.Windows.ResourceDictionary>を含む `Resources` プロパティを持つことができるため、<xref:System.Windows.ResourceDictionary>からキー付きリソースを検索するビジュアルツリーを走査する利点はありません。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="d6cd6-199">ただし、リソースルックアップは、直接の論理ツリーの範囲を超えて拡張することもできます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="d6cd6-200">アプリケーションマークアップの場合、リソースルックアップは、アプリケーションレベルのリソースディクショナリに続き、次に、静的なプロパティまたはキーとして参照されるテーマサポートとシステム値に進みます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="d6cd6-201">また、リソース参照が動的である場合は、テーマの論理ツリーの外側のシステム値を参照することもできます。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="d6cd6-202">リソースディクショナリと参照ロジックの詳細については、「 [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d6cd6-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d6cd6-203">関連項目</span><span class="sxs-lookup"><span data-stu-id="d6cd6-203">See also</span></span>

- [<span data-ttu-id="d6cd6-204">入力の概要</span><span class="sxs-lookup"><span data-stu-id="d6cd6-204">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="d6cd6-205">WPF グラフィックス レンダリングの概要</span><span class="sxs-lookup"><span data-stu-id="d6cd6-205">WPF Graphics Rendering Overview</span></span>](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [<span data-ttu-id="d6cd6-206">ルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="d6cd6-206">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="d6cd6-207">オブジェクト ツリーに存在しないオブジェクト要素の初期化</span><span class="sxs-lookup"><span data-stu-id="d6cd6-207">Initialization for Object Elements Not in an Object Tree</span></span>](initialization-for-object-elements-not-in-an-object-tree.md)
- [<span data-ttu-id="d6cd6-208">WPF アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="d6cd6-208">WPF Architecture</span></span>](wpf-architecture.md)
