---
title: WPF アーキテクチャ
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 2ec979240b8fead10522817b77eef23e29409411
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740695"
---
# <a name="wpf-architecture"></a><span data-ttu-id="10222-102">WPF アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="10222-102">WPF Architecture</span></span>
<span data-ttu-id="10222-103">このトピックでは、Windows Presentation Foundation (WPF) クラス階層のガイドツアーについて説明します。</span><span class="sxs-lookup"><span data-stu-id="10222-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="10222-104">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の主なサブシステムの大部分について説明し、それらの相互作用について説明します。</span><span class="sxs-lookup"><span data-stu-id="10222-104">It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact.</span></span> <span data-ttu-id="10222-105">また、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]のアーキテクトによって行われたいくつかの選択肢についても詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="10222-105">It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="10222-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="10222-106">System.Object</span></span>  
 <span data-ttu-id="10222-107">主要な [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] プログラミングモデルは、マネージコードを通じて公開されます。</span><span class="sxs-lookup"><span data-stu-id="10222-107">The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code.</span></span> <span data-ttu-id="10222-108">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の設計フェーズの初期段階では、システムのマネージコンポーネントとアンマネージコンポーネントの間に行を描画する場所について、いくつかの論争がありました。</span><span class="sxs-lookup"><span data-stu-id="10222-108">Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="10222-109">CLR には、開発の生産性と堅牢性を高めるさまざまな機能が用意されています (メモリ管理、エラー処理、共通型システムなどを含む) が、コストが発生します。</span><span class="sxs-lookup"><span data-stu-id="10222-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="10222-110">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の主要なコンポーネントを次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="10222-110">The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below.</span></span> <span data-ttu-id="10222-111">図の赤色のセクション (プレゼンテーションフレームワーク、プレゼンテーションコア、およびミルコア) は、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の主要なコード部分です。</span><span class="sxs-lookup"><span data-stu-id="10222-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="10222-112">これらのうちの1つだけがアンマネージコンポーネント–ミルコアです。</span><span class="sxs-lookup"><span data-stu-id="10222-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="10222-113">ミルコアは、DirectX との緊密な統合を可能にするためにアンマネージコードで記述されています。</span><span class="sxs-lookup"><span data-stu-id="10222-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="10222-114">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] のすべての表示は DirectX エンジンを介して行われるため、ハードウェアとソフトウェアを効率的にレンダリングできます。</span><span class="sxs-lookup"><span data-stu-id="10222-114">All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-115">メモリと実行を細かく制御する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="10222-115">also required fine control over memory and execution.</span></span> <span data-ttu-id="10222-116">密度の高い合成エンジンは、パフォーマンスに大きな影響を与えます。そのため、パフォーマンスを得るためには、CLR の多くの利点が必要です。</span><span class="sxs-lookup"><span data-stu-id="10222-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="10222-117">![.NET Framework 内の WPF の位置。](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="10222-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="10222-118">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] のマネージ部分とアンマネージ部分の間の通信については、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="10222-118">Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic.</span></span> <span data-ttu-id="10222-119">マネージプログラミングモデルの残りの部分を次に示します。</span><span class="sxs-lookup"><span data-stu-id="10222-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="10222-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="10222-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="10222-121">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] のほとんどのオブジェクトは <xref:System.Windows.Threading.DispatcherObject>から派生します。これは、同時実行とスレッド処理を行うための基本的な構造を提供します。</span><span class="sxs-lookup"><span data-stu-id="10222-121">Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-122">は、ディスパッチャーによって実装されるメッセージングシステムに基づいています。</span><span class="sxs-lookup"><span data-stu-id="10222-122">is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="10222-123">これは、使い慣れた [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] メッセージポンプとよく似ています。実際、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] ディスパッチャーは、スレッド間の呼び出しを実行するために User32.dll メッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="10222-123">This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="10222-124">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] での同時実行については、ディスパッチャーとスレッドアフィニティの2つの主要概念を理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="10222-124">There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="10222-125">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の設計フェーズでは、目標は実行の1つのスレッドに移動しましたが、非スレッド "関連付け済み" モデルに移行することでした。</span><span class="sxs-lookup"><span data-stu-id="10222-125">During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="10222-126">スレッドアフィニティは、コンポーネントが実行中のスレッドの id を使用して何らかの種類の状態を格納するときに発生します。</span><span class="sxs-lookup"><span data-stu-id="10222-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="10222-127">最も一般的な形式は、スレッドローカルストア (TLS) を使用して状態を格納することです。</span><span class="sxs-lookup"><span data-stu-id="10222-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="10222-128">スレッドアフィニティでは、実行の各論理スレッドが、オペレーティングシステムの1つの物理スレッドによって所有されている必要があります。これは、メモリを集中的に使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="10222-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="10222-129">最終的には、WPF のスレッドモデルは、スレッドアフィニティを使用したシングルスレッド実行の既存の User32.dll スレッドモデルと同期した状態に保たれます。</span><span class="sxs-lookup"><span data-stu-id="10222-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="10222-130">これの主な理由は相互運用性でした。 OLE 2.0、クリップボード、Internet Explorer はすべて、シングルスレッドアフィニティ (STA) の実行を必要とします。</span><span class="sxs-lookup"><span data-stu-id="10222-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="10222-131">STA スレッドを持つオブジェクトがある場合は、スレッド間で通信を行い、正しいスレッドであることを検証する方法が必要です。</span><span class="sxs-lookup"><span data-stu-id="10222-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="10222-132">ここでは、ディスパッチャーの役割があります。</span><span class="sxs-lookup"><span data-stu-id="10222-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="10222-133">ディスパッチャーは、優先順位の高い複数のキューを持つ基本的なメッセージディスパッチシステムです。</span><span class="sxs-lookup"><span data-stu-id="10222-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="10222-134">メッセージの例としては、未加工の入力通知 (マウス移動)、フレームワーク関数 (レイアウト)、ユーザーコマンド (このメソッドの実行) などがあります。</span><span class="sxs-lookup"><span data-stu-id="10222-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="10222-135"><xref:System.Windows.Threading.DispatcherObject>から派生することによって、STA の動作を持つ CLR オブジェクトを作成し、作成時にディスパッチャーへのポインターを与えます。</span><span class="sxs-lookup"><span data-stu-id="10222-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="10222-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="10222-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="10222-137">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の構築で使用される主要なアーキテクチャ思想の1つは、メソッドまたはイベントのプロパティを優先することでした。</span><span class="sxs-lookup"><span data-stu-id="10222-137">One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events.</span></span> <span data-ttu-id="10222-138">プロパティは宣言型であり、アクションではなく意図を簡単に指定できます。</span><span class="sxs-lookup"><span data-stu-id="10222-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="10222-139">また、ユーザーインターフェイスのコンテンツを表示するための、モデル駆動型またはデータ駆動型のシステムもサポートされています。</span><span class="sxs-lookup"><span data-stu-id="10222-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="10222-140">この哲学には、アプリケーションの動作をより適切に制御するために、バインドできるプロパティを作成することを意図した効果がありました。</span><span class="sxs-lookup"><span data-stu-id="10222-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="10222-141">プロパティによってより多くのシステムを使用するためには、CLR が提供するよりも豊富なプロパティシステムが必要でした。</span><span class="sxs-lookup"><span data-stu-id="10222-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="10222-142">この豊富な例として、変更通知があります。</span><span class="sxs-lookup"><span data-stu-id="10222-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="10222-143">双方向のバインドを有効にするには、変更通知をサポートするために、バインドの両側が必要です。</span><span class="sxs-lookup"><span data-stu-id="10222-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="10222-144">プロパティ値に関連付けられた動作を使用するには、プロパティ値が変更されたときに通知を受け取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="10222-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="10222-145">Microsoft .NET Framework には**INotifyPropertyChange**というインターフェイスがあります。これにより、オブジェクトは変更通知を発行できますが、これは省略可能です。</span><span class="sxs-lookup"><span data-stu-id="10222-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-146">には、<xref:System.Windows.DependencyObject> の型から派生した、豊富なプロパティシステムが用意されています。</span><span class="sxs-lookup"><span data-stu-id="10222-146">provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="10222-147">プロパティシステムは、プロパティ式間の依存関係を追跡し、依存関係が変更されたときにプロパティ値を自動的に再検証するという、本当に "依存関係" プロパティシステムです。</span><span class="sxs-lookup"><span data-stu-id="10222-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="10222-148">たとえば、を継承するプロパティ (<xref:System.Windows.Controls.Control.FontSize%2A>など) がある場合、その値を継承する要素の親でプロパティが変更されると、システムは自動的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="10222-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="10222-149">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] プロパティシステムの基礎は、プロパティ式の概念です。</span><span class="sxs-lookup"><span data-stu-id="10222-149">The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression.</span></span> <span data-ttu-id="10222-150">この [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の最初のリリースでは、プロパティ式システムが閉じられており、式はすべてフレームワークの一部として提供されています。</span><span class="sxs-lookup"><span data-stu-id="10222-150">In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="10222-151">式は、プロパティシステムがデータバインディング、スタイル設定、継承をハードコーディングしていなくても、フレームワーク内の後のレイヤーによって提供されるためです。</span><span class="sxs-lookup"><span data-stu-id="10222-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="10222-152">プロパティシステムでは、プロパティ値のスパースストレージも提供されます。</span><span class="sxs-lookup"><span data-stu-id="10222-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="10222-153">オブジェクトは多数のプロパティを持つことができ、ほとんどの値は既定の状態 (継承、スタイルによる設定など) であるため、オブジェクトのすべてのインスタンスで定義されているすべてのプロパティの完全な重みを持つ必要があるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="10222-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="10222-154">プロパティシステムの最後の新機能は、添付プロパティの概念です。</span><span class="sxs-lookup"><span data-stu-id="10222-154">The final new feature of the property system is the notion of attached properties.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-155">要素は、合成とコンポーネントの再利用の原則に基づいて構築されます。</span><span class="sxs-lookup"><span data-stu-id="10222-155">elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="10222-156">多くの場合、含まれている要素 (<xref:System.Windows.Controls.Grid> レイアウト要素など) は、その動作を制御するために、子要素の追加データを必要とします (行または列の情報など)。</span><span class="sxs-lookup"><span data-stu-id="10222-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="10222-157">これらのすべてのプロパティをすべての要素に関連付けるのではなく、すべてのオブジェクトで他のオブジェクトのプロパティ定義を提供できます。</span><span class="sxs-lookup"><span data-stu-id="10222-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="10222-158">これは、JavaScript の "expando" 機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="10222-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="10222-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="10222-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="10222-160">システムが定義されている場合、次の手順では画面にピクセルが描画されます。</span><span class="sxs-lookup"><span data-stu-id="10222-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="10222-161"><xref:System.Windows.Media.Visual> クラスは、ビジュアルオブジェクトのツリーを構築するためにを提供します。各オブジェクトは、必要に応じて、これらの命令 (クリッピング、変換など) のレンダリング方法に関する描画命令とメタデータを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="10222-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="10222-162"><xref:System.Windows.Media.Visual> は非常に軽量で柔軟性があるように設計されています。そのため、ほとんどの機能はパブリック API を公開せず、保護されたコールバック関数に大きく依存しています。</span><span class="sxs-lookup"><span data-stu-id="10222-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="10222-163"><xref:System.Windows.Media.Visual> は、実際には [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] コンポジションシステムへのエントリポイントです。</span><span class="sxs-lookup"><span data-stu-id="10222-163"><xref:System.Windows.Media.Visual> is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system.</span></span> <span data-ttu-id="10222-164"><xref:System.Windows.Media.Visual> は、マネージ API とアンマネージドミルコアの2つのサブシステム間の接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="10222-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-165">は、ミルコアによって管理されているアンマネージデータ構造を走査することによってデータを表示します。</span><span class="sxs-lookup"><span data-stu-id="10222-165">displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="10222-166">これらの構造体は、合成ノードと呼ばれ、各ノードでレンダリング命令を含む階層表示ツリーを表します。</span><span class="sxs-lookup"><span data-stu-id="10222-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="10222-167">次の図の右側に示されているこのツリーは、メッセージングプロトコルを使用してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="10222-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="10222-168">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]のプログラミング時には、このメッセージングプロトコルを使用して内部でコンポジションツリーに通信する <xref:System.Windows.Media.Visual> の要素と派生型を作成します。</span><span class="sxs-lookup"><span data-stu-id="10222-168">When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="10222-169">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 内の各 <xref:System.Windows.Media.Visual> は、1つ、1つ、または複数の合成ノードを作成できます。</span><span class="sxs-lookup"><span data-stu-id="10222-169">Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="10222-170">![Windows Presentation Foundation のビジュアルツリー。](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="10222-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="10222-171">ここで注目すべき非常に重要なアーキテクチャの詳細があります。ビジュアルのツリー全体と描画命令がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="10222-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="10222-172">グラフィックス用語では、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] は保持されたレンダリングシステムを使用します。</span><span class="sxs-lookup"><span data-stu-id="10222-172">In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system.</span></span> <span data-ttu-id="10222-173">これにより、ユーザーコードへのコールバックでコンポジションシステムがブロックされることなく、高いリフレッシュレートでシステムを再描画できます。</span><span class="sxs-lookup"><span data-stu-id="10222-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="10222-174">これにより、応答しないアプリケーションの外観を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="10222-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="10222-175">図には実際にはわかりませんが、実際にはシステムが合成を実行する方法も重要です。</span><span class="sxs-lookup"><span data-stu-id="10222-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="10222-176">User32.dll と GDI では、システムはイミディエイトモードのクリッピングシステムで動作します。</span><span class="sxs-lookup"><span data-stu-id="10222-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="10222-177">コンポーネントをレンダリングする必要がある場合、システムは、コンポーネントがピクセルに触れることができないクリッピングの範囲を確立し、そのボックス内のピクセルを描画するようにコンポーネントに要求します。</span><span class="sxs-lookup"><span data-stu-id="10222-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="10222-178">このシステムは、メモリの制約付きシステムで非常に適しています。影響を受けるコンポーネントに触れる必要があるのは、1つのピクセルの色に寄与する2つのコンポーネントがないためです。</span><span class="sxs-lookup"><span data-stu-id="10222-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-179">は、"塗装のアルゴリズム" の描画モデルを使用します。</span><span class="sxs-lookup"><span data-stu-id="10222-179">uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="10222-180">これは、各コンポーネントをクリッピングするのではなく、各コンポーネントが画面の前面に戻るように求められることを意味します。</span><span class="sxs-lookup"><span data-stu-id="10222-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="10222-181">これにより、各コンポーネントで前のコンポーネントの表示を描画できます。</span><span class="sxs-lookup"><span data-stu-id="10222-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="10222-182">このモデルの利点は、複雑で部分的に透明な図形を持つことができることです。</span><span class="sxs-lookup"><span data-stu-id="10222-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="10222-183">現在の最新のグラフィックスハードウェアでは、このモデルは比較的高速です (User32.dll/GDI が作成されたときには当てはまりません)。</span><span class="sxs-lookup"><span data-stu-id="10222-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="10222-184">前述のように、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の中核となる理念は、より宣言的な "プロパティ中心" のプログラミングモデルに移行することです。</span><span class="sxs-lookup"><span data-stu-id="10222-184">As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="10222-185">ビジュアルシステムでは、これがいくつかの興味深い場所に表示されます。</span><span class="sxs-lookup"><span data-stu-id="10222-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="10222-186">まず、保持モードグラフィックシステムについて考えてみると、これは本当に命令型の DrawLine/DrawLine 型モデルからデータ指向モデル (new Line ()/new Line ()) に移動します。</span><span class="sxs-lookup"><span data-stu-id="10222-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="10222-187">このデータドリブンレンダリングへの移行により、プロパティを使用して描画命令に対する複雑な操作を表すことができます。</span><span class="sxs-lookup"><span data-stu-id="10222-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="10222-188"><xref:System.Windows.Media.Drawing> から派生する型は、実際にはレンダリングのためのオブジェクトモデルです。</span><span class="sxs-lookup"><span data-stu-id="10222-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="10222-189">次に、アニメーションシステムを評価すると、完全に宣言されていることがわかります。</span><span class="sxs-lookup"><span data-stu-id="10222-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="10222-190">開発者が次の位置または次の色を計算する必要はなく、アニメーションオブジェクトの一連のプロパティとしてアニメーションを表現できます。</span><span class="sxs-lookup"><span data-stu-id="10222-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="10222-191">これらのアニメーションは、開発者またはデザイナーの意図を表すことができます (このボタンをここから5秒に移動します)。また、システムは、これを実現するための最も効率的な方法を決定できます。</span><span class="sxs-lookup"><span data-stu-id="10222-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="10222-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="10222-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="10222-193"><xref:System.Windows.UIElement> は、レイアウト、入力、イベントなどのコアサブシステムを定義します。</span><span class="sxs-lookup"><span data-stu-id="10222-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="10222-194">レイアウトは、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]での主要な概念です。</span><span class="sxs-lookup"><span data-stu-id="10222-194">Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="10222-195">多くのシステムでは、固定されたレイアウトモデルのセットがあります (HTML はレイアウト用に3つのモデル、flow、absolute、テーブル)、またはレイアウトのモデルがありません (User32.dll は絶対配置のみをサポートします)。</span><span class="sxs-lookup"><span data-stu-id="10222-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]<span data-ttu-id="10222-196">、開発者やデザイナーが、命令型ロジックではなくプロパティ値によって駆動される柔軟性のある拡張可能なレイアウトモデルを必要としていることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="10222-196">started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="10222-197"><xref:System.Windows.UIElement> レベルでは、レイアウトの基本的なコントラクトが導入されます。これは、<xref:System.Windows.UIElement.Measure%2A> と <xref:System.Windows.UIElement.Arrange%2A> 成功を持つ2つのフェーズモデルです。</span><span class="sxs-lookup"><span data-stu-id="10222-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="10222-198"><xref:System.Windows.UIElement.Measure%2A> を使用すると、コンポーネントでどの程度のサイズを取得するかを指定できます。</span><span class="sxs-lookup"><span data-stu-id="10222-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="10222-199">これは、<xref:System.Windows.UIElement.Arrange%2A> とは別のフェーズです。親要素が子に複数回計測して最適な位置とサイズを決定することがあるためです。</span><span class="sxs-lookup"><span data-stu-id="10222-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="10222-200">親要素が子要素に測定を求めるという事実は、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の別の重要な理念としてコンテンツに対するものです。</span><span class="sxs-lookup"><span data-stu-id="10222-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content.</span></span> <span data-ttu-id="10222-201">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 内のすべてのコントロールは、そのコンテンツのサイズに合わせてサイズを変更する機能をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="10222-201">All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="10222-202">これにより、ローカライズがはるかに簡単になり、要素のサイズ変更に合わせて動的なレイアウトを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="10222-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="10222-203"><xref:System.Windows.UIElement.Arrange%2A> フェーズでは、親が各子の最終的なサイズを配置および決定できます。</span><span class="sxs-lookup"><span data-stu-id="10222-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="10222-204">多くの場合、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> および関連オブジェクトの出力側について話します。</span><span class="sxs-lookup"><span data-stu-id="10222-204">A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="10222-205">しかし、入力側にも非常に多くのイノベーションがあります。</span><span class="sxs-lookup"><span data-stu-id="10222-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="10222-206">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] の入力モデルの最も基本的な変更は、入力イベントをシステム経由でルーティングするための一貫したモデルです。</span><span class="sxs-lookup"><span data-stu-id="10222-206">Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="10222-207">入力は、カーネルモードデバイスドライバーの信号として生成され、Windows カーネルと User32.dll を含む複雑なプロセスを通じて、正しいプロセスとスレッドにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="10222-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="10222-208">入力に対応する User32.dll メッセージが [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]にルーティングされると、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 未加工の入力メッセージに変換され、ディスパッチャーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="10222-208">Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-209">を使用すると、未加工の入力イベントを複数の実際のイベントに変換できます。これにより、"MouseEnter" などの機能を、保証された配信によりシステムの低レベルで実装できます。</span><span class="sxs-lookup"><span data-stu-id="10222-209">allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="10222-210">各入力イベントは、少なくとも2つのイベント ("preview" イベントと実際のイベント) に変換されます。</span><span class="sxs-lookup"><span data-stu-id="10222-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="10222-211">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 内のすべてのイベントには、要素ツリーを通じたルーティングの概念があります。</span><span class="sxs-lookup"><span data-stu-id="10222-211">All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree.</span></span> <span data-ttu-id="10222-212">イベントは、ターゲットからツリーをルートまで走査する場合は "バブル" と呼ばれ、ルートから開始してターゲットを走査する場合は "トンネル" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="10222-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="10222-213">入力プレビューイベントトンネル。ツリー内の任意の要素を有効にして、イベントにフィルターを適用したり、アクションを実行したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="10222-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="10222-214">通常の (非プレビュー) イベントは、ターゲットからルートまでバブルされます。</span><span class="sxs-lookup"><span data-stu-id="10222-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="10222-215">このトンネルとバブルフェーズを分割することにより、キーボードアクセラレータなどの機能の実装が、複合環境で一貫した方法で実行されます。</span><span class="sxs-lookup"><span data-stu-id="10222-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="10222-216">User32.dll では、サポートするすべてのアクセラレータを含む単一のグローバルテーブルを使用して、キーボードアクセラレータを実装します (Ctrl + N を "New" にマッピングします)。</span><span class="sxs-lookup"><span data-stu-id="10222-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="10222-217">アプリケーションのディスパッチャーで、 **TranslateAccelerator**を呼び出します。これは、user32.dll の入力メッセージをスニッフィングし、登録されているアクセラレータに一致したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="10222-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="10222-218">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] では、システムが完全に "コンポーザブル" であるため、これは機能しません。すべての要素が任意のキーボードアクセラレータを処理して使用できます。</span><span class="sxs-lookup"><span data-stu-id="10222-218">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="10222-219">この2つのフェーズモデルを入力にすると、コンポーネントは独自の "TranslateAccelerator" を実装できます。</span><span class="sxs-lookup"><span data-stu-id="10222-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="10222-220">もう1つの手順を実行するために、<xref:System.Windows.UIElement> CommandBindings の概念も紹介します。</span><span class="sxs-lookup"><span data-stu-id="10222-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="10222-221">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] コマンドシステムを使用すると、開発者は、コマンドエンドポイント (<xref:System.Windows.Input.ICommand>を実装するもの) の観点から機能を定義できます。</span><span class="sxs-lookup"><span data-stu-id="10222-221">The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="10222-222">コマンドバインドを使用すると、要素で入力ジェスチャ (Ctrl + N) とコマンド (New) の間のマッピングを定義できます。</span><span class="sxs-lookup"><span data-stu-id="10222-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="10222-223">入力ジェスチャとコマンド定義はどちらも拡張可能であり、使用時に同時に接続することができます。</span><span class="sxs-lookup"><span data-stu-id="10222-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="10222-224">これにより、たとえば、エンドユーザーがアプリケーション内で使用するキーバインドをカスタマイズできるようにすることが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="10222-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="10222-225">トピック「」では、「[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] –プレゼンテーションコアアセンブリに実装されている機能」の「コア」機能に焦点を当てました。</span><span class="sxs-lookup"><span data-stu-id="10222-225">To this point in the topic, "core" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="10222-226">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の構築時には、基本要素 (**メジャー**と**配置**によるレイアウトのコントラクトなど) とフレームワークの部分 (<xref:System.Windows.Controls.Grid>などの特定のレイアウトの実装など) の明確な分離が目的の結果でした。</span><span class="sxs-lookup"><span data-stu-id="10222-226">When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="10222-227">目標は、外部の開発者が必要に応じて独自のフレームワークを作成できるようにする、スタックの拡張ポイントを小さくすることでした。</span><span class="sxs-lookup"><span data-stu-id="10222-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="10222-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="10222-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="10222-229"><xref:System.Windows.FrameworkElement> は、2つの異なる方法で確認できます。</span><span class="sxs-lookup"><span data-stu-id="10222-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="10222-230">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]の下位層で導入されたサブシステムの一連のポリシーとカスタマイズについて説明します。</span><span class="sxs-lookup"><span data-stu-id="10222-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="10222-231">また、一連の新しいサブシステムも導入されています。</span><span class="sxs-lookup"><span data-stu-id="10222-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="10222-232"><xref:System.Windows.FrameworkElement> によって導入される主なポリシーは、アプリケーションのレイアウトに関するものです。</span><span class="sxs-lookup"><span data-stu-id="10222-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="10222-233"><xref:System.Windows.FrameworkElement> は、<xref:System.Windows.UIElement> によって導入された基本的なレイアウトコントラクトに基づいて構築され、レイアウトの作成者が一貫した一連のプロパティドリブンレイアウトセマンティクスを持つことができるレイアウト "スロット" の概念を追加します。</span><span class="sxs-lookup"><span data-stu-id="10222-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="10222-234"><xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>、<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>、<xref:System.Windows.FrameworkElement.MinWidth%2A>、および <xref:System.Windows.FrameworkElement.Margin%2A> のようなプロパティ (いくつかの名前を付ける) は、レイアウトコンテナー内のすべてのコンポーネントが一貫した動作を <xref:System.Windows.FrameworkElement> から派生します。</span><span class="sxs-lookup"><span data-stu-id="10222-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="10222-235">また <xref:System.Windows.FrameworkElement> は、[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]のコア層にある多くの機能に対する API の公開を容易にします。</span><span class="sxs-lookup"><span data-stu-id="10222-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="10222-236">たとえば、<xref:System.Windows.FrameworkElement> は、<xref:System.Windows.FrameworkElement.BeginStoryboard%2A> メソッドを使用してアニメーションへの直接アクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="10222-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="10222-237"><xref:System.Windows.Media.Animation.Storyboard> には、一連のプロパティに対して複数のアニメーションをスクリプト化する方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="10222-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="10222-238"><xref:System.Windows.FrameworkElement> が導入する最も重要な2つの点は、データバインディングとスタイルです。</span><span class="sxs-lookup"><span data-stu-id="10222-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="10222-239">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] のデータバインディングサブシステムは、アプリケーション [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]を作成するために [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] または ASP.NET を使用しているすべてのユーザーに対して比較的なじみがある必要があります。</span><span class="sxs-lookup"><span data-stu-id="10222-239">The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="10222-240">これらの各システムでは、特定の要素の1つ以上のプロパティをデータにバインドすることを簡単に表すことができます。</span><span class="sxs-lookup"><span data-stu-id="10222-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-241">は、プロパティのバインド、変換、およびリストバインドを完全にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="10222-241">has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="10222-242">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] でのデータバインディングの最も興味深い機能の1つは、データテンプレートの導入です。</span><span class="sxs-lookup"><span data-stu-id="10222-242">One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates.</span></span> <span data-ttu-id="10222-243">データテンプレートを使用すると、データの一部を視覚化する方法を宣言によって指定できます。</span><span class="sxs-lookup"><span data-stu-id="10222-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="10222-244">データにバインドできるカスタムユーザーインターフェイスを作成する代わりに、問題を解決して、作成される表示をデータが決定できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="10222-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="10222-245">スタイル設定は、実際には軽量な形式のデータバインドです。</span><span class="sxs-lookup"><span data-stu-id="10222-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="10222-246">スタイルを使用すると、共有定義の一連のプロパティを、要素の1つ以上のインスタンスにバインドできます。</span><span class="sxs-lookup"><span data-stu-id="10222-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="10222-247">スタイルは、明示的な参照によって (<xref:System.Windows.FrameworkElement.Style%2A> プロパティを設定することによって) 要素に適用されるか、またはスタイルを要素の CLR 型に関連付けることによって暗黙的に適用されます。</span><span class="sxs-lookup"><span data-stu-id="10222-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="10222-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="10222-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="10222-249">コントロールの最も重要な機能は、テンプレートです。</span><span class="sxs-lookup"><span data-stu-id="10222-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="10222-250">WPF の合成システムを保持モードのレンダリングシステムと考えている場合、テンプレートを使用すると、コントロールは、パラメーター化された宣言型の方法でレンダリングを記述できます。</span><span class="sxs-lookup"><span data-stu-id="10222-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="10222-251"><xref:System.Windows.Controls.ControlTemplate> は、子要素のセットを作成するためのスクリプトにすぎず、コントロールによって提供されるプロパティへのバインドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="10222-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="10222-252"><xref:System.Windows.Controls.Control> には、いくつかのストックプロパティ、<xref:System.Windows.Controls.Control.Foreground%2A>、<xref:System.Windows.Controls.Control.Background%2A>、<xref:System.Windows.Controls.Control.Padding%2A>が用意されています。これを使用すると、テンプレート作成者はコントロールの表示をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="10222-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="10222-253">コントロールの実装には、データモデルと相互作用モデルが用意されています。</span><span class="sxs-lookup"><span data-stu-id="10222-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="10222-254">相互作用モデルは、一連のコマンド (ウィンドウの [閉じる] など) と入力ジェスチャへのバインドを定義します (ウィンドウの上隅の赤い X をクリックするなど)。</span><span class="sxs-lookup"><span data-stu-id="10222-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="10222-255">データモデルには、相互作用モデルをカスタマイズしたり、(テンプレートによって決定される) 表示をカスタマイズしたりするための一連のプロパティが用意されています。</span><span class="sxs-lookup"><span data-stu-id="10222-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="10222-256">これにより、データモデル (プロパティ)、相互作用モデル (コマンドとイベント)、および表示モデル (テンプレート) が分割され、コントロールの外観と動作を完全にカスタマイズできるようになります。</span><span class="sxs-lookup"><span data-stu-id="10222-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="10222-257">コントロールのデータモデルの一般的な側面は、コンテンツモデルです。</span><span class="sxs-lookup"><span data-stu-id="10222-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="10222-258"><xref:System.Windows.Controls.Button>のようなコントロールを表示すると、<xref:System.Object>型の "Content" という名前のプロパティがあることがわかります。</span><span class="sxs-lookup"><span data-stu-id="10222-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="10222-259">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] と ASP.NET では、通常、このプロパティは文字列になりますが、ボタンに配置できるコンテンツの種類が制限されます。</span><span class="sxs-lookup"><span data-stu-id="10222-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="10222-260">ボタンのコンテンツは、単純な文字列、複雑なデータオブジェクト、または要素ツリー全体のいずれかになります。</span><span class="sxs-lookup"><span data-stu-id="10222-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="10222-261">データオブジェクトの場合は、データテンプレートを使用して表示を作成します。</span><span class="sxs-lookup"><span data-stu-id="10222-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="10222-262">まとめ</span><span class="sxs-lookup"><span data-stu-id="10222-262">Summary</span></span>  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="10222-263">は、データ駆動型の動的なプレゼンテーションシステムを作成できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="10222-263">is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="10222-264">システムのすべての部分は、動作を駆動するプロパティセットを通じてオブジェクトを作成するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="10222-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="10222-265">データバインディングはシステムの基本的な部分であり、すべてのレイヤーで統合されています。</span><span class="sxs-lookup"><span data-stu-id="10222-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="10222-266">従来のアプリケーションでは、ディスプレイを作成し、いくつかのデータにバインドします。</span><span class="sxs-lookup"><span data-stu-id="10222-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="10222-267">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]では、コントロールに関するすべての側面が、何らかの種類のデータバインディングによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="10222-267">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="10222-268">ボタン内に表示されるテキストは、ボタン内に構築されたコントロールを作成し、その表示をボタンのコンテンツプロパティにバインドすることによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="10222-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="10222-269">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] ベースのアプリケーションの開発を開始すると、非常になじみがあります。</span><span class="sxs-lookup"><span data-stu-id="10222-269">When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar.</span></span> <span data-ttu-id="10222-270">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] または ASP.NET を使用する場合とほぼ同じ方法で、プロパティの設定、オブジェクトの使用、およびデータバインドを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="10222-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET.</span></span> <span data-ttu-id="10222-271">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]のアーキテクチャについてさらに詳しく調査することで、アプリケーションのコアドライバーとしてデータを根本的に扱う、より豊富なアプリケーションを作成できる可能性があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="10222-271">With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="10222-272">関連項目</span><span class="sxs-lookup"><span data-stu-id="10222-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="10222-273">データ バインディングの概要</span><span class="sxs-lookup"><span data-stu-id="10222-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="10222-274">レイアウト</span><span class="sxs-lookup"><span data-stu-id="10222-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="10222-275">アニメーションの概要</span><span class="sxs-lookup"><span data-stu-id="10222-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
