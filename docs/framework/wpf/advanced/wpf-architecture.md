---
title: Architecture
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187133"
---
# <a name="wpf-architecture"></a><span data-ttu-id="1daf3-102">WPF アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="1daf3-102">WPF Architecture</span></span>
<span data-ttu-id="1daf3-103">このトピックでは、Windows プレゼンテーション ファウンデーション (WPF) クラス階層のガイドツアーを提供します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="1daf3-104">WPF の主要なサブシステムの大部分をカバーし、その相互作用について説明します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="1daf3-105">また、WPF のアーキテクトが行った選択の一部についても詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>
## <a name="systemobject"></a><span data-ttu-id="1daf3-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="1daf3-106">System.Object</span></span>  
 <span data-ttu-id="1daf3-107">プライマリ WPF プログラミング モデルは、マネージ コードを通じて公開されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="1daf3-108">WPF の設計段階の初期段階では、システムのマネージ コンポーネントとアンマネージ コンポーネントの間に線を引く場所について、さまざまな議論がありました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="1daf3-109">CLR には、開発の生産性と堅牢性 (メモリ管理、エラー処理、共通型システムなど) を実現する機能が多数用意されていますが、コストがかかります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="1daf3-110">WPF の主要なコンポーネントを次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="1daf3-111">図の赤いセクション (プレゼンテーション フレームワーク、プレゼンテーションコア、およびミルコア) は、WPF の主要なコード部分です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="1daf3-112">このうち、1つだけがアンマネージコンポーネントであるミルコアです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="1daf3-113">Milcore は、DirectX との緊密な統合を可能にするために、アンマネージ コードで記述されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="1daf3-114">WPF での表示はすべて DirectX エンジンを通じて行われるため、効率的なハードウェアとソフトウェアのレンダリングが可能になります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="1daf3-115">WPF では、メモリと実行を細かく制御する必要もありました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="1daf3-116">milcore の合成エンジンは非常にパフォーマンスに敏感であり、パフォーマンスを得るためには CLR の多くの利点を放棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="1daf3-117">![.NET Framework 内の WPF の位置。](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="1daf3-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="1daf3-118">WPF のマネージ部分とアンマネージ部分の間の通信については、このトピックで後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="1daf3-119">マネージ プログラミング モデルの残りの部分を以下に説明します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="1daf3-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="1daf3-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="1daf3-121">WPF のオブジェクトの多<xref:System.Windows.Threading.DispatcherObject>くは、 から派生し、同時実行とスレッド処理を処理するための基本的な構成要素を提供します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="1daf3-122">WPF は、ディスパッチャーによって実装されるメッセージング システムに基づいています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="1daf3-123">これは、使い慣れた Win32 メッセージ ポンプとよく似ています。実際、WPF ディスパッチャーは、スレッド間呼び出しを実行するために User32 メッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="1daf3-124">WPF での同時実行について説明する際に理解する必要のある 2 つの主要な概念 、つまりディスパッチャーとスレッドアフィニティがあります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="1daf3-125">WPF の設計段階では、単一の実行スレッドに移行することが目標でしたが、非スレッドの "アフィニティ化" モデルに移行することが目標でした。</span><span class="sxs-lookup"><span data-stu-id="1daf3-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="1daf3-126">スレッドの類似性は、コンポーネントが実行スレッドの ID を使用して何らかの状態を格納するときに発生します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="1daf3-127">最も一般的な形式は、スレッド ローカル ストア (TLS) を使用して状態を格納することです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="1daf3-128">スレッドアフィニティでは、実行の各論理スレッドがオペレーティング システム内の 1 つの物理スレッドだけが所有している必要があり、メモリを集中的に消費する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="1daf3-129">最終的に、WPF のスレッド モデルは、スレッド アフィニティを使用した単一スレッド実行の既存の User32 スレッド モデルとの同期を維持しました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="1daf3-130">この主な理由は、OLE 2.0、クリップボード、Internet Explorer などのシステムで、シングル スレッド アフィニティ (STA) の実行が必要なため、相互運用性が実現しました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="1daf3-131">STA スレッドを持つオブジェクトが存在する場合、スレッド間で通信し、正しいスレッドであることを検証する方法が必要です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="1daf3-132">ここにディスパッチャーの役割があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="1daf3-133">ディスパッチャーは、複数の優先順位付きキューを持つ基本的なメッセージディスパッチシステムです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="1daf3-134">メッセージの例としては、生の入力通知 (マウス移動)、フレームワーク関数 (レイアウト)、またはユーザー コマンド (このメソッドを実行) などがあります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="1daf3-135">から<xref:System.Windows.Threading.DispatcherObject>派生すると、STA 動作を持つ CLR オブジェクトを作成し、作成時にディスパッチャーへのポインターを与えます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="1daf3-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="1daf3-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="1daf3-137">WPF の構築に使用される主なアーキテクチャの哲学の 1 つは、メソッドやイベントよりもプロパティの優先順位でした。</span><span class="sxs-lookup"><span data-stu-id="1daf3-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="1daf3-138">プロパティは宣言型であり、アクションの代わりにインテントをより簡単に指定できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="1daf3-139">また、ユーザー インターフェイスのコンテンツを表示するモデル駆動型 (データ ドリブン) システムもサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="1daf3-140">この考え方は、アプリケーションの動作をより適切に制御するために、バインドできるプロパティを増やすという意図された効果を持っていました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="1daf3-141">プロパティによって駆動されるシステムの多くを持つためには、CLR が提供するものよりも豊富なプロパティ システムが必要でした。</span><span class="sxs-lookup"><span data-stu-id="1daf3-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="1daf3-142">このリッチさの簡単な例は、変更通知です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="1daf3-143">双方向バインディングを有効にするには、変更通知をサポートするためにバインドの両側が必要です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="1daf3-144">プロパティ値に関連付けられた動作を持つには、プロパティ値が変更されたときに通知を受ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="1daf3-145">インターフェイス**INotifyPropertyChange**を使用すると、オブジェクトが変更通知を発行できますが、オプションです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="1daf3-146">WPF には、型から派生した、より<xref:System.Windows.DependencyObject>豊富なプロパティ システムが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="1daf3-147">プロパティ システムは、プロパティ式間の依存関係を追跡し、依存関係が変更されたときにプロパティ値を自動的に再検証するという意味で、真の"依存関係"プロパティ システムです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="1daf3-148">たとえば、値を継承する要素の親のプロパティが変更<xref:System.Windows.Controls.Control.FontSize%2A>されると、(など)プロパティを継承する場合、システムは自動的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="1daf3-149">WPF プロパティ システムの基礎は、プロパティ式の概念です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="1daf3-150">WPF のこの最初のリリースでは、プロパティ式システムが閉じられ、式はすべてフレームワークの一部として提供されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="1daf3-151">式は、プロパティ システムにデータ バインディング、スタイル設定、または継承をハード コード化せず、フレームワーク内の後のレイヤーによって提供される理由です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="1daf3-152">プロパティ システムは、プロパティ値の疎な格納も提供します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="1daf3-153">オブジェクトは数十個のプロパティを持つ可能性があり、値のほとんどはデフォルト状態 (継承、スタイルなど) であるため、オブジェクトのすべてのインスタンスに定義されているすべてのプロパティのウェイトを完全に設定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1daf3-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="1daf3-154">プロパティ システムの最後の新機能は、添付プロパティの概念です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="1daf3-155">WPF 要素は、構成とコンポーネントの再利用の原則に基づいて構築されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="1daf3-156">多くの場合、(レイアウト要素のような) 要素を<xref:System.Windows.Controls.Grid>含む一部の要素は、子要素の動作を制御するために追加のデータを必要とします (行/列情報など)。</span><span class="sxs-lookup"><span data-stu-id="1daf3-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="1daf3-157">すべてのプロパティをすべての要素に関連付ける代わりに、すべてのオブジェクトに他のオブジェクトのプロパティ定義を提供できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="1daf3-158">これは、JavaScript の "展開" 機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="1daf3-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="1daf3-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="1daf3-160">システムが定義されている場合、次のステップは画面に描画されるピクセルを取得することです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="1daf3-161">この<xref:System.Windows.Media.Visual>クラスは、ビジュアル オブジェクトのツリーを構築するために用意されており、各オブジェクトには、必要に応じて描画命令と、それらの命令 (クリッピング、変換など) のレンダリング方法に関するメタデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="1daf3-162"><xref:System.Windows.Media.Visual>非常に軽量で柔軟性を持つように設計されているので、ほとんどの機能はパブリック API を公開することはなく、保護されたコールバック関数に大きく依存しています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="1daf3-163"><xref:System.Windows.Media.Visual>は、WPF 合成システムへのエントリ ポイントです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="1daf3-164"><xref:System.Windows.Media.Visual>は、マネージ API とアンマネージ ミルコアという 2 つのサブシステム間の接続ポイントです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="1daf3-165">WPF は、milcore によって管理されているアンマネージ データ構造を走査してデータを表示します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="1daf3-166">コンポジション ノードと呼ばれるこれらの構造体は、各ノードでレンダリング命令を持つ階層表示ツリーを表します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="1daf3-167">下図の右側に示されているこのツリーは、メッセージング プロトコルを介してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="1daf3-168">WPF をプログラミングする場合、<xref:System.Windows.Media.Visual>このメッセージング プロトコルを通じて構成ツリーに内部的に通信する要素と派生型を作成します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="1daf3-169">WPF<xref:System.Windows.Media.Visual>の各ノードは、1 つ、どれも、または複数のコンポジション ノードを作成できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="1daf3-170">![Windows Presentation Foundation ビジュアル ツリー。](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="1daf3-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="1daf3-171">ここで注目する非常に重要なアーキテクチャの詳細があります - ビジュアルのツリー全体と描画命令がキャッシュされています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="1daf3-172">グラフィックス用語では、WPF は保持されたレンダリング システムを使用します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="1daf3-173">これにより、ユーザー コードへのコールバックで合成システムがブロックされることなく、システムが高いリフレッシュ レートで再描画できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="1daf3-174">これにより、応答しないアプリケーションが表示されないようにできます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="1daf3-175">図ではあまり分からないもう 1 つの重要な詳細は、システムが実際にどのように構成を実行するかを示しています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="1daf3-176">User32 および GDI では、システムは即時モードクリッピング システムで動作します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="1daf3-177">コンポーネントをレンダリングする必要がある場合、システムは、コンポーネントがピクセルに触れることができない範囲外のクリッピング境界を確立し、そのボックスにピクセルをペイントするようにコンポーネントに求められます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="1daf3-178">このシステムは、何かが変更されたときに影響を受けるコンポーネントに触れるだけで、2つのコンポーネントが単一ピクセルの色に寄与しないため、メモリに制約のあるシステムでは非常にうまく機能します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="1daf3-179">WPF は「画家のアルゴリズム」の描画モデルを使用します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="1daf3-180">つまり、各コンポーネントをクリッピングする代わりに、各コンポーネントをディスプレイの背面から前面にレンダリングするように求められます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="1daf3-181">これにより、各コンポーネントを前のコンポーネントの表示上にペイントできます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="1daf3-182">このモデルの利点は、複雑で部分的に透明な形状を持つことができる点です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="1daf3-183">今日の最新のグラフィックス ハードウェアでは、このモデルは比較的高速です (User32/ GDI が作成された場合はそうではありませんでした)。</span><span class="sxs-lookup"><span data-stu-id="1daf3-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="1daf3-184">前に述べたように、WPF の中心的な考え方は、より宣言的な"プロパティ中心"のプログラミング モデルに移行することです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="1daf3-185">ビジュアルシステムでは、これは興味深い場所のカップルに表示されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="1daf3-186">まず、保持モードのグラフィックシステムについて考えると、これは実際には、強制的な DrawLine/DrawLine 型モデルからデータ指向モデルに移動しています – 新しいライン()/新しいライン() 。</span><span class="sxs-lookup"><span data-stu-id="1daf3-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="1daf3-187">このデータ ドリブン レンダリングへの移行により、描画命令に対する複雑な操作をプロパティを使用して表現できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="1daf3-188">派生元の型<xref:System.Windows.Media.Drawing>は、実質的にレンダリングのオブジェクト モデルです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="1daf3-189">次に、アニメーション システムを評価すると、ほぼ完全に宣言的なアニメーションが表示されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="1daf3-190">開発者が次の場所や次の色を計算する代わりに、アニメーションをアニメーション オブジェクトのプロパティのセットとして表現できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="1daf3-191">これらのアニメーションは、開発者またはデザイナーの意図を表現でき (このボタンをここから 5 秒後にそこに移動)、システムはそれを実現するための最も効率的な方法を決定できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a><span data-ttu-id="1daf3-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="1daf3-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="1daf3-193"><xref:System.Windows.UIElement>は、レイアウト、入力、イベントなどのコア サブシステムを定義します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="1daf3-194">レイアウトは、WPF の中心的な概念です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="1daf3-195">多くのシステムには、固定のレイアウト モデルのセット (HTML はレイアウト用の 3 つのモデル、フロー、絶対、およびテーブルをサポートしています) か、レイアウトのモデルがありません (User32 は実際には絶対配置のみをサポートします)。</span><span class="sxs-lookup"><span data-stu-id="1daf3-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="1daf3-196">WPF は、開発者やデザイナーが、命令型ロジックではなくプロパティ値によって駆動できる、柔軟で拡張可能なレイアウト モデルを必要とするという前提から始まりました。</span><span class="sxs-lookup"><span data-stu-id="1daf3-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="1daf3-197"><xref:System.Windows.UIElement>レベルでは、レイアウトの基本契約が導入されます – とパス<xref:System.Windows.UIElement.Arrange%2A>を持<xref:System.Windows.UIElement.Measure%2A>つ2つのフェーズモデル。</span><span class="sxs-lookup"><span data-stu-id="1daf3-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="1daf3-198"><xref:System.Windows.UIElement.Measure%2A>を使用すると、コンポーネントがどの程度のサイズを取り、使用するかを決定できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="1daf3-199">親要素が子要素に<xref:System.Windows.UIElement.Arrange%2A>対して、その最適な位置とサイズを決定するために複数回測定するように要求する場合が多いため、これは別のフェーズです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="1daf3-200">親要素が子要素に測定を求めるという事実は、WPF のもう 1 つの重要な哲学を示しています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="1daf3-201">WPF のすべてのコントロールは、コンテンツの自然なサイズにサイズを設定する機能をサポートします。</span><span class="sxs-lookup"><span data-stu-id="1daf3-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="1daf3-202">これにより、ローカライズが大幅に容易になり、要素のサイズが変更されるに従って要素の動的なレイアウトが可能になります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="1daf3-203">フェーズ<xref:System.Windows.UIElement.Arrange%2A>を使用すると、親が各子の最終的なサイズを配置して決定できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="1daf3-204">多くの場合、WPF の出力側<xref:System.Windows.Media.Visual>と関連するオブジェクトについて話すのに多くの時間が費やされます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="1daf3-205">しかし、入力側にも膨大な量のイノベーションがあります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="1daf3-206">おそらく、WPF の入力モデルで最も根本的な変更は、入力イベントがシステムを通じてルーティングされる一貫したモデルです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="1daf3-207">入力は、カーネル モードのデバイス ドライバーのシグナルとして発生し、Windows カーネルと User32 を含む複雑なプロセスを通じて正しいプロセスとスレッドにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="1daf3-208">入力に対応する User32 メッセージが WPF にルーティングされると、WPF の未加工の入力メッセージに変換され、ディスパッチャーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="1daf3-209">WPF では、生の入力イベントを複数の実際のイベントに変換できるため、配信が保証された低レベルのシステムで "MouseEnter" などの機能を実装できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="1daf3-210">各入力イベントは、少なくとも 2 つのイベント ("プレビュー" イベントと実際のイベント) に変換されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="1daf3-211">WPF のすべてのイベントは、要素ツリーを通じてルーティングするという概念を持ちます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="1daf3-212">イベントは、ツリー上のターゲットからルートまで移動する場合は"バブル"と言われ、ルートから始まり、ターゲットまで移動すると「トンネル」といわれます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="1daf3-213">入力プレビュー イベント トンネルを使用して、ツリー内の任意の要素がイベントをフィルタまたはアクションを実行できるようにします。</span><span class="sxs-lookup"><span data-stu-id="1daf3-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="1daf3-214">通常の (プレビュー以外の) イベントは、ターゲットからルートまでバブルします。</span><span class="sxs-lookup"><span data-stu-id="1daf3-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="1daf3-215">トンネルとバブルのフェーズの間で分割すると、キーボード アクセラレータなどの機能の実装は、複合世界で一貫した方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="1daf3-216">User32 では、サポートするすべてのアクセラレータを含む単一のグローバル テーブルを持つことでキーボード アクセラレータを実装します (Ctrl + N マッピングを "New")。</span><span class="sxs-lookup"><span data-stu-id="1daf3-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="1daf3-217">アプリケーションのディスパッチャーで **、TranslateAccelerator**を呼び出して User32 の入力メッセージをスニッフィングし、登録されたアクセラレータに一致するものがあるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="1daf3-218">WPF では、システムが完全に "構成可能" であるため、この機能は機能しません。</span><span class="sxs-lookup"><span data-stu-id="1daf3-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="1daf3-219">入力用にこの 2 つのフェーズ モデルを使用すると、コンポーネントは独自の "TranslateAccelerator" を実装できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="1daf3-220">さらにこの 1 つの手順<xref:System.Windows.UIElement>を実行するには、コマンド バインドの概念も紹介します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="1daf3-221">WPF コマンド システムを使用すると、開発者はコマンド エンド ポイント (実装するもの)<xref:System.Windows.Input.ICommand>の観点から機能を定義できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="1daf3-222">コマンド バインディングを使用すると、入力ジェスチャ (Ctrl+N) とコマンド (New) の間のマッピングを要素で定義できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="1daf3-223">入力ジェスチャとコマンド定義の両方が拡張可能で、使用時に一緒に配線できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="1daf3-224">これにより、たとえば、エンド ユーザーがアプリケーション内で使用するキー バインドをカスタマイズできるようになるのは簡単です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="1daf3-225">このトピックでは、WPF の "コア" 機能 - プレゼンテーションコア アセンブリに実装されている機能が焦点となっています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="1daf3-226">WPF を構築する場合、基本部分 **([メジャー]** や **[配置]** を使用したレイアウトのコントラクトなど) とフレームワークの各<xref:System.Windows.Controls.Grid>部分 (特定のレイアウトの実装など) を明確に分離することが望ましい結果でした。</span><span class="sxs-lookup"><span data-stu-id="1daf3-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="1daf3-227">目標は、必要に応じて外部の開発者が独自のフレームワークを作成できるように、スタック内の低い拡張性ポイントを提供することでした。</span><span class="sxs-lookup"><span data-stu-id="1daf3-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="1daf3-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="1daf3-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="1daf3-229"><xref:System.Windows.FrameworkElement>2つの異なる方法で見ることができます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="1daf3-230">WPF の下位層で導入されたサブシステムに対する一連のポリシーとカスタマイズを紹介します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="1daf3-231">また、新しいサブシステムのセットも導入します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="1daf3-232">導入される<xref:System.Windows.FrameworkElement>主なポリシーは、アプリケーションのレイアウトに関するものです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="1daf3-233"><xref:System.Windows.FrameworkElement>によって導入された<xref:System.Windows.UIElement>基本的なレイアウト コントラクトに基づいており、レイアウト作成者が一貫したプロパティ駆動型レイアウト セマンティクスのセットを持つことを容易にするレイアウトの "スロット" の概念を追加します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="1daf3-234">、 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>、、<xref:System.Windows.FrameworkElement.MinWidth%2A>および<xref:System.Windows.FrameworkElement.Margin%2A>(いくつかの名前を付ける) などのプロパティは<xref:System.Windows.FrameworkElement>、レイアウト コンテナー内の一貫した動作から派生したすべてのコンポーネントを与えます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="1daf3-235"><xref:System.Windows.FrameworkElement>また、WPF のコア 層に含まれる多くの機能に対する API の公開が容易になります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="1daf3-236">たとえば、<xref:System.Windows.FrameworkElement>メソッドを使用してアニメーションに直接アクセス<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="1daf3-237">A<xref:System.Windows.Media.Animation.Storyboard>は、プロパティのセットに対して複数のアニメーションをスクリプト化する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="1daf3-238">最も重要なのは<xref:System.Windows.FrameworkElement>、データ バインディングとスタイルです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="1daf3-239">WPF のデータ バインディング サブシステムは、Windows フォームまたはASP.NETを使用してアプリケーション[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]を作成したユーザーには、比較的よく知っている必要があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used Windows Forms or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="1daf3-240">これらの各システムでは、特定の要素の 1 つ以上のプロパティをデータにバインドする簡単な方法があります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="1daf3-241">WPF では、プロパティ バインディング、変換、およびリスト のバインドを完全にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="1daf3-242">WPF のデータ バインディングの最も興味深い機能の 1 つは、データ テンプレートの導入です。</span><span class="sxs-lookup"><span data-stu-id="1daf3-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="1daf3-243">データ テンプレートを使用すると、データの視覚化方法を宣言によって指定できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="1daf3-244">データにバインドできるカスタム ユーザー インターフェイスを作成する代わりに、問題を回避して、作成される表示をデータで決定させることができます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="1daf3-245">スタイル設定は、実際には軽量のデータ バインディングです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="1daf3-246">スタイル設定を使用すると、共有定義のプロパティのセットを要素の 1 つ以上のインスタンスにバインドできます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="1daf3-247">スタイルは、明示的な参照 (プロパティを<xref:System.Windows.FrameworkElement.Style%2A>設定) によって要素に適用されるか、またはスタイルを要素の CLR 型に関連付けることによって暗黙的に適用されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="1daf3-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="1daf3-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="1daf3-249">コントロールの最も重要な機能は、テンプレートです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="1daf3-250">WPF のコンポジション システムを保持モード レンダリング システムと考える場合、テンプレートを使用すると、コントロールはパラメーター化された宣言的な方法でレンダリングを記述できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="1daf3-251">A<xref:System.Windows.Controls.ControlTemplate>は、コントロールによって提供されるプロパティへのバインディングを使用して、子要素のセットを作成するスクリプトにすぎません。</span><span class="sxs-lookup"><span data-stu-id="1daf3-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="1daf3-252"><xref:System.Windows.Controls.Control>には、<xref:System.Windows.Controls.Control.Foreground%2A>いくつかの名前を付けるストック<xref:System.Windows.Controls.Control.Background%2A><xref:System.Windows.Controls.Control.Padding%2A>プロパティのセット 、、つまり、テンプレート作成者がコントロールの表示をカスタマイズするために使用できます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="1daf3-253">コントロールの実装は、データ モデルと対話モデルを提供します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="1daf3-254">インタラクション モデルは、コマンドのセット (ウィンドウの Close など) と入力ジェスチャへのバインド (ウィンドウの上隅にある赤い X をクリックするなど) を定義します。</span><span class="sxs-lookup"><span data-stu-id="1daf3-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="1daf3-255">データ モデルには、インタラクション モデルをカスタマイズするか、テンプレートによって決定される表示をカスタマイズするためのプロパティのセットが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="1daf3-256">この分割は、データ モデル (プロパティ)、相互作用モデル (コマンドとイベント)、および表示モデル (テンプレート) で、コントロールの外観と動作を完全にカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="1daf3-257">コントロールのデータ モデルの一般的な側面は、コンテンツ モデルです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="1daf3-258">のような<xref:System.Windows.Controls.Button>コントロールを見ると、"Content" という名前のプロパティが type<xref:System.Object>であることがわかります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="1daf3-259">Windows フォームおよびASP.NETでは、通常、このプロパティは文字列になりますが、ボタンに配置できるコンテンツの種類が制限されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-259">In Windows Forms and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="1daf3-260">ボタンのコンテンツは、単純な文字列、複雑なデータ オブジェクト、または要素ツリー全体のいずれかです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="1daf3-261">データオブジェクトの場合、データテンプレートは、表示を構築するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>
## <a name="summary"></a><span data-ttu-id="1daf3-262">まとめ</span><span class="sxs-lookup"><span data-stu-id="1daf3-262">Summary</span></span>  
 <span data-ttu-id="1daf3-263">WPF は、動的なデータ ドリブン 表示システムを作成できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="1daf3-264">システムのすべての部分は、動作を駆動するプロパティ セットを通じてオブジェクトを作成するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="1daf3-265">データ バインディングはシステムの基本的な部分であり、すべての層に統合されています。</span><span class="sxs-lookup"><span data-stu-id="1daf3-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="1daf3-266">従来のアプリケーションでは、ディスプレイを作成してから、データにバインドします。</span><span class="sxs-lookup"><span data-stu-id="1daf3-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="1daf3-267">WPF では、コントロールに関するあらゆる側面が、ある種のデータ バインディングによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="1daf3-268">ボタン内に見つかったテキストは、ボタンの内部に構成されたコントロールを作成し、その表示をボタンの content プロパティにバインドすることによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="1daf3-269">WPF ベースのアプリケーションの開発を開始すると、非常に身近な感じがするはずです。</span><span class="sxs-lookup"><span data-stu-id="1daf3-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="1daf3-270">Windows フォームやASP.NETを使用する場合とほぼ同じ方法で、プロパティの設定、オブジェクトの使用、およびデータ バインドを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1daf3-270">You can set properties, use objects, and data bind in much the same way that you can using Windows Forms or ASP.NET.</span></span> <span data-ttu-id="1daf3-271">WPF のアーキテクチャについて詳しく調べると、データをアプリケーションのコア ドライバーとして基本的に扱う、より豊富なアプリケーションを作成する可能性が高いことがわかります。</span><span class="sxs-lookup"><span data-stu-id="1daf3-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1daf3-272">関連項目</span><span class="sxs-lookup"><span data-stu-id="1daf3-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="1daf3-273">データバインディングの概要</span><span class="sxs-lookup"><span data-stu-id="1daf3-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="1daf3-274">レイアウト</span><span class="sxs-lookup"><span data-stu-id="1daf3-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="1daf3-275">アニメーションの概要</span><span class="sxs-lookup"><span data-stu-id="1daf3-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
