---
title: Architecture
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187133"
---
# <a name="wpf-architecture"></a>WPF アーキテクチャ
このトピックでは、Windows プレゼンテーション ファウンデーション (WPF) クラス階層のガイドツアーを提供します。 WPF の主要なサブシステムの大部分をカバーし、その相互作用について説明します。 また、WPF のアーキテクトが行った選択の一部についても詳しく説明します。  

<a name="System_Object"></a>
## <a name="systemobject"></a>System.Object  
 プライマリ WPF プログラミング モデルは、マネージ コードを通じて公開されます。 WPF の設計段階の初期段階では、システムのマネージ コンポーネントとアンマネージ コンポーネントの間に線を引く場所について、さまざまな議論がありました。 CLR には、開発の生産性と堅牢性 (メモリ管理、エラー処理、共通型システムなど) を実現する機能が多数用意されていますが、コストがかかります。  
  
 WPF の主要なコンポーネントを次の図に示します。 図の赤いセクション (プレゼンテーション フレームワーク、プレゼンテーションコア、およびミルコア) は、WPF の主要なコード部分です。 このうち、1つだけがアンマネージコンポーネントであるミルコアです。 Milcore は、DirectX との緊密な統合を可能にするために、アンマネージ コードで記述されています。 WPF での表示はすべて DirectX エンジンを通じて行われるため、効率的なハードウェアとソフトウェアのレンダリングが可能になります。 WPF では、メモリと実行を細かく制御する必要もありました。 milcore の合成エンジンは非常にパフォーマンスに敏感であり、パフォーマンスを得るためには CLR の多くの利点を放棄する必要があります。  
  
 ![.NET Framework 内の WPF の位置。](./media/wpf-architect1.PNG "wpf_architect1")  
  
 WPF のマネージ部分とアンマネージ部分の間の通信については、このトピックで後ほど説明します。 マネージ プログラミング モデルの残りの部分を以下に説明します。  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a>System.Threading.DispatcherObject  
 WPF のオブジェクトの多<xref:System.Windows.Threading.DispatcherObject>くは、 から派生し、同時実行とスレッド処理を処理するための基本的な構成要素を提供します。 WPF は、ディスパッチャーによって実装されるメッセージング システムに基づいています。 これは、使い慣れた Win32 メッセージ ポンプとよく似ています。実際、WPF ディスパッチャーは、スレッド間呼び出しを実行するために User32 メッセージを使用します。  
  
 WPF での同時実行について説明する際に理解する必要のある 2 つの主要な概念 、つまりディスパッチャーとスレッドアフィニティがあります。  
  
 WPF の設計段階では、単一の実行スレッドに移行することが目標でしたが、非スレッドの "アフィニティ化" モデルに移行することが目標でした。 スレッドの類似性は、コンポーネントが実行スレッドの ID を使用して何らかの状態を格納するときに発生します。 最も一般的な形式は、スレッド ローカル ストア (TLS) を使用して状態を格納することです。 スレッドアフィニティでは、実行の各論理スレッドがオペレーティング システム内の 1 つの物理スレッドだけが所有している必要があり、メモリを集中的に消費する可能性があります。 最終的に、WPF のスレッド モデルは、スレッド アフィニティを使用した単一スレッド実行の既存の User32 スレッド モデルとの同期を維持しました。 この主な理由は、OLE 2.0、クリップボード、Internet Explorer などのシステムで、シングル スレッド アフィニティ (STA) の実行が必要なため、相互運用性が実現しました。  
  
 STA スレッドを持つオブジェクトが存在する場合、スレッド間で通信し、正しいスレッドであることを検証する方法が必要です。 ここにディスパッチャーの役割があります。 ディスパッチャーは、複数の優先順位付きキューを持つ基本的なメッセージディスパッチシステムです。 メッセージの例としては、生の入力通知 (マウス移動)、フレームワーク関数 (レイアウト)、またはユーザー コマンド (このメソッドを実行) などがあります。 から<xref:System.Windows.Threading.DispatcherObject>派生すると、STA 動作を持つ CLR オブジェクトを作成し、作成時にディスパッチャーへのポインターを与えます。  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a>System.Windows.DependencyObject  
 WPF の構築に使用される主なアーキテクチャの哲学の 1 つは、メソッドやイベントよりもプロパティの優先順位でした。 プロパティは宣言型であり、アクションの代わりにインテントをより簡単に指定できます。 また、ユーザー インターフェイスのコンテンツを表示するモデル駆動型 (データ ドリブン) システムもサポートされていました。 この考え方は、アプリケーションの動作をより適切に制御するために、バインドできるプロパティを増やすという意図された効果を持っていました。  
  
 プロパティによって駆動されるシステムの多くを持つためには、CLR が提供するものよりも豊富なプロパティ システムが必要でした。 このリッチさの簡単な例は、変更通知です。 双方向バインディングを有効にするには、変更通知をサポートするためにバインドの両側が必要です。 プロパティ値に関連付けられた動作を持つには、プロパティ値が変更されたときに通知を受ける必要があります。 インターフェイス**INotifyPropertyChange**を使用すると、オブジェクトが変更通知を発行できますが、オプションです。  
  
 WPF には、型から派生した、より<xref:System.Windows.DependencyObject>豊富なプロパティ システムが用意されています。 プロパティ システムは、プロパティ式間の依存関係を追跡し、依存関係が変更されたときにプロパティ値を自動的に再検証するという意味で、真の"依存関係"プロパティ システムです。 たとえば、値を継承する要素の親のプロパティが変更<xref:System.Windows.Controls.Control.FontSize%2A>されると、(など)プロパティを継承する場合、システムは自動的に更新されます。  
  
 WPF プロパティ システムの基礎は、プロパティ式の概念です。 WPF のこの最初のリリースでは、プロパティ式システムが閉じられ、式はすべてフレームワークの一部として提供されます。 式は、プロパティ システムにデータ バインディング、スタイル設定、または継承をハード コード化せず、フレームワーク内の後のレイヤーによって提供される理由です。  
  
 プロパティ システムは、プロパティ値の疎な格納も提供します。 オブジェクトは数十個のプロパティを持つ可能性があり、値のほとんどはデフォルト状態 (継承、スタイルなど) であるため、オブジェクトのすべてのインスタンスに定義されているすべてのプロパティのウェイトを完全に設定する必要はありません。  
  
 プロパティ システムの最後の新機能は、添付プロパティの概念です。 WPF 要素は、構成とコンポーネントの再利用の原則に基づいて構築されます。 多くの場合、(レイアウト要素のような) 要素を<xref:System.Windows.Controls.Grid>含む一部の要素は、子要素の動作を制御するために追加のデータを必要とします (行/列情報など)。 すべてのプロパティをすべての要素に関連付ける代わりに、すべてのオブジェクトに他のオブジェクトのプロパティ定義を提供できます。 これは、JavaScript の "展開" 機能に似ています。  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a>System.Windows.Media.Visual  
 システムが定義されている場合、次のステップは画面に描画されるピクセルを取得することです。 この<xref:System.Windows.Media.Visual>クラスは、ビジュアル オブジェクトのツリーを構築するために用意されており、各オブジェクトには、必要に応じて描画命令と、それらの命令 (クリッピング、変換など) のレンダリング方法に関するメタデータが含まれています。 <xref:System.Windows.Media.Visual>非常に軽量で柔軟性を持つように設計されているので、ほとんどの機能はパブリック API を公開することはなく、保護されたコールバック関数に大きく依存しています。  
  
 <xref:System.Windows.Media.Visual>は、WPF 合成システムへのエントリ ポイントです。 <xref:System.Windows.Media.Visual>は、マネージ API とアンマネージ ミルコアという 2 つのサブシステム間の接続ポイントです。  
  
 WPF は、milcore によって管理されているアンマネージ データ構造を走査してデータを表示します。 コンポジション ノードと呼ばれるこれらの構造体は、各ノードでレンダリング命令を持つ階層表示ツリーを表します。 下図の右側に示されているこのツリーは、メッセージング プロトコルを介してのみアクセスできます。  
  
 WPF をプログラミングする場合、<xref:System.Windows.Media.Visual>このメッセージング プロトコルを通じて構成ツリーに内部的に通信する要素と派生型を作成します。 WPF<xref:System.Windows.Media.Visual>の各ノードは、1 つ、どれも、または複数のコンポジション ノードを作成できます。  
  
 ![Windows Presentation Foundation ビジュアル ツリー。](./media/wpf-architecture2.PNG "wpf_architecture2")  
  
 ここで注目する非常に重要なアーキテクチャの詳細があります - ビジュアルのツリー全体と描画命令がキャッシュされています。 グラフィックス用語では、WPF は保持されたレンダリング システムを使用します。 これにより、ユーザー コードへのコールバックで合成システムがブロックされることなく、システムが高いリフレッシュ レートで再描画できます。 これにより、応答しないアプリケーションが表示されないようにできます。  
  
 図ではあまり分からないもう 1 つの重要な詳細は、システムが実際にどのように構成を実行するかを示しています。  
  
 User32 および GDI では、システムは即時モードクリッピング システムで動作します。 コンポーネントをレンダリングする必要がある場合、システムは、コンポーネントがピクセルに触れることができない範囲外のクリッピング境界を確立し、そのボックスにピクセルをペイントするようにコンポーネントに求められます。 このシステムは、何かが変更されたときに影響を受けるコンポーネントに触れるだけで、2つのコンポーネントが単一ピクセルの色に寄与しないため、メモリに制約のあるシステムでは非常にうまく機能します。  
  
 WPF は「画家のアルゴリズム」の描画モデルを使用します。 つまり、各コンポーネントをクリッピングする代わりに、各コンポーネントをディスプレイの背面から前面にレンダリングするように求められます。 これにより、各コンポーネントを前のコンポーネントの表示上にペイントできます。 このモデルの利点は、複雑で部分的に透明な形状を持つことができる点です。 今日の最新のグラフィックス ハードウェアでは、このモデルは比較的高速です (User32/ GDI が作成された場合はそうではありませんでした)。  
  
 前に述べたように、WPF の中心的な考え方は、より宣言的な"プロパティ中心"のプログラミング モデルに移行することです。 ビジュアルシステムでは、これは興味深い場所のカップルに表示されます。  
  
 まず、保持モードのグラフィックシステムについて考えると、これは実際には、強制的な DrawLine/DrawLine 型モデルからデータ指向モデルに移動しています – 新しいライン()/新しいライン() 。 このデータ ドリブン レンダリングへの移行により、描画命令に対する複雑な操作をプロパティを使用して表現できます。 派生元の型<xref:System.Windows.Media.Drawing>は、実質的にレンダリングのオブジェクト モデルです。  
  
 次に、アニメーション システムを評価すると、ほぼ完全に宣言的なアニメーションが表示されます。 開発者が次の場所や次の色を計算する代わりに、アニメーションをアニメーション オブジェクトのプロパティのセットとして表現できます。 これらのアニメーションは、開発者またはデザイナーの意図を表現でき (このボタンをここから 5 秒後にそこに移動)、システムはそれを実現するための最も効率的な方法を決定できます。  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a>System.Windows.UIElement  
 <xref:System.Windows.UIElement>は、レイアウト、入力、イベントなどのコア サブシステムを定義します。  
  
 レイアウトは、WPF の中心的な概念です。 多くのシステムには、固定のレイアウト モデルのセット (HTML はレイアウト用の 3 つのモデル、フロー、絶対、およびテーブルをサポートしています) か、レイアウトのモデルがありません (User32 は実際には絶対配置のみをサポートします)。 WPF は、開発者やデザイナーが、命令型ロジックではなくプロパティ値によって駆動できる、柔軟で拡張可能なレイアウト モデルを必要とするという前提から始まりました。 <xref:System.Windows.UIElement>レベルでは、レイアウトの基本契約が導入されます – とパス<xref:System.Windows.UIElement.Arrange%2A>を持<xref:System.Windows.UIElement.Measure%2A>つ2つのフェーズモデル。  
  
 <xref:System.Windows.UIElement.Measure%2A>を使用すると、コンポーネントがどの程度のサイズを取り、使用するかを決定できます。 親要素が子要素に<xref:System.Windows.UIElement.Arrange%2A>対して、その最適な位置とサイズを決定するために複数回測定するように要求する場合が多いため、これは別のフェーズです。 親要素が子要素に測定を求めるという事実は、WPF のもう 1 つの重要な哲学を示しています。 WPF のすべてのコントロールは、コンテンツの自然なサイズにサイズを設定する機能をサポートします。 これにより、ローカライズが大幅に容易になり、要素のサイズが変更されるに従って要素の動的なレイアウトが可能になります。 フェーズ<xref:System.Windows.UIElement.Arrange%2A>を使用すると、親が各子の最終的なサイズを配置して決定できます。  
  
 多くの場合、WPF の出力側<xref:System.Windows.Media.Visual>と関連するオブジェクトについて話すのに多くの時間が費やされます。 しかし、入力側にも膨大な量のイノベーションがあります。 おそらく、WPF の入力モデルで最も根本的な変更は、入力イベントがシステムを通じてルーティングされる一貫したモデルです。  
  
 入力は、カーネル モードのデバイス ドライバーのシグナルとして発生し、Windows カーネルと User32 を含む複雑なプロセスを通じて正しいプロセスとスレッドにルーティングされます。 入力に対応する User32 メッセージが WPF にルーティングされると、WPF の未加工の入力メッセージに変換され、ディスパッチャーに送信されます。 WPF では、生の入力イベントを複数の実際のイベントに変換できるため、配信が保証された低レベルのシステムで "MouseEnter" などの機能を実装できます。  
  
 各入力イベントは、少なくとも 2 つのイベント ("プレビュー" イベントと実際のイベント) に変換されます。 WPF のすべてのイベントは、要素ツリーを通じてルーティングするという概念を持ちます。 イベントは、ツリー上のターゲットからルートまで移動する場合は"バブル"と言われ、ルートから始まり、ターゲットまで移動すると「トンネル」といわれます。 入力プレビュー イベント トンネルを使用して、ツリー内の任意の要素がイベントをフィルタまたはアクションを実行できるようにします。 通常の (プレビュー以外の) イベントは、ターゲットからルートまでバブルします。  
  
 トンネルとバブルのフェーズの間で分割すると、キーボード アクセラレータなどの機能の実装は、複合世界で一貫した方法で動作します。 User32 では、サポートするすべてのアクセラレータを含む単一のグローバル テーブルを持つことでキーボード アクセラレータを実装します (Ctrl + N マッピングを "New")。 アプリケーションのディスパッチャーで **、TranslateAccelerator**を呼び出して User32 の入力メッセージをスニッフィングし、登録されたアクセラレータに一致するものがあるかどうかを判断します。 WPF では、システムが完全に "構成可能" であるため、この機能は機能しません。 入力用にこの 2 つのフェーズ モデルを使用すると、コンポーネントは独自の "TranslateAccelerator" を実装できます。  
  
 さらにこの 1 つの手順<xref:System.Windows.UIElement>を実行するには、コマンド バインドの概念も紹介します。 WPF コマンド システムを使用すると、開発者はコマンド エンド ポイント (実装するもの)<xref:System.Windows.Input.ICommand>の観点から機能を定義できます。 コマンド バインディングを使用すると、入力ジェスチャ (Ctrl+N) とコマンド (New) の間のマッピングを要素で定義できます。 入力ジェスチャとコマンド定義の両方が拡張可能で、使用時に一緒に配線できます。 これにより、たとえば、エンド ユーザーがアプリケーション内で使用するキー バインドをカスタマイズできるようになるのは簡単です。  
  
 このトピックでは、WPF の "コア" 機能 - プレゼンテーションコア アセンブリに実装されている機能が焦点となっています。 WPF を構築する場合、基本部分 **([メジャー]** や **[配置]** を使用したレイアウトのコントラクトなど) とフレームワークの各<xref:System.Windows.Controls.Grid>部分 (特定のレイアウトの実装など) を明確に分離することが望ましい結果でした。 目標は、必要に応じて外部の開発者が独自のフレームワークを作成できるように、スタック内の低い拡張性ポイントを提供することでした。  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a>System.Windows.FrameworkElement  
 <xref:System.Windows.FrameworkElement>2つの異なる方法で見ることができます。 WPF の下位層で導入されたサブシステムに対する一連のポリシーとカスタマイズを紹介します。 また、新しいサブシステムのセットも導入します。  
  
 導入される<xref:System.Windows.FrameworkElement>主なポリシーは、アプリケーションのレイアウトに関するものです。 <xref:System.Windows.FrameworkElement>によって導入された<xref:System.Windows.UIElement>基本的なレイアウト コントラクトに基づいており、レイアウト作成者が一貫したプロパティ駆動型レイアウト セマンティクスのセットを持つことを容易にするレイアウトの "スロット" の概念を追加します。 、 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>、、<xref:System.Windows.FrameworkElement.MinWidth%2A>および<xref:System.Windows.FrameworkElement.Margin%2A>(いくつかの名前を付ける) などのプロパティは<xref:System.Windows.FrameworkElement>、レイアウト コンテナー内の一貫した動作から派生したすべてのコンポーネントを与えます。  
  
 <xref:System.Windows.FrameworkElement>また、WPF のコア 層に含まれる多くの機能に対する API の公開が容易になります。 たとえば、<xref:System.Windows.FrameworkElement>メソッドを使用してアニメーションに直接アクセス<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>できます。 A<xref:System.Windows.Media.Animation.Storyboard>は、プロパティのセットに対して複数のアニメーションをスクリプト化する方法を提供します。  
  
 最も重要なのは<xref:System.Windows.FrameworkElement>、データ バインディングとスタイルです。  
  
 WPF のデータ バインディング サブシステムは、Windows フォームまたはASP.NETを使用してアプリケーション[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]を作成したユーザーには、比較的よく知っている必要があります。 これらの各システムでは、特定の要素の 1 つ以上のプロパティをデータにバインドする簡単な方法があります。 WPF では、プロパティ バインディング、変換、およびリスト のバインドを完全にサポートしています。  
  
 WPF のデータ バインディングの最も興味深い機能の 1 つは、データ テンプレートの導入です。 データ テンプレートを使用すると、データの視覚化方法を宣言によって指定できます。 データにバインドできるカスタム ユーザー インターフェイスを作成する代わりに、問題を回避して、作成される表示をデータで決定させることができます。  
  
 スタイル設定は、実際には軽量のデータ バインディングです。 スタイル設定を使用すると、共有定義のプロパティのセットを要素の 1 つ以上のインスタンスにバインドできます。 スタイルは、明示的な参照 (プロパティを<xref:System.Windows.FrameworkElement.Style%2A>設定) によって要素に適用されるか、またはスタイルを要素の CLR 型に関連付けることによって暗黙的に適用されます。  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a>System.Windows.Controls.Control  
 コントロールの最も重要な機能は、テンプレートです。 WPF のコンポジション システムを保持モード レンダリング システムと考える場合、テンプレートを使用すると、コントロールはパラメーター化された宣言的な方法でレンダリングを記述できます。 A<xref:System.Windows.Controls.ControlTemplate>は、コントロールによって提供されるプロパティへのバインディングを使用して、子要素のセットを作成するスクリプトにすぎません。  
  
 <xref:System.Windows.Controls.Control>には、<xref:System.Windows.Controls.Control.Foreground%2A>いくつかの名前を付けるストック<xref:System.Windows.Controls.Control.Background%2A><xref:System.Windows.Controls.Control.Padding%2A>プロパティのセット 、、つまり、テンプレート作成者がコントロールの表示をカスタマイズするために使用できます。 コントロールの実装は、データ モデルと対話モデルを提供します。 インタラクション モデルは、コマンドのセット (ウィンドウの Close など) と入力ジェスチャへのバインド (ウィンドウの上隅にある赤い X をクリックするなど) を定義します。 データ モデルには、インタラクション モデルをカスタマイズするか、テンプレートによって決定される表示をカスタマイズするためのプロパティのセットが用意されています。  
  
 この分割は、データ モデル (プロパティ)、相互作用モデル (コマンドとイベント)、および表示モデル (テンプレート) で、コントロールの外観と動作を完全にカスタマイズできます。  
  
 コントロールのデータ モデルの一般的な側面は、コンテンツ モデルです。 のような<xref:System.Windows.Controls.Button>コントロールを見ると、"Content" という名前のプロパティが type<xref:System.Object>であることがわかります。 Windows フォームおよびASP.NETでは、通常、このプロパティは文字列になりますが、ボタンに配置できるコンテンツの種類が制限されます。 ボタンのコンテンツは、単純な文字列、複雑なデータ オブジェクト、または要素ツリー全体のいずれかです。 データオブジェクトの場合、データテンプレートは、表示を構築するために使用されます。  
  
<a name="Summary"></a>
## <a name="summary"></a>まとめ  
 WPF は、動的なデータ ドリブン 表示システムを作成できるように設計されています。 システムのすべての部分は、動作を駆動するプロパティ セットを通じてオブジェクトを作成するように設計されています。 データ バインディングはシステムの基本的な部分であり、すべての層に統合されています。  
  
 従来のアプリケーションでは、ディスプレイを作成してから、データにバインドします。 WPF では、コントロールに関するあらゆる側面が、ある種のデータ バインディングによって生成されます。 ボタン内に見つかったテキストは、ボタンの内部に構成されたコントロールを作成し、その表示をボタンの content プロパティにバインドすることによって表示されます。  
  
 WPF ベースのアプリケーションの開発を開始すると、非常に身近な感じがするはずです。 Windows フォームやASP.NETを使用する場合とほぼ同じ方法で、プロパティの設定、オブジェクトの使用、およびデータ バインドを行うことができます。 WPF のアーキテクチャについて詳しく調べると、データをアプリケーションのコア ドライバーとして基本的に扱う、より豊富なアプリケーションを作成する可能性が高いことがわかります。  
  
## <a name="see-also"></a>関連項目

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [データバインディングの概要](../../../desktop-wpf/data/data-binding-overview.md)
- [レイアウト](layout.md)
- [アニメーションの概要](../graphics-multimedia/animation-overview.md)
