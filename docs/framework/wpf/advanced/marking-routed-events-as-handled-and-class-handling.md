---
title: ルーティング イベントの処理済みとしてのマーキング、およびクラス処理
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401041"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="4017e-102">ルーティング イベントの処理済みとしてのマーキング、およびクラス処理</span><span class="sxs-lookup"><span data-stu-id="4017e-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="4017e-103">ルーティング イベントのハンドラーでは、イベント データ内で、イベントを処理済みとしてマークできます。</span><span class="sxs-lookup"><span data-stu-id="4017e-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="4017e-104">イベントを処理すると、ルートが事実上短縮されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="4017e-105">クラス処理は、ルーティング イベントでサポートされているプログラミング概念です。</span><span class="sxs-lookup"><span data-stu-id="4017e-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="4017e-106">クラス ハンドラーでは、特定のルーティング イベントをクラス レベルのハンドラーで処理することができます。このハンドラーは、そのクラスのどのインスタンスのどのインスタンス ハンドラーよりも先に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="4017e-107">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="4017e-107">Prerequisites</span></span>  
 <span data-ttu-id="4017e-108">このトピックでは、「[ルーティング イベントの概要](routed-events-overview.md)」で紹介した概念を詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="4017e-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="4017e-109">イベントを処理済みとしてマークする場合</span><span class="sxs-lookup"><span data-stu-id="4017e-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="4017e-110">ルーティング イベントのイベント データで <xref:System.Windows.RoutedEventArgs.Handled%2A> プロパティの値を `true` に設定することを、"イベントを処理済みとしてマークする" と言います。</span><span class="sxs-lookup"><span data-stu-id="4017e-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="4017e-111">アプリケーションの作成者や、既存のルーティング イベントへの応答や新しいルーティング イベントの実装を行うコントロールの作成者が、どのような場合にルーティング イベントを処理済みとしてマークするかについては、絶対的な規則はありません。</span><span class="sxs-lookup"><span data-stu-id="4017e-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="4017e-112">ほとんどの場合、ルーティング イベントのイベント データで運ばれる "処理済み" の概念は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API で公開されているさまざまなルーティング イベントやカスタム ルーティング イベントに対するアプリケーションの応答のために、限定的なプロトコルとして使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="4017e-113">また、"処理済み" の問題のもう 1 つの考え方があります。ルーティング イベントに対するコードの応答が重要かつ比較的完全な形で行われた場合は、一般にルーティング イベントを処理済みとしてマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="4017e-114">通常は、1 つのルーティング イベント発生に対して、異なるハンドラー実装を必要とする複数の重要な応答があることは好ましくありません。</span><span class="sxs-lookup"><span data-stu-id="4017e-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="4017e-115">複数の応答が必要な場合は、ルーティング イベント システムを使用して転送するのではなく、単一のハンドラー内で一連のアプリケーション ロジックとして必要なコードを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="4017e-116">また、何が "重要" と考えるかも主観的なもので、アプリケーションやコードに応じて異なります。</span><span class="sxs-lookup"><span data-stu-id="4017e-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="4017e-117">一般的に、"重要な応答" の例には、フォーカスの設定、パブリック状態の変更、ビジュアル表現に影響するプロパティの設定、他の新しいイベントの発生などがあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="4017e-118">重要でない応答の例には、プライベート状態の変更 (ビジュアル表現への影響やプログラムによる表現を伴わない変更) や、イベントのログなどがあります。イベントの引数を確認して応答しないように選択する場合もこれに含まれます。</span><span class="sxs-lookup"><span data-stu-id="4017e-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="4017e-119">ルーティング イベントのこの "処理済み" 状態を使用するための "重要な応答" モデルは、ルーティング イベント システムの動作によって支えられています。[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] や <xref:System.Windows.UIElement.AddHandler%2A> の一般的なシグネチャで追加されるハンドラーは、イベント データが既に処理済みとしてマークされているルーティング イベントに対しては呼び出されないためです。</span><span class="sxs-lookup"><span data-stu-id="4017e-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="4017e-120">イベント ルート上の早い段階の処理によって処理済みとしてマークされたルーティング イベントを処理するためには、`handledEventsToo` パラメーター バージョン (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) を使ってハンドラーを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="4017e-121">場合によっては、コントロール自体が特定のルーティング イベントを処理済みとしてマークすることもあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="4017e-122">ルーティング イベントが処理済みとマークされた場合、ルーティング イベントへの応答としてコントロールが行ったアクションは、コントロールの実装の一部として重要、完全なもので、そのイベントにはそれ以上の処理は必要ないと、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの作成者が判断したことを表しています。</span><span class="sxs-lookup"><span data-stu-id="4017e-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="4017e-123">これは通常、イベントのクラス ハンドラーを追加するか、基底クラスに存在するクラス ハンドラー仮想メソッドの 1 つをオーバーライドすることによって行われます。</span><span class="sxs-lookup"><span data-stu-id="4017e-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="4017e-124">このイベント処理は、必要に応じて回避することもできます。詳細については、このトピックの「[コントロールによるイベント抑制の回避](#WorkingAroundEventSuppressionByControls)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4017e-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="4017e-125">"プレビュー" (トンネル) イベントとバブル イベントのイベント処理</span><span class="sxs-lookup"><span data-stu-id="4017e-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="4017e-126">プレビュー ルーティング イベントは、要素ツリーのトンネル ルートをたどるイベントです。</span><span class="sxs-lookup"><span data-stu-id="4017e-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="4017e-127">名前付け規則に含まれる "Preview" は、対応するバブル ルーティング イベントより前にプレビュー (トンネル) ルーティング イベントが発生するという入力イベントの原則を表しています。</span><span class="sxs-lookup"><span data-stu-id="4017e-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="4017e-128">また、トンネルとバブルのペアを持つ入力ルーティング イベントは、別個の処理ロジックを持ちます。</span><span class="sxs-lookup"><span data-stu-id="4017e-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="4017e-129">トンネル/プレビュー ルーティング イベントがイベント リスナーによって処理済みとしてマークされた場合、バブル ルーティング イベントは処理済みとしてマークされます。これは、バブル ルーティング イベントのすべてのリスナーがそのイベントを受け取る前であっても変わりません。</span><span class="sxs-lookup"><span data-stu-id="4017e-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="4017e-130">トンネル ルーティング イベントとバブル ルーティング イベントは、厳密には別個のイベントですが、この動作を実現するために、同じイベント データのインスタンスをあえて共有しています。</span><span class="sxs-lookup"><span data-stu-id="4017e-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="4017e-131">このトンネル ルーティング イベントとバブル ルーティング イベントの間の関連は、任意の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスで宣言されたルーティング イベントをそのクラスが発生させる方法の内部実装によって実現されます。これは入力ルーティング イベントのペアにも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="4017e-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="4017e-132">このクラスレベルの実装が存在しなければ、名前付けスキームを共有するトンネル ルーティング イベントとバブル ルーティング イベントの間に関連はありません。つまり、そのような実装がなければ、それらは 2 つのまったく別のルーティング イベントとなり、順番に発生することや、イベント データを共有することはなくなります。</span><span class="sxs-lookup"><span data-stu-id="4017e-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="4017e-133">カスタム クラスでトンネル/バブル入力ルーティング イベントのペアを実装する方法の詳細については、「[方法 : カスタム ルーティング イベントを作成する](how-to-create-a-custom-routed-event.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4017e-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="4017e-134">クラス ハンドラーとインスタンス ハンドラー</span><span class="sxs-lookup"><span data-stu-id="4017e-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="4017e-135">ルーティング イベントでは、クラス リスナーとインスタンス リスナーという 2 種類のイベント リスナーが考慮されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="4017e-136">クラス リスナーが存在するのは、型の静的コンストラクターで特定の <xref:System.Windows.EventManager> API である <xref:System.Windows.EventManager.RegisterClassHandler%2A> が呼び出されたか、要素の基底クラスのクラス ハンドラー仮想メソッドがオーバーライドされた場合です。</span><span class="sxs-lookup"><span data-stu-id="4017e-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="4017e-137">インスタンス リスナーは、<xref:System.Windows.UIElement.AddHandler%2A> の呼び出しによってルーティング イベントに対応する 1 つ以上のハンドラーがアタッチされた特定のクラス インスタンスおよび要素です。</span><span class="sxs-lookup"><span data-stu-id="4017e-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="4017e-138">既存の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ルーティング イベントでは、共通言語ランタイム (CLR) のイベント ラッパーである add{} および remove{} のそのイベントでの実装の一部として、<xref:System.Windows.UIElement.AddHandler%2A> が呼び出されます。属性構文によってイベント ハンドラーをアタッチする簡単な [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] のメカニズムも、この方法で実現されています。</span><span class="sxs-lookup"><span data-stu-id="4017e-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="4017e-139">したがって、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] の簡単な使用でも、最終的には <xref:System.Windows.UIElement.AddHandler%2A> の呼び出しと同じことになります。</span><span class="sxs-lookup"><span data-stu-id="4017e-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="4017e-140">登録されたハンドラー実装があるかどうか、ビジュアル ツリー内の各要素がチェックされます。</span><span class="sxs-lookup"><span data-stu-id="4017e-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="4017e-141">ハンドラーはルート全体で呼び出される可能性があり、呼び出される順序は、ルーティング イベントのルーティング戦略によってあらかじめ決まっています。</span><span class="sxs-lookup"><span data-stu-id="4017e-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="4017e-142">たとえば、バブル ルーティング イベントでは、ルーティング イベントを発生させた要素と同じ要素にアタッチされているハンドラーが最初に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="4017e-143">その後、ルーティング イベントは次の親要素に "浮上" します。アプリケーションのルート要素に到達するまで、これが繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="4017e-144">バブル ルートのルート要素の視点から見ると、イベント引数を処理済みとしてマークするハンドラーが、クラス処理や、よりルーティング イベント ソースに近い要素によって呼び出された場合、ルート要素のハンドラーは呼び出されません。これにより、イベント ルートは、ルート要素に到達する前に事実上短縮されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="4017e-145">しかし、イベント ルートが完全に停止するわけではありません。クラス ハンドラーやインスタンス ハンドラーによってルーティング イベントが処理済みとしてマークされた場合にも呼び出されるように、特別な条件を使用してハンドラーが追加されている可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="4017e-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="4017e-146">詳細については、このトピックで後述する「[イベントが処理済みとしてマークされていても呼び出されるインスタンス ハンドラーの追加](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4017e-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="4017e-147">イベント ルートより深いレベルでは、クラスの特定のインスタンスに対して、複数のクラス ハンドラーが作用している可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="4017e-148">なぜなら、ルーティング イベントのクラス処理モデルでは、クラスの階層構造に属するすべてのクラスが、各ルーティング イベントに対して独自のクラス ハンドラーをそれぞれ登録できるためです。</span><span class="sxs-lookup"><span data-stu-id="4017e-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="4017e-149">各クラス ハンドラーは内部ストアに追加され、アプリケーションのイベント ルートが構築されたときには、すべてのクラス ハンドラーがイベント ルートに追加されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="4017e-150">クラス ハンドラーは、最派生クラスのクラス ハンドラーが最初に呼び出され、以下それぞれの基底クラスのクラス ハンドラーが順に呼び出されていくように、ルートに追加されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="4017e-151">一般に、クラス ハンドラーは、既に処理済みとしてマークされたルーティング イベントにも反応するようには登録されません。</span><span class="sxs-lookup"><span data-stu-id="4017e-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="4017e-152">したがって、このクラス処理のしくみでは、次の 2 つの方法のいずれかを実現できます。</span><span class="sxs-lookup"><span data-stu-id="4017e-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="4017e-153">派生クラスでは、基底クラスから継承されたクラス処理を補完するために、ルーティング イベントを処理済みとしてマークしないハンドラーを追加することができます。これは、派生クラスのハンドラーより後に基底クラスのハンドラーが呼び出されるためです。</span><span class="sxs-lookup"><span data-stu-id="4017e-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="4017e-154">派生クラスでは、ルーティング イベントを処理済みとしてマークするクラス ハンドラーを追加することで、基底クラスのクラス処理を置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="4017e-155">この方法を使用する場合には注意が必要です。外観、状態のロジック、入力処理、コマンド処理などの部分で、基底コントロールが意図した設計と変わってしまう可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="4017e-156">コントロールの基底クラスでのルーティング イベントのクラス処理</span><span class="sxs-lookup"><span data-stu-id="4017e-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="4017e-157">イベント ルートの各要素ノードでは、クラス リスナーに、その要素のどのインスタンス リスナーよりも先にルーティング イベントに応答する機会が与えられます。</span><span class="sxs-lookup"><span data-stu-id="4017e-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="4017e-158">このため、特定のコントロール クラス実装でそれ以上伝達されないようにルーティング イベントを抑制したり、ルーティング イベントに対してそのクラスの機能である特別な処理を提供したりするために、クラス ハンドラーが使用されることもあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="4017e-159">たとえば、クラス固有の独自のイベントを発生させて、特定のクラスのコンテキストでユーザー入力の状態が持つ意味についてより具体的な情報をそのイベントに含めることができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="4017e-160">この場合、そのクラス実装によって、より一般的なルーティング イベントが処理済みとしてマークされます。</span><span class="sxs-lookup"><span data-stu-id="4017e-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="4017e-161">通常、クラス ハンドラーが追加されるときは、共有しているイベント データが既に処理済みとしてマークされているルーティング イベントに対してはハンドラーが呼び出されないように設定されます。ただし、例外的なケースのために、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> には、ルーティング イベントが処理済みとしてマークされている場合にも呼び出されるようにクラス ハンドラーを登録するシグネチャも用意されています。</span><span class="sxs-lookup"><span data-stu-id="4017e-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="4017e-162">クラス ハンドラー仮想メソッド</span><span class="sxs-lookup"><span data-stu-id="4017e-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="4017e-163">一部の要素 (特に、<xref:System.Windows.UIElement> などの基底要素) では、その要素の一連のパブリック ルーティング イベントに対応する空の "On\*Event" および "OnPreview\*Event" という仮想メソッドが公開されています。</span><span class="sxs-lookup"><span data-stu-id="4017e-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="4017e-164">これらの仮想メソッドをオーバーライドすれば、そのルーティング イベントに対するクラス ハンドラーを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="4017e-165">基底要素クラスでは、上で説明したように <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> を使用して、これらの仮想メソッドが、各ルーティング イベントのクラス ハンドラーとして登録されています。</span><span class="sxs-lookup"><span data-stu-id="4017e-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="4017e-166">On\*Event 仮想メソッドを使用すると、対応するルーティング イベントのクラス処理の実装が大幅に簡略化され、それぞれの型の静的コンストラクターで特別な初期化を行う必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="4017e-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="4017e-167">たとえば、<xref:System.Windows.UIElement.OnDragEnter%2A> 仮想メソッドをオーバーライドすることによって、<xref:System.Windows.UIElement> の任意の派生クラスに <xref:System.Windows.UIElement.DragEnter> イベントのクラス処理を追加することができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="4017e-168">オーバーライドの中では、ルーティング イベントを処理する、他のイベントを発生させる、インスタンスの要素プロパティを変更する可能性があるクラス固有のロジックを開始するなどのアクションや、これらのアクションの任意の組み合わせを実行できます。</span><span class="sxs-lookup"><span data-stu-id="4017e-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="4017e-169">一般に、こうしたオーバーライドでは、イベントを処理済みとしてマークする場合でも、基本実装を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="4017e-170">これらの仮想メソッドは基底クラスで定義されているため、基本実装を呼び出すことを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4017e-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="4017e-171">プロテクト仮想メソッドの標準的な呼び出しパターンでは、それぞれの仮想メソッドから、基本実装を呼び出す形になります。これは、ルーティング イベントのクラス処理の固有のしくみ (任意のインスタンスに対して、最派生クラスのハンドラーから基底クラスのハンドラーへという順で、クラス階層構造のすべてのクラスのクラス ハンドラーが呼び出される) を実質的に置き換え、同様の処理を実現することになります。</span><span class="sxs-lookup"><span data-stu-id="4017e-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="4017e-172">基本実装の呼び出しを省略するのは、基底クラスの処理ロジックを意図的に変更する必要がある場合だけにしてください。</span><span class="sxs-lookup"><span data-stu-id="4017e-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="4017e-173">基本実装をオーバーライド コードの前と後のどちらで呼び出すかは、それぞれの実装の性質によって異なります。</span><span class="sxs-lookup"><span data-stu-id="4017e-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="4017e-174">入力イベント クラスの処理</span><span class="sxs-lookup"><span data-stu-id="4017e-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="4017e-175">すべてのクラス ハンドラー仮想メソッドは、すべての共有イベント データが処理済みとしてマークされていない場合にのみ呼び出されるように登録されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="4017e-176">また、入力イベントに固有のしくみとして、一般に、トンネル バージョンとバブル バージョンのイベントが順番に発生し、両方のバージョンでイベント データが共有されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="4017e-177">このため、トンネル バージョンとバブル バージョンの入力イベント用のクラス ハンドラーの特定のペアについて、イベントがすぐに処理済みとしてマークされないようにしたい場合があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="4017e-178">イベントを処理済みとしてマークするようにトンネル クラス処理の仮想メソッドを実装すると、バブル クラスのハンドラーが呼び出されなくなります (トンネル イベントやバブル イベントに対して通常の方法で登録したインスタンス ハンドラーも呼び出されません)。</span><span class="sxs-lookup"><span data-stu-id="4017e-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="4017e-179">ノードでのクラス処理が完了すると、インスタンス リスナーが考慮されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="4017e-180">イベントが処理済みとしてマークされていても呼び出されるインスタンス ハンドラーの追加</span><span class="sxs-lookup"><span data-stu-id="4017e-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="4017e-181"><xref:System.Windows.UIElement.AddHandler%2A> メソッドには、既に他のハンドラーによってイベント データが調整され、イベントが処理済みとしてマークされていても、イベントがルートでその処理要素に到達するたびに必ずイベント システムによって呼び出されるハンドラーを追加できる、特殊なオーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="4017e-182">この方法は通常は使用されません。</span><span class="sxs-lookup"><span data-stu-id="4017e-182">This is not typically done.</span></span> <span data-ttu-id="4017e-183">一般にハンドラーは、イベントが要素ツリーのどこで処理されるかに関係なく、そのイベントによって影響を受ける可能性があるアプリケーション コードのすべての領域を調整するように作成することができます。これは、複数の結果が求められる場合でも同じです。</span><span class="sxs-lookup"><span data-stu-id="4017e-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="4017e-184">また、通常は、そのイベントに応答する必要がある要素は実際に 1 つだけなので、適切なアプリケーション ロジックが既に発生していることになります。</span><span class="sxs-lookup"><span data-stu-id="4017e-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="4017e-185">しかし、イベントが要素ツリーやコントロール複合の他の要素によって既に処理済みとしてマークされていても、要素ツリーのもっと上 (ルートによってはもっと下) にある他の要素のハンドラーを呼び出す必要がある場合もあります。そうした例外的なケースに対しては、`handledEventsToo` オーバーロードを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="4017e-186">処理済みのイベントを未処理としてマークする場合</span><span class="sxs-lookup"><span data-stu-id="4017e-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="4017e-187">一般には、処理済みとしてマークされているルーティング イベントを未処理としてマークする (<xref:System.Windows.RoutedEventArgs.Handled%2A> の設定を `false` に戻す) ことはお勧めしません。これは、`handledEventsToo` で動作するハンドラーの場合も同じです。</span><span class="sxs-lookup"><span data-stu-id="4017e-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="4017e-188">しかし、一部の入力イベントでは、高レベルのイベント表現と低レベルのイベント表現が重複することがあります。ツリー内のある位置では高レベルのイベントが取得され、別の位置では低レベルのイベントが取得される場合です。</span><span class="sxs-lookup"><span data-stu-id="4017e-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="4017e-189">たとえば、子要素で高レベルのキー イベント (<xref:System.Windows.UIElement.TextInput> など) がリッスンされており、親要素で低レベルのイベント (<xref:System.Windows.UIElement.KeyDown> など) がリッスンされているとします。</span><span class="sxs-lookup"><span data-stu-id="4017e-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="4017e-190">親要素が低レベルのイベントを処理した場合、直感的には子要素が先にイベントを処理するはずであるにもかかわらず、高レベルのイベントが子要素で抑制されてしまうことがあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="4017e-191">このような状況では、親要素と子要素の両方に低レベルのイベントのハンドラーを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="4017e-192">この場合、子要素のハンドラー実装によって低レベルのイベントが処理済みとしてマークされる可能性がありますが、親要素のハンドラー実装がそれを再び未処理に設定して、ツリーのもっと上にある要素 (および高レベルのイベント) がそのイベントに応答できるようにします。</span><span class="sxs-lookup"><span data-stu-id="4017e-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="4017e-193">この状況は通常はあまりありません。</span><span class="sxs-lookup"><span data-stu-id="4017e-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="4017e-194">コントロール複合の入力イベントの意図的な抑制</span><span class="sxs-lookup"><span data-stu-id="4017e-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="4017e-195">ルーティング イベントのクラス処理は、主に入力イベントと複合コントロールに対して使用されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="4017e-196">複合コントロールは、その名のとおり、複数の実用的なコントロールまたはコントロールの基底クラスで構成されています。</span><span class="sxs-lookup"><span data-stu-id="4017e-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="4017e-197">コントロールを作成する際に、それらの各サブコンポーネントで発生するすべての入力イベントを 1 つにまとめて、コントロール全体が 1 つのイベント ソースとしてイベントを報告するように作る場合があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="4017e-198">また、コンポーネントからのイベントを完全に抑制する場合や、コンポーネントで定義された別のイベント (より多くの情報を含むイベントや、より具体的な動作を表すイベント) に置き換える場合もあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="4017e-199">ここでは、コンポーネント作成者ならだれもが目にする典型的な例として、マウス イベントが [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] の <xref:System.Windows.Controls.Button> によって処理され、すべてのボタンに含まれる直感的なイベントである <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントに最終的に対応付けられるしくみを見てみます。</span><span class="sxs-lookup"><span data-stu-id="4017e-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="4017e-200"><xref:System.Windows.Controls.Button> 基底クラス (<xref:System.Windows.Controls.Primitives.ButtonBase>) は、<xref:System.Windows.Controls.Control> から派生し、Control は <xref:System.Windows.FrameworkElement> と <xref:System.Windows.UIElement> から派生します。コントロールの入力の処理に必要なイベント インフラストラクチャの大半は、<xref:System.Windows.UIElement> のレベルにあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="4017e-201">具体的に言うと、<xref:System.Windows.UIElement> では、その境界内でマウス カーソルのヒット テストを処理する一般的な <xref:System.Windows.Input.Mouse> イベントが処理され、ほとんどの一般的なボタン アクション (<xref:System.Windows.UIElement.MouseLeftButtonDown> など) のための個々のイベントが提供されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="4017e-202">また、<xref:System.Windows.UIElement> では、<xref:System.Windows.UIElement.MouseLeftButtonDown> の登録済みクラス ハンドラーとして、空の仮想メソッド <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> が提供され、<xref:System.Windows.Controls.Primitives.ButtonBase> によってそれがオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="4017e-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="4017e-203">同様に、<xref:System.Windows.Controls.Primitives.ButtonBase> では <xref:System.Windows.UIElement.MouseLeftButtonUp> に対してクラス ハンドラーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="4017e-204">イベント データが渡されるそのオーバーライドでは、<xref:System.Windows.RoutedEventArgs.Handled%2A> が `true` に設定されることで、<xref:System.Windows.RoutedEventArgs> インスタンスが処理済みとしてマークされます。その同じイベント データが残りのルートで使用され、他のクラス ハンドラーや、インスタンス ハンドラーや、イベント セッターに渡されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="4017e-205">また、<xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> のオーバーライドでは、次に <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントが生成されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="4017e-206">その結果、ほとんどのリスナーにとっては、<xref:System.Windows.UIElement.MouseLeftButtonDown> イベントと <xref:System.Windows.UIElement.MouseLeftButtonUp> イベントが "消滅" し、<xref:System.Windows.Controls.Primitives.ButtonBase.Click> に置き換えられたことになります。このイベントは、ボタンの複合の一部やまったく別の要素からではなく本当のボタンから発生したものとして認識されるため、より多くの意味を持つと言えます。</span><span class="sxs-lookup"><span data-stu-id="4017e-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="4017e-207">コントロールによるイベント抑制の回避</span><span class="sxs-lookup"><span data-stu-id="4017e-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="4017e-208">個々のコントロール内で行われるこのイベントの抑制の動作が、アプリケーションのイベント処理ロジックの全体的な目的の妨げになることがあります。</span><span class="sxs-lookup"><span data-stu-id="4017e-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="4017e-209">たとえば、何らかの理由で <xref:System.Windows.UIElement.MouseLeftButtonDown> のハンドラーがアプリケーションのルート要素に配置された場合、ボタンをマウスでクリックしても、ルート レベルの <xref:System.Windows.UIElement.MouseLeftButtonDown> ハンドラーや <xref:System.Windows.UIElement.MouseLeftButtonUp> ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="4017e-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="4017e-210">イベント自体は実際に "浮上" しました (既に説明したように、処理済みとしてマークされた後、イベント ルートは終了するのではなく、ルーティング イベント システムによってハンドラー呼び出しの動作が変更されます)。</span><span class="sxs-lookup"><span data-stu-id="4017e-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="4017e-211">ルーティング イベントがボタンに到達すると、より多くの意味を持つ <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントに置き換えるために、<xref:System.Windows.Controls.Primitives.ButtonBase> のクラス処理によって <xref:System.Windows.UIElement.MouseLeftButtonDown> が処理済みとしてマークされます。</span><span class="sxs-lookup"><span data-stu-id="4017e-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="4017e-212">その結果、ルートのさらに上にある標準の <xref:System.Windows.UIElement.MouseLeftButtonDown> ハンドラーは呼び出されなくなります。</span><span class="sxs-lookup"><span data-stu-id="4017e-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="4017e-213">このような状況でもハンドラーが呼び出されるようにするには 2 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="4017e-214">1 つ目は、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> の `handledEventsToo` シグネチャを使用して意図的にハンドラーを追加する方法です。</span><span class="sxs-lookup"><span data-stu-id="4017e-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="4017e-215">この方法には、イベント ハンドラーの追加をコードからしか行えず、マークアップからは行うことができないという制限があります。</span><span class="sxs-lookup"><span data-stu-id="4017e-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="4017e-216">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] でイベント属性の値としてイベント ハンドラー名を指定する単純な構文では、この動作は実現できません。</span><span class="sxs-lookup"><span data-stu-id="4017e-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="4017e-217">2 つ目の方法は、トンネル バージョンとバブル バージョンのルーティング イベントがペアになっている入力イベントでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="4017e-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="4017e-218">これらのルーティング イベントについて、対応するプレビュー/トンネル ルーティング イベントにハンドラーを追加することができます。</span><span class="sxs-lookup"><span data-stu-id="4017e-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="4017e-219">そのルーティング イベントはルートからトンネリングを開始するため、アプリケーション要素ツリーの先祖要素のレベルにプレビュー ハンドラーをアタッチしておけば、イベントがボタン クラス処理コードによってインターセプトされなくなります。</span><span class="sxs-lookup"><span data-stu-id="4017e-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="4017e-220">この方法を使用する場合は、プレビュー イベントを処理済みとしてマークする際に注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="4017e-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="4017e-221"><xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> をルート要素で処理する例で言うと、ハンドラー実装でイベントを <xref:System.Windows.RoutedEventArgs.Handled%2A> としてマークすると、実際には <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントが抑制されます。</span><span class="sxs-lookup"><span data-stu-id="4017e-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="4017e-222">通常これは望ましくない動作です。</span><span class="sxs-lookup"><span data-stu-id="4017e-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4017e-223">関連項目</span><span class="sxs-lookup"><span data-stu-id="4017e-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="4017e-224">プレビュー イベント</span><span class="sxs-lookup"><span data-stu-id="4017e-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="4017e-225">カスタム ルーティング イベントを作成する</span><span class="sxs-lookup"><span data-stu-id="4017e-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="4017e-226">ルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="4017e-226">Routed Events Overview</span></span>](routed-events-overview.md)
