---
title: 添付プロパティの概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: f4e8ea9fb0643a4a434bf20fa719c3fd2d01435b
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/14/2019
ms.locfileid: "74089332"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="edade-102">添付プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="edade-102">Attached Properties Overview</span></span>

<span data-ttu-id="edade-103">添付プロパティは、XAML によって定義された概念です。</span><span class="sxs-lookup"><span data-stu-id="edade-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="edade-104">添付プロパティは、任意のオブジェクトに設定可能なグローバル プロパティの型として使用されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="edade-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="edade-105">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] では通常、添付プロパティは従来のプロパティ "ラッパー" を含まない依存関係プロパティの特殊な形式として定義されています。</span><span class="sxs-lookup"><span data-stu-id="edade-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="edade-106">応募<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="edade-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="edade-107">このトピックでは、ユーザーが [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] クラスの既存の依存関係プロパティの使用という観点から依存関係プロパティを理解し、「[依存関係プロパティの概要](dependency-properties-overview.md)」トピックを通読していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="edade-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="edade-108">このトピックの例を実行するには、XAML について理解し、WPF アプリケーションの記述方法を理解しておく必要もあります。</span><span class="sxs-lookup"><span data-stu-id="edade-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="edade-109">添付プロパティを使用する理由<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="edade-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="edade-110">添付プロパティの目的の 1 つは、親要素に実際に定義されているプロパティに対する一意の値を、異なる子要素が指定できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="edade-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="edade-111">このシナリオの適用例として、子要素から親要素に、[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] での表示方法を通知させることがあります。</span><span class="sxs-lookup"><span data-stu-id="edade-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="edade-112">1つの例として、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="edade-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="edade-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> プロパティは、<xref:System.Windows.Controls.DockPanel> 自体ではなく、<xref:System.Windows.Controls.DockPanel>内に含まれる要素に設定されるように設計されているため、添付プロパティとして作成されます。</span><span class="sxs-lookup"><span data-stu-id="edade-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="edade-114"><xref:System.Windows.Controls.DockPanel> クラスは <xref:System.Windows.Controls.DockPanel.DockProperty>という名前の静的 <xref:System.Windows.DependencyProperty> フィールドを定義し、<xref:System.Windows.Controls.DockPanel.GetDock%2A> および <xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドを添付プロパティのパブリックアクセサーとして提供します。</span><span class="sxs-lookup"><span data-stu-id="edade-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="edade-115">アタッチされたプロパティ (XAML の)<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="edade-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="edade-116">XAML では、構文 *AttachedPropertyProvider*.*PropertyName* を使用して添付プロパティを設定します</span><span class="sxs-lookup"><span data-stu-id="edade-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="edade-117">XAML で <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> を設定する方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="edade-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="edade-118">使用方法は静的プロパティに似ていることに注意してください。name で指定されたインスタンスを参照するのではなく、添付プロパティを所有および登録する型 <xref:System.Windows.Controls.DockPanel> を常に参照します。</span><span class="sxs-lookup"><span data-stu-id="edade-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="edade-119">さらに、XAML の添付プロパティはマークアップに設定する属性であるため、設定操作にのみ関連性があります。</span><span class="sxs-lookup"><span data-stu-id="edade-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="edade-120">XAML でプロパティを直接取得することはできませんが、スタイルのトリガー (詳細については、「[スタイルとテンプレート](../controls/styling-and-templating.md)」を参照) などの値を比較するための間接的な機構があります。</span><span class="sxs-lookup"><span data-stu-id="edade-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="edade-121">WPF での添付プロパティの実装</span><span class="sxs-lookup"><span data-stu-id="edade-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="edade-122">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]では、UI プレゼンテーションに関連する WPF 型に存在する添付プロパティのほとんどは、依存関係プロパティとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="edade-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="edade-123">添付プロパティは XAML の概念ですが、依存関係プロパティは WPF の概念です。</span><span class="sxs-lookup"><span data-stu-id="edade-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="edade-124">WPF の添付プロパティは依存関係プロパティであるため、プロパティメタデータなどの依存関係プロパティの概念と、そのプロパティメタデータの既定値をサポートします。</span><span class="sxs-lookup"><span data-stu-id="edade-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="edade-125">所有する型によって添付プロパティがどのように使用されるか<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="edade-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="edade-126">添付プロパティはどのオブジェクトにも設定できますが、プロパティを設定したことによって自動的に意味のある結果が得られるわけでも、値が別のオブジェクトによって使用されるわけでもありません。</span><span class="sxs-lookup"><span data-stu-id="edade-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="edade-127">一般に、添付プロパティの目的は、想定されるさまざまなクラス階層または論理関係から生じるオブジェクトが、添付プロパティを定義する型に共通する情報をレポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="edade-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="edade-128">添付プロパティを定義する型は、一般的に次のいずれかのモデルに従っています。</span><span class="sxs-lookup"><span data-stu-id="edade-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="edade-129">添付プロパティを定義する型が、添付プロパティの値を設定する要素の親要素になるように設計されている。</span><span class="sxs-lookup"><span data-stu-id="edade-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="edade-130">この型の子オブジェクトは、一部のオブジェクト ツリー構造で内部ロジックを反復し、値を取得して、その値に対する処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="edade-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="edade-131">添付プロパティを定義する型が、想定されるさまざまな親要素およびコンテンツ モデルの子要素として使用される。</span><span class="sxs-lookup"><span data-stu-id="edade-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="edade-132">添付プロパティを定義する型が、サービスを表す。</span><span class="sxs-lookup"><span data-stu-id="edade-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="edade-133">その他の型は、添付プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="edade-133">Other types set values for the attached property.</span></span> <span data-ttu-id="edade-134">プロパティを設定する要素がサービスのコンテキストで評価されると、添付プロパティの値がサービス クラスの内部ロジックにより取得されます。</span><span class="sxs-lookup"><span data-stu-id="edade-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="edade-135">親定義の添付プロパティの例</span><span class="sxs-lookup"><span data-stu-id="edade-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="edade-136">WPF が添付プロパティを定義する最も一般的なシナリオは、親要素が子要素のコレクションをサポートし、さらに、各子要素に対して動作の詳細が個別に報告される動作を実装する場合です。</span><span class="sxs-lookup"><span data-stu-id="edade-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="edade-137"><xref:System.Windows.Controls.DockPanel> は <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 添付プロパティを定義し、<xref:System.Windows.Controls.DockPanel> レンダリングロジックの一部としてクラスレベルのコードを持つことができます (具体的には、<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> および <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>)。</span><span class="sxs-lookup"><span data-stu-id="edade-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="edade-138"><xref:System.Windows.Controls.DockPanel> インスタンスは、その直接の子要素のいずれかに <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>の値が設定されているかどうかを常に確認します。</span><span class="sxs-lookup"><span data-stu-id="edade-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="edade-139">設定されている場合は、その値が、その子要素に適用されるレンダリング ロジックの入力になります。</span><span class="sxs-lookup"><span data-stu-id="edade-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="edade-140">入れ子になった <xref:System.Windows.Controls.DockPanel> インスタンスはそれぞれ独自の直接の子要素のコレクションを処理しますが、その動作は <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 値を <xref:System.Windows.Controls.DockPanel> プロセスする方法に固有の実装です。</span><span class="sxs-lookup"><span data-stu-id="edade-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="edade-141">直接の親以外の要素に影響を与える添付プロパティを所有することは、理論上は可能です。</span><span class="sxs-lookup"><span data-stu-id="edade-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="edade-142"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 添付プロパティが、<xref:System.Windows.Controls.DockPanel> 親要素を持たない要素に設定されている場合は、エラーまたは例外は発生しません。</span><span class="sxs-lookup"><span data-stu-id="edade-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="edade-143">これは、グローバルプロパティ値が設定されていることを意味しますが、情報を使用できる現在の <xref:System.Windows.Controls.DockPanel> 親がありません。</span><span class="sxs-lookup"><span data-stu-id="edade-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="edade-144">アタッチされるプロパティ (コードの)<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="edade-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="edade-145">WPF の添付プロパティには、get/set アクセスを簡単にするための一般的な CLR "ラッパー" メソッドはありません。</span><span class="sxs-lookup"><span data-stu-id="edade-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="edade-146">これは、プロパティが設定されているインスタンスの場合、添付プロパティは必ずしも CLR 名前空間の一部ではないためです。</span><span class="sxs-lookup"><span data-stu-id="edade-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="edade-147">ただし、XAML の解析時に XAML プロセッサがその値を設定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="edade-148">有効な添付プロパティの使用をサポートするには、添付プロパティの所有者の型が**Get_PropertyName_** と**Set_PropertyName_** の形式で専用のアクセサーメソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="edade-149">この専用のアクセサー メソッドは、コード内の添付プロパティの取得/設定でも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="edade-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="edade-150">コードの観点では、添付プロパティはプロパティ アクセサーではなくメソッド アクセサーを含むバッキング フィールドに似ており、そのバッキング フィールドは特に定義することなくすべてのオブジェクトに存在することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="edade-151">次の例は、コードに添付プロパティを設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="edade-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="edade-152">この例では、`myCheckBox` は <xref:System.Windows.Controls.CheckBox> クラスのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="edade-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="edade-153">XAML の場合と同様に、コードの3行目で `myDockPanel` の子要素として `myCheckBox` がまだ追加されていない場合、コードの4行目では例外は生成されませんが、プロパティ値は <xref:System.Windows.Controls.DockPanel> 親と対話しないため、何もない。</span><span class="sxs-lookup"><span data-stu-id="edade-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="edade-154">子要素に設定された <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 値だけが <xref:System.Windows.Controls.DockPanel> 親要素の存在と組み合わせられると、レンダリングされたアプリケーションで有効な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="edade-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="edade-155">(この場合、添付プロパティを設定してからツリーに接続するか、</span><span class="sxs-lookup"><span data-stu-id="edade-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="edade-156">ツリーに接続してから添付プロパティを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="edade-157">どちらの操作でも、結果は同じです。)</span><span class="sxs-lookup"><span data-stu-id="edade-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="edade-158">添付プロパティのメタデータ<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="edade-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="edade-159">プロパティを登録するときに、プロパティがレンダリングや測定などに影響するかどうかなど、プロパティの特性を指定するように <xref:System.Windows.FrameworkPropertyMetadata> が設定されます。</span><span class="sxs-lookup"><span data-stu-id="edade-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="edade-160">添付プロパティのメタデータは、一般的に依存関係プロパティとの違いがありません。</span><span class="sxs-lookup"><span data-stu-id="edade-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="edade-161">オーバーライドの既定値を添付プロパティのメタデータに指定すると、その値がオーバーライドするクラスのインスタンスの暗黙的な添付プロパティの既定値になります。</span><span class="sxs-lookup"><span data-stu-id="edade-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="edade-162">具体的には、一部のプロセスが添付プロパティの `Get` メソッド アクセサーを使用してそのプロパティの値のクエリを行った場合に、メタデータを指定したクラスのインスタンスが指定されており、その添付プロパティの値が設定されていないと、既定値がレポートされます。</span><span class="sxs-lookup"><span data-stu-id="edade-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="edade-163">プロパティでプロパティ値の継承を有効にする場合は、未接続の依存関係プロパティではなく添付プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="edade-164">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="edade-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="edade-165">カスタム添付プロパティ<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="edade-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="edade-166">添付プロパティを作成する場合<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="edade-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="edade-167">添付プロパティは、定義クラスではないクラスで使用できるプロパティ設定機構を用意する理由がある場合に作成できます。</span><span class="sxs-lookup"><span data-stu-id="edade-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="edade-168">この最も一般的なシナリオが、レイアウトです。</span><span class="sxs-lookup"><span data-stu-id="edade-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="edade-169">既存のレイアウトプロパティの例としては、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>、<xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>、および <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>があります。</span><span class="sxs-lookup"><span data-stu-id="edade-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="edade-170">これによって実現するシナリオは、レイアウト制御要素の子要素として存在する要素が、レイアウト親要素に対して個別にレイアウト要件を表現するというものです。親が添付プロパティとして定義したプロパティ値を、個々の子要素が設定します。</span><span class="sxs-lookup"><span data-stu-id="edade-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="edade-171">クラスがサービスを表しており、クラスでサービスをより透過的に統合できるようにしたい場合にも、添付プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="edade-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="edade-172">もう1つのシナリオは、 **[プロパティ]** ウィンドウの編集など、VISUAL Studio WPF デザイナーのサポートを受け取ることです。</span><span class="sxs-lookup"><span data-stu-id="edade-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="edade-173">詳細については、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="edade-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="edade-174">前述のように、プロパティ値の継承を使用する場合には、添付プロパティを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="edade-175">添付プロパティを作成する方法<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="edade-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="edade-176">クラスが、他の型で使用するために厳密に添付プロパティを定義している場合、クラスは <xref:System.Windows.DependencyObject>から派生する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="edade-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="edade-177">ただし、添付プロパティが依存関係プロパティでもある WPF モデル全体に従う場合は、<xref:System.Windows.DependencyObject> から派生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="edade-178"><xref:System.Windows.DependencyProperty>型の `public static readonly` フィールドを宣言することによって、添付プロパティを依存関係プロパティとして定義します。</span><span class="sxs-lookup"><span data-stu-id="edade-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="edade-179">このフィールドを定義するには、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドの戻り値を使用します。</span><span class="sxs-lookup"><span data-stu-id="edade-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="edade-180">フィールド名は、定義されている WPF パターンに従って、識別フィールドとそれが表すプロパティの名前が付けられている場合に、添付プロパティ名が文字列 `Property`と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="edade-181">添付プロパティプロバイダーは、添付プロパティのアクセサーとして静的**Get_PropertyName_** および**Set_PropertyName_** メソッドを提供する必要もあります。この操作を行わないと、プロパティシステムが添付プロパティを使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="edade-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="edade-182">添付プロパティの get アクセサーを省略した場合、Visual Studio や Blend for Visual Studio などのデザインツールでは、プロパティのデータバインディングは機能しません。</span><span class="sxs-lookup"><span data-stu-id="edade-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="edade-183">Get アクセサー</span><span class="sxs-lookup"><span data-stu-id="edade-183">The Get Accessor</span></span>

<span data-ttu-id="edade-184">**Get_PropertyName_** アクセサーのシグネチャは次のようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="edade-185">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="edade-186">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> メソッドは、パラメーターを <xref:System.Windows.UIElement>として入力します。これは、添付プロパティが <xref:System.Windows.UIElement> インスタンスでのみ設定されるためです。</span><span class="sxs-lookup"><span data-stu-id="edade-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="edade-187">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="edade-188">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A> メソッドでは、値をその列挙にのみ設定できるため、<xref:System.Windows.Controls.Dock>として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="edade-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="edade-189">Set アクセサー</span><span class="sxs-lookup"><span data-stu-id="edade-189">The Set Accessor</span></span>

<span data-ttu-id="edade-190">**Set_PropertyName_** アクセサーのシグネチャは次のようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="edade-191">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="edade-192">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドでは、添付プロパティは <xref:System.Windows.UIElement> インスタンスでのみ設定されるため、<xref:System.Windows.UIElement>として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="edade-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="edade-193">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="edade-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="edade-194">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドでは、値をその列挙にのみ設定できるため、<xref:System.Windows.Controls.Dock>として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="edade-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="edade-195">このメソッドの値は、マークアップの添付プロパティの使用で添付プロパティが検出されたときに XAML ローダーから生じる入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="edade-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="edade-196">この入力はマークアップの XAML 属性値として指定された値です。</span><span class="sxs-lookup"><span data-stu-id="edade-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="edade-197">したがって、適切な型を属性値 (最終的には単なる文字列) から作成できるように、使用する型の型変換、値シリアライザー、またはマークアップ拡張サポートが必要です。</span><span class="sxs-lookup"><span data-stu-id="edade-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="edade-198">次の例は、(<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドを使用した) 依存関係プロパティの登録と、 **Get_PropertyName_** アクセサーと**Set_PropertyName_** アクセサーを示しています。</span><span class="sxs-lookup"><span data-stu-id="edade-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="edade-199">この例では、添付プロパティ名は `IsBubbleSource` です。</span><span class="sxs-lookup"><span data-stu-id="edade-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="edade-200">したがって、アクセサーの名前は `GetIsBubbleSource` および `SetIsBubbleSource` である必要があります。</span><span class="sxs-lookup"><span data-stu-id="edade-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="edade-201">添付プロパティの属性</span><span class="sxs-lookup"><span data-stu-id="edade-201">Attached Property Attributes</span></span>

<span data-ttu-id="edade-202">WPF では、添付プロパティに関する情報をリフレクションプロセスに提供するためのいくつかの .NET 属性、およびリフレクションとプロパティ情報 (デザイナーなど) の一般的なユーザーを定義します。</span><span class="sxs-lookup"><span data-stu-id="edade-202">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="edade-203">添付プロパティに含まれる型は膨大な範囲に及ぶため、デザイナーには XAML を使用する特定のテクノロジの実装に定義されたすべての添付プロパティのグローバル リストがユーザーに表示されないようにするための手段が必要となります。</span><span class="sxs-lookup"><span data-stu-id="edade-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="edade-204">WPF が添付プロパティ用に定義する .NET 属性を使用して、特定の添付プロパティを [プロパティ] ウィンドウに表示する必要がある状況のスコープを設定できます。</span><span class="sxs-lookup"><span data-stu-id="edade-204">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="edade-205">また、この属性をカスタム添付プロパティに適用するという選択肢もあります。</span><span class="sxs-lookup"><span data-stu-id="edade-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="edade-206">.NET 属性の目的と構文については、適切なリファレンスページで説明されています。</span><span class="sxs-lookup"><span data-stu-id="edade-206">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="edade-207">添付プロパティの詳細を学習する<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="edade-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="edade-208">添付プロパティの作成の詳細については、「[方法: 添付プロパティを登録する](how-to-register-an-attached-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="edade-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="edade-209">依存関係プロパティおよび添付プロパティの高度な使用シナリオについては、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="edade-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="edade-210">プロパティは添付プロパティとしても依存関係プロパティとしても登録できますが、"ラッパー" 実装は公開したままにすることができます。</span><span class="sxs-lookup"><span data-stu-id="edade-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="edade-211">この場合、プロパティをその要素に設定することも、XAML の添付プロパティの構文を使用して任意の要素に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="edade-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="edade-212">標準とアタッチの両方の使用に適したシナリオを持つプロパティの例としては、<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>があります。</span><span class="sxs-lookup"><span data-stu-id="edade-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="edade-213">関連項目</span><span class="sxs-lookup"><span data-stu-id="edade-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="edade-214">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="edade-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="edade-215">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="edade-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="edade-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="edade-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="edade-217">方法: 添付プロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="edade-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
