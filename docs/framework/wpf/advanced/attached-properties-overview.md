---
title: 添付プロパティの概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: b207db459776c9f8fa7ea247d01071eeb8c995cf
ms.sourcegitcommit: 465547886a1224a5435c3ac349c805e39ce77706
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/21/2020
ms.locfileid: "81739293"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="ae3ed-102">添付プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="ae3ed-102">Attached Properties Overview</span></span>

<span data-ttu-id="ae3ed-103">添付プロパティは、XAML によって定義された概念です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="ae3ed-104">添付プロパティは、任意のオブジェクトに設定可能なグローバル プロパティの型として使用されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="ae3ed-105">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] では通常、添付プロパティは従来のプロパティ "ラッパー" を含まない依存関係プロパティの特殊な形式として定義されています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <a name="prerequisites"></a><span data-ttu-id="ae3ed-106">前提条件 <a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="ae3ed-107">この記事では、ユーザーが [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] クラスの既存の依存関係プロパティの使用という観点から依存関係プロパティを理解し、「[依存関係プロパティの概要](dependency-properties-overview.md)」トピックを通読していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-107">This article assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="ae3ed-108">この記事の例について理解するには、XAML および WPF アプリケーションの記述方法について知っておく必要もあります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-108">To follow the examples in this article, you should also understand XAML and know how to write WPF applications.</span></span>

## <a name="why-use-attached-properties"></a><span data-ttu-id="ae3ed-109">添付プロパティを使用する理由 <a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="ae3ed-110">添付プロパティの目的の 1 つは、親要素に定義されているプロパティに対する一意の値を、異なる子要素が指定できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that's defined in a parent element.</span></span> <span data-ttu-id="ae3ed-111">このシナリオの適用例として、子要素から親要素に、[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] での表示方法を通知させることがあります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="ae3ed-112">1 つの例として、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ae3ed-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> プロパティは添付プロパティとして作成されます。このプロパティが、<xref:System.Windows.Controls.DockPanel> 自体ではなく、<xref:System.Windows.Controls.DockPanel> の内部に含まれる要素に設定されるように設計されているためです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel> rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="ae3ed-114"><xref:System.Windows.Controls.DockPanel> クラスでは <xref:System.Windows.Controls.DockPanel.DockProperty> という名前の静的な <xref:System.Windows.DependencyProperty> フィールドが定義されており、<xref:System.Windows.Controls.DockPanel.GetDock%2A> および <xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドが添付プロパティのパブリック アクセサーとして提供されます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <a name="attached-properties-in-xaml"></a><span data-ttu-id="ae3ed-115">XAML の添付プロパティ <a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="ae3ed-116">XAML では、構文 *AttachedPropertyProvider*.*PropertyName* を使用して添付プロパティを設定します</span><span class="sxs-lookup"><span data-stu-id="ae3ed-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="ae3ed-117">XAML での <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> の設定方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="ae3ed-118">使い方は静的プロパティに少し似ています。名前で指定されたインスタンスを参照するのではなく、添付プロパティを所有して登録する型 <xref:System.Windows.Controls.DockPanel> を常に参照します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-118">The usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="ae3ed-119">さらに、XAML の添付プロパティはマークアップに設定する属性であるため、設定操作にのみ関連性があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="ae3ed-120">XAML でプロパティを直接取得することはできませんが、スタイルのトリガー (詳細については、「[スタイルとテンプレート](../../../desktop-wpf/fundamentals/styles-templates-overview.md)」を参照) などの値を比較するための間接的な機構があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="ae3ed-121">WPF での添付プロパティの実装</span><span class="sxs-lookup"><span data-stu-id="ae3ed-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="ae3ed-122">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] では、WPF 型の UI 関連の添付プロパティのほとんどが、依存関係プロパティとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the UI-related attached properties on WPF types are implemented as dependency properties.</span></span> <span data-ttu-id="ae3ed-123">添付プロパティは XAML の概念であり、依存関係プロパティは WPF の概念です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="ae3ed-124">WPF の添付プロパティは依存関係プロパティであるため、プロパティのメタデータ、そしてその既定値といった依存関係プロパティの概念がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="ae3ed-125">所有する型による添付プロパティの使用方法 <a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="ae3ed-126">添付プロパティはどのオブジェクトにも設定できますが、プロパティを設定したことによって自動的に意味のある結果が得られるわけでも、値が別のオブジェクトによって使用されるわけでもありません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="ae3ed-127">一般に、添付プロパティの目的は、想定されるさまざまなクラス階層または論理関係から生じるオブジェクトが、添付プロパティを定義する型に共通する情報をレポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="ae3ed-128">添付プロパティを定義する型は、一般的に次のいずれかのモデルに従っています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="ae3ed-129">添付プロパティを定義する型が、添付プロパティの値を設定する要素の親要素になるように設計されている。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="ae3ed-130">この型の子オブジェクトは、一部のオブジェクト ツリー構造で内部ロジックを反復し、値を取得して、その値に対する処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="ae3ed-131">添付プロパティを定義する型が、想定されるさまざまな親要素およびコンテンツ モデルの子要素として使用される。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="ae3ed-132">添付プロパティを定義する型が、サービスを表す。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="ae3ed-133">その他の型は、添付プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-133">Other types set values for the attached property.</span></span> <span data-ttu-id="ae3ed-134">プロパティを設定する要素がサービスのコンテキストで評価されると、添付プロパティの値がサービス クラスの内部ロジックにより取得されます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="ae3ed-135">親定義の添付プロパティの例</span><span class="sxs-lookup"><span data-stu-id="ae3ed-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="ae3ed-136">WPF で添付プロパティが定義される最も一般的なシナリオは、親要素で子要素のコレクションがサポートされ、さらに動作の詳細が子要素ごとにレポートされるような動作が実装される場合です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="ae3ed-137"><xref:System.Windows.Controls.DockPanel> では <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 添付プロパティが定義されており、<xref:System.Windows.Controls.DockPanel> には、そのレンダリング ロジック (具体的には、<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> および <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>) の一部としてクラスレベルのコードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="ae3ed-138"><xref:System.Windows.Controls.DockPanel> インスタンスでは、直下の子要素のいずれかに <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> の値が設定されているかどうかが常に確認されます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae3ed-139">設定されている場合は、その値が、その子要素に適用されるレンダリング ロジックの入力になります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="ae3ed-140">入れ子になった <xref:System.Windows.Controls.DockPanel> インスタンスではそれぞれが所有する直下の子要素のコレクションが処理されますが、<xref:System.Windows.Controls.DockPanel> による <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> の値の処理方法は、実装によって異なります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="ae3ed-141">直接の親以外の要素に影響を与える添付プロパティを所有することは、理論上は可能です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="ae3ed-142"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 添付プロパティが要素で設定されており、その要素に影響を与える <xref:System.Windows.Controls.DockPanel> 親要素がない場合、エラーまたは例外は発生しません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="ae3ed-143">これは単に、グローバル プロパティ値が設定されているものの、その情報を消費する最新の <xref:System.Windows.Controls.DockPanel> の親が存在しないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <a name="attached-properties-in-code"></a><span data-ttu-id="ae3ed-144">コードの添付プロパティ <a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="ae3ed-145">WPF の添付プロパティには、取得と設定のアクセスを簡単にする、一般的な CLR の "ラッパー" メソッドは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="ae3ed-146">これは、添付プロパティが、プロパティが設定されているインスタンスの CLR 名前空間の一部とは限らないためです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="ae3ed-147">ただし、XAML の解析時に XAML プロセッサがその値を設定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="ae3ed-148">有効な添付プロパティの使用をサポートするには、添付プロパティの所有者の種類ごとに **Get_PropertyName_** および **Set_PropertyName_** の形式で専用のアクセサー メソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="ae3ed-149">この専用のアクセサー メソッドは、コード内の添付プロパティの取得/設定でも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="ae3ed-150">コードの観点では、添付プロパティはプロパティ アクセサーではなくメソッド アクセサーを含むバッキング フィールドに似ており、そのバッキング フィールドは特に定義することなくすべてのオブジェクトに存在することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="ae3ed-151">次の例は、コードに添付プロパティを設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="ae3ed-152">この例では、`myCheckBox` は <xref:System.Windows.Controls.CheckBox> クラスのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="ae3ed-153">XAML と同様、コードの 4 行目に `myDockPanel` の子要素として `myCheckBox` が追加されていない場合、45行目で例外が発生することはありませんが、プロパティ値が <xref:System.Windows.Controls.DockPanel> の親と対話しないため、処理が行われません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the fourth line of code, the fifth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="ae3ed-154"><xref:System.Windows.Controls.DockPanel> 親要素の存在と組み合わされた子要素で値 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> が設定されている場合にのみ、レンダリングされたアプリケーションで有効な動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="ae3ed-155">(この場合、添付プロパティを設定してからツリーに接続するか、</span><span class="sxs-lookup"><span data-stu-id="ae3ed-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="ae3ed-156">ツリーに接続してから添付プロパティを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="ae3ed-157">どちらの操作でも、結果は同じです。)</span><span class="sxs-lookup"><span data-stu-id="ae3ed-157">Either action order provides the same result.)</span></span>

## <a name="attached-property-metadata"></a><span data-ttu-id="ae3ed-158">添付プロパティのメタデータ <a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="ae3ed-159">プロパティを登録すると、そのプロパティがレンダリング、測定などに影響するかどうかといったプロパティの特性を指定するように <xref:System.Windows.FrameworkPropertyMetadata> が設定されます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="ae3ed-160">添付プロパティのメタデータは、一般的に依存関係プロパティとの違いがありません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="ae3ed-161">オーバーライドの既定値を添付プロパティのメタデータに指定すると、その値がオーバーライドするクラスのインスタンスの暗黙的な添付プロパティの既定値になります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="ae3ed-162">具体的には、一部のプロセスが添付プロパティの `Get` メソッド アクセサーを使用してそのプロパティの値のクエリを行った場合に、メタデータを指定したクラスのインスタンスが指定されており、その添付プロパティの値が設定されていないと、既定値がレポートされます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="ae3ed-163">プロパティでプロパティ値の継承を有効にする場合は、未接続の依存関係プロパティではなく添付プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="ae3ed-164">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <a name="custom-attached-properties"></a><span data-ttu-id="ae3ed-165">カスタム添付プロパティ <a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-165">Custom Attached Properties <a name="custom"></a></span></span>

### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="ae3ed-166">添付プロパティを作成するタイミング <a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="ae3ed-167">添付プロパティは、定義クラスではないクラスで使用できるプロパティ設定機構を用意する理由がある場合に作成できます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="ae3ed-168">この最も一般的なシナリオが、レイアウトです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="ae3ed-169">既存のレイアウト プロパティの例は、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>、<xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>、<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType> などです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae3ed-170">これによって実現するシナリオは、レイアウト制御要素の子要素として存在する要素が、レイアウト親要素に対して個別にレイアウト要件を表現するというものです。親が添付プロパティとして定義したプロパティ値を、個々の子要素が設定します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="ae3ed-171">クラスがサービスを表しており、クラスでサービスをより透過的に統合できるようにしたい場合にも、添付プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="ae3ed-172">さらに別のシナリオは、 **[プロパティ]** ウィンドウの編集など、Visual Studio WPF デザイナーのサポートを利用する場合です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="ae3ed-173">詳しくは、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="ae3ed-174">前述のように、プロパティ値の継承を使用する場合には、添付プロパティを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="ae3ed-175">添付プロパティの作成方法 <a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="ae3ed-176">クラスにおいて、他の型で使用する目的のみで添付プロパティが定義されている場合は、そのクラスを <xref:System.Windows.DependencyObject> から派生させる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="ae3ed-177">ただし、添付プロパティが依存関係プロパティでもある、WPF モデル全体を使用する場合は、<xref:System.Windows.DependencyObject> から派生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="ae3ed-178"><xref:System.Windows.DependencyProperty> 型の `public static readonly` フィールドを宣言することにより、添付プロパティを依存関係プロパティとして定義します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="ae3ed-179">このフィールドは、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドの戻り値を使用して定義します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="ae3ed-180">識別フィールドとそれが表すプロパティの名前付けに関して確立されている WPF のパターンに従うには、`Property` の文字列が付加され、フィールド名が添付プロパティ名と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="ae3ed-181">添付プロパティのプロバイダーでは、添付プロパティのアクセサーとして **Get_PropertyName_** および **Set_PropertyName_** の静的メソッドを指定する必要があります。これを行わないと、プロパティ システムが添付プロパティを使用できません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this results in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="ae3ed-182">添付プロパティの get アクセサーを省略すると、プロパティのデータ バインディングが Visual Studio や Blend for Visual Studio などのデザイン ツールで動作しません。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="ae3ed-183">Get アクセサー</span><span class="sxs-lookup"><span data-stu-id="ae3ed-183">The Get Accessor</span></span>

<span data-ttu-id="ae3ed-184">**Get_PropertyName_** アクセサーのシグネチャは次の形式にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="ae3ed-185">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ae3ed-186">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> メソッドでは、このパラメーターの型が <xref:System.Windows.UIElement> となっています。これは、添付プロパティが <xref:System.Windows.UIElement> インスタンスでのみ設定されることになっているからです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="ae3ed-187">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ae3ed-188">たとえば、<xref:System.Windows.Controls.DockPanel.GetDock%2A> メソッドの型は <xref:System.Windows.Controls.Dock> です。これは値が列挙型にしか設定できないためです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="ae3ed-189">Set アクセサー</span><span class="sxs-lookup"><span data-stu-id="ae3ed-189">The Set Accessor</span></span>

<span data-ttu-id="ae3ed-190">**Set_PropertyName_** アクセサーのシグネチャは次の形式にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="ae3ed-191">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ae3ed-192">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドでは、型が <xref:System.Windows.UIElement> となっています。これは、添付プロパティが <xref:System.Windows.UIElement> インスタンスでのみ設定されることになっているからです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="ae3ed-193">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ae3ed-194">たとえば、<xref:System.Windows.Controls.DockPanel.SetDock%2A> メソッドの型は <xref:System.Windows.Controls.Dock> です。これは値が列挙型にしか設定できないためです。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="ae3ed-195">このメソッドの値は、マークアップの添付プロパティの使用で添付プロパティが検出されたときに XAML ローダーから生じる入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="ae3ed-196">この入力はマークアップの XAML 属性値として指定された値です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="ae3ed-197">したがって、適切な型を属性値 (最終的には単なる文字列) から作成できるように、使用する型の型変換、値シリアライザー、またはマークアップ拡張サポートが必要です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="ae3ed-198">次の例では、(<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドを使用した) 依存関係プロパティの登録と、**Get_PropertyName_** および **Set_PropertyName_** アクセサーを示します。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="ae3ed-199">この例では、添付プロパティ名は `IsBubbleSource` です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="ae3ed-200">したがって、アクセサーの名前は `GetIsBubbleSource` および `SetIsBubbleSource` である必要があります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="ae3ed-201">添付プロパティの属性</span><span class="sxs-lookup"><span data-stu-id="ae3ed-201">Attached Property Attributes</span></span>

<span data-ttu-id="ae3ed-202">WPF では複数の .NET 属性が定義されています。これは添付プロパティに関する情報をリフレクション プロセス、リフレクションおよびプロパティ情報の一般的なユーザー (デザイナーなど) に提供することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-202">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="ae3ed-203">添付プロパティに含まれる型は膨大な範囲に及ぶため、デザイナーには XAML を使用する特定のテクノロジの実装に定義されたすべての添付プロパティのグローバル リストがユーザーに表示されないようにするための手段が必要となります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="ae3ed-204">WPF で添付プロパティに対して定義されている .NET 属性を使用すると、指定した添付プロパティのみをプロパティ ウィンドウに表示することができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-204">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="ae3ed-205">また、この属性をカスタム添付プロパティに適用するという選択肢もあります。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="ae3ed-206">.NET 属性の目的および構文は、次の参照ページに記載されています。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-206">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="ae3ed-207">添付プロパティの詳細情報 <a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="ae3ed-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="ae3ed-208">添付プロパティの作成の詳細については、「[方法: 添付プロパティを登録する](how-to-register-an-attached-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="ae3ed-209">依存関係プロパティおよび添付プロパティの高度な使用シナリオについては、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="ae3ed-210">プロパティは添付プロパティとしても依存関係プロパティとしても登録できますが、"ラッパー" 実装は公開したままにすることができます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="ae3ed-211">この場合、プロパティをその要素に設定することも、XAML の添付プロパティの構文を使用して任意の要素に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="ae3ed-212">標準使用および添付による使用の両方に適したシナリオでのプロパティの例は、<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType> です。</span><span class="sxs-lookup"><span data-stu-id="ae3ed-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="ae3ed-213">関連項目</span><span class="sxs-lookup"><span data-stu-id="ae3ed-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="ae3ed-214">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="ae3ed-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="ae3ed-215">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="ae3ed-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="ae3ed-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="ae3ed-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="ae3ed-217">方法: 添付プロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="ae3ed-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
