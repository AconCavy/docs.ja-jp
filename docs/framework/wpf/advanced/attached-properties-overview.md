---
title: 添付プロパティの概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 5086401f4616074d364c1d387b751116120d5969
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389000"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="848be-102">添付プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="848be-102">Attached Properties Overview</span></span>

<span data-ttu-id="848be-103">添付プロパティは、XAML によって定義された概念です。</span><span class="sxs-lookup"><span data-stu-id="848be-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="848be-104">添付プロパティは、任意のオブジェクトに設定可能なグローバル プロパティの型として使用されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="848be-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="848be-105">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] では通常、添付プロパティは従来のプロパティ "ラッパー" を含まない依存関係プロパティの特殊な形式として定義されています。</span><span class="sxs-lookup"><span data-stu-id="848be-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <a name="prerequisites"></a><span data-ttu-id="848be-106">前提条件<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="848be-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="848be-107">このトピックは、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] クラスの既存の依存関係プロパティのコンシューマーの観点から依存関係プロパティを理解しており、「[依存関係プロパティの概要](dependency-properties-overview.md)」を読んでいることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="848be-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="848be-108">このトピックの例に従うには、XAML を理解し、WPF アプリケーションの作成方法を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <a name="why-use-attached-properties"></a><span data-ttu-id="848be-109">添付プロパティを使用する理由<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="848be-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="848be-110">添付プロパティの目的の 1 つは、親要素に実際に定義されているプロパティに対する一意の値を、異なる子要素が指定できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="848be-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="848be-111">このシナリオの適用例として、子要素から親要素に、[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] での表示方法を通知させることがあります。</span><span class="sxs-lookup"><span data-stu-id="848be-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="848be-112">その一例が<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="848be-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="848be-113">プロパティ<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>は、それ自体ではなく<xref:System.Windows.Controls.DockPanel>、 内に含まれる要素に設定されるように設計されているため、<xref:System.Windows.Controls.DockPanel>添付プロパティとして作成されます。</span><span class="sxs-lookup"><span data-stu-id="848be-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="848be-114">この<xref:System.Windows.Controls.DockPanel>クラスは、<xref:System.Windows.DependencyProperty>という名前<xref:System.Windows.Controls.DockPanel.DockProperty>の静的フィールドを定義<xref:System.Windows.Controls.DockPanel.GetDock%2A>し<xref:System.Windows.Controls.DockPanel.SetDock%2A>、 と メソッドを添付プロパティのパブリック アクセサーとして提供します。</span><span class="sxs-lookup"><span data-stu-id="848be-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <a name="attached-properties-in-xaml"></a><span data-ttu-id="848be-115">XAML の添付プロパティ<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="848be-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="848be-116">XAML では、構文 *AttachedPropertyProvider*.*PropertyName* を使用して添付プロパティを設定します</span><span class="sxs-lookup"><span data-stu-id="848be-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="848be-117">XAML<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>で設定する方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="848be-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="848be-118">使用法は静的プロパティと似ています。名前で指定されたインスタンス<xref:System.Windows.Controls.DockPanel>を参照するのではなく、常に添付プロパティを所有し、登録する型を参照します。</span><span class="sxs-lookup"><span data-stu-id="848be-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="848be-119">さらに、XAML の添付プロパティはマークアップに設定する属性であるため、設定操作にのみ関連性があります。</span><span class="sxs-lookup"><span data-stu-id="848be-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="848be-120">XAML でプロパティを直接取得することはできませんが、スタイルのトリガー (詳細については、「[スタイルとテンプレート](../controls/styling-and-templating.md)」を参照) などの値を比較するための間接的な機構があります。</span><span class="sxs-lookup"><span data-stu-id="848be-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="848be-121">WPF での添付プロパティの実装</span><span class="sxs-lookup"><span data-stu-id="848be-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="848be-122">では[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]、UI プレゼンテーションに関連する WPF 型に存在する添付プロパティのほとんどは、依存関係プロパティとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="848be-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="848be-123">添付プロパティは XAML の概念ですが、依存関係プロパティは WPF の概念です。</span><span class="sxs-lookup"><span data-stu-id="848be-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="848be-124">WPF 添付プロパティは依存関係プロパティであるため、プロパティ メタデータなどの依存関係プロパティの概念とそのプロパティ メタデータの既定値をサポートします。</span><span class="sxs-lookup"><span data-stu-id="848be-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="848be-125">所有型で添付プロパティを使用する方法<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="848be-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="848be-126">添付プロパティはどのオブジェクトにも設定できますが、プロパティを設定したことによって自動的に意味のある結果が得られるわけでも、値が別のオブジェクトによって使用されるわけでもありません。</span><span class="sxs-lookup"><span data-stu-id="848be-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="848be-127">一般に、添付プロパティの目的は、想定されるさまざまなクラス階層または論理関係から生じるオブジェクトが、添付プロパティを定義する型に共通する情報をレポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="848be-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="848be-128">添付プロパティを定義する型は、一般的に次のいずれかのモデルに従っています。</span><span class="sxs-lookup"><span data-stu-id="848be-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="848be-129">添付プロパティを定義する型が、添付プロパティの値を設定する要素の親要素になるように設計されている。</span><span class="sxs-lookup"><span data-stu-id="848be-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="848be-130">この型の子オブジェクトは、一部のオブジェクト ツリー構造で内部ロジックを反復し、値を取得して、その値に対する処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="848be-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="848be-131">添付プロパティを定義する型が、想定されるさまざまな親要素およびコンテンツ モデルの子要素として使用される。</span><span class="sxs-lookup"><span data-stu-id="848be-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="848be-132">添付プロパティを定義する型が、サービスを表す。</span><span class="sxs-lookup"><span data-stu-id="848be-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="848be-133">その他の型は、添付プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="848be-133">Other types set values for the attached property.</span></span> <span data-ttu-id="848be-134">プロパティを設定する要素がサービスのコンテキストで評価されると、添付プロパティの値がサービス クラスの内部ロジックにより取得されます。</span><span class="sxs-lookup"><span data-stu-id="848be-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="848be-135">親定義の添付プロパティの例</span><span class="sxs-lookup"><span data-stu-id="848be-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="848be-136">WPF が添付プロパティを定義する最も一般的なシナリオは、親要素が子要素コレクションをサポートし、動作の詳細が子要素ごとに個別に報告される動作も実装する場合です。</span><span class="sxs-lookup"><span data-stu-id="848be-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="848be-137"><xref:System.Windows.Controls.DockPanel>は、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>添付プロパティを定義<xref:System.Windows.Controls.DockPanel>し、クラス レベルのコードをレンダリング ロジックの一部<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A>として<xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>持ちます (具体的には、 と )。</span><span class="sxs-lookup"><span data-stu-id="848be-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="848be-138">インスタンス<xref:System.Windows.Controls.DockPanel>は、その直接の子要素のいずれかがに値を設定しているかどうかを常にチェックします<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="848be-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="848be-139">設定されている場合は、その値が、その子要素に適用されるレンダリング ロジックの入力になります。</span><span class="sxs-lookup"><span data-stu-id="848be-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="848be-140">入れ<xref:System.Windows.Controls.DockPanel>子になったインスタンスは、それぞれ直接の子要素コレクションを処理しますが、その動作は、値<xref:System.Windows.Controls.DockPanel>を処理<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>する方法に実装固有です。</span><span class="sxs-lookup"><span data-stu-id="848be-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="848be-141">直接の親以外の要素に影響を与える添付プロパティを所有することは、理論上は可能です。</span><span class="sxs-lookup"><span data-stu-id="848be-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="848be-142">添付プロパティ<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>が、親要素を持たない<xref:System.Windows.Controls.DockPanel>要素に対して設定されている場合、エラーまたは例外は発生しません。</span><span class="sxs-lookup"><span data-stu-id="848be-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="848be-143">これは、グローバル プロパティ値が設定されたが、情報を消費する可能性<xref:System.Windows.Controls.DockPanel>のある現在の親がないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="848be-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <a name="attached-properties-in-code"></a><span data-ttu-id="848be-144">コード内の添付プロパティ<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="848be-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="848be-145">WPF の添付プロパティには、取得/設定を簡単に行うための典型的な CLR の "ラッパー" メソッドはありません。</span><span class="sxs-lookup"><span data-stu-id="848be-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="848be-146">これは、添付プロパティが、プロパティが設定されているインスタンスの CLR 名前空間の一部であるとは限らないためです。</span><span class="sxs-lookup"><span data-stu-id="848be-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="848be-147">ただし、XAML の解析時に XAML プロセッサがその値を設定できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="848be-148">添付プロパティの効果的な使用をサポートするには、添付プロパティの所有者の種類が **、Get_PropertyName_** および**Set_PropertyName_** の形式で専用のアクセサ メソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="848be-149">この専用のアクセサー メソッドは、コード内の添付プロパティの取得/設定でも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="848be-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="848be-150">コードの観点では、添付プロパティはプロパティ アクセサーではなくメソッド アクセサーを含むバッキング フィールドに似ており、そのバッキング フィールドは特に定義することなくすべてのオブジェクトに存在することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="848be-151">次の例は、コードに添付プロパティを設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="848be-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="848be-152">この例では、`myCheckBox`クラスのインスタンスです<xref:System.Windows.Controls.CheckBox>。</span><span class="sxs-lookup"><span data-stu-id="848be-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="848be-153">XAML の場合と同様に`myCheckBox`、コードの 4 行目`myDockPanel`で子要素として追加されていない場合、コードの 5 行目は例外を発生しませんが、プロパティ値は<xref:System.Windows.Controls.DockPanel>親と対話しないため、何も実行されません。</span><span class="sxs-lookup"><span data-stu-id="848be-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the fourth line of code, the fifth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="848be-154">子要素<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>に設定された値と親要素の存在を組み合わせた値だけが、レンダリングされたアプリケーションで有効な動作を引き起こします。 <xref:System.Windows.Controls.DockPanel></span><span class="sxs-lookup"><span data-stu-id="848be-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="848be-155">(この場合、添付プロパティを設定してからツリーに接続するか、</span><span class="sxs-lookup"><span data-stu-id="848be-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="848be-156">ツリーに接続してから添付プロパティを設定することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="848be-157">どちらの操作でも、結果は同じです。)</span><span class="sxs-lookup"><span data-stu-id="848be-157">Either action order provides the same result.)</span></span>

## <a name="attached-property-metadata"></a><span data-ttu-id="848be-158">添付プロパティメタデータ<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="848be-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="848be-159">プロパティを登録するときに、<xref:System.Windows.FrameworkPropertyMetadata>プロパティがレンダリング、計測などに影響するかどうかなど、プロパティの特性を指定するように設定されます。</span><span class="sxs-lookup"><span data-stu-id="848be-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="848be-160">添付プロパティのメタデータは、一般的に依存関係プロパティとの違いがありません。</span><span class="sxs-lookup"><span data-stu-id="848be-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="848be-161">オーバーライドの既定値を添付プロパティのメタデータに指定すると、その値がオーバーライドするクラスのインスタンスの暗黙的な添付プロパティの既定値になります。</span><span class="sxs-lookup"><span data-stu-id="848be-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="848be-162">具体的には、一部のプロセスが添付プロパティの `Get` メソッド アクセサーを使用してそのプロパティの値のクエリを行った場合に、メタデータを指定したクラスのインスタンスが指定されており、その添付プロパティの値が設定されていないと、既定値がレポートされます。</span><span class="sxs-lookup"><span data-stu-id="848be-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="848be-163">プロパティでプロパティ値の継承を有効にする場合は、未接続の依存関係プロパティではなく添付プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="848be-164">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="848be-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <a name="custom-attached-properties"></a><span data-ttu-id="848be-165">カスタム添付プロパティ<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="848be-165">Custom Attached Properties <a name="custom"></a></span></span>

### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="848be-166">添付プロパティを作成する場合<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="848be-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="848be-167">添付プロパティは、定義クラスではないクラスで使用できるプロパティ設定機構を用意する理由がある場合に作成できます。</span><span class="sxs-lookup"><span data-stu-id="848be-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="848be-168">この最も一般的なシナリオが、レイアウトです。</span><span class="sxs-lookup"><span data-stu-id="848be-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="848be-169">既存のレイアウト プロパティの<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>例<xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>としては<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>、 、および が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="848be-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="848be-170">これによって実現するシナリオは、レイアウト制御要素の子要素として存在する要素が、レイアウト親要素に対して個別にレイアウト要件を表現するというものです。親が添付プロパティとして定義したプロパティ値を、個々の子要素が設定します。</span><span class="sxs-lookup"><span data-stu-id="848be-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="848be-171">クラスがサービスを表しており、クラスでサービスをより透過的に統合できるようにしたい場合にも、添付プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="848be-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="848be-172">さらに別のシナリオは、プロパティ ウィンドウの編集など、Visual Studio WPF デザイナーのサポートを受ける**です**。</span><span class="sxs-lookup"><span data-stu-id="848be-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="848be-173">詳細については、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="848be-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="848be-174">前述のように、プロパティ値の継承を使用する場合には、添付プロパティを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="848be-175">添付プロパティを作成する方法<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="848be-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="848be-176">クラスが他の型で使用するために添付プロパティを厳密に定義している場合、そのクラスは から<xref:System.Windows.DependencyObject>派生する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="848be-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="848be-177">ただし、アタッチされたプロパティを依存関係<xref:System.Windows.DependencyObject>プロパティにするという WPF モデル全体に従う場合は、から派生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="848be-178">型のフィールドを宣言して、添付プロパティを`public static readonly`依存関係プロパティとして定義<xref:System.Windows.DependencyProperty>します。</span><span class="sxs-lookup"><span data-stu-id="848be-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="848be-179">このフィールドは、メソッドの戻り値を使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>して定義します。</span><span class="sxs-lookup"><span data-stu-id="848be-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="848be-180">フィールド名は、識別フィールドとそれらが表すプロパティに名前を付`Property`けるという確立された WPF パターンに従って、文字列を付加した添付プロパティ名と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="848be-181">また、添付プロパティ プロバイダは、静的**Get_PropertyName_** および**Set_PropertyName_** メソッドを添付プロパティのアクセサとして提供する必要があります。これを行わないと、プロパティ システムが添付プロパティを使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="848be-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="848be-182">添付プロパティの get アクセサーを省略すると、Visual Studio や Visual Studio 用ブレンドなどのデザイン ツールでは、プロパティのデータ バインディングは機能しません。</span><span class="sxs-lookup"><span data-stu-id="848be-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="848be-183">Get アクセサー</span><span class="sxs-lookup"><span data-stu-id="848be-183">The Get Accessor</span></span>

<span data-ttu-id="848be-184">**Get_PropertyName_** アクセサーのシグネチャは次の指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="848be-185">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="848be-186">たとえば、アタッチされた<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>プロパティはインスタンスに対<xref:System.Windows.UIElement>してのみ設定されるため、メソッドはパラメーターをとして型指定<xref:System.Windows.UIElement>します。</span><span class="sxs-lookup"><span data-stu-id="848be-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="848be-187">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="848be-188">たとえば、値はその<xref:System.Windows.Controls.DockPanel.GetDock%2A>列挙型にしか<xref:System.Windows.Controls.Dock>設定できないため、メソッドは 、この型として型を指定します。</span><span class="sxs-lookup"><span data-stu-id="848be-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="848be-189">Set アクセサー</span><span class="sxs-lookup"><span data-stu-id="848be-189">The Set Accessor</span></span>

<span data-ttu-id="848be-190">**Set_PropertyName_** アクセサのシグネチャは次の必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="848be-191">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="848be-192">たとえば、アタッチされた<xref:System.Windows.Controls.DockPanel.SetDock%2A>プロパティはインスタンスに<xref:System.Windows.UIElement>対してのみ設定されるため、メソッドは 、この型として<xref:System.Windows.UIElement>型を指定します。</span><span class="sxs-lookup"><span data-stu-id="848be-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="848be-193">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="848be-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="848be-194">たとえば、値はその<xref:System.Windows.Controls.DockPanel.SetDock%2A>列挙型にしか<xref:System.Windows.Controls.Dock>設定できないため、メソッドは 、この型として型を指定します。</span><span class="sxs-lookup"><span data-stu-id="848be-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="848be-195">このメソッドの値は、マークアップの添付プロパティの使用で添付プロパティが検出されたときに XAML ローダーから生じる入力であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="848be-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="848be-196">この入力はマークアップの XAML 属性値として指定された値です。</span><span class="sxs-lookup"><span data-stu-id="848be-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="848be-197">したがって、適切な型を属性値 (最終的には単なる文字列) から作成できるように、使用する型の型変換、値シリアライザー、またはマークアップ拡張サポートが必要です。</span><span class="sxs-lookup"><span data-stu-id="848be-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="848be-198">次の例は、依存関係プロパティの登録 (<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッドを使用) と **、Get_PropertyName_** アクセサーと**Set_PropertyName_** アクセサーを示しています。</span><span class="sxs-lookup"><span data-stu-id="848be-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="848be-199">この例では、添付プロパティ名は `IsBubbleSource` です。</span><span class="sxs-lookup"><span data-stu-id="848be-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="848be-200">したがって、アクセサーの名前は `GetIsBubbleSource` および `SetIsBubbleSource` である必要があります。</span><span class="sxs-lookup"><span data-stu-id="848be-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="848be-201">添付プロパティの属性</span><span class="sxs-lookup"><span data-stu-id="848be-201">Attached Property Attributes</span></span>

<span data-ttu-id="848be-202">WPF では、リフレクション プロセスに添付されたプロパティに関する情報を提供するためのいくつかの .NET 属性を定義し、デザイナーなどのリフレクションおよびプロパティ情報の典型的なユーザーに対して使用します。</span><span class="sxs-lookup"><span data-stu-id="848be-202">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="848be-203">添付プロパティに含まれる型は膨大な範囲に及ぶため、デザイナーには XAML を使用する特定のテクノロジの実装に定義されたすべての添付プロパティのグローバル リストがユーザーに表示されないようにするための手段が必要となります。</span><span class="sxs-lookup"><span data-stu-id="848be-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="848be-204">WPF が添付プロパティに対して定義する .NET 属性を使用すると、特定の添付プロパティをプロパティ ウィンドウに表示する必要がある状況をスコープ指定できます。</span><span class="sxs-lookup"><span data-stu-id="848be-204">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="848be-205">また、この属性をカスタム添付プロパティに適用するという選択肢もあります。</span><span class="sxs-lookup"><span data-stu-id="848be-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="848be-206">NET 属性の目的と構文は、適切なリファレンス ページで説明されています。</span><span class="sxs-lookup"><span data-stu-id="848be-206">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="848be-207">添付プロパティの詳細<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="848be-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="848be-208">添付プロパティの作成の詳細については、「[方法: 添付プロパティを登録する](how-to-register-an-attached-property.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="848be-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="848be-209">依存関係プロパティおよび添付プロパティの高度な使用シナリオについては、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="848be-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="848be-210">プロパティは添付プロパティとしても依存関係プロパティとしても登録できますが、"ラッパー" 実装は公開したままにすることができます。</span><span class="sxs-lookup"><span data-stu-id="848be-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="848be-211">この場合、プロパティをその要素に設定することも、XAML の添付プロパティの構文を使用して任意の要素に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="848be-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="848be-212">標準と添付の両方の使用法に適したシナリオを持つプロパティの<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>例は です。</span><span class="sxs-lookup"><span data-stu-id="848be-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="848be-213">関連項目</span><span class="sxs-lookup"><span data-stu-id="848be-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="848be-214">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="848be-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="848be-215">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="848be-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="848be-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="848be-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="848be-217">添付プロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="848be-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
