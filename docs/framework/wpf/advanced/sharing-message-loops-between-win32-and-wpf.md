---
title: Win32 と WPF 間でのメッセージ ループの共有
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: e1b96284d69645876d3e383beb03a2cc540d8b7b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2020
ms.locfileid: "76731711"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="131d4-102">Win32 と WPF 間でのメッセージ ループの共有</span><span class="sxs-lookup"><span data-stu-id="131d4-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="131d4-103">このトピックでは、<xref:System.Windows.Threading.Dispatcher> の既存のメッセージ ループの公開を使用するか、相互運用コードの Win32 側に別のメッセージ ループを作成することにより、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] との相互運用のためのメッセージ ループを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="131d4-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="131d4-104">ComponentDispatcher とメッセージ ループ</span><span class="sxs-lookup"><span data-stu-id="131d4-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="131d4-105">相互運用とキーボード イベント サポートの通常のシナリオとして、<xref:System.Windows.Interop.IKeyboardInputSink> を実装する方法、または <xref:System.Windows.Interop.HwndSource> や <xref:System.Windows.Interop.HwndHost> など、既に <xref:System.Windows.Interop.IKeyboardInputSink> を実装しているクラスからサブクラスを作成する方法があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="131d4-106">ただし、キーボード シンクのサポートでは、相互運用の境界を越えてメッセージを送受信するときに発生する可能性があるすべてのメッセージ ループのニーズに対応できるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="131d4-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="131d4-107">アプリケーション メッセージ ループ アーキテクチャを形式化するために、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] には <xref:System.Windows.Interop.ComponentDispatcher> クラスが用意されています。これには、メッセージ ループが従う単純なプロトコルが定義されています。</span><span class="sxs-lookup"><span data-stu-id="131d4-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="131d4-108"><xref:System.Windows.Interop.ComponentDispatcher> は、いくつかのメンバーが公開されている静的クラスです。</span><span class="sxs-lookup"><span data-stu-id="131d4-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="131d4-109">各メソッドのスコープは、呼び出しスレッドに暗黙的に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="131d4-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="131d4-110">メッセージ ループでは、これらの API の一部をクリティカルなタイミングで呼び出す必要があります (次のセクションで定義します)。</span><span class="sxs-lookup"><span data-stu-id="131d4-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="131d4-111"><xref:System.Windows.Interop.ComponentDispatcher> には、他のコンポーネント (キーボード シンクなど) からリッスンできるイベントが用意されています。</span><span class="sxs-lookup"><span data-stu-id="131d4-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="131d4-112"><xref:System.Windows.Threading.Dispatcher> クラスを使用すると、適切なすべての <xref:System.Windows.Interop.ComponentDispatcher> メソッドを適切なシーケンスで呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="131d4-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="131d4-113">独自のメッセージ ループを実装している場合、コードでは同様の方法で <xref:System.Windows.Interop.ComponentDispatcher> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="131d4-114">スレッドに対して <xref:System.Windows.Interop.ComponentDispatcher> メソッドを呼び出すと、そのスレッドに登録されていたイベント ハンドラーのみが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="131d4-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="131d4-115">メッセージ ループの作成</span><span class="sxs-lookup"><span data-stu-id="131d4-115">Writing Message Loops</span></span>  
 <span data-ttu-id="131d4-116">独自のメッセージ ループを作成する場合に使用する <xref:System.Windows.Interop.ComponentDispatcher> メンバーのチェックリストを次に示します。</span><span class="sxs-lookup"><span data-stu-id="131d4-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="131d4-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: スレッドがモーダルであることを示すには、メッセージ ループでこれを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="131d4-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: スレッドが非モーダルに戻ったことを示すには、メッセージ ループでこれを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="131d4-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: <xref:System.Windows.Interop.ComponentDispatcher> で <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> イベントを発生させる必要があることを示すには、メッセージ ループでこれを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="131d4-120"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> が `true` の場合、<xref:System.Windows.Interop.ComponentDispatcher> によって <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> が発生することはありませんが、モーダル状態のときに <xref:System.Windows.Interop.ComponentDispatcher> が応答できない場合でも、メッセージ ループでは <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> の呼び出しを選択できます。</span><span class="sxs-lookup"><span data-stu-id="131d4-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="131d4-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: 新しいメッセージが使用可能であることを示すには、メッセージ ループでこれを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="131d4-122">戻り値は、<xref:System.Windows.Interop.ComponentDispatcher> イベントのリスナーによってメッセージが処理されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="131d4-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="131d4-123"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> から `true` (処理済み) が返される場合、ディスパッチャーではメッセージに対してそれ以上何もする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="131d4-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="131d4-124">戻り値が `false` の場合、ディスパッチャーでは Win32 関数 `TranslateMessage` を呼び出し、次に `DispatchMessage` を呼び出すことが期待されます。</span><span class="sxs-lookup"><span data-stu-id="131d4-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="131d4-125">ComponentDispatcher と既存のメッセージ処理の使用</span><span class="sxs-lookup"><span data-stu-id="131d4-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="131d4-126">固有の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] メッセージ ループに依存する場合に使用する <xref:System.Windows.Interop.ComponentDispatcher> メンバーのチェックリストを次に示します。</span><span class="sxs-lookup"><span data-stu-id="131d4-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="131d4-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: アプリケーションがモーダルになっているかどうかを返します (たとえば、モーダル メッセージ ループがプッシュされた、など)。</span><span class="sxs-lookup"><span data-stu-id="131d4-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="131d4-128"><xref:System.Windows.Interop.ComponentDispatcher> を使用すると、この状態を追跡できます。このクラスにはメッセージ ループからの <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> および <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> の呼び出し数が保持されるためです。</span><span class="sxs-lookup"><span data-stu-id="131d4-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="131d4-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> および <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> イベントは、デリゲート呼び出しの標準規則に従います。</span><span class="sxs-lookup"><span data-stu-id="131d4-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="131d4-130">デリゲートは不特定の順序で呼び出され、最初のデリゲートでメッセージが処理済みとマークされた場合でも、すべてのデリゲートが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="131d4-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="131d4-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: アイドル処理を実行するための適切かつ効率的な時間を示します (そのスレッドに対して保留中のメッセージは他にありません)。</span><span class="sxs-lookup"><span data-stu-id="131d4-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="131d4-132">スレッドがモーダルの場合、<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> は発生しません。</span><span class="sxs-lookup"><span data-stu-id="131d4-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="131d4-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: メッセージ ポンプで処理されるすべてのメッセージに対して発生します。</span><span class="sxs-lookup"><span data-stu-id="131d4-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="131d4-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> の間に処理されなかったすべてのメッセージに対して発生します。</span><span class="sxs-lookup"><span data-stu-id="131d4-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="131d4-135"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> イベントまたは <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> イベントの後で、イベント データの参照によって渡された `handled` パラメーターが `true` の場合、メッセージは処理済みと見なされます。</span><span class="sxs-lookup"><span data-stu-id="131d4-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="131d4-136">`handled` が `true` の場合、イベント ハンドラーではメッセージを無視する必要があります。これは、別のハンドラーによって先にメッセージが処理されたことを意味するためです。</span><span class="sxs-lookup"><span data-stu-id="131d4-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="131d4-137">両方のイベントに対する複数のイベント ハンドラーによってメッセージが変更される場合があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="131d4-138">ディスパッチャーでは、元の変更されていないメッセージではなく、変更されたメッセージをディスパッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="131d4-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> はすべてのリスナーに配信されますが、メッセージに応答してコードを呼び出す必要があるのは、メッセージの宛先に指定された HWND を含むトップレベル ウィンドウのみ、というのがアーキテクチャの目的です。</span><span class="sxs-lookup"><span data-stu-id="131d4-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="131d4-140">HwndSource で ComponentDispatcher イベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="131d4-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="131d4-141"><xref:System.Windows.Interop.HwndSource> がトップレベル ウィンドウ (親 HWND なし) の場合、<xref:System.Windows.Interop.ComponentDispatcher> に登録されます。</span><span class="sxs-lookup"><span data-stu-id="131d4-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="131d4-142"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> が発生し、メッセージが <xref:System.Windows.Interop.HwndSource> または子ウィンドウを対象としている場合、<xref:System.Windows.Interop.HwndSource> からその <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>、<xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>、<xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> キーボード シンク シーケンスが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="131d4-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="131d4-143"><xref:System.Windows.Interop.HwndSource> がトップレベル ウィンドウではない (親 HWND がある) 場合、処理は行われません。</span><span class="sxs-lookup"><span data-stu-id="131d4-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="131d4-144">処理を行うのはトップレベル ウィンドウのみと想定されており、相互運用シナリオの一部としてキーボード シンクをサポートするトップ レベル ウィンドウであることが想定されています。</span><span class="sxs-lookup"><span data-stu-id="131d4-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="131d4-145">適切なキーボード シンク メソッドを最初に呼び出さずに <xref:System.Windows.Interop.HwndSource> に対して <xref:System.Windows.Interop.HwndHost.WndProc%2A> を呼び出すと、アプリケーションは <xref:System.Windows.UIElement.KeyDown> などの上位のキーボード イベントを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="131d4-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="131d4-146">ただし、キーボード シンク メソッドは呼び出されません。これにより、アクセス キーのサポートなどの望ましいキーボード入力モデル機能は使用されません。</span><span class="sxs-lookup"><span data-stu-id="131d4-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="131d4-147">これは、メッセージ ループから <xref:System.Windows.Interop.ComponentDispatcher> の関連スレッドに適切に通知されなかったため、または親 HWND から適切なキーボード シンク応答が呼び出されなかったために発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="131d4-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="131d4-148"><xref:System.Windows.Interop.HwndSource.AddHook%2A> メソッドを使用してそのメッセージのフックを追加した場合、キーボード シンクに送信されたメッセージが HWND に送信されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="131d4-149">メッセージはメッセージ ポンプ レベルで直接処理され、`DispatchMessage` 関数に送信されていない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="131d4-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="131d4-150">関連項目</span><span class="sxs-lookup"><span data-stu-id="131d4-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="131d4-151">WPF と Win32 の相互運用性</span><span class="sxs-lookup"><span data-stu-id="131d4-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="131d4-152">スレッド モデル</span><span class="sxs-lookup"><span data-stu-id="131d4-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="131d4-153">入力の概要</span><span class="sxs-lookup"><span data-stu-id="131d4-153">Input Overview</span></span>](input-overview.md)
