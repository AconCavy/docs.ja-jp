---
title: カスタム依存関係プロパティ
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: 8e3ac7207a5ef05b94e97f005ecd17d5078669a4
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740885"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="50027-102">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="50027-102">Custom Dependency Properties</span></span>

<span data-ttu-id="50027-103">このトピックは、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] アプリケーション開発者およびコンポーネントの作成者が、カスタム依存関係プロパティを作成したくなる理由を説明し、実装手順にくわえ、プロパティのパフォーマンス、使いやすさ、または多用性を向上させることができるいくつかの実装オプションについて説明します。</span><span class="sxs-lookup"><span data-stu-id="50027-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="50027-104">必要条件</span><span class="sxs-lookup"><span data-stu-id="50027-104">Prerequisites</span></span>

<span data-ttu-id="50027-105">このトピックは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスの既存の依存関係プロパティのコンシューマーの観点から依存関係プロパティを理解しており、「[依存関係プロパティの概要](dependency-properties-overview.md)」というトピックを読んでいることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="50027-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="50027-106">このトピックの例に従うには、[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] について理解し、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションの作成方法に精通している必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="50027-107">依存関係プロパティとは</span><span class="sxs-lookup"><span data-stu-id="50027-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="50027-108">それ以外の場合は、共通言語ランタイム (CLR) プロパティを有効にして、スタイル設定、データバインディング、継承、アニメーション、および既定値をサポートすることができます。これは、依存関係プロパティとして実装することによって行います。</span><span class="sxs-lookup"><span data-stu-id="50027-108">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="50027-109">依存関係プロパティは、<xref:System.Windows.DependencyProperty.Register%2A> メソッド (または <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>) を呼び出すことによって [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティシステムに登録され、<xref:System.Windows.DependencyProperty> 識別子フィールドによってサポートされるプロパティです。</span><span class="sxs-lookup"><span data-stu-id="50027-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="50027-110">依存関係プロパティは <xref:System.Windows.DependencyObject> 型によってのみ使用できますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラス階層では非常に高い <xref:System.Windows.DependencyObject> であるため、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] で使用できるクラスの大部分は依存関係プロパティをサポートできます。</span><span class="sxs-lookup"><span data-stu-id="50027-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="50027-111">依存関係プロパティの詳細、およびこの SDK での記述に使用される用語と規則の詳細については、「[依存関係プロパティの概要](dependency-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="50027-112">依存関係プロパティの例</span><span class="sxs-lookup"><span data-stu-id="50027-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="50027-113">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスに実装されている依存関係プロパティの例 <xref:System.Windows.Controls.TextBox.Text%2A> としては、<xref:System.Windows.Controls.Control.Background%2A> プロパティ、<xref:System.Windows.FrameworkElement.Width%2A> プロパティ、およびその他の多くのプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="50027-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="50027-114">クラスによって公開される各依存関係プロパティには、その同じクラスで公開される <xref:System.Windows.DependencyProperty> 型の対応するパブリック静的フィールドがあります。</span><span class="sxs-lookup"><span data-stu-id="50027-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="50027-115">これが依存関係プロパティの識別子です。</span><span class="sxs-lookup"><span data-stu-id="50027-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="50027-116">この識別子は規則を使用して命名されます。依存関係プロパティの名前と文字列 `Property` がこれに付加されます。</span><span class="sxs-lookup"><span data-stu-id="50027-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="50027-117">たとえば、<xref:System.Windows.Controls.Control.Background%2A> プロパティの対応する <xref:System.Windows.DependencyProperty> 識別子フィールドは <xref:System.Windows.Controls.Control.BackgroundProperty>です。</span><span class="sxs-lookup"><span data-stu-id="50027-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="50027-118">識別子は、登録されたときの依存関係プロパティに関する情報を格納します。この識別子は、後で <xref:System.Windows.DependencyObject.SetValue%2A>の呼び出しなど、依存関係プロパティに関連する他の操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="50027-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="50027-119">「[依存関係プロパティの概要](dependency-properties-overview.md)」で説明したように、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のすべての依存関係プロパティ (ほとんどの添付プロパティを除く) も、"ラッパー" 実装によって CLR プロパティになります。</span><span class="sxs-lookup"><span data-stu-id="50027-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="50027-120">そのため、コードから、他の CLR プロパティを使用するのと同じ方法でラッパーを定義する CLR アクセサーを呼び出すことによって、依存関係プロパティを取得または設定できます。</span><span class="sxs-lookup"><span data-stu-id="50027-120">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="50027-121">確立された依存関係プロパティのコンシューマーは、通常、基になるプロパティシステムへの接続ポイントである <xref:System.Windows.DependencyObject> メソッド <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A>を使用しません。</span><span class="sxs-lookup"><span data-stu-id="50027-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="50027-122">代わりに、CLR プロパティの既存の実装は、識別子フィールドを適切に使用して、プロパティの `get` および `set` ラッパー実装内で <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> 呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="50027-122">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="50027-123">カスタム依存関係プロパティを自分で実装する場合、同様の方法でラッパーを定義します。</span><span class="sxs-lookup"><span data-stu-id="50027-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="50027-124">依存関係プロパティを実装すべき状況</span><span class="sxs-lookup"><span data-stu-id="50027-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="50027-125">クラスにプロパティを実装するときに、クラスが <xref:System.Windows.DependencyObject>から派生している限り、<xref:System.Windows.DependencyProperty> 識別子を使用してプロパティを返すことができるため、依存関係プロパティにすることができます。</span><span class="sxs-lookup"><span data-stu-id="50027-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="50027-126">シナリオのニーズによっては、プロパティを依存関係プロパティにすることが必要ない場合や適切でない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="50027-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="50027-127">場合によっては、プロパティをプライベート フィールドでバッキングする一般的な手法で十分な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="50027-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="50027-128">ただし、プロパティで次の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 機能の 1 つ以上をサポートする場合には、常に依存関係プロパティとしてプロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="50027-129">プロパティをスタイルで設定可能にする。</span><span class="sxs-lookup"><span data-stu-id="50027-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="50027-130">詳しくは、「 [スタイルとテンプレート](../controls/styling-and-templating.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="50027-130">For more information, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>

- <span data-ttu-id="50027-131">プロパティでデータ バインディングをサポートする。</span><span class="sxs-lookup"><span data-stu-id="50027-131">You want your property to support data binding.</span></span> <span data-ttu-id="50027-132">データ バインディングの依存関係プロパティの詳細については、「[2 つのコントロールのプロパティをバインドする](../data/how-to-bind-the-properties-of-two-controls.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="50027-133">プロパティを動的リソース参照で設定可能にする。</span><span class="sxs-lookup"><span data-stu-id="50027-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="50027-134">詳細については、「[XAML リソース](../../../desktop-wpf/fundamentals/xaml-resources-define.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-134">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="50027-135">要素ツリーの親要素からプロパティ値を自動的に継承する。</span><span class="sxs-lookup"><span data-stu-id="50027-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="50027-136">この場合は、CLR アクセス用のプロパティラッパーも作成する場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドに登録します。</span><span class="sxs-lookup"><span data-stu-id="50027-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="50027-137">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="50027-138">プロパティをアニメーション化できるようにする。</span><span class="sxs-lookup"><span data-stu-id="50027-138">You want your property to be animatable.</span></span> <span data-ttu-id="50027-139">詳しくは、「 [アニメーションの概要](../graphics-multimedia/animation-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="50027-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="50027-140">プロパティの前の値が、プロパティ システム、環境、または、ユーザーによって行われたアクションによって変更された場合、または読み取りおよびスタイルの使用によって変更された場合に、プロパティ システムに報告させる。</span><span class="sxs-lookup"><span data-stu-id="50027-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="50027-141">プロパティのメタデータを使用すると、プロパティ システムがプロパティ値が明らかに変更されたと判断するたびに呼び出されるコールバック メソッドをプロパティで指定できます。</span><span class="sxs-lookup"><span data-stu-id="50027-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="50027-142">関連する概念は、プロパティ値の強制型変換です。</span><span class="sxs-lookup"><span data-stu-id="50027-142">A related concept is property value coercion.</span></span> <span data-ttu-id="50027-143">詳しくは、「[依存関係プロパティのコールバックと検証](dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="50027-144">プロパティ値の変更に、要素のビジュアルを再構成するためのレイアウト システムが必要かどうかを報告するなど、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロセスでも使用されている確立されたメタデータ規則を使用する。</span><span class="sxs-lookup"><span data-stu-id="50027-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="50027-145">または、派生クラスが既定値などのメタデータに基づく特性を変更できるように、メタデータのオーバーライドを使用できるようする。</span><span class="sxs-lookup"><span data-stu-id="50027-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="50027-146">カスタムコントロールのプロパティを使用して、 **[プロパティ]** ウィンドウの編集など、VISUAL Studio WPF デザイナーのサポートを受ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="50027-147">詳細については、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="50027-148">これらのシナリオを検討するときに、完全に新しいプロパティを実装するよりも、既存の依存関係プロパティのメタデータをオーバーライドすることで、シナリオを実現できるかどうかも考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="50027-149">メタデータのオーバーライドが実用的かどうかは、シナリオとそのシナリオが既存の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 依存関係プロパティとクラスでの実装にどのくらい似ているかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="50027-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="50027-150">既存のプロパティでメタデータをオーバーライドする方法の詳細については、「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="50027-151">依存関係プロパティを定義するためのチェックリスト</span><span class="sxs-lookup"><span data-stu-id="50027-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="50027-152">依存関係プロパティの定義は、次の 4 つの異なる概念で構成されます。</span><span class="sxs-lookup"><span data-stu-id="50027-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="50027-153">これらの概念は、一部は実装で最終的に 1 行のコードとして結合されるため、必ずしも厳密な手順である必要はありません。</span><span class="sxs-lookup"><span data-stu-id="50027-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="50027-154">(省略可能) 依存関係プロパティのプロパティ メタデータを作成します。</span><span class="sxs-lookup"><span data-stu-id="50027-154">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="50027-155">所有者型とプロパティ値の型を指定して、プロパティ システムにプロパティ名を登録します。</span><span class="sxs-lookup"><span data-stu-id="50027-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="50027-156">プロパティのメタデータも指定します (使用している場合)。</span><span class="sxs-lookup"><span data-stu-id="50027-156">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="50027-157">所有者の種類で `public` `static` `readonly` フィールドとして <xref:System.Windows.DependencyProperty> 識別子を定義します。</span><span class="sxs-lookup"><span data-stu-id="50027-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="50027-158">依存関係プロパティの名前と一致する名前を持つ CLR "ラッパー" プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="50027-158">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="50027-159">CLR "ラッパー" プロパティの `get` と `set` アクセサーを実装して、それをバッキングする依存関係プロパティと接続します。</span><span class="sxs-lookup"><span data-stu-id="50027-159">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="50027-160">プロパティ システムにプロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="50027-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="50027-161">プロパティを依存関係プロパティにするためには、そのプロパティをプロパティ システムが保持するテーブルに登録し、その後のプロパティ システム操作で修飾子として使用する一意の識別子をプロパティに設定します。</span><span class="sxs-lookup"><span data-stu-id="50027-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="50027-162">これらの操作は、内部操作である場合もあれば、プロパティシステム Api を呼び出す独自のコードである場合もあります。</span><span class="sxs-lookup"><span data-stu-id="50027-162">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="50027-163">プロパティを登録するには、クラスの本体 (クラス内では、メンバー定義の外部) で <xref:System.Windows.DependencyProperty.Register%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="50027-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="50027-164">識別子フィールドは、戻り値として <xref:System.Windows.DependencyProperty.Register%2A> メソッドの呼び出しによっても提供されます。</span><span class="sxs-lookup"><span data-stu-id="50027-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="50027-165"><xref:System.Windows.DependencyProperty.Register%2A> 呼び出しが他のメンバー定義の外部で行われる理由は、この戻り値を使用して、クラスの一部として <xref:System.Windows.DependencyProperty> 型の `public` `static` `readonly` フィールドを割り当てて作成するためです。</span><span class="sxs-lookup"><span data-stu-id="50027-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="50027-166">このフィールドは、依存関係プロパティの識別子になります。</span><span class="sxs-lookup"><span data-stu-id="50027-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="50027-167">依存関係プロパティの命名規則</span><span class="sxs-lookup"><span data-stu-id="50027-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="50027-168">依存関係プロパティについては、確立されている命名規則があり、例外的な状況を除き、必ず従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="50027-169">依存関係プロパティ自体には、この例のように基本名 "AquariumGraphic" が設定されます。この例は、<xref:System.Windows.DependencyProperty.Register%2A>の最初のパラメーターとして指定されています。</span><span class="sxs-lookup"><span data-stu-id="50027-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="50027-170">この名前は、それぞれの登録型内で一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="50027-171">基本型から継承された依存関係プロパティは、登録型の一部に既になっていると見なされ、継承されたプロパティの名前は、再度登録することはできません。</span><span class="sxs-lookup"><span data-stu-id="50027-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="50027-172">しかし、その依存関係プロパティが継承されていない場合でも、依存関係プロパティの所有者としてクラスを追加する方法があります。詳細については、「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="50027-173">識別子フィールドを作成するときに、登録したプロパティの名前にサフィックス `Property` を付けて、このフィールドに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="50027-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="50027-174">このフィールドは依存関係プロパティの識別子で、後で独自のコードによってプロパティにアクセスする他のコードによって、ラッパーに対して実行する <xref:System.Windows.DependencyObject.SetValue%2A> および <xref:System.Windows.DependencyObject.GetValue%2A> 呼び出しの入力として使用されます。は、プロパティシステムによって許可される外部コードアクセス、および [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] プロセッサによって許可される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="50027-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="50027-175">クラス本体で依存関係プロパティを定義することは一般的な実装ですが、クラスの静的コンストラクターで依存関係プロパティを定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="50027-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="50027-176">依存関係プロパティを初期化するために複数行のコードが必要な場合には、このアプローチが適している場合があります。</span><span class="sxs-lookup"><span data-stu-id="50027-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="50027-177">"ラッパー" を実装する</span><span class="sxs-lookup"><span data-stu-id="50027-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="50027-178">ラッパーの実装では、`get` の実装で <xref:System.Windows.DependencyObject.GetValue%2A> を呼び出す必要があります。また、`set` 実装で <xref:System.Windows.DependencyObject.SetValue%2A> します (わかりやすくするために、元の登録呼び出しとフィールドもここに表示されています)。</span><span class="sxs-lookup"><span data-stu-id="50027-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="50027-179">すべての例外的な状況では、ラッパーの実装では <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> のアクションのみを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="50027-180">この理由については、「[XAML 読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)」のトピックで説明しています。</span><span class="sxs-lookup"><span data-stu-id="50027-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="50027-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスで提供されているすべての既存のパブリックな依存関係プロパティは、この単純なラッパー実装モデルを使用します。依存関係プロパティのしくみの複雑さの大部分は、本質的にプロパティ システムの動作であるか、強制変換やプロパティ メタデータを通じたプロパティ変更のコールバックなど、その他の概念を通じて実装されます。</span><span class="sxs-lookup"><span data-stu-id="50027-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="50027-182">この場合も、慣例により、ラッパープロパティの名前は、選択した名前と同じである必要があります。また、プロパティを登録した <xref:System.Windows.DependencyProperty.Register%2A> 呼び出しの最初のパラメーターとして指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="50027-183">プロパティが規則に従っていない場合、すべての可能な使用を無効にする必要はありませんが、次のような注目すべき問題がいくつか発生します。</span><span class="sxs-lookup"><span data-stu-id="50027-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="50027-184">スタイルとテンプレートの一部が機能しない。</span><span class="sxs-lookup"><span data-stu-id="50027-184">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="50027-185">ほとんどのツールとデザイナーは、適切に [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] をシリアル化するため、またはプロパティごとのレベルでのデザイナー環境のサポートを提供するために命名規則に依存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="50027-186">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ローダーの現在の実装は、属性値を処理するときに、ラッパーを完全にバイパスして、命名規則に依存しています。</span><span class="sxs-lookup"><span data-stu-id="50027-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="50027-187">詳しくは、「[XAML 読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="50027-188">新しい依存関係プロパティのプロパティ メタデータ</span><span class="sxs-lookup"><span data-stu-id="50027-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="50027-189">依存関係プロパティを登録するときに、プロパティ システムを通じて登録すると、プロパティの特性を格納するメタデータ オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="50027-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="50027-190">これらの特性の多くには、プロパティが <xref:System.Windows.DependencyProperty.Register%2A>の単純なシグネチャに登録されている場合に設定される既定値があります。</span><span class="sxs-lookup"><span data-stu-id="50027-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="50027-191"><xref:System.Windows.DependencyProperty.Register%2A> の他の署名では、プロパティを登録するときに必要なメタデータを指定できます。</span><span class="sxs-lookup"><span data-stu-id="50027-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="50027-192">依存関係プロパティに指定される最も一般的なメタデータは、プロパティを使用する新しいインスタンスに適用される既定値を与えるためのものです。</span><span class="sxs-lookup"><span data-stu-id="50027-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="50027-193"><xref:System.Windows.FrameworkElement>の派生クラスに存在する依存関係プロパティを作成する場合は、基本 <xref:System.Windows.PropertyMetadata> クラスではなく、より特殊化されたメタデータクラス <xref:System.Windows.FrameworkPropertyMetadata> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="50027-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="50027-194"><xref:System.Windows.FrameworkPropertyMetadata> クラスのコンストラクターには、さまざまなメタデータ特性を組み合わせて指定できるいくつかのシグネチャがあります。</span><span class="sxs-lookup"><span data-stu-id="50027-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="50027-195">既定値のみを指定する場合は、<xref:System.Object>型の1つのパラメーターを受け取る署名を使用します。</span><span class="sxs-lookup"><span data-stu-id="50027-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="50027-196">そのオブジェクトパラメーターは、プロパティの型固有の既定値として渡します (提供される既定値は、<xref:System.Windows.DependencyProperty.Register%2A> 呼び出しで `propertyType` パラメーターとして指定した型である必要があります)。</span><span class="sxs-lookup"><span data-stu-id="50027-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="50027-197"><xref:System.Windows.FrameworkPropertyMetadata>には、プロパティのメタデータオプションフラグを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="50027-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="50027-198">これらのフラグは、登録後にプロパティ メタデータで個々のプロパティに変換され、特定の条件をレイアウト エンジンなどの他のプロセスに伝えるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="50027-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="50027-199">適切なメタデータ フラグの設定</span><span class="sxs-lookup"><span data-stu-id="50027-199">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="50027-200">プロパティ (またはその値の変更) が [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]に影響を与える場合、特に、レイアウトシステムがページ内の要素のサイズを設定または表示する方法に影響を与える場合は、次のフラグを1つ以上設定します: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="50027-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="50027-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> は、このプロパティに対する変更によって、親オブジェクトが親内で必要になる可能性のある領域が含まれている場合に、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] レンダリングを変更する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="50027-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="50027-202">たとえば、"Width" プロパティには、このフラグが設定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-202">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="50027-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> は、このプロパティへの変更によって、通常は専用の領域を変更する必要がないが、スペース内の位置が変更されたことを示す [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] のレンダリングを変更する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="50027-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="50027-204">たとえば、"Alignment" プロパティには、このフラグが設定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-204">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="50027-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> は、レイアウトや測定に影響を与えずに、別のレンダリングが必要な他の変更が発生したことを示します。</span><span class="sxs-lookup"><span data-stu-id="50027-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="50027-206">"Background" など、既存の要素の色を変更するプロパティはその一例です。</span><span class="sxs-lookup"><span data-stu-id="50027-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="50027-207">これらのフラグは、プロパティ システムやレイアウトのコールバックの独自のオーバーライド実装のためのメタデータのプロトコルとしてよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="50027-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="50027-208">たとえば、インスタンスのいずれかのプロパティが値の変更を報告し、そのメタデータで `true` として <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> た場合、<xref:System.Windows.UIElement.InvalidateArrange%2A> を呼び出す <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> コールバックがあるとします。</span><span class="sxs-lookup"><span data-stu-id="50027-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="50027-209">上記で説明した必要なサイズを変更する方法に加え、一部のプロパティは含まれる親要素のレンダリング特性に影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="50027-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="50027-210">例として、フロードキュメントモデルで使用される <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> プロパティがあります。このプロパティを変更すると、その段落を含むフロードキュメントの全体的なレンダリングを変更できます。</span><span class="sxs-lookup"><span data-stu-id="50027-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="50027-211"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> または <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> を使用して、独自のプロパティで類似したケースを特定します。</span><span class="sxs-lookup"><span data-stu-id="50027-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="50027-212">既定では、依存関係プロパティはデータ バインディングをサポートします。</span><span class="sxs-lookup"><span data-stu-id="50027-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="50027-213">データ バインディングにとって現実的なシナリオがない場合や、大きなオブジェクトのデータ バインディングのパフォーマンスが問題として認識される場合には、意図的にデータ バインディングを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="50027-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="50027-214">既定では、依存関係プロパティのデータバインディング <xref:System.Windows.Data.Binding.Mode%2A> は既定で <xref:System.Windows.Data.BindingMode.OneWay>に設定されています。</span><span class="sxs-lookup"><span data-stu-id="50027-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="50027-215">バインドは、バインドインスタンスごとに <xref:System.Windows.Data.BindingMode.TwoWay> するようにいつでも変更できます。詳細については、「[バインディングの方向を指定する](../data/how-to-specify-the-direction-of-the-binding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="50027-216">ただし、依存関係プロパティの作成者は、プロパティが既定で <xref:System.Windows.Data.BindingMode.TwoWay> バインドモードを使用するように選択できます。</span><span class="sxs-lookup"><span data-stu-id="50027-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="50027-217">既存の依存関係プロパティの例としては、<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>があります。このプロパティのシナリオでは、<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 設定ロジックと <xref:System.Windows.Controls.MenuItem> の合成が既定のテーマスタイルと対話します。</span><span class="sxs-lookup"><span data-stu-id="50027-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="50027-218"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> プロパティロジックは、データバインディングをネイティブに使用して、他の状態プロパティやメソッド呼び出しに従ってプロパティの状態を維持します。</span><span class="sxs-lookup"><span data-stu-id="50027-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="50027-219">既定で <xref:System.Windows.Data.BindingMode.TwoWay> をバインドするもう1つのプロパティの例は <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="50027-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="50027-220"><xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> フラグを設定することによって、カスタム依存関係プロパティでプロパティの継承を有効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="50027-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="50027-221">プロパティの継承は、親要素と子要素に共通のプロパティがあるシナリオに便利で、子要素に、親に設定されたのと同じ値に設定した特定のプロパティ値を持たせることは理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="50027-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="50027-222">継承可能なプロパティの例として <xref:System.Windows.FrameworkElement.DataContext%2A>があります。これは、データ表示の重要なマスター詳細シナリオを有効にするためにバインド操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="50027-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="50027-223"><xref:System.Windows.FrameworkElement.DataContext%2A> 継承可能にすることで、すべての子要素もそのデータコンテキストを継承します。</span><span class="sxs-lookup"><span data-stu-id="50027-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="50027-224">プロパティ値の継承により、ページまたはアプリケーションのルートでデータ コンテキストを指定できます。すべての使用可能な子要素内のバインディングに再度指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="50027-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="50027-225">また <xref:System.Windows.FrameworkElement.DataContext%2A> は、継承によって既定値がオーバーライドされることを示す良い例でもありますが、常に特定の子要素でローカルに設定することができます。詳細については、「[階層データでマスター詳細パターンを使用する](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="50027-226">プロパティ値の継承にはパフォーマンスが低下する可能性があるため、控え目に使用する必要があります。詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="50027-227"><xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> フラグを設定して、ナビゲーションジャーナリングサービスで依存関係プロパティを検出または使用する必要があるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="50027-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="50027-228">例として、<xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> プロパティがあります。選択コントロールで選択された項目は、履歴履歴がナビゲートされるときに保持される必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="50027-229">読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="50027-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="50027-230">読み取り専用の依存関係プロパティを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="50027-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="50027-231">ただし、読み取り専用としてプロパティを定義する理由のシナリオには、プロパティ システムに登録して、識別子を公開するための手順が異なるため、若干の違いがあります。</span><span class="sxs-lookup"><span data-stu-id="50027-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="50027-232">詳細については、「[読み取り専用の依存関係プロパティ](read-only-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="50027-233">コレクション型依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="50027-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="50027-234">コレクション型依存関係プロパティには、考慮すべき実装問題が他にもいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="50027-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="50027-235">詳細については、「[コレクション型依存関係プロパティ](collection-type-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="50027-236">依存関係プロパティのセキュリティに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="50027-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="50027-237">依存関係プロパティは、パブリック プロパティとして宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="50027-238">依存関係プロパティ識別子フィールドは、パブリック静的フィールドとして宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="50027-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="50027-239">他のアクセスレベル (protected など) を宣言しようとしても、依存関係プロパティは、プロパティシステム Api と組み合わせて、識別子を使用していつでもアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="50027-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="50027-240">メタデータレポートや、プロパティシステムの一部である値の決定 Api (<xref:System.Windows.LocalValueEnumerator>など) が原因で、保護された識別子フィールドにアクセスできる可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="50027-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="50027-241">詳細については、「[依存関係プロパティのセキュリティ](dependency-property-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="50027-242">依存関係プロパティとクラス コンストラクター</span><span class="sxs-lookup"><span data-stu-id="50027-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="50027-243">マネージド コード プログラミングでは、クラス コンストラクターが仮想メソッドを呼び出さないという一般的な方針があります (多くの場合は FxCop などのコード分析ツールによって適用されます)。</span><span class="sxs-lookup"><span data-stu-id="50027-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="50027-244">これは、派生クラスのコンストラクターの基本の初期化としてコンストラクターを呼び出すことができ、コンストラクターから仮想メソッドを入力することで、構築されるオブジェクトのインスタンスの初期化が不完全な状態で行われる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="50027-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="50027-245"><xref:System.Windows.DependencyObject>から派生したクラスから派生する場合は、プロパティシステム自体がを呼び出し、仮想メソッドを内部的に公開していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="50027-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="50027-246">これらの仮想メソッドは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システム サービスの一部です。</span><span class="sxs-lookup"><span data-stu-id="50027-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="50027-247">メソッドをオーバーライドすることで、派生クラスが値の決定に参加できるようになります。</span><span class="sxs-lookup"><span data-stu-id="50027-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="50027-248">ランタイムの初期化の潜在的な問題を回避するには、非常に特殊なコンストラクター パターンに従っている場合を除き、依存関係プロパティの値をクラスのコンストラクター内で設定しないでください。</span><span class="sxs-lookup"><span data-stu-id="50027-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="50027-249">詳細については、「[DependencyObject の安全なコンストラクター パターン](safe-constructor-patterns-for-dependencyobjects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="50027-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="50027-250">関連項目</span><span class="sxs-lookup"><span data-stu-id="50027-250">See also</span></span>

- [<span data-ttu-id="50027-251">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="50027-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="50027-252">依存関係プロパティのメタデータ</span><span class="sxs-lookup"><span data-stu-id="50027-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="50027-253">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="50027-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="50027-254">コレクション型依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="50027-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="50027-255">依存関係プロパティのセキュリティ</span><span class="sxs-lookup"><span data-stu-id="50027-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="50027-256">XAML 読み込みと依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="50027-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="50027-257">DependencyObject の安全なコンストラクター パターン</span><span class="sxs-lookup"><span data-stu-id="50027-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
