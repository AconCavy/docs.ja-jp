---
title: カスタム依存関係プロパティ
description: Windows Presentation Foundation でプロパティを実装する手順と、プロパティのパフォーマンス、使いやすさ、または多用性を向上させるためのオプションについて学習します。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: b082340afb8b1a814fc5923126aa58183d43bc01
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168154"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="068b5-103">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="068b5-103">Custom Dependency Properties</span></span>

<span data-ttu-id="068b5-104">このトピックは、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] アプリケーション開発者およびコンポーネントの作成者が、カスタム依存関係プロパティを作成したくなる理由を説明し、実装手順にくわえ、プロパティのパフォーマンス、使いやすさ、または多用性を向上させることができるいくつかの実装オプションについて説明します。</span><span class="sxs-lookup"><span data-stu-id="068b5-104">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="068b5-105">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="068b5-105">Prerequisites</span></span>

<span data-ttu-id="068b5-106">このトピックは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスの既存の依存関係プロパティのコンシューマーの観点から依存関係プロパティを理解しており、「[依存関係プロパティの概要](dependency-properties-overview.md)」というトピックを読んでいることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="068b5-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="068b5-107">このトピックの例を理解するには、[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] について理解し、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] アプリケーションの作成方法に精通している必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="068b5-108">依存関係プロパティとは</span><span class="sxs-lookup"><span data-stu-id="068b5-108">What Is a Dependency Property?</span></span>

<span data-ttu-id="068b5-109">共通言語ランタイム (CLR) プロパティを依存関係プロパティとして実装することで、プロパティでスタイル設定、データ バインディング、継承、アニメーション、および既定値のサポートを有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-109">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="068b5-110">依存関係プロパティは、<xref:System.Windows.DependencyProperty.Register%2A> メソッド (または <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>) を呼び出すことで [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システムに登録され、<xref:System.Windows.DependencyProperty> 識別子フィールドによってバッキングされるプロパティです。</span><span class="sxs-lookup"><span data-stu-id="068b5-110">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="068b5-111">依存関係プロパティは、<xref:System.Windows.DependencyObject> 型でのみ使用できますが、<xref:System.Windows.DependencyObject> は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラス階層でかなり上位にあるため、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] で使用可能なほとんどのクラスで依存関係プロパティをサポートすることができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-111">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="068b5-112">依存関係プロパティと、これらをこの SDK で説明するために使用されている用語と規則の詳細については、「[依存関係プロパティの概要](dependency-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-112">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="068b5-113">依存関係プロパティの例</span><span class="sxs-lookup"><span data-stu-id="068b5-113">Examples of Dependency Properties</span></span>

<span data-ttu-id="068b5-114">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスで実装される依存関係プロパティの例は、<xref:System.Windows.Controls.Control.Background%2A> プロパティ、<xref:System.Windows.FrameworkElement.Width%2A> プロパティ、<xref:System.Windows.Controls.TextBox.Text%2A> など、多数あります。</span><span class="sxs-lookup"><span data-stu-id="068b5-114">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="068b5-115">クラスによって公開される各依存関係プロパティには、同じクラスで公開されている <xref:System.Windows.DependencyProperty> 型の対応するパブリックな静的フィールドがあります。</span><span class="sxs-lookup"><span data-stu-id="068b5-115">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="068b5-116">これが依存関係プロパティの識別子です。</span><span class="sxs-lookup"><span data-stu-id="068b5-116">This is the identifier for the dependency property.</span></span> <span data-ttu-id="068b5-117">この識別子は規則を使用して命名されます。依存関係プロパティの名前と文字列 `Property` がこれに付加されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-117">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="068b5-118">たとえば、<xref:System.Windows.Controls.Control.Background%2A> プロパティに対応する <xref:System.Windows.DependencyProperty> 識別子フィールドは <xref:System.Windows.Controls.Control.BackgroundProperty> です。</span><span class="sxs-lookup"><span data-stu-id="068b5-118">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="068b5-119">識別子には、登録時の依存関係プロパティに関する情報が格納され、識別子はその後、<xref:System.Windows.DependencyObject.SetValue%2A> の呼び出しなど、依存関係プロパティが関係するその他の操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-119">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="068b5-120">「[依存関係プロパティの概要](dependency-properties-overview.md)」で説明されているように、"ラッパー" の実装により、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 内のすべての依存関係プロパティ (ほとんどの添付プロパティを除く) も CLR プロパティです。</span><span class="sxs-lookup"><span data-stu-id="068b5-120">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="068b5-121">そのため、他の CLR プロパティで使用するのと同じ方法でラッパーが定義されている CLR アクセサーを呼び出すことで、コードから依存関係プロパティを取得または設定できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-121">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="068b5-122">確立された依存関係プロパティのコンシューマーは、基になるプロパティ システムへの接続ポイントである、<xref:System.Windows.DependencyObject> のメソッド <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> を、通常は使用しません。</span><span class="sxs-lookup"><span data-stu-id="068b5-122">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="068b5-123">むしろ、CLR プロパティの既存の実装では、識別子のフィールドを適切に使用して、プロパティの `get` および `set` のラッパーの実装内で、<xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> が既に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="068b5-123">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="068b5-124">カスタム依存関係プロパティを自分で実装する場合、同様の方法でラッパーを定義します。</span><span class="sxs-lookup"><span data-stu-id="068b5-124">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="068b5-125">依存関係プロパティを実装すべき状況</span><span class="sxs-lookup"><span data-stu-id="068b5-125">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="068b5-126">クラスにプロパティを実装する場合、クラスが <xref:System.Windows.DependencyObject> から派生している限り、プロパティを <xref:System.Windows.DependencyProperty> 識別子でバッキングして、依存関係プロパティにすることができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-126">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="068b5-127">シナリオのニーズによっては、プロパティを依存関係プロパティにすることが必要ない場合や適切でない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="068b5-127">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="068b5-128">場合によっては、プロパティをプライベート フィールドでバッキングする一般的な手法で十分な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="068b5-128">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="068b5-129">ただし、プロパティで次の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 機能の 1 つ以上をサポートする場合には、常に依存関係プロパティとしてプロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-129">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="068b5-130">プロパティをスタイルで設定可能にする。</span><span class="sxs-lookup"><span data-stu-id="068b5-130">You want your property to be settable in a style.</span></span> <span data-ttu-id="068b5-131">詳しくは、「 [スタイルとテンプレート](../../../desktop-wpf/fundamentals/styles-templates-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="068b5-131">For more information, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

- <span data-ttu-id="068b5-132">プロパティでデータ バインディングをサポートする。</span><span class="sxs-lookup"><span data-stu-id="068b5-132">You want your property to support data binding.</span></span> <span data-ttu-id="068b5-133">データ バインディングの依存関係プロパティの詳細については、「[2 つのコントロールのプロパティをバインドする](../data/how-to-bind-the-properties-of-two-controls.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-133">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="068b5-134">プロパティを動的リソース参照で設定可能にする。</span><span class="sxs-lookup"><span data-stu-id="068b5-134">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="068b5-135">詳細については、「[XAML リソース](../../../desktop-wpf/fundamentals/xaml-resources-define.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-135">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="068b5-136">要素ツリーの親要素からプロパティ値を自動的に継承する。</span><span class="sxs-lookup"><span data-stu-id="068b5-136">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="068b5-137">この場合、CLR アクセスのプロパティ ラッパーも作成する場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドに登録します。</span><span class="sxs-lookup"><span data-stu-id="068b5-137">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="068b5-138">詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-138">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="068b5-139">プロパティをアニメーション化できるようにする。</span><span class="sxs-lookup"><span data-stu-id="068b5-139">You want your property to be animatable.</span></span> <span data-ttu-id="068b5-140">詳しくは、「 [アニメーションの概要](../graphics-multimedia/animation-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="068b5-140">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="068b5-141">プロパティの前の値が、プロパティ システム、環境、または、ユーザーによって行われたアクションによって変更された場合、または読み取りおよびスタイルの使用によって変更された場合に、プロパティ システムに報告させる。</span><span class="sxs-lookup"><span data-stu-id="068b5-141">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="068b5-142">プロパティのメタデータを使用すると、プロパティ システムがプロパティ値が明らかに変更されたと判断するたびに呼び出されるコールバック メソッドをプロパティで指定できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-142">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="068b5-143">関連する概念は、プロパティ値の強制型変換です。</span><span class="sxs-lookup"><span data-stu-id="068b5-143">A related concept is property value coercion.</span></span> <span data-ttu-id="068b5-144">詳しくは、「[依存関係プロパティのコールバックと検証](dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-144">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="068b5-145">プロパティ値の変更に、要素のビジュアルを再構成するためのレイアウト システムが必要かどうかを報告するなど、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロセスでも使用されている確立されたメタデータ規則を使用する。</span><span class="sxs-lookup"><span data-stu-id="068b5-145">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="068b5-146">または、派生クラスが既定値などのメタデータに基づく特性を変更できるように、メタデータのオーバーライドを使用できるようする。</span><span class="sxs-lookup"><span data-stu-id="068b5-146">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="068b5-147">カスタム コントロールのプロパティで、 **[プロパティ]** ウィンドウの編集などの Visual Studio WPF デザイナーのサポートを受ける。</span><span class="sxs-lookup"><span data-stu-id="068b5-147">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="068b5-148">詳しくは、「[コントロールの作成の概要](../controls/control-authoring-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-148">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="068b5-149">これらのシナリオを検討するときに、完全に新しいプロパティを実装するよりも、既存の依存関係プロパティのメタデータをオーバーライドすることで、シナリオを実現できるかどうかも考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-149">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="068b5-150">メタデータのオーバーライドが実用的かどうかは、シナリオとそのシナリオが既存の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 依存関係プロパティとクラスでの実装にどのくらい似ているかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="068b5-150">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="068b5-151">既存のプロパティでメタデータをオーバーライドする方法の詳細については、「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-151">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="068b5-152">依存関係プロパティを定義するためのチェックリスト</span><span class="sxs-lookup"><span data-stu-id="068b5-152">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="068b5-153">依存関係プロパティの定義は、次の 4 つの異なる概念で構成されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-153">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="068b5-154">これらの概念は、一部は実装で最終的に 1 行のコードとして結合されるため、必ずしも厳密な手順である必要はありません。</span><span class="sxs-lookup"><span data-stu-id="068b5-154">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="068b5-155">(省略可能) 依存関係プロパティのプロパティ メタデータを作成します。</span><span class="sxs-lookup"><span data-stu-id="068b5-155">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="068b5-156">所有者型とプロパティ値の型を指定して、プロパティ システムにプロパティ名を登録します。</span><span class="sxs-lookup"><span data-stu-id="068b5-156">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="068b5-157">プロパティのメタデータも指定します (使用している場合)。</span><span class="sxs-lookup"><span data-stu-id="068b5-157">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="068b5-158">所有者型で <xref:System.Windows.DependencyProperty> 識別子を `public` `static` `readonly` フィールドとして定義します。</span><span class="sxs-lookup"><span data-stu-id="068b5-158">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="068b5-159">名前が依存関係プロパティの名前と一致する CLR "ラッパー" プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="068b5-159">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="068b5-160">CLR "ラッパー" プロパティの `get` と `set` のアクセサーを実装して、バッキングする依存関係プロパティと接続します。</span><span class="sxs-lookup"><span data-stu-id="068b5-160">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="068b5-161">プロパティ システムにプロパティを登録する</span><span class="sxs-lookup"><span data-stu-id="068b5-161">Registering the Property with the Property System</span></span>

<span data-ttu-id="068b5-162">プロパティを依存関係プロパティにするためには、そのプロパティをプロパティ システムが保持するテーブルに登録し、その後のプロパティ システム操作で修飾子として使用する一意の識別子をプロパティに設定します。</span><span class="sxs-lookup"><span data-stu-id="068b5-162">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="068b5-163">これらの操作は、内部操作にすることも、プロパティ システム API を呼び出す独自のコードにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="068b5-163">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="068b5-164">プロパティを登録するには、クラスの本文内 (クラス内部だが任意のメンバーの定義の外側) で <xref:System.Windows.DependencyProperty.Register%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="068b5-164">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="068b5-165">識別子フィールドも <xref:System.Windows.DependencyProperty.Register%2A> メソッドの呼び出しによって、戻り値として提供されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-165">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="068b5-166"><xref:System.Windows.DependencyProperty.Register%2A> の呼び出しが他のメンバー定義の外部で行われる理由は、この戻り値を使用して、<xref:System.Windows.DependencyProperty> 型の `public` `static` `readonly` フィールドをクラスの一部として割り当ておよび作成するからです。</span><span class="sxs-lookup"><span data-stu-id="068b5-166">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="068b5-167">このフィールドは、依存関係プロパティの識別子になります。</span><span class="sxs-lookup"><span data-stu-id="068b5-167">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="068b5-168">依存関係プロパティの命名規則</span><span class="sxs-lookup"><span data-stu-id="068b5-168">Dependency Property Name Conventions</span></span>

<span data-ttu-id="068b5-169">依存関係プロパティについては、確立されている命名規則があり、例外的な状況を除き、必ず従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-169">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="068b5-170">依存関係プロパティ自体には、基本的な名前 (この例では "AquariumGraphic") があります。この名前は、<xref:System.Windows.DependencyProperty.Register%2A> の最初のパラメーターとして指定されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-170">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="068b5-171">この名前は、それぞれの登録型内で一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-171">That name must be unique within each registering type.</span></span> <span data-ttu-id="068b5-172">基本型から継承された依存関係プロパティは、登録型の一部に既になっていると見なされ、継承されたプロパティの名前は、再度登録することはできません。</span><span class="sxs-lookup"><span data-stu-id="068b5-172">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="068b5-173">しかし、その依存関係プロパティが継承されていない場合でも、依存関係プロパティの所有者としてクラスを追加する方法があります。詳細については、「[依存関係プロパティのメタデータ](dependency-property-metadata.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-173">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="068b5-174">識別子フィールドを作成するときに、登録したプロパティの名前にサフィックス `Property` を付けて、このフィールドに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="068b5-174">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="068b5-175">このフィールドは、依存関係プロパティの識別子です。これは後でラッパー内で行う <xref:System.Windows.DependencyObject.SetValue%2A> と <xref:System.Windows.DependencyObject.GetValue%2A> の呼び出しの入力として、プロパティにアクセスする他のコード、独自のコード、許可した任意の外部コードのアクセス、プロパティ システムによって使用され、また [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] プロセッサによって潜在的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-175">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="068b5-176">クラス本体で依存関係プロパティを定義することは一般的な実装ですが、クラスの静的コンストラクターで依存関係プロパティを定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="068b5-176">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="068b5-177">依存関係プロパティを初期化するために複数行のコードが必要な場合には、このアプローチが適している場合があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-177">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="068b5-178">"ラッパー" を実装する</span><span class="sxs-lookup"><span data-stu-id="068b5-178">Implementing the "Wrapper"</span></span>

<span data-ttu-id="068b5-179">ラッパーの実装では、`get` の実装で <xref:System.Windows.DependencyObject.GetValue%2A> を呼び出し、`set` の実装で <xref:System.Windows.DependencyObject.SetValue%2A> を呼び出す必要があります (わかりやすくするため、ここには元の登録の呼び出しとフィールドも示されています)。</span><span class="sxs-lookup"><span data-stu-id="068b5-179">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="068b5-180">例外的な状況を除き、ラッパーの実装では <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> の操作のみをそれぞれ実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-180">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="068b5-181">この理由については、「[XAML 読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)」のトピックで説明しています。</span><span class="sxs-lookup"><span data-stu-id="068b5-181">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="068b5-182">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] クラスで提供されているすべての既存のパブリックな依存関係プロパティは、この単純なラッパー実装モデルを使用します。依存関係プロパティのしくみの複雑さの大部分は、本質的にプロパティ システムの動作であるか、強制変換やプロパティ メタデータを通じたプロパティ変更のコールバックなど、その他の概念を通じて実装されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-182">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="068b5-183">ここでも、規則により、ラッパー プロパティの名前は、プロパティを登録した <xref:System.Windows.DependencyProperty.Register%2A> 呼び出しの最初のパラメーターとして選択して指定した名前と同じである必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-183">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="068b5-184">プロパティが規則に従っていない場合、すべての可能な使用を無効にする必要はありませんが、次のような注目すべき問題がいくつか発生します。</span><span class="sxs-lookup"><span data-stu-id="068b5-184">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="068b5-185">スタイルとテンプレートの一部が機能しない。</span><span class="sxs-lookup"><span data-stu-id="068b5-185">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="068b5-186">ほとんどのツールとデザイナーは、適切に [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] をシリアル化するため、またはプロパティごとのレベルでのデザイナー環境のサポートを提供するために命名規則に依存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-186">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="068b5-187">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ローダーの現在の実装は、属性値を処理するときに、ラッパーを完全にバイパスして、名前付け規則に依存しています。</span><span class="sxs-lookup"><span data-stu-id="068b5-187">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="068b5-188">詳しくは、「[XAML 読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-188">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="068b5-189">新しい依存関係プロパティのプロパティ メタデータ</span><span class="sxs-lookup"><span data-stu-id="068b5-189">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="068b5-190">依存関係プロパティを登録するときに、プロパティ システムを通じて登録すると、プロパティの特性を格納するメタデータ オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-190">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="068b5-191">これらの特性の多くには、プロパティが <xref:System.Windows.DependencyProperty.Register%2A> の単純なシグネチャで登録された場合に設定される既定の設定があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-191">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="068b5-192"><xref:System.Windows.DependencyProperty.Register%2A> の他のシグネチャでは、プロパティを登録するときに好みのメタデータを指定できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-192">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="068b5-193">依存関係プロパティに指定される最も一般的なメタデータは、プロパティを使用する新しいインスタンスに適用される既定値を与えるためのものです。</span><span class="sxs-lookup"><span data-stu-id="068b5-193">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="068b5-194"><xref:System.Windows.FrameworkElement> の派生クラスに存在する依存関係プロパティを作成する場合、基底クラス <xref:System.Windows.PropertyMetadata> ではなく、より専門的なメタデータ クラス <xref:System.Windows.FrameworkPropertyMetadata> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-194">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="068b5-195"><xref:System.Windows.FrameworkPropertyMetadata> クラスのコンストラクターには、複数のシグネチャがあり、組み合わせてさまざまなメタデータの特性を指定できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-195">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="068b5-196">既定値のみを指定する場合は、型 <xref:System.Object> の 1 つのパラメーターを受け取るシグネチャを使用します。</span><span class="sxs-lookup"><span data-stu-id="068b5-196">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="068b5-197">そのオブジェクトのパラメーターをプロパティの型固有の既定値として渡します (提供された既定値は、<xref:System.Windows.DependencyProperty.Register%2A> の呼び出しで `propertyType` パラメーターとして指定した型である必要があります)。</span><span class="sxs-lookup"><span data-stu-id="068b5-197">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="068b5-198"><xref:System.Windows.FrameworkPropertyMetadata> に対しては、プロパティのメタデータのオプション フラグを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="068b5-198">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="068b5-199">これらのフラグは、登録後にプロパティ メタデータで個々のプロパティに変換され、特定の条件をレイアウト エンジンなどの他のプロセスに伝えるために使用されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-199">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="068b5-200">適切なメタデータ フラグの設定</span><span class="sxs-lookup"><span data-stu-id="068b5-200">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="068b5-201">プロパティ (またはその値の変更) が[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] に影響する場合、特にレイアウト システムのサイズ設定またはページへの要素のレンダリング方法に影響を及ぼす場合は、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> のフラグを 1 つ以上設定します。</span><span class="sxs-lookup"><span data-stu-id="068b5-201">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="068b5-202"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> は、含まれるオブジェクトが親内の領域を多かれ少なかれ必要とする場合がある場所でこのプロパティを変更するには、[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] レンダリングへの変更が必要なことを示します。</span><span class="sxs-lookup"><span data-stu-id="068b5-202"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="068b5-203">たとえば、"Width" プロパティには、このフラグが設定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-203">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="068b5-204"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> は、このプロパティを変更するには、通常は専用領域の変更の必要がない [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] レンダリングへの変更が必要なことを示しますが、領域内での配置は変更されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="068b5-204"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="068b5-205">たとえば、"Alignment" プロパティには、このフラグが設定されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-205">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="068b5-206"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> は、レイアウトとメジャーには影響しないものの、別のレンダリングを必要とするその他の変更が発生していることを示します。</span><span class="sxs-lookup"><span data-stu-id="068b5-206"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="068b5-207">"Background" など、既存の要素の色を変更するプロパティはその一例です。</span><span class="sxs-lookup"><span data-stu-id="068b5-207">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="068b5-208">これらのフラグは、プロパティ システムやレイアウトのコールバックの独自のオーバーライド実装のためのメタデータのプロトコルとしてよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-208">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="068b5-209">たとえば、インスタンスの任意のプロパティが値の変更を報告し、そのメタデータ内で <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> が `true` に設定されている場合は、<xref:System.Windows.UIElement.InvalidateArrange%2A> を呼び出す <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> コールバックを使用できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-209">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="068b5-210">上記で説明した必要なサイズを変更する方法に加え、一部のプロパティは含まれる親要素のレンダリング特性に影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-210">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="068b5-211">例として、フロー ドキュメント モデルで使用される <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> プロパティがあります。これは、そのプロパティへの変更によって、段落を含むフロー ドキュメントの全体的なレンダリングを変更できます。</span><span class="sxs-lookup"><span data-stu-id="068b5-211">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="068b5-212"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> または <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> を使用して、独自のプロパティで同様のケースを特定します。</span><span class="sxs-lookup"><span data-stu-id="068b5-212">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="068b5-213">既定では、依存関係プロパティはデータ バインディングをサポートします。</span><span class="sxs-lookup"><span data-stu-id="068b5-213">By default, dependency properties support data binding.</span></span> <span data-ttu-id="068b5-214">データ バインディングにとって現実的なシナリオがない場合や、大きなオブジェクトのデータ バインディングのパフォーマンスが問題として認識される場合には、意図的にデータ バインディングを無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-214">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="068b5-215">既定では、依存関係プロパティのデータ バインディング <xref:System.Windows.Data.Binding.Mode%2A> の既定値は <xref:System.Windows.Data.BindingMode.OneWay> です。</span><span class="sxs-lookup"><span data-stu-id="068b5-215">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="068b5-216">バインドはバインディング インスタンスごとにいつでも <xref:System.Windows.Data.BindingMode.TwoWay> に変更できます。詳細については、[バインディングの方向の指定](../data/how-to-specify-the-direction-of-the-binding.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-216">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="068b5-217">ただし、依存関係プロパティの作成者は、プロパティで <xref:System.Windows.Data.BindingMode.TwoWay> バインド モードを既定で使用するように選択することができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-217">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="068b5-218">既存の依存関係プロパティの例として <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType> があります。このプロパティのシナリオでは、<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 設定ロジックと <xref:System.Windows.Controls.MenuItem> の合成により、既定のテーマ スタイルとの対話が行われます。</span><span class="sxs-lookup"><span data-stu-id="068b5-218">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="068b5-219"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> プロパティ ロジックでは、データ バインディングをネイティブに使用し、他の状態プロパティとメソッドの呼び出しに従って、プロパティの状態が維持されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-219">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="068b5-220">既定で <xref:System.Windows.Data.BindingMode.TwoWay> をバインドするプロパティの別の例には、<xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType> があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-220">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="068b5-221"><xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> フラグを設定することで、カスタム依存関係プロパティでプロパティの継承を有効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="068b5-221">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="068b5-222">プロパティの継承は、親要素と子要素に共通のプロパティがあるシナリオに便利で、子要素に、親に設定されたのと同じ値に設定した特定のプロパティ値を持たせることは理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="068b5-222">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="068b5-223">継承可能なプロパティの例は、<xref:System.Windows.FrameworkElement.DataContext%2A> です。これは、データの表示に重要なマスターと詳細のシナリオを有効にするためのバインディング操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="068b5-223">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="068b5-224"><xref:System.Windows.FrameworkElement.DataContext%2A> を継承可能にすることで、すべての子要素もそのデータ コンテキストを継承します。</span><span class="sxs-lookup"><span data-stu-id="068b5-224">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="068b5-225">プロパティ値の継承により、ページまたはアプリケーションのルートでデータ コンテキストを指定できます。すべての使用可能な子要素内のバインディングに再度指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="068b5-225">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="068b5-226"><xref:System.Windows.FrameworkElement.DataContext%2A> は、継承が既定値をオーバーライドするものの、常に特定の任意の子要素でローカルに設定できることを示す良い例でもあります。詳細については、[階層データでのマスター詳細パターンの使用](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-226"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="068b5-227">プロパティ値の継承にはパフォーマンスが低下する可能性があるため、控え目に使用する必要があります。詳細については、「[プロパティ値の継承](property-value-inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-227">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="068b5-228"><xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> フラグを設定して、依存関係プロパティをナビゲーション ジャーナリング サービスで検出または使用するかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="068b5-228">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="068b5-229"><xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> プロパティはその一例で、選択コントロールで選択されたすべての項目は、ジャーナリング履歴がナビゲートされるときに保持される必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-229">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="068b5-230">読み取り専用の依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="068b5-230">Read-Only Dependency Properties</span></span>

<span data-ttu-id="068b5-231">読み取り専用の依存関係プロパティを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="068b5-231">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="068b5-232">ただし、読み取り専用としてプロパティを定義する理由のシナリオには、プロパティ システムに登録して、識別子を公開するための手順が異なるため、若干の違いがあります。</span><span class="sxs-lookup"><span data-stu-id="068b5-232">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="068b5-233">詳細については、「[読み取り専用の依存関係プロパティ](read-only-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-233">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="068b5-234">コレクション型依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="068b5-234">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="068b5-235">コレクション型依存関係プロパティには、考慮すべき実装問題が他にもいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="068b5-235">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="068b5-236">詳細については、「[コレクション型依存関係プロパティ](collection-type-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-236">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="068b5-237">依存関係プロパティのセキュリティに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="068b5-237">Dependency Property Security Considerations</span></span>

<span data-ttu-id="068b5-238">依存関係プロパティは、パブリック プロパティとして宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-238">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="068b5-239">依存関係プロパティ識別子フィールドは、パブリック静的フィールドとして宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="068b5-239">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="068b5-240">他のアクセス レベル (プロテクトなど) を宣言しようとした場合でも、依存関係プロパティには、プロパティ システム API と組み合わせた識別子を通じて、常にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="068b5-240">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="068b5-241">保護された識別子フィールドでも、潜在的にアクセス可能です。これは、メタデータのレポートまたは <xref:System.Windows.LocalValueEnumerator> などのプロパティ システムの一部である値決定の API によるものです。</span><span class="sxs-lookup"><span data-stu-id="068b5-241">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="068b5-242">詳細については、「[依存関係プロパティのセキュリティ](dependency-property-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-242">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="068b5-243">依存関係プロパティとクラス コンストラクター</span><span class="sxs-lookup"><span data-stu-id="068b5-243">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="068b5-244">マネージド コード プログラミングでは、クラス コンストラクターが仮想メソッドを呼び出さないという一般的な方針があります (多くの場合は FxCop などのコード分析ツールによって適用されます)。</span><span class="sxs-lookup"><span data-stu-id="068b5-244">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="068b5-245">これは、派生クラスのコンストラクターの基本の初期化としてコンストラクターを呼び出すことができ、コンストラクターから仮想メソッドを入力することで、構築されるオブジェクトのインスタンスの初期化が不完全な状態で行われる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="068b5-245">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="068b5-246"><xref:System.Windows.DependencyObject> から既に派生した任意のクラスから派生する場合、プロパティ システム自体が仮想メソッドを内部的に呼び出して公開することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-246">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="068b5-247">これらの仮想メソッドは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システム サービスの一部です。</span><span class="sxs-lookup"><span data-stu-id="068b5-247">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="068b5-248">メソッドをオーバーライドすることで、派生クラスが値の決定に参加できるようになります。</span><span class="sxs-lookup"><span data-stu-id="068b5-248">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="068b5-249">ランタイムの初期化の潜在的な問題を回避するには、非常に特殊なコンストラクター パターンに従っている場合を除き、依存関係プロパティの値をクラスのコンストラクター内で設定しないでください。</span><span class="sxs-lookup"><span data-stu-id="068b5-249">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="068b5-250">詳細については、「[DependencyObject の安全なコンストラクター パターン](safe-constructor-patterns-for-dependencyobjects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="068b5-250">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="068b5-251">関連項目</span><span class="sxs-lookup"><span data-stu-id="068b5-251">See also</span></span>

- [<span data-ttu-id="068b5-252">依存関係プロパティの概要</span><span class="sxs-lookup"><span data-stu-id="068b5-252">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="068b5-253">依存関係プロパティのメタデータ</span><span class="sxs-lookup"><span data-stu-id="068b5-253">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="068b5-254">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="068b5-254">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="068b5-255">コレクション型依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="068b5-255">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="068b5-256">依存関係プロパティのセキュリティ</span><span class="sxs-lookup"><span data-stu-id="068b5-256">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="068b5-257">XAML 読み込みと依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="068b5-257">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="068b5-258">DependencyObject の安全なコンストラクター パターン</span><span class="sxs-lookup"><span data-stu-id="068b5-258">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
