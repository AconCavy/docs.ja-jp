---
title: プレビュー イベント
ms.date: 03/30/2017
helpviewer_keywords:
- Preview events [WPF]
- suppressing events [WPF]
- events [WPF], Preview
- events [WPF], suppressing
ms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e
ms.openlocfilehash: 75165df94aa8b508ef85cf970933efb98b9d62ca
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "61772880"
---
# <a name="preview-events"></a><span data-ttu-id="1e3c9-102">プレビュー イベント</span><span class="sxs-lookup"><span data-stu-id="1e3c9-102">Preview Events</span></span>
<span data-ttu-id="1e3c9-103">プレビュー イベントは、トンネリング イベントとも呼ばれ、ルートの方向がアプリケーション ルートからイベントを発生させた要素に向かって移動し、イベント データのソースとして報告されるルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-103">Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.</span></span> <span data-ttu-id="1e3c9-104">すべてのイベント シナリオでプレビュー イベントがサポートされている、または必要とされているわけではありません。このトピックでは、プレビュー イベントが存在する状況、アプリケーションまたはコンポーネントでそれらを処理する方法、カスタム コンポーネントまたはクラスでプレビュー イベントを作成することが適切な場合について説明します。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-104">Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.</span></span>  
  
## <a name="preview-events-and-input"></a><span data-ttu-id="1e3c9-105">プレビュー イベントと入力</span><span class="sxs-lookup"><span data-stu-id="1e3c9-105">Preview Events and Input</span></span>  
 <span data-ttu-id="1e3c9-106">一般的にプレビュー イベントを処理するときは、イベント データで処理されるイベントをマークすることにご注意ください。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-106">When you handle Preview events in general, be cautious about marking the events handled in the event data.</span></span> <span data-ttu-id="1e3c9-107">発生させた要素 (イベント データでソースとして報告される要素) 以外の要素でプレビュー イベントを処理すると、発生した元のイベントを処理する機会が要素に提供されないという影響があります。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-107">Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.</span></span> <span data-ttu-id="1e3c9-108">これが望ましい結果になる場合もあります。問題の要素がコントロールの合成内のリレーションシップに存在する場合は特にそうです。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-108">Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.</span></span>  
  
 <span data-ttu-id="1e3c9-109">特に入力イベントの場合、プレビュー イベントでもイベント データ インスタンスが同等のバブリング イベントと共有されます。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-109">For input events specifically, Preview events also share event data instances with the equivalent bubbling event.</span></span> <span data-ttu-id="1e3c9-110">入力イベントを処理済みとマークするためにプレビュー イベント クラス ハンドラーを使用する場合、バブリング入力イベント クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-110">If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.</span></span> <span data-ttu-id="1e3c9-111">また、イベントを処理済みとマークするためにプレビュー イベント インスタンス ハンドラーを使用する場合、通常、バブリング イベントのハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-111">Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.</span></span> <span data-ttu-id="1e3c9-112">イベントが処理済みとしてマークされている場合でも、呼び出すオプションを使用してクラス ハンドラーまたはインスタンス ハンドラーを登録またはアタッチできますが、この手法は一般的には使用されません。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-112">Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.</span></span>  
  
 <span data-ttu-id="1e3c9-113">クラス処理とプレビュー イベントとの関係の詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](marking-routed-events-as-handled-and-class-handling.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-113">For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="1e3c9-114">コントロールによるイベント抑制の回避</span><span class="sxs-lookup"><span data-stu-id="1e3c9-114">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="1e3c9-115">プレビュー イベントが一般的に使用されるシナリオの 1 つとして、入力イベントの複合コントロール処理があります。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-115">One scenario where Preview events are commonly used is for composited control handling of input events.</span></span> <span data-ttu-id="1e3c9-116">場合によっては、コントロールの作成者が、おそらく、より多くの情報を伝達する、またはより具体的な動作を意味するコンポーネント定義のイベントを置き換える目的で、特定のイベントがコントロールから発生しないように抑制することがあります。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-116">Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="1e3c9-117">たとえば、マウスをキャプチャし、常に <xref:System.Windows.Controls.Button> 自体によって発生する <xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントを発生させるために、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> を使用して、<xref:System.Windows.Controls.Button> またはその複合要素によって発生する <xref:System.Windows.UIElement.MouseLeftButtonDown> および <xref:System.Windows.UIElement.MouseRightButtonDown> バブリング イベントを抑制することができます。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-117">For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself.</span></span> <span data-ttu-id="1e3c9-118">イベントとそのデータはルートに沿って続行されますが、<xref:System.Windows.Controls.Button> によってイベント データは <xref:System.Windows.RoutedEventArgs.Handled%2A> とマークされるため、`handledEventsToo` ケースで動作する必要があることを明確に示すイベントのハンドラーのみが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-118">The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.</span></span>  <span data-ttu-id="1e3c9-119">アプリケーションのルートに向かう他の要素に、コントロール抑制イベントを処理する機会がまだ必要な場合、代替手段の 1 つは、`true` に指定された `handledEventsToo` を使って、コード内でハンドラーをアタッチすることです。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-119">If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`.</span></span> <span data-ttu-id="1e3c9-120">ただし、多くの場合、より簡単な手法は、処理するルーティング方向を変更して、入力イベントと同等のプレビューにすることです。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-120">But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.</span></span> <span data-ttu-id="1e3c9-121">たとえば、コントロールによって <xref:System.Windows.UIElement.MouseLeftButtonDown> が抑制されている場合は、代わりに <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> のハンドラーをアタッチしてみてください。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-121">For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead.</span></span> <span data-ttu-id="1e3c9-122">この手法は、<xref:System.Windows.UIElement.MouseLeftButtonDown> などの基本要素の入力イベントに対してのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-122">This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="1e3c9-123">これらの入力イベントでは、トンネルおよびバブルのペアが使用され、両方のイベントが発生し、イベント データが共有されます。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-123">These input events use tunnel/bubble pairs, raise both events, and share the event data.</span></span>  
  
 <span data-ttu-id="1e3c9-124">これらの手法にはそれぞれに副作用または制限事項があります。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-124">Each of these techniques has either side effects or limitations.</span></span> <span data-ttu-id="1e3c9-125">プレビュー イベントを処理することの副作用は、その時点でイベントを処理すると、バブリング イベントの処理が想定されているハンドラーが無効になる可能性があることです。そのため、制限事項は、まだルートのプレビュー部分にある間にイベントに処理済みとマークすることが、通常は推奨されないということです。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-125">The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.</span></span> <span data-ttu-id="1e3c9-126">`handledEventsToo` 手法の制限事項は、属性として [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] で `handledEventsToo` ハンドラーを指定できないことです。ハンドラーがアタッチされる要素へのオブジェクト参照を取得した後、コードにイベント ハンドラーを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e3c9-126">The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1e3c9-127">関連項目</span><span class="sxs-lookup"><span data-stu-id="1e3c9-127">See also</span></span>

- [<span data-ttu-id="1e3c9-128">ルーティング イベントの処理済みとしてのマーキング、およびクラス処理</span><span class="sxs-lookup"><span data-stu-id="1e3c9-128">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="1e3c9-129">ルーティング イベントの概要</span><span class="sxs-lookup"><span data-stu-id="1e3c9-129">Routed Events Overview</span></span>](routed-events-overview.md)
