---
title: XAML クラスとカスタム クラス
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 4cd0ba7fa03d2578f4477c3ccf53188fbbea2dbd
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186265"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="8c4b5-102">WPF における XAML とカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="8c4b5-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="8c4b5-103">共通言語ランタイム (CLR) フレームワークで実装された XAML は、共通言語ランタイム (CLR) 言語でカスタム クラスまたはカスタム構造を定義し、XAML マークアップを使用してそのクラスにアクセスする機能をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="8c4b5-104">通常は、カスタム型を[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]XAML 名前空間プレフィックスにマップすることで、同じマークアップ ファイル内で -defined 型とカスタム型を組み合わせて使用できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="8c4b5-105">このトピックでは、XAML 要素として使用するためにカスタム クラスが満たす必要がある要件について説明します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="8c4b5-106">アプリケーションまたはアセンブリのカスタム クラス</span><span class="sxs-lookup"><span data-stu-id="8c4b5-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="8c4b5-107">XAML で使用されるカスタム クラスは、分離コード内またはプライマリ[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]アプリケーションを生成する他のコード内、または実行可能ファイルやクラス ライブラリとして使用される DLL などの個別のアセンブリ内のクラスとして、2 つの異なる方法で定義できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="8c4b5-108">これらのアプローチには、それぞれ特に長所と短所があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="8c4b5-109">クラス ライブラリを作成する利点は、このようなカスタム クラスをさまざまなアプリケーション間で共有できることです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="8c4b5-110">また、独立したライブラリを使用すると、アプリケーションのバージョン管理の問題を簡単に制御でき、XAML ページ上のルート要素として使用するクラスを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="8c4b5-111">アプリケーションでカスタム クラスを定義する利点は、この手法が比較的軽量であり、メイン アプリケーションの実行可能ファイル以外に別のアセンブリを導入するときに発生する配置とテストの問題を最小限に抑える点です。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="8c4b5-112">XAML で要素として使用するには、同じアセンブリで定義されている場合でも、異なるアセンブリで定義されている場合でも、カスタム クラスを CLR 名前空間と XML 名前空間の間でマップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="8c4b5-113">[「WPF XAML の XAML 名前空間と名前空間マッピング](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="8c4b5-114">XAML 要素としてのカスタム クラスの要件</span><span class="sxs-lookup"><span data-stu-id="8c4b5-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="8c4b5-115">オブジェクト要素としてインスタンス化できるようにするには、クラスが次の要件を満たしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="8c4b5-116">カスタム クラスはパブリッククラスで、既定の (パラメーターなしの) パブリック コンストラクターをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="8c4b5-117">(構造に関する注意事項については、次のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="8c4b5-118">カスタム クラスは、入れ子になったクラスであってはなりません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="8c4b5-119">入れ子になったクラスと、一般的な CLR の使用構文の[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]"ドット" は、添付プロパティなどの他の機能や XAML 機能と干渉します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="8c4b5-120">オブジェクト定義では、オブジェクト要素構文を有効にするだけでなく、そのオブジェクトを値型として受け取るその他のパブリック プロパティに対するプロパティ要素構文も有効にします。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="8c4b5-121">これは、オブジェクトがオブジェクト要素としてインスタンス化され、そのようなプロパティのプロパティ要素値を埋めることができるためです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="8c4b5-122">構造体</span><span class="sxs-lookup"><span data-stu-id="8c4b5-122">Structures</span></span>  
 <span data-ttu-id="8c4b5-123">カスタム型として定義した構造体は、 XAML で[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]常に構築できます。これは、CLR コンパイラが、すべてのプロパティ値を既定値に初期化する構造体のパラメーターなしのコンストラクターを暗黙的に作成するためです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="8c4b5-124">場合によっては、構造の既定の構築動作やオブジェクト要素の使用が望ましくないことがあります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="8c4b5-125">これは、構造体が値を埋め、概念的に和集合として機能することを意図しているためであり、含まれる値が相互に排他的な解釈を持ち、したがってそのプロパティのいずれも設定可能でない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="8c4b5-126">このような[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]構造の例は<xref:System.Windows.GridLength>です。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="8c4b5-127">一般に、このような構造体は、値が属性形式で表現できるように型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="8c4b5-128">構造体は、パラメーターなしのコンストラクターを使用してコード構築の同様の動作を公開する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="8c4b5-129">XAML 属性としてのカスタム クラスのプロパティの要件</span><span class="sxs-lookup"><span data-stu-id="8c4b5-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="8c4b5-130">プロパティは、値による型 (プリミティブなど) を参照するか、XAML プロセッサがアクセスできるパラメーターなしのコンストラクターまたは専用の型コンバーターを持つ型のクラスを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="8c4b5-131">CLR XAML 実装では、XAML プロセッサは、言語プリミティブのネイティブ サポートを通じて、または型またはバ<xref:System.ComponentModel.TypeConverterAttribute>ッキング型定義のメンバーへのアプリケーションを通じて、このようなコンバーターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="8c4b5-132">また、プロパティは抽象クラス型またはインターフェイスを参照する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="8c4b5-133">抽象クラスまたはインターフェイスの場合、XAML 解析の期待値は、プロパティ値がインターフェイスを実装する実用的なクラス インスタンス、または抽象クラスから派生する型のインスタンスで満たされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="8c4b5-134">プロパティは抽象クラスで宣言できますが、抽象クラスから派生する実用的なクラスでのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="8c4b5-135">これは、クラスのオブジェクト要素を作成するには、クラスに対してパブリック なパラメーターなしのコンストラクターが必要であるためです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="8c4b5-136">型コンバーター有効属性構文</span><span class="sxs-lookup"><span data-stu-id="8c4b5-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="8c4b5-137">クラス レベルで専用の属性付き型コンバーターを提供する場合、適用された型変換は、その型をインスタンス化する必要があるプロパティの属性構文を有効にします。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="8c4b5-138">型コンバーターは、型のオブジェクト要素の使用を有効にしません。その型のパラメーターなしのコンストラクターが存在するだけで、オブジェクト要素の使用が可能になります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="8c4b5-139">したがって、型コンバーターが有効になっているプロパティは、型自体がオブジェクト要素構文もサポートしていない限り、プロパティ構文では通常使用できません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="8c4b5-140">ただし、プロパティ要素の構文を指定することはできますが、プロパティ要素に文字列を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="8c4b5-141">この使用法は属性構文の使用と本質的に同等であり、属性値の強固な空白の処理が必要でない限り、このような使用法は一般的ではありません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="8c4b5-142">たとえば、次に示しているのは、文字列を受け取るプロパティ要素の使用方法と、属性の使用法と同等です。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="8c4b5-143">属性構文が許可されているプロパティの例では、XAML を使用してオブジェクト要素を含むプロパティ要素構文は、型を<xref:System.Windows.Input.Cursor>取得するさまざまなプロパティです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="8c4b5-144">この<xref:System.Windows.Input.Cursor>クラスには専用の型コンバーター<xref:System.Windows.Input.CursorConverter>がありますが、パラメーターなしのコンストラクターは公開されないため、実際<xref:System.Windows.FrameworkElement.Cursor%2A><xref:System.Windows.Input.Cursor>の型が参照型であっても、プロパティは属性構文を使用してのみ設定できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="8c4b5-145">プロパティごとの型コンバーター</span><span class="sxs-lookup"><span data-stu-id="8c4b5-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="8c4b5-146">または、プロパティ自体がプロパティ レベルで型コンバーターを宣言することもできます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="8c4b5-147">これにより、属性の入力文字列値を適切な型に基づいて操作の入力として処理することにより、プロパティの型のオブジェクトを<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>インラインでインスタンス化する "ミニ言語" が有効になります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="8c4b5-148">通常、これは便利なアクセサーを提供するために行われ、XAML でプロパティを設定する唯一の手段としては行われません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="8c4b5-149">ただし、パラメーターなしのコンストラクターまたは属性付き型コンバーターを提供しない既存の CLR 型を使用する場合は、型コンバーターを属性に使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="8c4b5-150">API の[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]例として、型を取得する<xref:System.Globalization.CultureInfo>特定のプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="8c4b5-151">この場合、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]以前のバージョンのフレームワークで使用されていた<xref:System.Globalization.CultureInfo>互換性と移行シナリオに対応するために既存の Microsoft .NET Framework 型を使用しましたが<xref:System.Globalization.CultureInfo>、XAML プロパティ値として直接使用できるように、必要なコンストラクターや型レベルの型変換をサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="8c4b5-152">XAML の使用法を持つプロパティを公開する場合は、特にコントロールの作成者である場合は、依存関係プロパティを使用してそのプロパティをバッキングすることを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="8c4b5-153">これは、バッキングを使用してパフォーマンスを[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]向上させることができるため、XAML プロセッサの既存の実装を使用<xref:System.Windows.DependencyProperty>する場合に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="8c4b5-154">依存関係プロパティは、XAML アクセス可能なプロパティに対してユーザーが期待するプロパティのプロパティ システム機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="8c4b5-155">これには、アニメーション、データ バインディング、スタイル サポートなどの機能が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="8c4b5-156">詳細については、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」および「 [XAML の読み込みと依存関係プロパティ](xaml-loading-and-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="8c4b5-157">型コンバーターの記述と帰属</span><span class="sxs-lookup"><span data-stu-id="8c4b5-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="8c4b5-158">場合によっては、プロパティ型の型変換<xref:System.ComponentModel.TypeConverter>を提供するカスタム派生クラスを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="8c4b5-159">XAML の使用法をサポートする型コンバーターを派生および作成する方法、および<xref:System.ComponentModel.TypeConverterAttribute>を適用する方法については[、「TypeConverters と XAML](typeconverters-and-xaml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="8c4b5-160">カスタム クラスのイベントに関する XAML イベント ハンドラー属性構文の要件</span><span class="sxs-lookup"><span data-stu-id="8c4b5-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="8c4b5-161">CLR イベントとして使用できるようにするには、パラメーターなしのコンストラクターをサポートするクラス、または派生クラスでイベントにアクセスできる抽象クラスで、イベントをパブリック イベントとして公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="8c4b5-162">ルーティング`add`イベントとして便利に使用するには、CLR`remove`<xref:System.Windows.UIElement.AddHandler%2A><xref:System.Windows.UIElement.RemoveHandler%2A>イベントに明示的なメソッドとメソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="8c4b5-163">これらのメソッドは、イベントがアタッチされているインスタンスのルーティング イベント ハンドラー ストアにハンドラーを追加または削除します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8c4b5-164">を使用して<xref:System.Windows.UIElement.AddHandler%2A>ルーティング イベントのハンドラーを直接登録し、ルーティング イベントを公開する CLR イベントを意図的に定義しないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="8c4b5-165">イベントは、ハンドラーをアタッチするための XAML 属性構文を有効にせず、結果のクラスは、その型の機能のあまり透過的な XAML ビューを提供するため、一般的には推奨されません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>
## <a name="writing-collection-properties"></a><span data-ttu-id="8c4b5-166">コレクションプロパティの書き込み</span><span class="sxs-lookup"><span data-stu-id="8c4b5-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="8c4b5-167">コレクション型を受け取るプロパティには、コレクションに追加されるオブジェクトを指定できる XAML 構文があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="8c4b5-168">この構文には、2 つの注目すべき機能があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="8c4b5-169">コレクション オブジェクトであるオブジェクトは、オブジェクト要素構文で指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="8c4b5-170">コレクション型を受け取る XAML でプロパティを指定すると、そのコレクション型が暗黙的に存在します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="8c4b5-171">マークアップ内のコレクション プロパティの子要素は、コレクションのメンバーになるように処理されます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="8c4b5-172">通常、コレクションのメンバーへのコード アクセスは、 などの`Add`リスト/ディクショナリ メソッドを通じて、またはインデクサーを通じて実行されます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="8c4b5-173">ただし、XAML 構文はメソッドやインデクサーをサポートしていません (例外: XAML 2009 ではメソッドをサポートできますが、XAML 2009 を使用すると、WPF の使用法が制限[されます。](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)</span><span class="sxs-lookup"><span data-stu-id="8c4b5-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="8c4b5-174">コレクションは、明らかに要素のツリーを構築するための非常に一般的な要件であり、宣言型 XAML でこれらのコレクションを設定する何らかの方法が必要です。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="8c4b5-175">したがって、コレクション プロパティの子要素は、コレクション プロパティ型の値であるコレクションに追加することによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="8c4b5-176">.NET Framework XAML サービスの実装、つまり、WPF XAML プロセッサは、コレクション プロパティを構成するものに対して次の定義を使用します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="8c4b5-177">プロパティのプロパティ型は、次のいずれかを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="8c4b5-178"><xref:System.Collections.IList> を実装します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="8c4b5-179">実装または<xref:System.Collections.IDictionary>汎用同等の (<xref:System.Collections.Generic.IDictionary%602>) を実装します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="8c4b5-180">派生元<xref:System.Array>(XAML の配列の詳細については、「 [x:配列マークアップ拡張機能](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="8c4b5-181">実装<xref:System.Windows.Markup.IAddChild>( によって定義される[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]インターフェイス ) 。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="8c4b5-182">CLR のこれらの型にはメソッドがあり`Add`、オブジェクト グラフを作成するときに、XAML プロセッサが基になるコレクションに項目を追加するために使用します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8c4b5-183">ジェネリック`List`インターフェイス`Dictionary`およびインターフェイス<xref:System.Collections.Generic.IList%601> <xref:System.Collections.Generic.IDictionary%602>( および ) は、XAML[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]プロセッサによるコレクション検出ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="8c4b5-184">ただし<xref:System.Collections.Generic.List%601>、直接実装<xref:System.Collections.IList>するため、クラスを基本クラスとして使用することも<xref:System.Collections.Generic.Dictionary%602>、基底クラスとして使用<xref:System.Collections.IDictionary>することもできます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="8c4b5-185">コレクションを受け取るプロパティを宣言する場合は、その型の新しいインスタンスでそのプロパティ値がどのように初期化されるかについて注意してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="8c4b5-186">依存関係プロパティとしてプロパティを実装していない場合は、コレクション型のコンストラクターを呼び出すバッキング フィールドを使用するプロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="8c4b5-187">プロパティが依存関係プロパティの場合は、既定の型コンストラクターの一部としてコレクション プロパティを初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="8c4b5-188">これは、依存関係プロパティはメタデータから既定値を取得し、通常はコレクション プロパティの初期値を静的な共有コレクションにしたくないためです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="8c4b5-189">各包含型インスタンスごとにコレクション インスタンスが存在する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="8c4b5-190">詳細については、「[カスタム依存関係プロパティ](custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="8c4b5-191">コレクション プロパティにカスタム コレクション型を実装できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="8c4b5-192">暗黙的なコレクション プロパティの処理のため、カスタム コレクション型は、XAML で暗黙的に使用するためにパラメーターなしのコンストラクターを提供する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="8c4b5-193">ただし、オプションでコレクション型のパラメーターなしのコンストラクターを指定できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="8c4b5-194">これはやりがいのある練習です。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="8c4b5-195">パラメーターなしのコンストラクターを指定しない限り、コレクションをオブジェクト要素として明示的に宣言することはできません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="8c4b5-196">マークアップ作成者によっては、明示的なコレクションをマークアップ スタイルの問題として表示する方が好まれます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="8c4b5-197">また、パラメーターなしのコンストラクターは、コレクション型をプロパティ値として使用する新しいオブジェクトを作成するときに、初期化要件を簡略化できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="8c4b5-198">XAML コンテンツ プロパティの宣言</span><span class="sxs-lookup"><span data-stu-id="8c4b5-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="8c4b5-199">XAML 言語は、コンテンツ プロパティ[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]の概念を定義します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="8c4b5-200">オブジェクト構文で使用できる各クラスには、1 つの XAML コンテンツ プロパティを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="8c4b5-201">クラスの XAML コンテンツ プロパティとしてプロパティを宣言するには、クラス定義<xref:System.Windows.Markup.ContentPropertyAttribute>の一部として を適用します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="8c4b5-202">目的の XAML コンテンツ プロパティの名前を<xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A>属性で指定します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="8c4b5-203">プロパティは、リフレクション構造として<xref:System.Reflection.PropertyInfo>ではなく、名前で文字列として指定されます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="8c4b5-204">コレクション プロパティを XAML コンテンツ プロパティとして指定できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="8c4b5-205">その結果、オブジェクト要素は、コレクション オブジェクト要素またはプロパティ要素タグを介さずに、1 つ以上の子要素を持つことができるプロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="8c4b5-206">これらの要素は、XAML コンテンツ プロパティの値として扱われ、バッキング コレクション インスタンスに追加されます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="8c4b5-207">一部の既存の XAML コンテンツ`Object`プロパティでは、 のプロパティの種類を使用します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="8c4b5-208">これにより、XAML コンテンツ プロパティは、 などのプリミティブ値を<xref:System.String>取得でき、単一の参照オブジェクト値を取得できます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="8c4b5-209">このモデルに従う場合、使用するタイプは、型決定と可能な型の処理を担当します。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="8c4b5-210"><xref:System.Object>コンテンツ タイプの一般的な理由は、オブジェクト コンテンツを文字列として追加する単純な方法 (既定のプレゼンテーション処理を受ける) と、既定以外のプレゼンテーションや追加データを指定するオブジェクト コンテンツを追加する高度な方法の両方をサポートするためです。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>
## <a name="serializing-xaml"></a><span data-ttu-id="8c4b5-211">XAML のシリアル化</span><span class="sxs-lookup"><span data-stu-id="8c4b5-211">Serializing XAML</span></span>  
 <span data-ttu-id="8c4b5-212">コントロールの作成者など、特定のシナリオでは、XAML でインスタンス化できるオブジェクト表現を、同等の XAML マークアップにシリアル化して戻すこともできます。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="8c4b5-213">シリアル化の要件については、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="8c4b5-214">[「コントロールの作成の概要](../controls/control-authoring-overview.md)」および[「要素ツリー」と「シリアル化](element-tree-and-serialization.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c4b5-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8c4b5-215">関連項目</span><span class="sxs-lookup"><span data-stu-id="8c4b5-215">See also</span></span>

- [<span data-ttu-id="8c4b5-216">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="8c4b5-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="8c4b5-217">カスタム依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="8c4b5-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="8c4b5-218">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="8c4b5-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="8c4b5-219">基本要素の概要</span><span class="sxs-lookup"><span data-stu-id="8c4b5-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="8c4b5-220">XAML 読み込みと依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="8c4b5-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
