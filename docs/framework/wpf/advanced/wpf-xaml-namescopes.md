---
title: XAML 名前スコープ
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 4383492157191f61cf04a2fdd6ce27e9183bda8b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744421"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="8c126-102">WPF XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="8c126-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="8c126-103">XAML 名前スコープは、XAML で定義されているオブジェクトを識別する概念です。</span><span class="sxs-lookup"><span data-stu-id="8c126-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="8c126-104">XAML 名前スコープ内の名前を使用すると、オブジェクトの XAML 定義の名前と、オブジェクトツリー内のそのインスタンスに対応するオブジェクトの間のリレーションシップを確立できます。</span><span class="sxs-lookup"><span data-stu-id="8c126-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="8c126-105">通常、xaml アプリケーションの個々の XAML ページルートを読み込むときに、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] マネージコード内の XAML 名前スコープが作成されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="8c126-106">プログラミングオブジェクトとしての XAML 名前スコープは、<xref:System.Windows.Markup.INameScope> インターフェイスによって定義され、実際のクラス <xref:System.Windows.NameScope>によっても実装されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="8c126-107">読み込まれた XAML アプリケーションでの名前スコープ</span><span class="sxs-lookup"><span data-stu-id="8c126-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="8c126-108">より広範なプログラミングまたはコンピューターサイエンスのコンテキストでは、プログラミングの概念には、オブジェクトへのアクセスに使用できる一意の識別子または名前の原則が含まれることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="8c126-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="8c126-109">識別子または名前を使用するシステムでは、名前スコープによって、その名前のオブジェクトが要求された場合にプロセスまたは技法が検索する境界、または識別名の一意性が強制される境界が定義されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="8c126-110">これらの一般的な原則は、XAML 名前スコープに当てはまります。</span><span class="sxs-lookup"><span data-stu-id="8c126-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="8c126-111">WPF では、XAML 名前スコープは、ページが読み込まれるときに XAML ページのルート要素に作成されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="8c126-112">ページルートから開始する XAML ページ内で指定された各名前は、関連する XAML 名前スコープに追加されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="8c126-113">WPF XAML では、一般的なルート要素 (<xref:System.Windows.Controls.Page>、<xref:System.Windows.Window>など) の要素は常に XAML 名前スコープを制御します。</span><span class="sxs-lookup"><span data-stu-id="8c126-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="8c126-114"><xref:System.Windows.FrameworkElement> や <xref:System.Windows.FrameworkContentElement> などの要素がマークアップ内のページのルート要素である場合、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] プロセッサは、<xref:System.Windows.Controls.Page> が動作する XAML 名前スコープを提供できるように、<xref:System.Windows.Controls.Page> ルートを暗黙的に追加します。</span><span class="sxs-lookup"><span data-stu-id="8c126-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8c126-115">WPF のビルドアクションでは、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] マークアップ内のどの要素にも `Name` または `x:Name` 属性が定義されていない場合でも、XAML 実稼働の XAML 名前スコープが作成されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="8c126-116">任意の XAML 名前スコープで同じ名前を2回使用しようとすると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="8c126-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="8c126-117">分離コードがあり、コンパイルされたアプリケーションの一部である WPF XAML の場合、初期マークアップコンパイル中にページ用に生成されたクラスを作成するときに、WPF ビルドアクションによってビルド時に例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="8c126-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="8c126-118">ビルドアクションによってマークアップコンパイルされていない XAML の場合、xaml が読み込まれると、XAML 名前スコープの問題に関連する例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8c126-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="8c126-119">Xaml デザイナーは、デザイン時に XAML 名前スコープの問題を予測する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="8c126-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="8c126-120">ランタイムオブジェクトツリーへのオブジェクトの追加</span><span class="sxs-lookup"><span data-stu-id="8c126-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="8c126-121">XAML が解析される瞬間は、WPF XAML 名前スコープが作成および定義された時点を表します。</span><span class="sxs-lookup"><span data-stu-id="8c126-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="8c126-122">オブジェクトを、そのツリーを生成した XAML を解析した後の特定の時点でオブジェクトツリーに追加した場合、新しいオブジェクトの `Name` または `x:Name` の値によって、XAML 名前スコープの情報が自動的に更新されることはありません。</span><span class="sxs-lookup"><span data-stu-id="8c126-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="8c126-123">XAML が読み込まれた後にオブジェクトの名前を WPF XAML 名前スコープに追加するには、xaml 名前スコープを定義するオブジェクトで <xref:System.Windows.Markup.INameScope.RegisterName%2A> の適切な実装を呼び出す必要があります。これは通常、XAML ページルートです。</span><span class="sxs-lookup"><span data-stu-id="8c126-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="8c126-124">名前が登録されていない場合は、追加されたオブジェクトを <xref:System.Windows.FrameworkElement.FindName%2A>などのメソッドを使用して名前で参照することはできません。また、この名前をアニメーションの対象として使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="8c126-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="8c126-125">アプリケーション開発者にとって最も一般的なシナリオは、ページの現在のルートの XAML 名前スコープに名前を登録するために <xref:System.Windows.FrameworkElement.RegisterName%2A> を使用することです。</span><span class="sxs-lookup"><span data-stu-id="8c126-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="8c126-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> は、アニメーション用のオブジェクトを対象とするストーリーボードの重要なシナリオの一部です。</span><span class="sxs-lookup"><span data-stu-id="8c126-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="8c126-127">詳細については、「[ストーリーボードの概要](../graphics-multimedia/storyboards-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c126-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="8c126-128">XAML 名前スコープを定義するオブジェクト以外のオブジェクトで <xref:System.Windows.FrameworkElement.RegisterName%2A> を呼び出すと、その名前は、呼び出し元のオブジェクトが保持されている XAML 名前スコープにまだ登録されます。これは、オブジェクトを定義する XAML 名前スコープで <xref:System.Windows.FrameworkElement.RegisterName%2A> を呼び出した場合と同様です。</span><span class="sxs-lookup"><span data-stu-id="8c126-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="8c126-129">コード内の XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="8c126-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="8c126-130">XAML 名前スコープを作成し、コードで使用することができます。</span><span class="sxs-lookup"><span data-stu-id="8c126-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="8c126-131">Xaml 名前スコープの作成に関係する Api と概念は、純粋なコードの使用でも同じです。これは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の XAML プロセッサが XAML 自体を処理するときにこれらの Api と概念を使用するためです。</span><span class="sxs-lookup"><span data-stu-id="8c126-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="8c126-132">概念と API は主に、XAML で部分的または完全に定義されているオブジェクトツリー内の名前でオブジェクトを検索できるようにするために存在します。</span><span class="sxs-lookup"><span data-stu-id="8c126-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="8c126-133">読み込まれた XAML からではなく、プログラムによって作成されるアプリケーションでは、XAML 名前スコープを定義するオブジェクトは <xref:System.Windows.Markup.INameScope>を実装するか、<xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement> 派生クラスである必要があります。これは、インスタンスで XAML 名前スコープの作成をサポートするためです。</span><span class="sxs-lookup"><span data-stu-id="8c126-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="8c126-134">また、XAML プロセッサによって読み込まれて処理されない要素については、オブジェクトの XAML 名前スコープが既定で作成または初期化されることはありません。</span><span class="sxs-lookup"><span data-stu-id="8c126-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="8c126-135">後で名前を登録するオブジェクトに対して、新しい XAML 名前スコープを明示的に作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8c126-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="8c126-136">XAML 名前スコープを作成するには、静的な <xref:System.Windows.NameScope.SetNameScope%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8c126-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="8c126-137">`dependencyObject` パラメーターとしてそれを所有するオブジェクトと、`value` パラメーターとして新しい <xref:System.Windows.NameScope.%23ctor%2A> コンストラクター呼び出しを指定します。</span><span class="sxs-lookup"><span data-stu-id="8c126-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="8c126-138"><xref:System.Windows.NameScope.SetNameScope%2A> の `dependencyObject` として指定されたオブジェクトが <xref:System.Windows.Markup.INameScope> 実装ではない場合、<xref:System.Windows.FrameworkElement> または <xref:System.Windows.FrameworkContentElement>、任意の子要素の <xref:System.Windows.FrameworkElement.RegisterName%2A> を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="8c126-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="8c126-139">新しい XAML 名前スコープを明示的に作成できない場合は、<xref:System.Windows.FrameworkElement.RegisterName%2A> を呼び出すと例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="8c126-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="8c126-140">コードで XAML 名前スコープ Api を使用する例については、「[名前スコープの定義](../graphics-multimedia/how-to-define-a-name-scope.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8c126-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="8c126-141">スタイルとテンプレートでの XAML 名前スコープ</span><span class="sxs-lookup"><span data-stu-id="8c126-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="8c126-142">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のスタイルとテンプレートを使用すると、簡単な方法でコンテンツを再利用したり、再適用したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="8c126-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="8c126-143">ただし、スタイルやテンプレートには、テンプレートレベルで定義された XAML 名を持つ要素が含まれる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="8c126-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="8c126-144">同じテンプレートを1ページで複数回使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="8c126-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="8c126-145">このため、スタイルとテンプレートは、スタイルまたはテンプレートが適用されているオブジェクトツリー内の任意の場所に関係なく、独自の XAML 名前スコープを定義します。</span><span class="sxs-lookup"><span data-stu-id="8c126-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="8c126-146">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="8c126-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="8c126-147">ここでは、同じテンプレートが2つの異なるボタンに適用されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="8c126-148">テンプレートに個別の XAML 名前スコープがない場合は、テンプレートで使用される `TheBorder` 名によって、XAML 名前スコープで名前の競合が発生します。</span><span class="sxs-lookup"><span data-stu-id="8c126-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="8c126-149">テンプレートの各インスタンス化には独自の XAML 名前スコープがあるため、この例では、インスタンス化されたテンプレートの XAML 名前スコープには名前が1つだけ含まれます。</span><span class="sxs-lookup"><span data-stu-id="8c126-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="8c126-150">また、スタイルは独自の XAML 名前スコープも定義します。これは、ストーリーボードの一部に特定の名前を割り当てることができるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="8c126-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="8c126-151">これらの名前を使用すると、コントロールのカスタマイズの一部としてテンプレートを再定義した場合でも、その名前の要素を対象とするコントロール固有の動作が有効になります。</span><span class="sxs-lookup"><span data-stu-id="8c126-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="8c126-152">個別の XAML 名前スコープがあるため、テンプレート内の名前付き要素を検索する方が、ページ内でテンプレート化されていない名前付き要素を見つけるよりも困難です。</span><span class="sxs-lookup"><span data-stu-id="8c126-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="8c126-153">まず、適用するテンプレートを決定する必要があります。そのためには、テンプレートが適用されているコントロールの <xref:System.Windows.Controls.Control.Template%2A> プロパティ値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8c126-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="8c126-154">次に、テンプレートバージョンの <xref:System.Windows.FrameworkTemplate.FindName%2A>を呼び出し、テンプレートが適用されたコントロールを2番目のパラメーターとして渡します。</span><span class="sxs-lookup"><span data-stu-id="8c126-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="8c126-155">コントロールの作成者が、適用されるテンプレートの特定の名前付き要素が、コントロール自体で定義されている動作のターゲットである場合に、コントロールの実装コードから <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="8c126-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="8c126-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A> メソッドは保護されているので、コントロールの作成者だけがアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="8c126-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="8c126-157">テンプレート内から作業していて、テンプレートが適用されている XAML 名前スコープにアクセスする必要がある場合は、<xref:System.Windows.FrameworkElement.TemplatedParent%2A>の値を取得し、そこで <xref:System.Windows.FrameworkElement.FindName%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8c126-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="8c126-158">テンプレート内での作業の例として、適用されるテンプレートの要素からイベントが発生するイベントハンドラーの実装を記述する場合があります。</span><span class="sxs-lookup"><span data-stu-id="8c126-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="8c126-159">XAML 名前スコープと名前関連 Api</span><span class="sxs-lookup"><span data-stu-id="8c126-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="8c126-160"><xref:System.Windows.FrameworkElement> には、<xref:System.Windows.FrameworkElement.FindName%2A>、<xref:System.Windows.FrameworkElement.RegisterName%2A>、および <xref:System.Windows.FrameworkElement.UnregisterName%2A> のメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="8c126-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="8c126-161">これらのメソッドを呼び出すオブジェクトが XAML 名前スコープを所有している場合、メソッドは、関連する XAML 名前スコープのメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8c126-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="8c126-162">それ以外の場合は、親要素が XAML 名前スコープを所有しているかどうかがチェックされ、xaml 名前スコープが見つかるまで、このプロセスが再帰的に繰り返されます (XAML プロセッサの動作により、ルートに XAML 名前スコープがあることが保証されます)。</span><span class="sxs-lookup"><span data-stu-id="8c126-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="8c126-163"><xref:System.Windows.FrameworkContentElement> の動作は似ていますが、XAML 名前スコープを所有する <xref:System.Windows.FrameworkContentElement> がないという例外があります。</span><span class="sxs-lookup"><span data-stu-id="8c126-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="8c126-164">メソッドは <xref:System.Windows.FrameworkContentElement> に存在するため、呼び出しを最終的に <xref:System.Windows.FrameworkElement> の親要素に転送できます。</span><span class="sxs-lookup"><span data-stu-id="8c126-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="8c126-165"><xref:System.Windows.NameScope.SetNameScope%2A> は、新しい XAML 名前スコープを既存のオブジェクトにマップするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8c126-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="8c126-166">XAML 名前スコープをリセットまたはクリアするために <xref:System.Windows.NameScope.SetNameScope%2A> を複数回呼び出すことができますが、これは一般的な使用方法ではありません。</span><span class="sxs-lookup"><span data-stu-id="8c126-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="8c126-167">また、<xref:System.Windows.NameScope.GetNameScope%2A> は通常、コードからは使用されません。</span><span class="sxs-lookup"><span data-stu-id="8c126-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="8c126-168">XAML 名前スコープの実装</span><span class="sxs-lookup"><span data-stu-id="8c126-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="8c126-169">次のクラスは <xref:System.Windows.Markup.INameScope> を直接実装します。</span><span class="sxs-lookup"><span data-stu-id="8c126-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="8c126-170"><xref:System.Windows.ResourceDictionary> は、XAML 名または名前スコープを使用しません。キーは、ディクショナリの実装であるため、代わりにキーを使用します。</span><span class="sxs-lookup"><span data-stu-id="8c126-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="8c126-171"><xref:System.Windows.ResourceDictionary> が <xref:System.Windows.Markup.INameScope> を実装する唯一の理由は、実際の XAML 名前スコープと <xref:System.Windows.ResourceDictionary> がキーを処理する方法と、XAML 名前スコープが親要素によって <xref:System.Windows.ResourceDictionary> に適用されないようにするために、ユーザーコードの例外を発生させることができるためです。</span><span class="sxs-lookup"><span data-stu-id="8c126-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="8c126-172"><xref:System.Windows.FrameworkTemplate> と <xref:System.Windows.Style> は、明示的なインターフェイス定義によって <xref:System.Windows.Markup.INameScope> を実装します。</span><span class="sxs-lookup"><span data-stu-id="8c126-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="8c126-173">明示的な実装では、これらの XAML 名前スコープが <xref:System.Windows.Markup.INameScope> インターフェイスを介してアクセスされたときに従来の動作を行うことができます。これは、XAML 名前スコープが [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 内部プロセスによって伝達される方法です。</span><span class="sxs-lookup"><span data-stu-id="8c126-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="8c126-174">ただし、明示的なインターフェイス定義は、<xref:System.Windows.FrameworkTemplate> および <xref:System.Windows.Style>の従来の API サーフェイスの一部ではありません。 <xref:System.Windows.FrameworkTemplate> で <xref:System.Windows.Markup.INameScope> メソッドを呼び出し、直接 <xref:System.Windows.Style> する必要はほとんどなく、代わりに <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>などの他の API を使用する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="8c126-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="8c126-175">次のクラスは、<xref:System.Windows.NameScope?displayProperty=nameWithType> ヘルパークラスを使用し、<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> 添付プロパティを使用してその XAML 名前スコープの実装に接続することによって、独自の XAML 名前スコープを定義します。</span><span class="sxs-lookup"><span data-stu-id="8c126-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="8c126-176">関連項目</span><span class="sxs-lookup"><span data-stu-id="8c126-176">See also</span></span>

- [<span data-ttu-id="8c126-177">XAML 名前空間および WPF XAML の名前空間の割り当て</span><span class="sxs-lookup"><span data-stu-id="8c126-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="8c126-178">x:Name ディレクティブ</span><span class="sxs-lookup"><span data-stu-id="8c126-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
