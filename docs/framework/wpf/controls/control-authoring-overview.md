---
title: コントロールの作成の概要
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: a6ab5463cc28aa590454ae1304714d3d12ee7c6b
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646136"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="ded58-102">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="ded58-102">Control authoring overview</span></span>

<span data-ttu-id="ded58-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] コントロール モデルの機能拡張により、新しいコントロールを作成する必要性が大幅に削減されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="ded58-104">ただし、場合によっては、カスタム コントロールを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="ded58-105">このトピックでは、カスタム コントロールを作成する必要性を最小限に抑える機能と、[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] のさまざまなコントロール作成モデルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="ded58-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="ded58-106">また、新しいコントロールを作成する方法も示します。</span><span class="sxs-lookup"><span data-stu-id="ded58-106">This topic also demonstrates how to create a new control.</span></span>

<a name="when_to_write_a_new_control"></a>

## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="ded58-107">新しいコントロールの作成に代わる方法</span><span class="sxs-lookup"><span data-stu-id="ded58-107">Alternatives to Writing a New Control</span></span>

<span data-ttu-id="ded58-108">従来は、既存のコントロールをカスタマイズする場合、背景色、境界線の幅、フォントのサイズなど、コントロールの標準プロパティを変更するなどの範囲に制限されていました。</span><span class="sxs-lookup"><span data-stu-id="ded58-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="ded58-109">これらの定義済みのパラメーター以外に、コントロールの外観や動作にまでカスタマイズを拡張しようとすると、通常、既存のコントロールを継承し、コントロールを描画するメソッドをオーバーライドして、新しいコントロールを作成する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="ded58-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="ded58-110">その方法は今でも選択できますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の場合、リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用して、既存のコントロールをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="ded58-111">新しいコントロールを作成しなくても、これらの機能を使用して、カスタマイズされた一貫性のあるエクスペリエンスを得られる方法としては、次のような例が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="ded58-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>

- <span data-ttu-id="ded58-112">**リッチ コンテンツ。**</span><span class="sxs-lookup"><span data-stu-id="ded58-112">**Rich Content.**</span></span> <span data-ttu-id="ded58-113">標準の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの多くがリッチ コンテンツをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ded58-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="ded58-114">たとえば、<xref:System.Windows.Controls.Button> のコンテンツ プロパティは <xref:System.Object> 型であるため、理論的にはどのようなものでも <xref:System.Windows.Controls.Button> 上に表示できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="ded58-115">ボタンに画像とテキストを表示するには、画像と <xref:System.Windows.Controls.TextBlock> を <xref:System.Windows.Controls.StackPanel> に追加し、その <xref:System.Windows.Controls.StackPanel> を <xref:System.Windows.Controls.ContentControl.Content%2A> プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="ded58-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="ded58-116">コントロールには、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の視覚的要素と任意のデータを表示できるため、複雑な視覚化をサポートするために、新しいコントロールを作成したり、既存のコントロールを変更したりする必要性が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="ded58-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="ded58-117"><xref:System.Windows.Controls.Button> のコンテンツ モデルや [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のその他のコンテンツ モデルの詳細については、「[WPF のコンテンツ モデル](wpf-content-model.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](wpf-content-model.md).</span></span>

- <span data-ttu-id="ded58-118">**スタイル**</span><span class="sxs-lookup"><span data-stu-id="ded58-118">**Styles.**</span></span> <span data-ttu-id="ded58-119"><xref:System.Windows.Style> は、コントロールのプロパティを表す値のコレクションです。</span><span class="sxs-lookup"><span data-stu-id="ded58-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="ded58-120">スタイルを使用すると、新しいコントロールを作成しなくても、必要なコントロールの外観と動作を備えた再利用可能な表現を作成できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="ded58-121">たとえば、すべての <xref:System.Windows.Controls.TextBlock> コントロールにフォント サイズ 14 の赤色の Arial フォントを設定するとします。</span><span class="sxs-lookup"><span data-stu-id="ded58-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="ded58-122">そこで、リソースとしてスタイルを作成し、それに応じて、適切なプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="ded58-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="ded58-123">すると、アプリケーションに追加する <xref:System.Windows.Controls.TextBlock> はすべて同じ外観になります。</span><span class="sxs-lookup"><span data-stu-id="ded58-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>

- <span data-ttu-id="ded58-124">**データ テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="ded58-124">**Data Templates.**</span></span> <span data-ttu-id="ded58-125"><xref:System.Windows.DataTemplate> を使用すると、コントロールにデータを表示する方法をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="ded58-126">たとえば、<xref:System.Windows.DataTemplate> を使用して、<xref:System.Windows.Controls.ListBox> にデータを表示する方法を指定できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="ded58-127">この例については、「[データ テンプレートの概要](../data/data-templating-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-127">For an example of this, see [Data Templating Overview](../data/data-templating-overview.md).</span></span>  <span data-ttu-id="ded58-128"><xref:System.Windows.DataTemplate> については、データの表示方法のカスタマイズのほか、UI 要素を含めることもでき、カスタム UI の柔軟性を高めることができます。</span><span class="sxs-lookup"><span data-stu-id="ded58-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="ded58-129">たとえば、<xref:System.Windows.DataTemplate> を使用して、<xref:System.Windows.Controls.ComboBox> を作成し、その各項目にチェック ボックスを付けることができます。</span><span class="sxs-lookup"><span data-stu-id="ded58-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>

- <span data-ttu-id="ded58-130">**コントロール テンプレート。**</span><span class="sxs-lookup"><span data-stu-id="ded58-130">**Control Templates.**</span></span> <span data-ttu-id="ded58-131">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のコントロールの多くでは、<xref:System.Windows.Controls.ControlTemplate> を使用して、コントロールの構造と外観が定義されています。これにより、コントロールの外観と機能を分離できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="ded58-132">コントロールの <xref:System.Windows.Controls.ControlTemplate> を再定義すると、その外観を大幅に変更できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="ded58-133">たとえば、信号機のような外観のコントロールが必要だとします。</span><span class="sxs-lookup"><span data-stu-id="ded58-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="ded58-134">このコントロールのユーザー インターフェイスと機能は単純です。</span><span class="sxs-lookup"><span data-stu-id="ded58-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="ded58-135">コントロールは 3 つの円で構成され、一度に点灯するのはそのうちの 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="ded58-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="ded58-136">少し考えた結果、<xref:System.Windows.Controls.RadioButton> を使用すると、一度に 1 つだけ選択する機能を実現できることに気付いたとします。しかし、<xref:System.Windows.Controls.RadioButton> の既定の外観は信号機のライトとは全然似ていません。</span><span class="sxs-lookup"><span data-stu-id="ded58-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="ded58-137"><xref:System.Windows.Controls.RadioButton> では、コントロール テンプレートを使用して外観を定義しているため、コントロールの要件に合わせて <xref:System.Windows.Controls.ControlTemplate> を再定義し、オプション ボタンで信号機を実現するのは簡単です。</span><span class="sxs-lookup"><span data-stu-id="ded58-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>

  > [!NOTE]
  > <span data-ttu-id="ded58-138"><xref:System.Windows.Controls.RadioButton> では <xref:System.Windows.DataTemplate> を使用できますが、この例の場合、<xref:System.Windows.DataTemplate> では不十分です。</span><span class="sxs-lookup"><span data-stu-id="ded58-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="ded58-139"><xref:System.Windows.DataTemplate> では、コントロールのコンテンツの外観が定義されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="ded58-140"><xref:System.Windows.Controls.RadioButton> の場合、コンテンツとは、<xref:System.Windows.Controls.RadioButton> が選択されているかどうかを示す円の右側に表示される内容です。</span><span class="sxs-lookup"><span data-stu-id="ded58-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="ded58-141">信号機の例では、オプション ボタンに必要なのは "点灯" する円だけです。</span><span class="sxs-lookup"><span data-stu-id="ded58-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="ded58-142">信号機の外観の要件が <xref:System.Windows.Controls.RadioButton> の既定の外観とは大きく異なるため、<xref:System.Windows.Controls.ControlTemplate> を再定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="ded58-143">一般的に、コントロールのコンテンツ (またはデータ) を定義するために <xref:System.Windows.DataTemplate> を使用し、コントロールの構成方法を定義するために <xref:System.Windows.Controls.ControlTemplate> を使用します。</span><span class="sxs-lookup"><span data-stu-id="ded58-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>

- <span data-ttu-id="ded58-144">**トリガー。**</span><span class="sxs-lookup"><span data-stu-id="ded58-144">**Triggers.**</span></span> <span data-ttu-id="ded58-145"><xref:System.Windows.Trigger> を使用すると、新しいコントロールを作成しなくても、コントロールの外観と動作を動的に変更できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="ded58-146">たとえば、複数の <xref:System.Windows.Controls.ListBox> コントロールを使用するアプリケーションがあり、各 <xref:System.Windows.Controls.ListBox> の選択項目を赤色の太字で表示するとします。</span><span class="sxs-lookup"><span data-stu-id="ded58-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="ded58-147">まず思いつくのは、<xref:System.Windows.Controls.ListBox> を継承したクラスを作成して、<xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> メソッドをオーバーライドし、選択項目の外観を変更する方法ですが、<xref:System.Windows.Controls.ListBoxItem> のスタイルに選択項目の外観を変更するトリガーを追加する方法の方が適切です。</span><span class="sxs-lookup"><span data-stu-id="ded58-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="ded58-148">トリガーを使用すると、プロパティ値を変更したり、プロパティ値に基づいた処理を実行したりできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="ded58-149"><xref:System.Windows.EventTrigger> を使用すると、イベント発生時に処理を実行できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>

<span data-ttu-id="ded58-150">スタイル、テンプレート、トリガーの詳細については、「[スタイルとテンプレート](../../../desktop-wpf/fundamentals/styles-templates-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-150">For more information about styles, templates, and triggers, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

<span data-ttu-id="ded58-151">一般に、既存のコントロールと同じ機能を持ち、外観が異なるコントロールが必要な場合は、このセクションで説明した方法のいずれかを使用して、既存のコントロールの外観を変更できないかどうかをまず検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ded58-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>

<a name="models_for_control_authoring"></a>

## <a name="models-for-control-authoring"></a><span data-ttu-id="ded58-152">コントロール作成モデル</span><span class="sxs-lookup"><span data-stu-id="ded58-152">Models for Control Authoring</span></span>

<span data-ttu-id="ded58-153">リッチ コンテンツ モデル、スタイル、テンプレート、トリガーを使用すると、新しいコントロールを作成する必要性が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="ded58-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="ded58-154">ただし、新しいコントロールを作成する必要がある場合は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の各種のコントロール作成モデルを理解することが重要です。</span><span class="sxs-lookup"><span data-stu-id="ded58-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="ded58-155">には、コントロールを作成するための一般的なモデルが 3 つあり、各モデルはそれぞれ異なる機能と柔軟性レベルを備えています。</span><span class="sxs-lookup"><span data-stu-id="ded58-155">provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="ded58-156">3 つのモデルの基底クラスは、<xref:System.Windows.Controls.UserControl>、<xref:System.Windows.Controls.Control>、<xref:System.Windows.FrameworkElement> です。</span><span class="sxs-lookup"><span data-stu-id="ded58-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>

### <a name="deriving-from-usercontrol"></a><span data-ttu-id="ded58-157">UserControl からの派生</span><span class="sxs-lookup"><span data-stu-id="ded58-157">Deriving from UserControl</span></span>

<span data-ttu-id="ded58-158">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でコントロールを作成する方法で最も簡単なのは、<xref:System.Windows.Controls.UserControl> から派生する方法です。</span><span class="sxs-lookup"><span data-stu-id="ded58-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="ded58-159"><xref:System.Windows.Controls.UserControl> を継承するコントロールを作成するときは、<xref:System.Windows.Controls.UserControl> に既存のコンポーネントを追加し、コンポーネントに名前を付けて、[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] でイベント ハンドラーを参照します。</span><span class="sxs-lookup"><span data-stu-id="ded58-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="ded58-160">次に、指定の要素を参照し、コードでイベント ハンドラーを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="ded58-161">この開発モデルは、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] でのアプリケーション開発に使用されるモデルとよく似ています。</span><span class="sxs-lookup"><span data-stu-id="ded58-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

<span data-ttu-id="ded58-162"><xref:System.Windows.Controls.UserControl> が正しく構築されていれば、リッチ コンテンツ、スタイル、トリガーの利点を活用できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="ded58-163">ただし、<xref:System.Windows.Controls.UserControl> を継承したコントロールの場合、そのユーザーは <xref:System.Windows.DataTemplate> または <xref:System.Windows.Controls.ControlTemplate> を使用して、外観をカスタマイズすることができません。</span><span class="sxs-lookup"><span data-stu-id="ded58-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="ded58-164"><xref:System.Windows.Controls.Control> クラスまたはその派生クラスのいずれか (<xref:System.Windows.Controls.UserControl> 以外) から派生して、テンプレートをサポートするカスタム コントロールを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>

#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="ded58-165">UserControl からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="ded58-165">Benefits of Deriving from UserControl</span></span>

<span data-ttu-id="ded58-166">次のすべての項目に該当する場合、<xref:System.Windows.Controls.UserControl> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>

- <span data-ttu-id="ded58-167">アプリケーションの構築と同じ方法でコントロールをビルドする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-167">You want to build your control similarly to how you build an application.</span></span>

- <span data-ttu-id="ded58-168">コントロールが既存のコンポーネントのみで構成されている場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-168">Your control consists only of existing components.</span></span>

- <span data-ttu-id="ded58-169">複雑なカスタマイズをサポートする必要がない場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-169">You don't need to support complex customization.</span></span>

### <a name="deriving-from-control"></a><span data-ttu-id="ded58-170">Control からの派生</span><span class="sxs-lookup"><span data-stu-id="ded58-170">Deriving from Control</span></span>

<span data-ttu-id="ded58-171"><xref:System.Windows.Controls.Control> クラスからの派生は、既存の [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロールの多くで使用されるモデルです。</span><span class="sxs-lookup"><span data-stu-id="ded58-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="ded58-172"><xref:System.Windows.Controls.Control> クラスから継承したコントロールを作成するときは、テンプレートを使用して、その外観を定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="ded58-173">これにより、操作ロジックと視覚的表現とが分離されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="ded58-174">また、イベントの代わりにコマンドとバインディングを使用し、<xref:System.Windows.Controls.ControlTemplate> での要素参照をできる限り避けることによって、UI とロジックを分離できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="ded58-175">コントロールの UI とロジックが適切に分離されていると、コントロールのユーザーは、コントロールの <xref:System.Windows.Controls.ControlTemplate> を再定義して、その外観をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="ded58-176">カスタム <xref:System.Windows.Controls.Control> の作成は、<xref:System.Windows.Controls.UserControl> の作成ほど単純ではありませんが、カスタム <xref:System.Windows.Controls.Control> を使用すると、より高い柔軟性が得られます。</span><span class="sxs-lookup"><span data-stu-id="ded58-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>

#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="ded58-177">Control からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="ded58-177">Benefits of Deriving from Control</span></span>

<span data-ttu-id="ded58-178">次のいずれかの項目に該当する場合は、<xref:System.Windows.Controls.UserControl> クラスを使用する代わりに、<xref:System.Windows.Controls.Control> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>

- <span data-ttu-id="ded58-179"><xref:System.Windows.Controls.ControlTemplate> を使用して、コントロールの外観をカスタマイズ可能にする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>

- <span data-ttu-id="ded58-180">コントロールがさまざまなテーマをサポートする必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-180">You want your control to support different themes.</span></span>

### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="ded58-181">FrameworkElement からの派生</span><span class="sxs-lookup"><span data-stu-id="ded58-181">Deriving from FrameworkElement</span></span>

<span data-ttu-id="ded58-182"><xref:System.Windows.Controls.UserControl> または <xref:System.Windows.Controls.Control> から派生されたコントロールは、既存の要素の構成に依存します。</span><span class="sxs-lookup"><span data-stu-id="ded58-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="ded58-183">多くの状況では、それで問題ありません。<xref:System.Windows.FrameworkElement> を継承するどのオブジェクトも <xref:System.Windows.Controls.ControlTemplate> に含めることができるためです。</span><span class="sxs-lookup"><span data-stu-id="ded58-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="ded58-184">しかし、場合によっては、単純な要素コンポジションでは、コントロールの外観に必要な機能を実現できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="ded58-185">このような状況では、<xref:System.Windows.FrameworkElement> のコンポーネントをベースにするのが適切な選択です。</span><span class="sxs-lookup"><span data-stu-id="ded58-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>

<span data-ttu-id="ded58-186"><xref:System.Windows.FrameworkElement> ベースのコンポーネントを作成するには、ダイレクト レンダリングとカスタム要素コンポジションの 2 つの標準的な方法があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="ded58-187">ダイレクト レンダリングでは、<xref:System.Windows.FrameworkElement> の <xref:System.Windows.UIElement.OnRender%2A> メソッドをオーバーライドし、コンポーネントのビジュアルを明示的に定義する <xref:System.Windows.Media.DrawingContext> 操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="ded58-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="ded58-188">これは、<xref:System.Windows.Controls.Image> と <xref:System.Windows.Controls.Border> で使用される方法です。</span><span class="sxs-lookup"><span data-stu-id="ded58-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="ded58-189">カスタム要素コンポジションでは、<xref:System.Windows.Media.Visual> 型のオブジェクトを使用して、コンポーネントの外観を構成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="ded58-190">例については、「[DrawingVisual オブジェクトの使用](../graphics-multimedia/using-drawingvisual-objects.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-190">For an example, see [Using DrawingVisual Objects](../graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="ded58-191"><xref:System.Windows.Controls.Primitives.Track> は、カスタム要素コンポジションを使用する [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] のコントロールの例です。</span><span class="sxs-lookup"><span data-stu-id="ded58-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="ded58-192">同じコントロールでダイレクト レンダリングとカスタム要素コンポジションを混在させることもできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>

#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="ded58-193">FrameworkElement からの派生の利点</span><span class="sxs-lookup"><span data-stu-id="ded58-193">Benefits of Deriving from FrameworkElement</span></span>

<span data-ttu-id="ded58-194">次のいずれかの項目に該当する場合、<xref:System.Windows.FrameworkElement> から派生することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>

- <span data-ttu-id="ded58-195">コントロールの外観について、単純な要素コンポジションが提供する以上の厳密な制御を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>

- <span data-ttu-id="ded58-196">独自のレンダリング ロジックを定義して、コントロールの外観を定義する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-196">You want to define the appearance of your control by defining your own render logic.</span></span>

- <span data-ttu-id="ded58-197"><xref:System.Windows.Controls.UserControl> および <xref:System.Windows.Controls.Control> を使用する方法では実現できない新しい方法で既存の要素を構成する必要がある場合。</span><span class="sxs-lookup"><span data-stu-id="ded58-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>

<a name="control_authoring_basics"></a>

## <a name="control-authoring-basics"></a><span data-ttu-id="ded58-198">コントロール作成の基本</span><span class="sxs-lookup"><span data-stu-id="ded58-198">Control Authoring Basics</span></span>

<span data-ttu-id="ded58-199">既に説明したように、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] の最も強力な機能の 1 つは、コントロールの基本的なプロパティ設定だけでは不可能な外観や動作の変更を実現し、しかもカスタム コントロールを作成する必要がないということです。</span><span class="sxs-lookup"><span data-stu-id="ded58-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="ded58-200">スタイル設定、データ バインディング、トリガーの各機能は、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] プロパティ システムおよび [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベント システムによって実現されています。</span><span class="sxs-lookup"><span data-stu-id="ded58-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="ded58-201">以降のセクションでは、カスタム コントロールのユーザーが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] に付属のコントロールと同じように、これらの機能を使用できるようにするために、カスタム コントロールの作成に使用するモデルに関係なく、従う必要があるプラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="ded58-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

### <a name="use-dependency-properties"></a><span data-ttu-id="ded58-202">依存関係プロパティの使用</span><span class="sxs-lookup"><span data-stu-id="ded58-202">Use Dependency Properties</span></span>

<span data-ttu-id="ded58-203">プロパティが依存関係プロパティである場合、以下の操作が可能です。</span><span class="sxs-lookup"><span data-stu-id="ded58-203">When a property is a dependency property, it is possible to do the following:</span></span>

- <span data-ttu-id="ded58-204">スタイルのプロパティを設定する。</span><span class="sxs-lookup"><span data-stu-id="ded58-204">Set the property in a style.</span></span>

- <span data-ttu-id="ded58-205">プロパティをデータ ソースにバインドする。</span><span class="sxs-lookup"><span data-stu-id="ded58-205">Bind the property to a data source.</span></span>

- <span data-ttu-id="ded58-206">プロパティの値として、動的リソースを使用する。</span><span class="sxs-lookup"><span data-stu-id="ded58-206">Use a dynamic resource as the property's value.</span></span>

- <span data-ttu-id="ded58-207">プロパティ名をアニメーション化する。</span><span class="sxs-lookup"><span data-stu-id="ded58-207">Animate the property.</span></span>

<span data-ttu-id="ded58-208">コントロールのプロパティがこれらの機能のいずれかをサポートす必要がある場合、それを依存関係プロパティとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="ded58-209">次の例では、以下の処理を実行して、`Value` という名前の依存関係プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-209">The following example defines a dependency property named `Value` by doing the following:</span></span>

- <span data-ttu-id="ded58-210">`ValueProperty` という名前の <xref:System.Windows.DependencyProperty> 識別子を、`public` `static` `readonly` フィールドとして定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="ded58-211"><xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType> を呼び出して、プロパティ システムにプロパティ名を登録し、次の項目を指定します。</span><span class="sxs-lookup"><span data-stu-id="ded58-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>

  - <span data-ttu-id="ded58-212">プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="ded58-212">The name of the property.</span></span>

  - <span data-ttu-id="ded58-213">プロパティの型。</span><span class="sxs-lookup"><span data-stu-id="ded58-213">The type of the property.</span></span>

  - <span data-ttu-id="ded58-214">プロパティを所有する型。</span><span class="sxs-lookup"><span data-stu-id="ded58-214">The type that owns the property.</span></span>

  - <span data-ttu-id="ded58-215">プロパティのメタデータ。</span><span class="sxs-lookup"><span data-stu-id="ded58-215">The metadata for the property.</span></span> <span data-ttu-id="ded58-216">メタデータには、プロパティの既定値、<xref:System.Windows.CoerceValueCallback> および <xref:System.Windows.PropertyChangedCallback> が含まれています。</span><span class="sxs-lookup"><span data-stu-id="ded58-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>

- <span data-ttu-id="ded58-217">プロパティの `get` アクセサーと `set` アクセサーを実装することにより、依存関係プロパティの登録名と同じ `Value` という名前で CLR ラッパー プロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-217">Define a CLR wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="ded58-218">`get` アクセサーと `set` アクセサーは、それぞれ <xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> しか呼び出すことができないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="ded58-219">依存関係プロパティのアクセサーには、その他のロジックを含めないことをお勧めします。クライアントおよび [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] では、アクセサーが省略され、<xref:System.Windows.DependencyObject.GetValue%2A> と <xref:System.Windows.DependencyObject.SetValue%2A> が直接呼び出されることがあるためです。</span><span class="sxs-lookup"><span data-stu-id="ded58-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="ded58-220">たとえば、プロパティがデータ ソースにバインドされている場合、プロパティの `set` アクセサーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="ded58-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="ded58-221">get アクセサーと set アクセサーに他のロジックを追加するのではなく、<xref:System.Windows.ValidateValueCallback>、<xref:System.Windows.CoerceValueCallback>、および <xref:System.Windows.PropertyChangedCallback> の各デリゲートを使用して、値の変更時に応答したり、値を確認したりします。</span><span class="sxs-lookup"><span data-stu-id="ded58-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="ded58-222">これらのコールバックの詳細については、「[依存関係プロパティのコールバックと検証](../advanced/dependency-property-callbacks-and-validation.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../advanced/dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="ded58-223"><xref:System.Windows.CoerceValueCallback> に対応する、`CoerceValue` という名前のメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="ded58-224">`CoerceValue` によって、`Value` は `MinValue` 以上で `MaxValue` 以下になります。</span><span class="sxs-lookup"><span data-stu-id="ded58-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>

- <span data-ttu-id="ded58-225"><xref:System.Windows.PropertyChangedCallback> に対応する、`OnValueChanged` という名前のメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="ded58-226">`OnValueChanged` では、<xref:System.Windows.RoutedPropertyChangedEventArgs%601> オブジェクトが作成され、`ValueChanged` ルーティング イベントの生成が準備されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="ded58-227">ルーティング イベントについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="ded58-227">Routed events are discussed in the next section.</span></span>

[!code-csharp[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
[!code-vb[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]

<span data-ttu-id="ded58-228">詳細については、「[カスタム依存関係プロパティ](../advanced/custom-dependency-properties.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-228">For more information, see [Custom Dependency Properties](../advanced/custom-dependency-properties.md).</span></span>

### <a name="use-routed-events"></a><span data-ttu-id="ded58-229">ルーティング イベントの使用</span><span class="sxs-lookup"><span data-stu-id="ded58-229">Use Routed Events</span></span>

<span data-ttu-id="ded58-230">依存関係プロパティで CLR プロパティの概念が追加機能によって拡張されるのと同様に、ルーティング イベントでは、標準の CLR イベントの概念が拡張されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-230">Just as dependency properties extend the notion of CLR properties with additional functionality, routed events extend the notion of standard CLR events.</span></span> <span data-ttu-id="ded58-231">新しい [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロール作成する場合、イベントをルーティング イベントとして実装することをお勧めします。ルーティング イベントは以下の機能をサポートしているためです。</span><span class="sxs-lookup"><span data-stu-id="ded58-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>

- <span data-ttu-id="ded58-232">複数のコントロールの親でイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="ded58-233">イベントがバブル イベントの場合、要素ツリー内の単一の親はイベントをサブスクライブできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="ded58-234">これにより、アプリケーション開発者は、複数のコントロールのイベントに 1 つのハンドラーで対応できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="ded58-235">たとえば、<xref:System.Windows.Controls.ListBox> の各項目に含まれるコントロール (<xref:System.Windows.DataTemplate> に含まれているため) の場合、アプリケーション開発者は、コントロールのイベントに対応するイベント ハンドラーを <xref:System.Windows.Controls.ListBox> で定義できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="ded58-236">いずれかのコントロールでイベントが発生するたびに、そのイベント ハンドラーが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>

- <span data-ttu-id="ded58-237">ルーティング イベントは <xref:System.Windows.EventSetter> で使用できます。これにより、アプリケーション開発者はイベントのハンドラーをスタイル内で指定できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>

- <span data-ttu-id="ded58-238">ルーティング イベントは <xref:System.Windows.EventTrigger> で使用でき、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] を使用したプロパティのアニメーション化に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ded58-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="ded58-239">詳しくは、「 [アニメーションの概要](../graphics-multimedia/animation-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="ded58-239">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

<span data-ttu-id="ded58-240">次に示す例では、以下の処理を実行して、ルーティング イベントを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-240">The following example defines a routed event by doing the following:</span></span>

- <span data-ttu-id="ded58-241">`ValueChangedEvent` という名前の <xref:System.Windows.RoutedEvent> 識別子を、`public` `static` `readonly` フィールドとして定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="ded58-242"><xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> メソッドを呼び出して、ルーティング イベントを登録します。</span><span class="sxs-lookup"><span data-stu-id="ded58-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ded58-243">この例では、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を呼び出すときに、次の情報を指定します。</span><span class="sxs-lookup"><span data-stu-id="ded58-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>

  - <span data-ttu-id="ded58-244">イベントの名前が `ValueChanged` であること。</span><span class="sxs-lookup"><span data-stu-id="ded58-244">The name of the event is `ValueChanged`.</span></span>

  - <span data-ttu-id="ded58-245">ルーティング方法が <xref:System.Windows.RoutingStrategy.Bubble> であること。ソース (イベントを発生させるオブジェクト) のイベント ハンドラーがまず呼び出され、その後、ソースの親要素のイベント ハンドラーが、最も近い親要素のイベント ハンドラーから順に呼び出されるルーティング方法です。</span><span class="sxs-lookup"><span data-stu-id="ded58-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>

  - <span data-ttu-id="ded58-246">イベント ハンドラーの型が <xref:System.Windows.RoutedPropertyChangedEventHandler%601> で、<xref:System.Decimal> 型で構築されていること。</span><span class="sxs-lookup"><span data-stu-id="ded58-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>

  - <span data-ttu-id="ded58-247">イベントを所有する型が `NumericUpDown` であること。</span><span class="sxs-lookup"><span data-stu-id="ded58-247">The owning type of the event is `NumericUpDown`.</span></span>

- <span data-ttu-id="ded58-248">`ValueChanged` という名前のパブリック イベントを宣言し、イベント アクセサー宣言を含めます。</span><span class="sxs-lookup"><span data-stu-id="ded58-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="ded58-249">この例では、`add` アクセサー宣言で <xref:System.Windows.UIElement.AddHandler%2A> を、`remove` アクセサーの宣言で <xref:System.Windows.UIElement.RemoveHandler%2A> をそれぞれ呼び出して、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] イベント サービスを使用します。</span><span class="sxs-lookup"><span data-stu-id="ded58-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>

- <span data-ttu-id="ded58-250">`ValueChanged`イベントを発生させる、保護された仮想メソッド `OnValueChanged` を作成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>

[!code-csharp[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
[!code-vb[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]

<span data-ttu-id="ded58-251">詳細については、「[ルーティング イベントの概要](../advanced/routed-events-overview.md)」および「[カスタム ルーティング イベントを作成する](../advanced/how-to-create-a-custom-routed-event.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-251">For more information, see [Routed Events Overview](../advanced/routed-events-overview.md) and [Create a Custom Routed Event](../advanced/how-to-create-a-custom-routed-event.md).</span></span>

### <a name="use-binding"></a><span data-ttu-id="ded58-252">バインディングの使用</span><span class="sxs-lookup"><span data-stu-id="ded58-252">Use Binding</span></span>

<span data-ttu-id="ded58-253">コントロールの UI とロジックを分離するには、データ バインディングを使用する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="ded58-254">これは、<xref:System.Windows.Controls.ControlTemplate> を使用してコントロールの外観を定義する場合に、特に重要です。</span><span class="sxs-lookup"><span data-stu-id="ded58-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="ded58-255">データ バインディングを使用すると、コードから UI の特定の部分を参照する必要性がなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="ded58-256"><xref:System.Windows.Controls.ControlTemplate> 内の要素の参照を避けることをお勧めします。コードで <xref:System.Windows.Controls.ControlTemplate> 内の要素を参照する場合、<xref:System.Windows.Controls.ControlTemplate> が変更されたときに、新しい <xref:System.Windows.Controls.ControlTemplate> に参照先の要素を含める必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="ded58-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>

<span data-ttu-id="ded58-257">次の例では、`NumericUpDown` コントロールの <xref:System.Windows.Controls.TextBlock> を更新し、名前を割り当てて、コード内の名前を使用してテキスト ボックスを参照しています。</span><span class="sxs-lookup"><span data-stu-id="ded58-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>

[!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]

[!code-csharp[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
[!code-vb[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]

<span data-ttu-id="ded58-258">次の例では、バインディングを使用して同じことを実現しています。</span><span class="sxs-lookup"><span data-stu-id="ded58-258">The following example uses binding to accomplish the same thing.</span></span>

[!code-xaml[UserControlNumericUpDown#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]

<span data-ttu-id="ded58-259">データ バインディングの詳細については、「[データ バインディングの概要](../../../desktop-wpf/data/data-binding-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-259">For more information about data binding, see [Data Binding Overview](../../../desktop-wpf/data/data-binding-overview.md).</span></span>

### <a name="design-for-designers"></a><span data-ttu-id="ded58-260">デザイナーに対応したデザイン</span><span class="sxs-lookup"><span data-stu-id="ded58-260">Design for Designers</span></span>

<span data-ttu-id="ded58-261">Visual Studio 用の WPF デザイナーでカスタム WPF コントロールのサポート (たとえば、[プロパティ] ウィンドウでのプロパティ編集) を利用するには、以下のガイドラインに従います。</span><span class="sxs-lookup"><span data-stu-id="ded58-261">To receive support for custom WPF controls in the WPF Designer for Visual Studio (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="ded58-262">WPF デザイナーでの開発の詳細については、「[Visual Studio で XAML をデザインする](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-262">For more information on developing for the WPF Designer, see [Design XAML in Visual Studio](/visualstudio/xaml-tools/designing-xaml-in-visual-studio).</span></span>

#### <a name="dependency-properties"></a><span data-ttu-id="ded58-263">依存関係プロパティ</span><span class="sxs-lookup"><span data-stu-id="ded58-263">Dependency Properties</span></span>

<span data-ttu-id="ded58-264">「依存関係プロパティの使用」で説明したように、CLR の `get` アクセサーと `set` アクセサーを実装します。</span><span class="sxs-lookup"><span data-stu-id="ded58-264">Be sure to implement CLR `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="ded58-265">デザイナーは、ラッパーを使用して依存関係プロパティの存在を検出する場合がありますが、[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] およびコントロールのクライアントと同様、プロパティを取得または設定するときにアクセサーを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ded58-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>

#### <a name="attached-properties"></a><span data-ttu-id="ded58-266">アタッチされるプロパティ</span><span class="sxs-lookup"><span data-stu-id="ded58-266">Attached Properties</span></span>

<span data-ttu-id="ded58-267">以下のガイドラインに従って、カスタム コントロールに添付プロパティを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-267">You should implement attached properties on custom controls using the following guidelines:</span></span>

- <span data-ttu-id="ded58-268">*PropertyName*`Property` という形式の `public` `static` `readonly` <xref:System.Windows.DependencyProperty> を、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドを使用して作成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="ded58-269"><xref:System.Windows.DependencyProperty.RegisterAttached%2A> に渡されるプロパティ名は、*PropertyName* と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>

- <span data-ttu-id="ded58-270">`Set`*PropertyName* および `Get`*PropertyName* という名前の `public` `static` CLR メソッドのペアを実装します。</span><span class="sxs-lookup"><span data-stu-id="ded58-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="ded58-271">いずれのメソッドでも、<xref:System.Windows.DependencyProperty> の派生クラスを最初の引数として受け取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="ded58-272">また、`Set`*PropertyName* メソッドでは、プロパティの登録データ型と同じ型の引数も受け取ります。</span><span class="sxs-lookup"><span data-stu-id="ded58-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="ded58-273">`Get`*PropertyName*メソッドでは、同じ型の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="ded58-274">`Set`*PropertyName*メソッドがない場合、プロパティは読み取り専用としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="ded58-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>

- <span data-ttu-id="ded58-275">`Set`*PropertyName* および `Get`*PropertyName* は、それぞれ、対象の依存関係オブジェクトの <xref:System.Windows.DependencyObject.GetValue%2A> メソッドおよび <xref:System.Windows.DependencyObject.SetValue%2A> メソッドのに直接転送する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="ded58-276">デザイナーが添付プロパティにアクセスするには、メソッド ラッパー経由で呼び出す場合もあれば、対象の依存関係オブジェクトを直接呼び出す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>

<span data-ttu-id="ded58-277">添付プロパティの詳細については、「[添付プロパティの概要](../advanced/attached-properties-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ded58-277">For more information on attached properties, see [Attached Properties Overview](../advanced/attached-properties-overview.md).</span></span>

### <a name="define-and-use-shared-resources"></a><span data-ttu-id="ded58-278">共有リソースの定義と使用</span><span class="sxs-lookup"><span data-stu-id="ded58-278">Define and Use Shared Resources</span></span>

<span data-ttu-id="ded58-279">アプリケーションと同じアセンブリにコントロールを含めることも、複数のアプリケーションが使用できる別のアセンブリにコントロールをパッケージ化することもできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="ded58-280">このトピックで説明した情報の大部分は、使用する方法に関係なく適用されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="ded58-281">ただし、1 つだけ例外があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="ded58-282">アプリケーションと同じアセンブリ内にコントロールを配置する場合、App.xaml ファイルにグローバル リソースを自由に追加できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="ded58-283">しかし、コントロールだけを含むアセンブリには、<xref:System.Windows.Application> オブジェクトが関連付けられないため、App.xaml ファイルは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ded58-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>

<span data-ttu-id="ded58-284">アプリケーションがリソースを検索するときは、次に示す順序で 3 つのレベルを検索します。</span><span class="sxs-lookup"><span data-stu-id="ded58-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>

1. <span data-ttu-id="ded58-285">要素レベル。</span><span class="sxs-lookup"><span data-stu-id="ded58-285">The element level.</span></span>

   <span data-ttu-id="ded58-286">システムは、リソースを参照する要素から検索を開始し、ルート要素に到達するまで、論理上の親のリソースの検索を継続します。</span><span class="sxs-lookup"><span data-stu-id="ded58-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>

2. <span data-ttu-id="ded58-287">アプリケーション レベル。</span><span class="sxs-lookup"><span data-stu-id="ded58-287">The application level.</span></span>

   <span data-ttu-id="ded58-288"><xref:System.Windows.Application> オブジェクトで定義されたリソース。</span><span class="sxs-lookup"><span data-stu-id="ded58-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>

3. <span data-ttu-id="ded58-289">テーマ レベル。</span><span class="sxs-lookup"><span data-stu-id="ded58-289">The theme level.</span></span>

   <span data-ttu-id="ded58-290">テーマ レベルのディクショナリは、Themes という名前のサブフォルダーに格納されています。</span><span class="sxs-lookup"><span data-stu-id="ded58-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="ded58-291">Themes フォルダー内のファイルはテーマに対応しています。</span><span class="sxs-lookup"><span data-stu-id="ded58-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="ded58-292">たとえば、Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml などのファイルがあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="ded58-293">generic.xaml という名前のファイルが含まれている場合もあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="ded58-294">システムがテーマ レベルでリソースを検索するとき、最初にテーマ固有のファイル内を検索し、次に generic.xaml 内を検索します。</span><span class="sxs-lookup"><span data-stu-id="ded58-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>

<span data-ttu-id="ded58-295">アプリケーションとは別のアセンブリ内にコントロールを含めるときは、グローバル リソースを要素レベルまたはテーマ レベルに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="ded58-296">どちらに配置する場合も、それぞれの利点があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-296">Both methods have their advantages.</span></span>

#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="ded58-297">要素レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="ded58-297">Defining Resources at the Element Level</span></span>

<span data-ttu-id="ded58-298">カスタムのリソース ディクショナリを作成し、それをコントロールのリソース ディクショナリと結合することによって、共有リソースを要素レベルで定義できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control's resource dictionary.</span></span>  <span data-ttu-id="ded58-299">このメソッドで定義する場合は、リソース ファイルに任意の名前を付けて、コントロールと同じフォルダーに配置できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="ded58-300">要素レベルでのリソースでは、単純な文字列をキーとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="ded58-301">次の例では、Dictionary1.xaml という名前の <xref:System.Windows.Media.LinearGradientBrush> リソース ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>

[!code-xaml[SharedResources#1](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]

<span data-ttu-id="ded58-302">ディクショナリを定義したら、それをコントロールのリソース ディクショナリにマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="ded58-303">これには、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] またはコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="ded58-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="ded58-304">次の例では、[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] を使用してリソース ディクショナリを結合します。</span><span class="sxs-lookup"><span data-stu-id="ded58-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>

[!code-xaml[SharedResources#2](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]

<span data-ttu-id="ded58-305">この方法の欠点は、参照するたびに <xref:System.Windows.ResourceDictionary> オブジェクトが作成されることです。</span><span class="sxs-lookup"><span data-stu-id="ded58-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="ded58-306">たとえば、ライブラリ内に 10 個のカスタム コントロールがあり、XAML を使用して各コントロール用の共有リソース ディクショナリを結合する場合、同一の <xref:System.Windows.ResourceDictionary> オブジェクトが 10 個作成されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="ded58-307">これを回避するには、コード内でリソースを結合し、結果として作成される <xref:System.Windows.ResourceDictionary> を返す、静的クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>

<span data-ttu-id="ded58-308">次の例では、共有の <xref:System.Windows.ResourceDictionary> を返すクラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ded58-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>

[!code-csharp[SharedResources#3](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]

<span data-ttu-id="ded58-309">次の例では、`InitializeComponent` を呼び出す前に、共有リソースをコントロールのコンス トラクター内でカスタム コントロールのリソースと結合します。</span><span class="sxs-lookup"><span data-stu-id="ded58-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="ded58-310">`SharedDictionaryManager.SharedDictionary` は静的プロパティであるため、<xref:System.Windows.ResourceDictionary> が作成されるのは 1 回だけです。</span><span class="sxs-lookup"><span data-stu-id="ded58-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="ded58-311">`InitializeComponent` が呼び出される前に、リソース ディクショナリが結合されため、コントロールは [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] ファイル内でリソースを使用できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>

[!code-csharp[SharedResources#4](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]

#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="ded58-312">テーマ レベルでのリソース定義</span><span class="sxs-lookup"><span data-stu-id="ded58-312">Defining Resources at the Theme Level</span></span>

[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="ded58-313">では、さまざまな Windows テーマ用にリソースを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-313">enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="ded58-314">コントロールの作成者は、特定のテーマ用のリソースを定義して、使用するテーマに応じてコントロールの外観を変更できます。</span><span class="sxs-lookup"><span data-stu-id="ded58-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="ded58-315">たとえば、Windows クラシックのテーマ (Windows 2000 の既定のテーマ) での <xref:System.Windows.Controls.Button> の外観は、Windows Luna テーマ (Windows XP の既定のテーマ) での <xref:System.Windows.Controls.Button> とは異なります。これは、<xref:System.Windows.Controls.Button> では、テーマごとに異なる <xref:System.Windows.Controls.ControlTemplate> が使用されるためです。</span><span class="sxs-lookup"><span data-stu-id="ded58-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>

<span data-ttu-id="ded58-316">テーマ固有のリソースは、固有のファイル名でリソース ディクショナリに保持されます。</span><span class="sxs-lookup"><span data-stu-id="ded58-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="ded58-317">これらのファイルは、コントロールが格納されているフォルダーのサブフォルダーである `Themes` フォルダー内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="ded58-318">次の表は、リソース ディクショナリ ファイルと、各ファイルに関連付けられているテーマを示しています。</span><span class="sxs-lookup"><span data-stu-id="ded58-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>

|<span data-ttu-id="ded58-319">リソース ディクショナリ ファイル名</span><span class="sxs-lookup"><span data-stu-id="ded58-319">Resource dictionary file name</span></span>|<span data-ttu-id="ded58-320">Windows テーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-320">Windows theme</span></span>|
|-----------------------------------|-------------------|
|`Classic.xaml`|<span data-ttu-id="ded58-321">Windows XP のクラシックな Windows 9x/2000 の外観</span><span class="sxs-lookup"><span data-stu-id="ded58-321">Classic Windows 9x/2000 look on Windows XP</span></span>|
|`Luna.NormalColor.xaml`|<span data-ttu-id="ded58-322">Windows XP の既定の青のテーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-322">Default blue theme on Windows XP</span></span>|
|`Luna.Homestead.xaml`|<span data-ttu-id="ded58-323">Windows XP のオリーブのテーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-323">Olive theme on Windows XP</span></span>|
|`Luna.Metallic.xaml`|<span data-ttu-id="ded58-324">Windows XP のシルバーのテーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-324">Silver theme on Windows XP</span></span>|
|`Royale.NormalColor.xaml`|<span data-ttu-id="ded58-325">Windows XP Media Center Edition の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-325">Default theme on Windows XP Media Center Edition</span></span>|
|`Aero.NormalColor.xaml`|<span data-ttu-id="ded58-326">Windows Vista の既定テーマ</span><span class="sxs-lookup"><span data-stu-id="ded58-326">Default theme on Windows Vista</span></span>|

<span data-ttu-id="ded58-327">すべてのテーマのリソースを定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="ded58-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="ded58-328">特定のテーマについてリソースが定義されていない場合、コントロールはリソースの `Classic.xaml` を確認します。</span><span class="sxs-lookup"><span data-stu-id="ded58-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="ded58-329">現在のテーマに対応するファイルや `Classic.xaml` でリソースが定義されていない場合、コントロールは汎用のリソースを使用します。汎用のリソースは、`generic.xaml` という名前のリソース ディクショナリ ファイルにあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="ded58-330">`generic.xaml` ファイルは、テーマ固有のリソース ディクショナリ ファイルと同じフォルダーに配置されています。</span><span class="sxs-lookup"><span data-stu-id="ded58-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="ded58-331">`generic.xaml` は、特定の Windows テーマには対応していませんが、テーマ レベルのディクショナリであることに変わりありません。</span><span class="sxs-lookup"><span data-stu-id="ded58-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>

<span data-ttu-id="ded58-332">[C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) または [Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) の、テーマおよび UI オートメーションがサポートされた NumericUpDown カスタム コントロールのサンプルには、`NumericUpDown` コントロール用の 2 つのリソース ディクショナリが含まれています。1 つは generic.xaml で、もう 1 つは Luna.NormalColor.xaml です。</span><span class="sxs-lookup"><span data-stu-id="ded58-332">The [C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) or [Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown custom control with theme and UI automation support sample contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml, and the other is in Luna.NormalColor.xaml.</span></span>

<span data-ttu-id="ded58-333">テーマ固有のリソース ディクショナリ ファイルのいずれかに <xref:System.Windows.Controls.ControlTemplate> を配置する場合、次の例に示すように、コントロール用の静的コンストラクターを作成し、<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> で <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-333">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>

[!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
[!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]

##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="ded58-334">テーマ リソース用のキーの定義と参照</span><span class="sxs-lookup"><span data-stu-id="ded58-334">Defining and Referencing Keys for Theme Resources</span></span>

<span data-ttu-id="ded58-335">要素レベルでリソースを定義するときに、文字列をキーとして割り当て、その文字列を使用してリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ded58-335">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="ded58-336">テーマ レベルでリソースを定義するときは、<xref:System.Windows.ComponentResourceKey> をキーとして使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-336">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="ded58-337">次の例では、generic.xaml でリソースを定義します。</span><span class="sxs-lookup"><span data-stu-id="ded58-337">The following example defines a resource in generic.xaml.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]

<span data-ttu-id="ded58-338">次の例では、<xref:System.Windows.ComponentResourceKey> をキーとして指定して、リソースを参照します。</span><span class="sxs-lookup"><span data-stu-id="ded58-338">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]

##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="ded58-339">テーマ リソースの場所の指定</span><span class="sxs-lookup"><span data-stu-id="ded58-339">Specifying the Location of Theme Resources</span></span>

<span data-ttu-id="ded58-340">コントロールのリソースを見つけるには、アセンブリにコントロール固有のリソースが含まれていることを、ホスト アプリケーションが認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ded58-340">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="ded58-341">これを可能にするには、コントロールが含まれているアセンブリに <xref:System.Windows.ThemeInfoAttribute> を追加します。</span><span class="sxs-lookup"><span data-stu-id="ded58-341">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="ded58-342"><xref:System.Windows.ThemeInfoAttribute> には、汎用のリソースの場所を指定する <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> プロパティと、テーマ固有のリソースの場所を指定する <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="ded58-342">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>

<span data-ttu-id="ded58-343">次の例では、<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> プロパティと <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> プロパティを <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly> に設定し、汎用リソースとテーマ固有のリソースがコントロールと同じアセンブリ内にあることを指定しています。</span><span class="sxs-lookup"><span data-stu-id="ded58-343">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>

[!code-csharp[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
[!code-vb[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]

## <a name="see-also"></a><span data-ttu-id="ded58-344">関連項目</span><span class="sxs-lookup"><span data-stu-id="ded58-344">See also</span></span>

- [<span data-ttu-id="ded58-345">Visual Studio で XAML をデザインする</span><span class="sxs-lookup"><span data-stu-id="ded58-345">Design XAML in Visual Studio</span></span>](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)
- [<span data-ttu-id="ded58-346">WPF におけるパッケージの URI</span><span class="sxs-lookup"><span data-stu-id="ded58-346">Pack URIs in WPF</span></span>](../app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="ded58-347">コントロールのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="ded58-347">Control Customization</span></span>](control-customization.md)
