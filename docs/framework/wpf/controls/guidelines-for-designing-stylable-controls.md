---
title: スタイルの設定が可能なコントロールを設計するためのガイドライン
ms.date: 03/30/2017
helpviewer_keywords:
- style design for controls [WPF]
- controls [WPF], style design
ms.assetid: c52dde45-a311-4531-af4c-853371c4d5f4
ms.openlocfilehash: 0fbb515afbeac05168ced6f0a99f50eb29a5c848
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459649"
---
# <a name="guidelines-for-designing-stylable-controls"></a><span data-ttu-id="fad73-102">スタイルの設定が可能なコントロールを設計するためのガイドライン</span><span class="sxs-lookup"><span data-stu-id="fad73-102">Guidelines for Designing Stylable Controls</span></span>

<span data-ttu-id="fad73-103">このドキュメントは、スタイルの設定とテンプレートの作成を簡単に行うためのコントロールを設計する際に考慮すべき一連のベスト プラクティスをまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="fad73-103">This document summarizes a set of best practices to consider when designing a control which you intend to be easily stylable and templatable.</span></span> <span data-ttu-id="fad73-104">組み込みの [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] コントロール セットのテーマのコントロールのスタイルの操作で試行錯誤を繰り返した結果、この一連のベスト プラクティスにたどり着きました。</span><span class="sxs-lookup"><span data-stu-id="fad73-104">We came to this set of best practices through a lot of trial and error while working on the theme control styles for the built-in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control set.</span></span> <span data-ttu-id="fad73-105">スタイリングの成功の鍵は、スタイルそのものであると同様に、適切に設計されたオブジェクト モデルの機能であることが分かりました。</span><span class="sxs-lookup"><span data-stu-id="fad73-105">We learned that successful styling is as much a function of a well-designed object model as it is of the style itself.</span></span> <span data-ttu-id="fad73-106">このドキュメントの対象読者は、スタイルの作成者ではなく、コントロールの作成者です。</span><span class="sxs-lookup"><span data-stu-id="fad73-106">The intended audience for this document is the control author, not the style author.</span></span>

<a name="Terminology"></a>

## <a name="terminology"></a><span data-ttu-id="fad73-107">用語</span><span class="sxs-lookup"><span data-stu-id="fad73-107">Terminology</span></span>

<span data-ttu-id="fad73-108">「スタイルとテンプレート」は、コントロールの作成者がコントロールの視覚的な側面をコントロールのスタイルとテンプレートに委ねることができるようにする一連のテクノロジを表します。</span><span class="sxs-lookup"><span data-stu-id="fad73-108">"Styling and templating" refer to the suite of technologies that enable a control author to defer the visual aspects of the control to the style and template of the control.</span></span> <span data-ttu-id="fad73-109">この一連のテクノロジは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="fad73-109">This suite of technologies includes:</span></span>

- <span data-ttu-id="fad73-110">スタイル (プロパティ セッター、トリガー、およびストーリー ボードを含む)。</span><span class="sxs-lookup"><span data-stu-id="fad73-110">Styles (including property setters, triggers, and storyboards).</span></span>

- <span data-ttu-id="fad73-111">リソース</span><span class="sxs-lookup"><span data-stu-id="fad73-111">Resources.</span></span>

- <span data-ttu-id="fad73-112">コントロール テンプレート</span><span class="sxs-lookup"><span data-stu-id="fad73-112">Control templates.</span></span>

- <span data-ttu-id="fad73-113">データ テンプレート</span><span class="sxs-lookup"><span data-stu-id="fad73-113">Data templates.</span></span>

<span data-ttu-id="fad73-114">スタイルとテンプレートの概要については、「[スタイルとテンプレート](../../../desktop-wpf/fundamentals/styles-templates-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fad73-114">For an introduction to styling and templating, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

<a name="Before_You_Start__Understanding_Your_Control"></a>

## <a name="before-you-start-understanding-your-control"></a><span data-ttu-id="fad73-115">開始前の作業: コントロールの確認</span><span class="sxs-lookup"><span data-stu-id="fad73-115">Before You Start: Understanding Your Control</span></span>

<span data-ttu-id="fad73-116">次のガイドラインに進む前に、コントロールの一般的な使用方法を理解し、これを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-116">Before you jump into these guidelines, it is important to understand and have defined the common usage of your control.</span></span> <span data-ttu-id="fad73-117">スタイル設定は、規則に従わないことが多い可能性セットに遭遇します。</span><span class="sxs-lookup"><span data-stu-id="fad73-117">Styling exposes an often unruly set of possibilities.</span></span> <span data-ttu-id="fad73-118">(多くのアプリケーションで、多くの開発者によって) 広く使用されるように作成されるコントロールは、コントロールの視覚的な外観に広範な変更を加えるためにスタイル設定を使用できるという課題に直面しています。</span><span class="sxs-lookup"><span data-stu-id="fad73-118">Controls that are written to be used broadly (in many applications, by many developers) face the challenge that styling can be used to make far-reaching changes to the visual appearance of the control.</span></span> <span data-ttu-id="fad73-119">実際には、スタイルのコントロールは、コントロールの作成者の意図に沿っていない場合すらあります。</span><span class="sxs-lookup"><span data-stu-id="fad73-119">In fact, the styled control may not even resemble the control author's intentions.</span></span> <span data-ttu-id="fad73-120">スタイル設定によって提供される柔軟性は実質的に無制限であるため、一般的な使用方法の概念を使用して、決定を詳しく調査できます。</span><span class="sxs-lookup"><span data-stu-id="fad73-120">Since the flexibility offered by styling is essentially boundless, you can use the idea of common usage to help you scope your decisions.</span></span>

<span data-ttu-id="fad73-121">コントロールの一般的な使用方法を理解するには、コントロールの価値提案について考慮することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fad73-121">To understand your control's common usage, it's good to think about the value proposition of the control.</span></span> <span data-ttu-id="fad73-122">作成したコントロールがテーブルにもたらすもので、その他のコントロールが提供できないものは何でしょうか。</span><span class="sxs-lookup"><span data-stu-id="fad73-122">What does your control bring to the table that no other control can offer?</span></span> <span data-ttu-id="fad73-123">一般的な使用方法は、特定の視覚的な外観を意味するのではなく、コントロールの原理とその使用法の妥当な一連の想定を意味します。</span><span class="sxs-lookup"><span data-stu-id="fad73-123">Common usage does not imply any specific visual appearance, but rather the philosophy of the control and a reasonable set of expectations about its usage.</span></span> <span data-ttu-id="fad73-124">このことを理解すると、一般的な場合での、構成モデルとコントロールのスタイル定義の動作に関するある想定を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="fad73-124">This understanding allows you to make some assumptions about the composition model and the style-defined behaviors of the control in the common case.</span></span> <span data-ttu-id="fad73-125">たとえば、<xref:System.Windows.Controls.ComboBox> の場合、一般的な使用方法を理解しても、特定の <xref:System.Windows.Controls.ComboBox> の角が丸いかどうかについての洞察を得ることはできませんが、<xref:System.Windows.Controls.ComboBox> にポップアップ ウィンドウや、このウィンドウを開いたり閉じたりするなんらかの方法がおそらく必要だという洞察は得ることができます。</span><span class="sxs-lookup"><span data-stu-id="fad73-125">In the case of <xref:System.Windows.Controls.ComboBox>, for example, understanding the common usage won't give you any insight about whether a particular <xref:System.Windows.Controls.ComboBox> has rounded corners, but it will give you insight into the fact that the <xref:System.Windows.Controls.ComboBox> probably needs a pop-up window and some way of toggling whether it is open.</span></span>

<a name="General_Guidelines"></a>

## <a name="general-guidelines"></a><span data-ttu-id="fad73-126">一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="fad73-126">General Guidelines</span></span>

- <span data-ttu-id="fad73-127">**テンプレートのコントラクトは厳密に適用しないでください。**</span><span class="sxs-lookup"><span data-stu-id="fad73-127">**Do not strictly enforce template contracts.**</span></span> <span data-ttu-id="fad73-128">コントロールのテンプレートのコントラクトは、要素、コマンド、バインディングまたはトリガーで構成されます。また、コントロールが正しく動作するために必要なまたは期待されているプロパティ設定が含まれる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="fad73-128">The template contract of a control might consist of elements, commands, bindings, triggers, or even property settings that are required or expected for a control to function properly.</span></span>

  - <span data-ttu-id="fad73-129">コントラクトを可能な限り最小限に抑えます。</span><span class="sxs-lookup"><span data-stu-id="fad73-129">Minimize contracts as much as possible.</span></span>

  - <span data-ttu-id="fad73-130">設計中 (つまり、設計ツールを使用時) にはコントロール テンプレートが未完成の状態であることが一般的です。</span><span class="sxs-lookup"><span data-stu-id="fad73-130">Design around the expectation that during design time (that is, when using a design tool) it is common for a control template to be in an incomplete state.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fad73-131">は「構成」状態のインフラストラクチャを提供しないため、コントロールは、このような状態が有効かもしれないという想定で構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-131">does not offer a "composing" state infrastructure, so controls have to be built with the expectation that such a state might be valid.</span></span>

  - <span data-ttu-id="fad73-132">テンプレートのコントラクトの側面に従わない場合、例外をスローしないでください。</span><span class="sxs-lookup"><span data-stu-id="fad73-132">Do not throw exceptions when any aspect of a template contract is not followed.</span></span> <span data-ttu-id="fad73-133">これらすべての点で、パネルの子が多すぎるまたは少なすぎる場合、例外をスローしないでください。</span><span class="sxs-lookup"><span data-stu-id="fad73-133">Along these lines, panels should not throw exceptions if they have too many or too few children.</span></span>

- <span data-ttu-id="fad73-134">**周辺機能をテンプレートのヘルパー要素に組み込んでください。**</span><span class="sxs-lookup"><span data-stu-id="fad73-134">**Factor peripheral functionality into template helper elements.**</span></span> <span data-ttu-id="fad73-135">各コントロールは、コア機能と真の価値提案に重点を置き、コントロールの一般的な使用方法で定義されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-135">Each control should be focused on its core functionality and true value proposition and defined by the control's common usage.</span></span> <span data-ttu-id="fad73-136">このために、テンプレート内で構成要素とヘルパー要素を使用し、周辺の動作およびビジュアル (つまり、コントロールのコア機能に関係のない動作とビジュアル) を有効にします。</span><span class="sxs-lookup"><span data-stu-id="fad73-136">To that end, use composition and helper elements within the template to enable peripheral behaviors and visualizations, that is, those behaviors and visualizations that do not contribute to the core functionality of the control.</span></span> <span data-ttu-id="fad73-137">ヘルパー要素は次の 3 つのカテゴリに分類されます。</span><span class="sxs-lookup"><span data-stu-id="fad73-137">Helper elements fall into three categories:</span></span>

  - <span data-ttu-id="fad73-138">**Standalone** ヘルパー型は、テンプレートで「匿名」で使用される、パブリックで再利用可能なコントロールまたはあるプリミティブです。つまり、ヘルパー要素もスタイル設定されたコントロールも他方を認識しません。</span><span class="sxs-lookup"><span data-stu-id="fad73-138">**Standalone** helper types are public and reusable controls or primitives that are used "anonymously" in a template, meaning that neither the helper element nor the styled control is aware of the other.</span></span> <span data-ttu-id="fad73-139">技術的には、任意の要素を匿名型にできますが、このコンテキストではこの用語は、対象となるシナリオを有効にする専用機能をカプセル化するこれらの型について説明します。</span><span class="sxs-lookup"><span data-stu-id="fad73-139">Technically, any element can be an anonymous type, but in this context the term describes those types that encapsulate specialized functionality to enable targeted scenarios.</span></span>

  - <span data-ttu-id="fad73-140">**Type-based** ヘルパー要素は、専用機能をカプセル化する新しい型です。</span><span class="sxs-lookup"><span data-stu-id="fad73-140">**Type-based** helper elements are new types that encapsulate specialized functionality.</span></span> <span data-ttu-id="fad73-141">これらの要素は通常、一般的なコントロールまたはプリミティブより狭い範囲の機能を持つように設計されています。</span><span class="sxs-lookup"><span data-stu-id="fad73-141">These elements are typically designed with a narrower range of functionality than common controls or primitives.</span></span> <span data-ttu-id="fad73-142">Standalone ヘルパー要素とは異なり、Type-based ヘルパー要素は、これが使用されるコンテキストを認識し、通常これが属しているテンプレートを持つコントロールとデータを共有する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-142">Unlike standalone helper elements, type-based helper elements are aware of the context in which they are used and typically must share data with the control to whose template they belong.</span></span>

  - <span data-ttu-id="fad73-143">**Named** ヘルパー要素は、コントロールがテンプレート内で名前で検索することを想定している一般的なコントロールまたはプリミティブです。</span><span class="sxs-lookup"><span data-stu-id="fad73-143">**Named** helper elements are common controls or primitives that a control expects to find within its template by name.</span></span> <span data-ttu-id="fad73-144">これらの要素には、テンプレート内で既知の名前が与えられ、コントロールが要素を検索し、プログラムでやり取りできるようにします。</span><span class="sxs-lookup"><span data-stu-id="fad73-144">These elements are given a well-known name within the template, making it possible for a control to find the element and interact with it programmatically.</span></span> <span data-ttu-id="fad73-145">特定の名前を持つ要素はテンプレート内に 1 つのみ存在できます。</span><span class="sxs-lookup"><span data-stu-id="fad73-145">There can only be one element with a given name in any template.</span></span>

  <span data-ttu-id="fad73-146">次の表は、現在コントロール スタイルで採用されているヘルパー要素を示しています (この一覧は完全ではありません)。</span><span class="sxs-lookup"><span data-stu-id="fad73-146">The following table shows helper elements employed by control styles today (this list is not exhaustive):</span></span>

  |<span data-ttu-id="fad73-147">要素</span><span class="sxs-lookup"><span data-stu-id="fad73-147">Element</span></span>|<span data-ttu-id="fad73-148">種類</span><span class="sxs-lookup"><span data-stu-id="fad73-148">Type</span></span>|<span data-ttu-id="fad73-149">使用者</span><span class="sxs-lookup"><span data-stu-id="fad73-149">Used by</span></span>|
  |-------------|----------|-------------|
  |<xref:System.Windows.Controls.ContentPresenter>|<span data-ttu-id="fad73-150">Type-based</span><span class="sxs-lookup"><span data-stu-id="fad73-150">Type-based</span></span>|<span data-ttu-id="fad73-151"><xref:System.Windows.Controls.Button>、<xref:System.Windows.Controls.CheckBox>、<xref:System.Windows.Controls.RadioButton>、<xref:System.Windows.Controls.Frame> など (すべての <xref:System.Windows.Controls.ContentControl> 型)</span><span class="sxs-lookup"><span data-stu-id="fad73-151"><xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.RadioButton>, <xref:System.Windows.Controls.Frame>, and so on (all <xref:System.Windows.Controls.ContentControl> types)</span></span>|
  |<xref:System.Windows.Controls.ItemsPresenter>|<span data-ttu-id="fad73-152">Type-based</span><span class="sxs-lookup"><span data-stu-id="fad73-152">Type-based</span></span>|<span data-ttu-id="fad73-153"><xref:System.Windows.Controls.ListBox>、<xref:System.Windows.Controls.ComboBox>、<xref:System.Windows.Controls.Menu> など (すべての <xref:System.Windows.Controls.ItemsControl> 型)</span><span class="sxs-lookup"><span data-stu-id="fad73-153"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, and so on (all <xref:System.Windows.Controls.ItemsControl> types)</span></span>|
  |<xref:System.Windows.Controls.Primitives.ToolBarOverflowPanel>|<span data-ttu-id="fad73-154">Named</span><span class="sxs-lookup"><span data-stu-id="fad73-154">Named</span></span>|<xref:System.Windows.Controls.ToolBar>|
  |<xref:System.Windows.Controls.Primitives.Popup>|<span data-ttu-id="fad73-155">Standalone</span><span class="sxs-lookup"><span data-stu-id="fad73-155">Standalone</span></span>|<span data-ttu-id="fad73-156"><xref:System.Windows.Controls.ComboBox>、<xref:System.Windows.Controls.ToolBar>、<xref:System.Windows.Controls.Menu>、<xref:System.Windows.Controls.ToolTip> など</span><span class="sxs-lookup"><span data-stu-id="fad73-156"><xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolTip>, and so on</span></span>|
  |<xref:System.Windows.Controls.Primitives.RepeatButton>|<span data-ttu-id="fad73-157">Named</span><span class="sxs-lookup"><span data-stu-id="fad73-157">Named</span></span>|<span data-ttu-id="fad73-158"><xref:System.Windows.Controls.Slider>、<xref:System.Windows.Controls.Primitives.ScrollBar> など</span><span class="sxs-lookup"><span data-stu-id="fad73-158"><xref:System.Windows.Controls.Slider>, <xref:System.Windows.Controls.Primitives.ScrollBar>, and so on</span></span>|
  |<xref:System.Windows.Controls.Primitives.ScrollBar>|<span data-ttu-id="fad73-159">Named</span><span class="sxs-lookup"><span data-stu-id="fad73-159">Named</span></span>|<xref:System.Windows.Controls.ScrollViewer>|
  |<xref:System.Windows.Controls.ScrollViewer>|<span data-ttu-id="fad73-160">Standalone</span><span class="sxs-lookup"><span data-stu-id="fad73-160">Standalone</span></span>|<span data-ttu-id="fad73-161"><xref:System.Windows.Controls.ListBox>、<xref:System.Windows.Controls.ComboBox>、<xref:System.Windows.Controls.Menu>、<xref:System.Windows.Controls.Frame> など</span><span class="sxs-lookup"><span data-stu-id="fad73-161"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.Frame>, and so on</span></span>|
  |<xref:System.Windows.Controls.Primitives.TabPanel>|<span data-ttu-id="fad73-162">Standalone</span><span class="sxs-lookup"><span data-stu-id="fad73-162">Standalone</span></span>|<xref:System.Windows.Controls.TabControl>|
  |<xref:System.Windows.Controls.TextBox>|<span data-ttu-id="fad73-163">Named</span><span class="sxs-lookup"><span data-stu-id="fad73-163">Named</span></span>|<xref:System.Windows.Controls.ComboBox>|
  |<xref:System.Windows.Controls.Primitives.TickBar>|<span data-ttu-id="fad73-164">Type-based</span><span class="sxs-lookup"><span data-stu-id="fad73-164">Type-based</span></span>|<xref:System.Windows.Controls.Slider>|

- <span data-ttu-id="fad73-165">**ヘルパー要素の必要なユーザー指定のバインディングまたはプロパティ設定を最小限に抑えます**。</span><span class="sxs-lookup"><span data-stu-id="fad73-165">**Minimize required user-specified bindings or property settings on helper elements**.</span></span> <span data-ttu-id="fad73-166">コントロール テンプレート内で正しく機能するために、ヘルパー要素が特定のバインディングまたはプロパティ設定を要求することが一般的です。</span><span class="sxs-lookup"><span data-stu-id="fad73-166">It is common for a helper element to require certain bindings or property settings in order to function properly within the control template.</span></span> <span data-ttu-id="fad73-167">ヘルパー要素とテンプレート化されたコントロールがこれらの設定をできる限り多く確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-167">The helper element and templated control should, as much as possible, establish these settings.</span></span> <span data-ttu-id="fad73-168">プロパティの設定やバインディングの確立を行うとき、ユーザーが設定した値をオーバーライドしないように注意してください。</span><span class="sxs-lookup"><span data-stu-id="fad73-168">When setting properties or establishing bindings, care should be taken to not override values set by the user.</span></span> <span data-ttu-id="fad73-169">具体的なベスト プラクティスは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="fad73-169">Specific best practices are as follows:</span></span>

  - <span data-ttu-id="fad73-170">Named ヘルパー要素は親によって識別する必要があり、親はこのヘルパー要素に必要な設定を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-170">Named helper elements should be identified by the parent and the parent should establish any required settings on the helper element.</span></span>

  - <span data-ttu-id="fad73-171">Type-based ヘルパー要素は、自身に必要な設定を直接確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-171">Type-based helper elements should establish any required settings directly on themselves.</span></span> <span data-ttu-id="fad73-172">これを行うと、`TemplatedParent` (使用するテンプレートのコントロールの型) などの使用する情報コンテキストをクエリするヘルパー要素が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-172">Doing this may require the helper element to query for information context in which it is being used, including its `TemplatedParent` (the control type of the template in which it is being used).</span></span> <span data-ttu-id="fad73-173">たとえば、<xref:System.Windows.Controls.ContentPresenter> は、<xref:System.Windows.Controls.ContentControl> 派生型で使用されている場合、その `TemplatedParent` の `Content` プロパティを、その <xref:System.Windows.Controls.ContentPresenter.Content%2A> プロパティに自動的にバインドします。</span><span class="sxs-lookup"><span data-stu-id="fad73-173">For example, <xref:System.Windows.Controls.ContentPresenter> automatically binds the `Content` property of its `TemplatedParent` to its <xref:System.Windows.Controls.ContentPresenter.Content%2A> property when used in a <xref:System.Windows.Controls.ContentControl> derived type.</span></span>

  - <span data-ttu-id="fad73-174">Standalone ヘルパー要素はこの方法では最適化できません。その理由は、定義上、ヘルパー要素もその親も他方を認識していないためです。</span><span class="sxs-lookup"><span data-stu-id="fad73-174">Standalone helper elements cannot be optimized in this way because, by definition, neither the helper element nor the parent knows about the other.</span></span>

- <span data-ttu-id="fad73-175">**Name プロパティを使用してテンプレート内で要素にフラグを設定します**。</span><span class="sxs-lookup"><span data-stu-id="fad73-175">**Use the Name property to flag elements within a template**.</span></span> <span data-ttu-id="fad73-176">プログラムで要素にアクセスするためにそのスタイルで要素を検索する必要があるコントロールは、`Name` プロパティおよび `FindName` パラダイムを使用してこの操作を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-176">A control that needs to find an element in its style in order to access it programmatically should do so using the `Name` property and the `FindName` paradigm.</span></span> <span data-ttu-id="fad73-177">コントロールは、要素が見つからない場合には例外をスローせず、その要素を必要としていた機能を安全に無効にします。</span><span class="sxs-lookup"><span data-stu-id="fad73-177">A control should not throw an exception when an element is not found, but silently and gracefully disable the functionality which required that element.</span></span>

- <span data-ttu-id="fad73-178">**コントロールの状態と動作をスタイルで表現するためのベスト プラクティスを使用します。**</span><span class="sxs-lookup"><span data-stu-id="fad73-178">**Use best practices for expressing control state and behavior in a style.**</span></span> <span data-ttu-id="fad73-179">コントロールの状態の変更と動作をスタイルで表すためのベスト プラクティスの順序付きリストを次に示します。</span><span class="sxs-lookup"><span data-stu-id="fad73-179">The following is an ordered list of best practices for expressing control state changes and behavior in a style.</span></span> <span data-ttu-id="fad73-180">シナリオを有効にするリストの最初の項目を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-180">You should use the first item on the list that enables your scenario.</span></span>

  1. <span data-ttu-id="fad73-181">プロパティ バインディング</span><span class="sxs-lookup"><span data-stu-id="fad73-181">Property binding.</span></span> <span data-ttu-id="fad73-182">例: <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> と <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType> の間のバインド。</span><span class="sxs-lookup"><span data-stu-id="fad73-182">Example: binding between <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> and <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>.</span></span>

  2. <span data-ttu-id="fad73-183">トリガーされたプロパティの変更またはプロパティのアニメーション。</span><span class="sxs-lookup"><span data-stu-id="fad73-183">Triggered property changes or property animations.</span></span> <span data-ttu-id="fad73-184">例: <xref:System.Windows.Controls.Button> のホバー状態。</span><span class="sxs-lookup"><span data-stu-id="fad73-184">Example: the hover state of a <xref:System.Windows.Controls.Button>.</span></span>

  3. <span data-ttu-id="fad73-185">コマンド。</span><span class="sxs-lookup"><span data-stu-id="fad73-185">Command.</span></span> <span data-ttu-id="fad73-186">例: <xref:System.Windows.Controls.Primitives.ScrollBar> の <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> / <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand>。</span><span class="sxs-lookup"><span data-stu-id="fad73-186">Example: <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> / <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>

  4. <span data-ttu-id="fad73-187">Standalone ヘルパー要素。</span><span class="sxs-lookup"><span data-stu-id="fad73-187">Standalone helper elements.</span></span> <span data-ttu-id="fad73-188">例: <xref:System.Windows.Controls.TabControl> の <xref:System.Windows.Controls.Primitives.TabPanel>。</span><span class="sxs-lookup"><span data-stu-id="fad73-188">Example: <xref:System.Windows.Controls.Primitives.TabPanel> in <xref:System.Windows.Controls.TabControl>.</span></span>

  5. <span data-ttu-id="fad73-189">Type-based ヘルパー型。</span><span class="sxs-lookup"><span data-stu-id="fad73-189">Type-based helper types.</span></span> <span data-ttu-id="fad73-190">例: <xref:System.Windows.Controls.Button> の <xref:System.Windows.Controls.ContentPresenter>、<xref:System.Windows.Controls.Slider> の <xref:System.Windows.Controls.Primitives.TickBar>。</span><span class="sxs-lookup"><span data-stu-id="fad73-190">Example: <xref:System.Windows.Controls.ContentPresenter> in <xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.Primitives.TickBar> in <xref:System.Windows.Controls.Slider>.</span></span>

  6. <span data-ttu-id="fad73-191">Named ヘルパー要素。</span><span class="sxs-lookup"><span data-stu-id="fad73-191">Named helper elements.</span></span> <span data-ttu-id="fad73-192">例: <xref:System.Windows.Controls.ComboBox> の <xref:System.Windows.Controls.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="fad73-192">Example: <xref:System.Windows.Controls.TextBox> in <xref:System.Windows.Controls.ComboBox>.</span></span>

  7. <span data-ttu-id="fad73-193">Named ヘルパー型からのバブル イベント。</span><span class="sxs-lookup"><span data-stu-id="fad73-193">Bubbled events from named helper types.</span></span> <span data-ttu-id="fad73-194">スタイル要素からバブル イベントをリッスンする場合、イベントを生成する要素を一意に識別できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-194">If you listen for bubbled events from a style element, you should require that the element generating the event can be uniquely identified.</span></span> <span data-ttu-id="fad73-195">例: <xref:System.Windows.Controls.ToolBar> の <xref:System.Windows.Controls.Primitives.Thumb>。</span><span class="sxs-lookup"><span data-stu-id="fad73-195">Example: <xref:System.Windows.Controls.Primitives.Thumb> in <xref:System.Windows.Controls.ToolBar>.</span></span>

  8. <span data-ttu-id="fad73-196">カスタム `OnRender` 動作。</span><span class="sxs-lookup"><span data-stu-id="fad73-196">Custom `OnRender` behavior.</span></span> <span data-ttu-id="fad73-197">例: <xref:System.Windows.Controls.Button> の <xref:Microsoft.Windows.Themes.ButtonChrome>。</span><span class="sxs-lookup"><span data-stu-id="fad73-197">Example: <xref:Microsoft.Windows.Themes.ButtonChrome> in <xref:System.Windows.Controls.Button>.</span></span>

- <span data-ttu-id="fad73-198">**(テンプレートのトリガー) ではなくスタイルのトリガーを控えめに使用します**。</span><span class="sxs-lookup"><span data-stu-id="fad73-198">**Use style triggers (as opposed to template triggers) sparingly**.</span></span> <span data-ttu-id="fad73-199">テンプレートの要素のプロパティに影響するトリガーは、テンプレートで宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-199">Triggers that affect properties on elements in the template must be declared in the template.</span></span> <span data-ttu-id="fad73-200">コントロールのプロパティに影響するトリガー (`TargetName` 以外) は、テンプレートの変更がトリガーも破棄することがわかっていない限り、スタイルで宣言できます。</span><span class="sxs-lookup"><span data-stu-id="fad73-200">Triggers that affect properties on the control (no `TargetName`) may be declared in the style unless you know that changing the template should also destroy the trigger.</span></span>

- <span data-ttu-id="fad73-201">**既存のスタイル パターンとの一貫性を保ちます。**</span><span class="sxs-lookup"><span data-stu-id="fad73-201">**Be consistent with existing styling patterns.**</span></span> <span data-ttu-id="fad73-202">多くの場合、問題を解決する方法は複数あります。</span><span class="sxs-lookup"><span data-stu-id="fad73-202">Many times there are multiple ways to solve a problem.</span></span> <span data-ttu-id="fad73-203">可能な場合、既存のコントロール スタイル設定パターンとの一貫性を維持してください。</span><span class="sxs-lookup"><span data-stu-id="fad73-203">Be aware of and, when possible, consistent with existing control styling patterns.</span></span> <span data-ttu-id="fad73-204">これは、同じ基本データ型 (<xref:System.Windows.Controls.ContentControl>、<xref:System.Windows.Controls.ItemsControl>、<xref:System.Windows.Controls.Primitives.RangeBase> など) から派生したコントロールでは特に重要です。</span><span class="sxs-lookup"><span data-stu-id="fad73-204">This is especially important for controls that derive from the same base type (for example, <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.Primitives.RangeBase>, and so on).</span></span>

- <span data-ttu-id="fad73-205">**プロパティを公開し、テンプレートを再設定せずに一般的なカスタマイズ シナリオを有効にします**。</span><span class="sxs-lookup"><span data-stu-id="fad73-205">**Expose properties to enable common customization scenarios without retemplating**.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="fad73-206">はプラグ可能/カスタマイズ可能な部分をサポートしないため、コントロールのユーザーは 2 つのカスタマイズ メソッドのみを使用できます。プロパティを直接設定するか、スタイルを使用してプロパティを設定するかです。</span><span class="sxs-lookup"><span data-stu-id="fad73-206">does not support pluggable/customizable parts, so a control user is left with only two methods of customization: setting properties directly or setting properties using styles.</span></span> <span data-ttu-id="fad73-207">このことを念頭に置いて、このメソッドを使用しない場合にはテンプレートの再設定をしなければならなくなる、非常に一般的で優先度の高いカスタマイズのシナリオを対象とした、数に限りのあるプロパティに使用することが適切です。</span><span class="sxs-lookup"><span data-stu-id="fad73-207">With that in mind, it is appropriate to surface a limited number of properties targeted at very common, high-priority customization scenarios which would otherwise require the retemplating.</span></span> <span data-ttu-id="fad73-208">カスタマイズのシナリオをいつ有効にし、どのように有効にするかについてのベスト プラクティスを次に示します。</span><span class="sxs-lookup"><span data-stu-id="fad73-208">Here are best practices for when and how to enable customization scenarios:</span></span>

  - <span data-ttu-id="fad73-209">非常に一般的なカスタマイズをコントロールのプロパティとして公開し、テンプレートで使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-209">Very common customizations should be exposed as properties on the control and consumed by the template.</span></span>

  - <span data-ttu-id="fad73-210">(まれではないが) あまり一般的ではないカスタマイズは、添付プロパティとして公開し、テンプレートで使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-210">Less common (though not rare) customizations should be exposed as attached properties and consumed by the template.</span></span>

  - <span data-ttu-id="fad73-211">既知だがまれなカスタマイズでテンプレートの再設定が必要になることは容認されます。</span><span class="sxs-lookup"><span data-stu-id="fad73-211">It is acceptable for known but rare customizations to require retemplating.</span></span>

<a name="Theme_Considerations"></a>

## <a name="theme-considerations"></a><span data-ttu-id="fad73-212">テーマの注意事項</span><span class="sxs-lookup"><span data-stu-id="fad73-212">Theme Considerations</span></span>

- <span data-ttu-id="fad73-213">**テーマ スタイルは、すべてのテーマで一貫性のあるプロパティのセマンティクスを持つようにする必要がありますが、その保証はありません**。</span><span class="sxs-lookup"><span data-stu-id="fad73-213">**Theme styles should attempt to have consistent property semantics across all themes, but make no guarantee**.</span></span> <span data-ttu-id="fad73-214">ドキュメントの一部として、コントロールは、コントロールのプロパティのセマンティクス、つまり、コントロールのプロパティの「意味」を説明するドキュメントが必要です。</span><span class="sxs-lookup"><span data-stu-id="fad73-214">As part of its documentation, your control should have a document describing the control's property semantics, that is, the "meaning" of a property for a control.</span></span> <span data-ttu-id="fad73-215">たとえば、<xref:System.Windows.Controls.ComboBox> コントロールは、<xref:System.Windows.Controls.ComboBox> 内の <xref:System.Windows.Controls.Control.Background%2A> プロパティの意味を定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-215">For example, the <xref:System.Windows.Controls.ComboBox> control should define the meaning of the <xref:System.Windows.Controls.Control.Background%2A> property within <xref:System.Windows.Controls.ComboBox>.</span></span> <span data-ttu-id="fad73-216">コントロールの既定のスタイルは、すべてのテーマでそのドキュメントで定義されたセマンティクスに従おうとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-216">The default styles for your control should attempt to follow the semantics defined in that document across all themes.</span></span> <span data-ttu-id="fad73-217">一方コントロールのユーザーは、プロパティのセマンティクスがテーマごとに変わる可能性があることを認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-217">Control users, on the other hand, should be aware that property semantics can change from theme to theme.</span></span> <span data-ttu-id="fad73-218">特定のケースでは、指定したプロパティが特定のテーマで必要な視覚上の制約下では表現できない場合があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-218">In certain cases, a given property may not be expressible under the visual constraints required by a particular theme.</span></span> <span data-ttu-id="fad73-219">(たとえば、クラシックのテーマには、多くのコントロールに対して `Thickness` の適用先にできる単一の境界線がありません。)</span><span class="sxs-lookup"><span data-stu-id="fad73-219">(The Classic theme, for example, does not have a single border to which `Thickness` can be applied for many controls.)</span></span>

- <span data-ttu-id="fad73-220">**テーマ スタイルは、すべてのテーマで一貫性のあるトリガー セマンティクスを持つ必要はありません**。</span><span class="sxs-lookup"><span data-stu-id="fad73-220">**Theme styles do not need to have consistent trigger semantics across all themes**.</span></span> <span data-ttu-id="fad73-221">トリガーまたはアニメーションを通してコントロール スタイルによって公開されている動作は、テーマごとに異なります。</span><span class="sxs-lookup"><span data-stu-id="fad73-221">The behavior exposed by a control style through triggers or animations may vary from theme to theme.</span></span> <span data-ttu-id="fad73-222">コントロールのユーザーは、すべてのテーマで特定の動作を実現するために、コントロールが同じメカニズムを必ずしも使用しないことを認識している必要があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-222">Control users should be aware that a control will not necessarily employ the same mechanism to achieve a particular behavior across all themes.</span></span> <span data-ttu-id="fad73-223">たとえば、1 つのテーマがアニメーションを使用してホバー動作を表現し、別のテーマがトリガーを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-223">One theme, for example, may use an animation to express hover behavior where another theme uses a trigger.</span></span> <span data-ttu-id="fad73-224">これにより、カスタマイズされたコントロールでの動作の保持に不整合が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fad73-224">This can result in inconsistencies in behavior preservation on customized controls.</span></span> <span data-ttu-id="fad73-225">(たとえば、背景のプロパティの変更は、ホバー状態がトリガーを使用して表現されている場合、コントロールのホバー状態には影響しません。</span><span class="sxs-lookup"><span data-stu-id="fad73-225">(Changing the background property, for example, might not affect the hover state of the control if that state is expressed using a trigger.</span></span> <span data-ttu-id="fad73-226">ただし、ホバー状態がアニメーションを使用して実装されている場合、背景の変更がアニメーションを損なって修復できなくなり、状態遷移が発生する可能性があります。)</span><span class="sxs-lookup"><span data-stu-id="fad73-226">However, if the hover state is implemented using an animation, changing to background could irreparably break the animation and therefore the state transition.)</span></span>

- <span data-ttu-id="fad73-227">**テーマ スタイルは、すべてのテーマで一貫性のある「レイアウト」セマンティクスを持つ必要はありません**。</span><span class="sxs-lookup"><span data-stu-id="fad73-227">**Theme styles do not need to have consistent "layout" semantics across all themes**.</span></span> <span data-ttu-id="fad73-228">たとえば、既定のスタイルは、コントロールがすべてのテーマで同じ量のサイズを占有することを保証する必要はなく、また、コントロールがすべてのテーマで同じコンテンツの余白/パディングを持つことを保証する必要もありません。</span><span class="sxs-lookup"><span data-stu-id="fad73-228">For example, the default style does not need to guarantee that a control will occupy the same amount of size in all themes or guarantee that a control will have the same content margins / padding across all themes.</span></span>

## <a name="see-also"></a><span data-ttu-id="fad73-229">関連項目</span><span class="sxs-lookup"><span data-stu-id="fad73-229">See also</span></span>

- [<span data-ttu-id="fad73-230">スタイルとテンプレート</span><span class="sxs-lookup"><span data-stu-id="fad73-230">Styling and Templating</span></span>](../../../desktop-wpf/fundamentals/styles-templates-overview.md)
- [<span data-ttu-id="fad73-231">コントロールの作成の概要</span><span class="sxs-lookup"><span data-stu-id="fad73-231">Control Authoring Overview</span></span>](control-authoring-overview.md)
