---
title: パフォーマンスに関する考慮事項 (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 6cd0adb7963b3cfc05fcd6f30d8a7039a50f9485
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/19/2020
ms.locfileid: "77452462"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="42719-102">パフォーマンスに関する考慮事項 (Entity Framework)</span><span class="sxs-lookup"><span data-stu-id="42719-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="42719-103">このトピックでは、ADO.NET Entity Framework のパフォーマンス特性を示し、Entity Framework アプリケーションのパフォーマンスを向上させるために役立つ注意事項について説明します。</span><span class="sxs-lookup"><span data-stu-id="42719-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="42719-104">クエリ実行の段階</span><span class="sxs-lookup"><span data-stu-id="42719-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="42719-105">Entity Framework でのクエリのパフォーマンスをより深く理解するには、概念モデルに対して実行されたクエリがデータをオブジェクトとして返す際の動作を知る必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="42719-106">この一連の動作を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="42719-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="42719-107">操作</span><span class="sxs-lookup"><span data-stu-id="42719-107">Operation</span></span>|<span data-ttu-id="42719-108">相対コスト</span><span class="sxs-lookup"><span data-stu-id="42719-108">Relative Cost</span></span>|<span data-ttu-id="42719-109">頻度</span><span class="sxs-lookup"><span data-stu-id="42719-109">Frequency</span></span>|<span data-ttu-id="42719-110">コメント</span><span class="sxs-lookup"><span data-stu-id="42719-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="42719-111">メタデータの読み込み</span><span class="sxs-lookup"><span data-stu-id="42719-111">Loading metadata</span></span>|<span data-ttu-id="42719-112">中</span><span class="sxs-lookup"><span data-stu-id="42719-112">Moderate</span></span>|<span data-ttu-id="42719-113">各アプリケーション ドメイン内で 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-113">Once in each application domain.</span></span>|<span data-ttu-id="42719-114">Entity Framework が使用するモデルとマッピングのメタデータが、<xref:System.Data.Metadata.Edm.MetadataWorkspace> に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="42719-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="42719-115">このメタデータはグローバルにキャッシュされ、同じアプリケーション ドメイン内にある <xref:System.Data.Objects.ObjectContext> の他のインスタンスも使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="42719-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="42719-116">データベース接続を開く</span><span class="sxs-lookup"><span data-stu-id="42719-116">Opening the database connection</span></span>|<span data-ttu-id="42719-117">中<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="42719-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="42719-118">必要時</span><span class="sxs-lookup"><span data-stu-id="42719-118">As needed.</span></span>|<span data-ttu-id="42719-119">開いているデータベースへの接続によって貴重なリソースが消費されるため、Entity Framework は必要に応じてのみデータベース接続を開き、閉じます。</span><span class="sxs-lookup"><span data-stu-id="42719-119">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="42719-120">接続は、明示的に開くこともできます。</span><span class="sxs-lookup"><span data-stu-id="42719-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="42719-121">詳細については、「[接続とトランザクションの管理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="42719-122">ビューの生成</span><span class="sxs-lookup"><span data-stu-id="42719-122">Generating views</span></span>|<span data-ttu-id="42719-123">高</span><span class="sxs-lookup"><span data-stu-id="42719-123">High</span></span>|<span data-ttu-id="42719-124">各アプリケーション ドメイン内で 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-124">Once in each application domain.</span></span> <span data-ttu-id="42719-125">(事前生成可能)</span><span class="sxs-lookup"><span data-stu-id="42719-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="42719-126">Entity Framework が、概念モデルに対してクエリを実行したり変更内容をデータ ソースに保存したりできるようになるには、データベースにアクセスするためのローカル クエリ ビューのセットを事前に生成しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="42719-127">このビューを生成する際のコストは高いため、デザイン時にビューを事前に作成してプロジェクトに追加しておくことができます。</span><span class="sxs-lookup"><span data-stu-id="42719-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="42719-128">詳細については、「[方法: ビューを事前に生成してクエリのパフォーマンスを向上](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))させる」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="42719-129">クエリの準備</span><span class="sxs-lookup"><span data-stu-id="42719-129">Preparing the query</span></span>|<span data-ttu-id="42719-130">中<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="42719-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="42719-131">各一意のクエリに対して 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-131">Once for each unique query.</span></span>|<span data-ttu-id="42719-132">クエリ コマンドを作成したり、モデルとマッピングのメタデータに基づいてコマンド ツリーを生成したり、返されるデータの形状を定義したりするためのコストが含まれます。</span><span class="sxs-lookup"><span data-stu-id="42719-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="42719-133">Entity SQL と LINQ の両方のクエリ コマンドがキャッシュされるため、同じクエリであれば、後続の実行は短時間で済みます。</span><span class="sxs-lookup"><span data-stu-id="42719-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="42719-134">後続の実行でさらにコストを削減するためにコンパイル済み LINQ クエリを使用でき、コンパイル済みクエリが自動的にキャッシュされる LINQ クエリよりも効率的である場合があります。</span><span class="sxs-lookup"><span data-stu-id="42719-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="42719-135">詳細については、「[コンパイル済みクエリ (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-135">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="42719-136">LINQ クエリの実行に関する一般的な情報については、「 [LINQ to Entities](./language-reference/linq-to-entities.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-136">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="42719-137">**注:** `Enumerable.Contains` 演算子をメモリ内コレクションに適用する LINQ to Entities クエリは、自動的にはキャッシュされません。</span><span class="sxs-lookup"><span data-stu-id="42719-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="42719-138">またコンパイル済み LINQ クエリのメモリ内コレクションをパラメーターで表すことは許可されていません。</span><span class="sxs-lookup"><span data-stu-id="42719-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="42719-139">クエリの実行</span><span class="sxs-lookup"><span data-stu-id="42719-139">Executing the query</span></span>|<span data-ttu-id="42719-140">低<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="42719-140">Low<sup>2</sup></span></span>|<span data-ttu-id="42719-141">各クエリに対して 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-141">Once for each query.</span></span>|<span data-ttu-id="42719-142">ADO.NET データ プロバイダーを使用してデータ ソースに対してコマンドを実行するコスト。</span><span class="sxs-lookup"><span data-stu-id="42719-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="42719-143">大半のデータ ソースではクエリ プランがキャッシュされるため、同じクエリであれば、後続の実行は短時間で済むことがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="42719-144">型の読み込みと検証</span><span class="sxs-lookup"><span data-stu-id="42719-144">Loading and validating types</span></span>|<span data-ttu-id="42719-145">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="42719-145">Low<sup>3</sup></span></span>|<span data-ttu-id="42719-146">各 <xref:System.Data.Objects.ObjectContext> インスタンスに対して 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="42719-147">型が読み込まれ、概念モデルが定義する型に照らし合わせて検証されます。</span><span class="sxs-lookup"><span data-stu-id="42719-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="42719-148">Tracking</span><span class="sxs-lookup"><span data-stu-id="42719-148">Tracking</span></span>|<span data-ttu-id="42719-149">低<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="42719-149">Low<sup>3</sup></span></span>|<span data-ttu-id="42719-150">クエリが返す各オブジェクトに対して 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-150">Once for each object that a query returns.</span></span> <span data-ttu-id="42719-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="42719-151"><sup>4</sup></span></span>|<span data-ttu-id="42719-152">クエリが <xref:System.Data.Objects.MergeOption.NoTracking> のマージ オプションを使用する場合には、この段階でパフォーマンスが低下することはありません。</span><span class="sxs-lookup"><span data-stu-id="42719-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="42719-153">クエリが <xref:System.Data.Objects.MergeOption.AppendOnly>、<xref:System.Data.Objects.MergeOption.PreserveChanges>、または <xref:System.Data.Objects.MergeOption.OverwriteChanges> のいずれかのマージ オプションを使用する場合には、クエリ結果が <xref:System.Data.Objects.ObjectStateManager> で追跡されます。</span><span class="sxs-lookup"><span data-stu-id="42719-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="42719-154">クエリが返す追跡対象の各オブジェクトに対して <xref:System.Data.EntityKey> が生成され、<xref:System.Data.Objects.ObjectStateEntry> に <xref:System.Data.Objects.ObjectStateManager> を作成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="42719-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="42719-155"><xref:System.Data.Objects.ObjectStateEntry> に対応する既存の <xref:System.Data.EntityKey> がある場合には、既存のオブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="42719-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="42719-156"><xref:System.Data.Objects.MergeOption.PreserveChanges> または <xref:System.Data.Objects.MergeOption.OverwriteChanges> オプションが指定されている場合、オブジェクトは更新後に返されます。</span><span class="sxs-lookup"><span data-stu-id="42719-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="42719-157">詳細については、「 [Id 解決、状態管理、および Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="42719-158">オブジェクトの具体化</span><span class="sxs-lookup"><span data-stu-id="42719-158">Materializing the objects</span></span>|<span data-ttu-id="42719-159">中程度<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="42719-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="42719-160">クエリが返す各オブジェクトに対して 1 回</span><span class="sxs-lookup"><span data-stu-id="42719-160">Once for each object that a query returns.</span></span> <span data-ttu-id="42719-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="42719-161"><sup>4</sup></span></span>|<span data-ttu-id="42719-162">返された <xref:System.Data.Common.DbDataReader> オブジェクトを読み取ったり、オブジェクトを作成してプロパティ値を設定したりするプロセス。プロパティ値は、<xref:System.Data.Common.DbDataRecord> クラスの各インスタンスの値に基づきます。</span><span class="sxs-lookup"><span data-stu-id="42719-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="42719-163">オブジェクトが <xref:System.Data.Objects.ObjectContext> に既に存在しており、クエリに <xref:System.Data.Objects.MergeOption.AppendOnly> または <xref:System.Data.Objects.MergeOption.PreserveChanges> マージ オプションが指定されている場合、この段階でパフォーマンスを低下することはありません。</span><span class="sxs-lookup"><span data-stu-id="42719-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="42719-164">詳細については、「 [Id 解決、状態管理、および Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="42719-165"><sup>1</sup>データソースプロバイダーが接続プールを実装する場合、接続を開くコストはプール全体に分散されます。</span><span class="sxs-lookup"><span data-stu-id="42719-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="42719-166">.NET Provider for SQL Server は、接続プールをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="42719-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="42719-167"><sup>2</sup>コストは、クエリの複雑さが増加して増加します。</span><span class="sxs-lookup"><span data-stu-id="42719-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="42719-168"><sup>3</sup>合計コストは、クエリによって返されるオブジェクトの数に比例して増加します。</span><span class="sxs-lookup"><span data-stu-id="42719-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="42719-169"><sup>4</sup>このオーバーヘッドは、entityclient クエリには必要ありません。 entityclient クエリでは、オブジェクトではなく <xref:System.Data.EntityClient.EntityDataReader> が返されるからです。</span><span class="sxs-lookup"><span data-stu-id="42719-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="42719-170">詳細については、「 [Entity Framework 用の EntityClient プロバイダー](entityclient-provider-for-the-entity-framework.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-170">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="42719-171">その他の注意点</span><span class="sxs-lookup"><span data-stu-id="42719-171">Additional Considerations</span></span>  
 <span data-ttu-id="42719-172">Entity Framework アプリケーションのパフォーマンスを低下させる可能性があるその他の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="42719-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="42719-173">クエリの実行</span><span class="sxs-lookup"><span data-stu-id="42719-173">Query Execution</span></span>  
 <span data-ttu-id="42719-174">クエリがリソースを大量に消費することがあるので、コード内のどの個所で、またどのコンピューター上でクエリを実行するのかを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="42719-175">遅延実行と即時実行</span><span class="sxs-lookup"><span data-stu-id="42719-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="42719-176"><xref:System.Data.Objects.ObjectQuery%601> クエリまたは LINQ クエリを作成しても、すぐには実行されないことがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="42719-177">クエリの実行は、結果が必要になるまで遅延されます。たとえば、`foreach` (C#) または `For Each` (Visual Basic) の列挙時や、<xref:System.Collections.Generic.List%601> コレクションに割り当てられた場合などです。</span><span class="sxs-lookup"><span data-stu-id="42719-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="42719-178">クエリがすぐに実行されるのは、<xref:System.Data.Objects.ObjectQuery%601.Execute%2A> 上で <xref:System.Data.Objects.ObjectQuery%601> メソッドが呼び出されたときや、単一クエリを返す LINQ メソッド (<xref:System.Linq.Enumerable.First%2A> や <xref:System.Linq.Enumerable.Any%2A> など) が呼び出されたときです。</span><span class="sxs-lookup"><span data-stu-id="42719-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="42719-179">詳細については、「[オブジェクトクエリ](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100))と[クエリ実行 (LINQ to Entities)](./language-reference/query-execution.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="42719-180">クライアント側での LINQ クエリの実行</span><span class="sxs-lookup"><span data-stu-id="42719-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="42719-181">LINQ クエリの実行は、データ ソースをホストするコンピューター上で行われますが、LINQ クエリは部分的にクライアント コンピューター上で評価されることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="42719-182">詳細については、「[クエリの実行」 (LINQ to Entities)](./language-reference/query-execution.md)のストア実行に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="42719-183">クエリとマッピングの複雑さ</span><span class="sxs-lookup"><span data-stu-id="42719-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="42719-184">個々のクエリの複雑さおよびエンティティ モデルのマッピングの複雑さは、クエリ パフォーマンスに大きな影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="42719-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="42719-185">マッピングの複雑さ</span><span class="sxs-lookup"><span data-stu-id="42719-185">Mapping complexity</span></span>  
 <span data-ttu-id="42719-186">概念モデルのエンティティとストレージ モデルのテーブルとの間で、単純な一対一より複雑なマッピングのモデルは、一対一マッピングのモデルより複雑なコマンドを生成します。</span><span class="sxs-lookup"><span data-stu-id="42719-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="42719-187">クエリの複雑さ</span><span class="sxs-lookup"><span data-stu-id="42719-187">Query complexity</span></span>  
 <span data-ttu-id="42719-188">データソースに対して実行されるコマンド内に多数の結合を必要とするクエリや、データを大量に返すクエリは、次のようにパフォーマンスを低下させることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="42719-189">単純に見える概念モデルに対してクエリを実行したところ、より複雑なクエリをデータ ソースに対して実行する結果になることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="42719-190">これは、Entity Framework が、概念モデルに対するクエリをデータ ソースに対する等価のクエリに変換するからです。</span><span class="sxs-lookup"><span data-stu-id="42719-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="42719-191">概念モデルの 1 つのエンティティ セットが、データ ソースの複数のテーブルにマップされている場合や、エンティティ間のリレーションシップが結合テーブルにマップされている場合には、データ ソース クエリに対して実行されるクエリ コマンドで 1 つ以上の結合が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="42719-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="42719-192">所定のクエリでデータ ソースに対して実行されるコマンドを表示するには、<xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> クラスまたは <xref:System.Data.Objects.ObjectQuery%601> クラスの <xref:System.Data.EntityClient.EntityCommand> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="42719-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="42719-193">詳細については、「[方法: ストアコマンドを表示する](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="42719-194">Entity SQL クエリが入れ子になっていると、サーバー上で結合が作成され、その結果多数の行が返されることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="42719-195">projection 句内の入れ子になったクエリの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="42719-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="42719-196">さらに、このようなクエリでは、入れ子になったクエリ全体でオブジェクトを複製する単一クエリがクエリ パイプラインで生成されます。</span><span class="sxs-lookup"><span data-stu-id="42719-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="42719-197">そのため、1 つの列が複数回複製されることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="42719-198">SQL Server など、一部のデータベースでは、これによって TempDB テーブルのサイズが非常に大きくなり、サーバーのパフォーマンスに悪影響を及ぼす場合があります。</span><span class="sxs-lookup"><span data-stu-id="42719-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="42719-199">入れ子になったクエリを実行するときには、注意を払う必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-199">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="42719-200">クライアントが、結果セットのサイズに比例してリソースを消費するような操作を実行している場合、データを大量に返すクエリを実行すると、パフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="42719-201">このような場合には、クエリによって返されるデータの量を制限することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="42719-202">詳細については、「[方法: クエリ結果をページに表示する](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="42719-203">Entity Framework によって自動的に生成されるコマンドは、データベース開発者が明示的に記述した同様のコマンドより複雑になることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="42719-204">データ ソースに対して実行されるコマンドを明示的に制御する必要がある場合には、テーブル値関数またはストアド プロシージャへのマッピングを定義することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="42719-205">リレーションシップ</span><span class="sxs-lookup"><span data-stu-id="42719-205">Relationships</span></span>  
 <span data-ttu-id="42719-206">クエリのパフォーマンスを最適化するには、エンティティ間のリレーションシップをエンティティ モデル内のアソシエーションとしてだけでなく、データ ソース内の論理リレーションシップとしても定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="42719-207">クエリ パス</span><span class="sxs-lookup"><span data-stu-id="42719-207">Query Paths</span></span>  
 <span data-ttu-id="42719-208">既定では、<xref:System.Data.Objects.ObjectQuery%601> を実行しても、関連オブジェクトは返されません (リレーションシップ自体を表現するオブジェクトが存在する場合でも)。</span><span class="sxs-lookup"><span data-stu-id="42719-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="42719-209">関連オブジェクトは、次の 3 つの方法のいずれかで読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="42719-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="42719-210"><xref:System.Data.Objects.ObjectQuery%601> が実行される前にクエリ パスを設定します。</span><span class="sxs-lookup"><span data-stu-id="42719-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="42719-211">オブジェクトが公開するナビゲーション プロパティに対して `Load` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="42719-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="42719-212"><xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> で <xref:System.Data.Objects.ObjectContext> オプションを `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="42719-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="42719-213">これは、 [Entity Data Model デザイナー](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))を使用してオブジェクトレイヤーコードを生成するときに自動的に実行されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="42719-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="42719-214">詳細については、「[生成されるコードの概要](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="42719-215">使用するオプションを検討する際には、データベースに対する要求数と 1 つのクエリで返されるデータ量の間でのトレードオフに注意してください。</span><span class="sxs-lookup"><span data-stu-id="42719-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="42719-216">詳細については、「[関連オブジェクトの読み込み](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="42719-217">クエリ パスの使用</span><span class="sxs-lookup"><span data-stu-id="42719-217">Using query paths</span></span>  
 <span data-ttu-id="42719-218">クエリ パスは、クエリによって返されるオブジェクトのグラフを定義します。</span><span class="sxs-lookup"><span data-stu-id="42719-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="42719-219">クエリ パスを定義する場合、データベースに対する 1 件の要求だけで、パスによって定義されたすべてのオブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="42719-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="42719-220">クエリ パスを使用すると、見かけ上は簡単なオブジェクト クエリのデータ ソースに対して複雑なコマンドが実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="42719-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="42719-221">これは、1 つのクエリ内の関連オブジェクトを返すには、1 つまたは複数の結合が必要になるために発生します。</span><span class="sxs-lookup"><span data-stu-id="42719-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="42719-222">継承のあるエンティティや多対多のリレーションシップを含んだパスなど、複雑なエンティティ モデルに対してクエリを実行する場合は、さらに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="42719-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="42719-223"><xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> によって生成されるコマンドを表示するには、<xref:System.Data.Objects.ObjectQuery%601> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="42719-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="42719-224">詳細については、「[方法: ストアコマンドを表示する](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="42719-225">クエリ パスに含まれる関連オブジェクトが多すぎる場合や、オブジェクトに含まれる行データが多すぎる場合、データ ソースはクエリを完了できないことがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="42719-226">これは、クエリでデータ ソースの機能を超える中間一時ストレージが必要になる場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="42719-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="42719-227">この場合は、関連オブジェクトを明示的に読み込むと、データ ソース クエリの複雑さを軽減できます。</span><span class="sxs-lookup"><span data-stu-id="42719-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="42719-228">関連オブジェクトの明示的な読み込み</span><span class="sxs-lookup"><span data-stu-id="42719-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="42719-229">`Load` または <xref:System.Data.Objects.DataClasses.EntityCollection%601> を返すナビゲーション プロパティ上で <xref:System.Data.Objects.DataClasses.EntityReference%601> メソッドを呼び出すことによって、関連オブジェクトを明示的に読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="42719-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="42719-230">オブジェクトを明示的に読み込むには、`Load` を呼び出すたびにデータベースへのラウンドトリップが必要になります。</span><span class="sxs-lookup"><span data-stu-id="42719-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="42719-231">`Load` ステートメント (Visual Basic では `foreach`) を使用するときなど、返されたオブジェクトのコレクションをループ処理しながら、`For Each` を呼び出す場合、データ ソース固有のプロバイダーは 1 つの接続で複数のアクティブな結果セットをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="42719-232">SQL Server データベースの場合、プロバイダー接続文字列に `MultipleActiveResultSets = true` の値を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="42719-233">エンティティに <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> プロパティまたは <xref:System.Data.Objects.DataClasses.EntityCollection%601> プロパティがない場合は、<xref:System.Data.Objects.DataClasses.EntityReference%601> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="42719-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="42719-234">これは、POCO エンティティを使用している場合に有効です。</span><span class="sxs-lookup"><span data-stu-id="42719-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="42719-235">関連オブジェクトを明示的に読み込むと、結合の数と冗長データの量が減少しますが、`Load` にはデータベースへの接続が繰り返し必要になります。多数のオブジェクトを明示的に読み込む場合には、高コストになることがあります。</span><span class="sxs-lookup"><span data-stu-id="42719-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="42719-236">変更の保存</span><span class="sxs-lookup"><span data-stu-id="42719-236">Saving Changes</span></span>  
 <span data-ttu-id="42719-237"><xref:System.Data.Objects.ObjectContext.SaveChanges%2A> 上で <xref:System.Data.Objects.ObjectContext> メソッドを呼び出すと、コンテキスト内で追加、更新、または削除された各オブジェクトに対して独立した作成、更新、または削除のコマンドが生成されます。</span><span class="sxs-lookup"><span data-stu-id="42719-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="42719-238">このコマンドは、1 つのトランザクションのデータ ソースで実行されます。</span><span class="sxs-lookup"><span data-stu-id="42719-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="42719-239">クエリの場合と同様に、作成、更新、および削除の操作は、概念モデルのマッピングの複雑さに依存します。</span><span class="sxs-lookup"><span data-stu-id="42719-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="42719-240">分散トランザクション</span><span class="sxs-lookup"><span data-stu-id="42719-240">Distributed Transactions</span></span>  
 <span data-ttu-id="42719-241">明示的トランザクションでの操作で、分散トランザクション コーディネーター (DTC: Distributed Transaction Coordinator) によって管理されるリソースが必要とされることがありますが、このような操作は DTC を必要としない同様の操作より高コストになります。</span><span class="sxs-lookup"><span data-stu-id="42719-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="42719-242">DTC への昇格は、次の状況で発生します。</span><span class="sxs-lookup"><span data-stu-id="42719-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="42719-243">明示的トランザクションを常に DTC に昇格する SQL Server 2000 データベースやその他のデータ ソースに対して、明示的トランザクションで操作を実行する場合。</span><span class="sxs-lookup"><span data-stu-id="42719-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="42719-244">接続が Entity Framework によって管理されている場合に、SQL Server 2005 に対して操作を行う明示的なトランザクション。</span><span class="sxs-lookup"><span data-stu-id="42719-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="42719-245">これは、接続が閉じられ、1つのトランザクション内で再度開かれるたびに (Entity Framework の既定の動作)、SQL Server 2005 が DTC に昇格するために発生します。</span><span class="sxs-lookup"><span data-stu-id="42719-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="42719-246">この DTC 昇格は、SQL Server 2008 使用時には生じません。</span><span class="sxs-lookup"><span data-stu-id="42719-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="42719-247">SQL Server 2005 使用時にこの昇格を回避するには、トランザクション内で接続を明示的に開いて閉じる必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="42719-248">詳細については、「[接続とトランザクションの管理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="42719-249">明示的トランザクションが使用されるのは、1 つの <xref:System.Transactions> トランザクション内で操作を 1 つ以上実行するときです。</span><span class="sxs-lookup"><span data-stu-id="42719-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="42719-250">詳細については、「[接続とトランザクションの管理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="42719-251">パフォーマンスを向上させるための戦略</span><span class="sxs-lookup"><span data-stu-id="42719-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="42719-252">次の戦略を使用すると、Entity Framework でのクエリの全体的なパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="42719-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="42719-253">ビューの事前生成</span><span class="sxs-lookup"><span data-stu-id="42719-253">Pre-generate views</span></span>  
 <span data-ttu-id="42719-254">アプリケーションがクエリを初めて実行する際、エンティティ モデルに基づいたビュー生成は高コストになります。</span><span class="sxs-lookup"><span data-stu-id="42719-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="42719-255">EdmGen.exe ユーティリティを使用して、プロジェクトに追加できる Visual Basic または C# のコード ファイルとして設計時に事前にビューを生成しておきます。</span><span class="sxs-lookup"><span data-stu-id="42719-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="42719-256">テキスト テンプレート変換ツールキットを使用して、事前にコンパイルされたビューを生成することもできます。</span><span class="sxs-lookup"><span data-stu-id="42719-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="42719-257">事前に生成したビューは、現在のバージョンの指定エンティティ モデルに対応することを確認するために、実行時に検証されます。</span><span class="sxs-lookup"><span data-stu-id="42719-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="42719-258">詳細については、「[方法: ビューを事前に生成してクエリのパフォーマンスを向上](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))させる」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="42719-259">サイズが非常に大きいモデルで作業する場合は、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="42719-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="42719-260">.NET メタデータ形式では、特定のバイナリ内のユーザー文字列の数が 16,777,215 (0xFFFFFF) に制限されます。</span><span class="sxs-lookup"><span data-stu-id="42719-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="42719-261">非常に大きなモデルのビューを生成しているときに、ビューファイルがこのサイズ制限に達した場合は、"他のユーザー文字列を作成する論理空間が残っていません" と表示されます。</span><span class="sxs-lookup"><span data-stu-id="42719-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="42719-262">コンパイルエラーです。</span><span class="sxs-lookup"><span data-stu-id="42719-262">compile error.</span></span> <span data-ttu-id="42719-263">このサイズ制限は、すべてのマネージド バイナリに適用されます。</span><span class="sxs-lookup"><span data-stu-id="42719-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="42719-264">詳細については、大規模で複雑なモデルを使用する場合のエラーを回避する方法を示す[ブログ](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-264">For more information see the [blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="42719-265">クエリの NoTracking マージ オプションの使用を検討する</span><span class="sxs-lookup"><span data-stu-id="42719-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="42719-266">オブジェクト コンテキスト内で返されたオブジェクトを追跡するにはコストが生じます。</span><span class="sxs-lookup"><span data-stu-id="42719-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="42719-267">オブジェクトに対する変更内容を検出したり、同じ論理エンティティに対する複数の要求で同じオブジェクト インスタンスが返されるようにするには、オブジェクトを <xref:System.Data.Objects.ObjectContext> インスタンスにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="42719-268">オブジェクトを更新または削除する予定がなく、id 管理を必要としない場合は、クエリの実行時に <xref:System.Data.Objects.MergeOption.NoTracking> マージオプションを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="42719-269">適量のデータを返す</span><span class="sxs-lookup"><span data-stu-id="42719-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="42719-270">シナリオによっては、<xref:System.Data.Objects.ObjectQuery%601.Include%2A> メソッドを使用してクエリ パスを指定する方がはるかに速いことがあります。データベースに対する必要なラウンド トリップ数が減るからです。</span><span class="sxs-lookup"><span data-stu-id="42719-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="42719-271">ただし、他のシナリオでは、関連オブジェクトを読み込むためにデータベースへのラウンド トリップを増やす方が速くなることがあります。これは、クエリが単純で結合数が少ないほど、データの冗長性が低下するからです。</span><span class="sxs-lookup"><span data-stu-id="42719-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="42719-272">したがって、関連オブジェクトを取得するためのさまざまな方法について、パフォーマンスをテストすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="42719-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="42719-273">詳細については、「[関連オブジェクトの読み込み](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="42719-274">1 つのクエリで大量のデータが返されることを回避するには、クエリの結果を扱いやすいサイズのグループに分割してページングすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="42719-275">詳細については、「[方法: クエリ結果をページに表示する](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="42719-276">ObjectContext のスコープを制限する</span><span class="sxs-lookup"><span data-stu-id="42719-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="42719-277">通常は、<xref:System.Data.Objects.ObjectContext> ステートメント (Visual Basic では `using`) 内に `Using…End Using` インスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="42719-278">これにより、パフォーマンスが向上します。これは、コードがステートメント ブロックを終了するときに、オブジェクト コンテキストに関連付けられたリソースが自動的に廃棄されるからです。</span><span class="sxs-lookup"><span data-stu-id="42719-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="42719-279">ただし、オブジェクト コンテキストによって管理されるオブジェクトにコントロールがバインドされている場合、バインドが必要とされる間は <xref:System.Data.Objects.ObjectContext> インスタンスを保持し、手動で廃棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="42719-280">詳細については、「[接続とトランザクションの管理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="42719-281">データベース接続を手動で開くことを検討する</span><span class="sxs-lookup"><span data-stu-id="42719-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="42719-282">アプリケーションで一連のオブジェクトクエリを実行したり、データソースに対する作成、更新、および削除操作を保持するために <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> を頻繁に呼び出す場合、Entity Framework はデータソースへの接続を継続的に開いて閉じる必要があります。</span><span class="sxs-lookup"><span data-stu-id="42719-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="42719-283">このような状況では、操作の開始時に接続を手動で開いて、操作の完了時に接続を手動で閉じるか廃棄することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="42719-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="42719-284">詳細については、「[接続とトランザクションの管理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="42719-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="42719-285">パフォーマンス データ</span><span class="sxs-lookup"><span data-stu-id="42719-285">Performance Data</span></span>  
 <span data-ttu-id="42719-286">Entity Framework の一部のパフォーマンスデータは、 [ADO.NET チームのブログ](https://docs.microsoft.com/archive/blogs/adonet/)の次の投稿で公開されています。</span><span class="sxs-lookup"><span data-stu-id="42719-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://docs.microsoft.com/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="42719-287">ADO.NET Entity Framework のパフォーマンスの調査-パート1</span><span class="sxs-lookup"><span data-stu-id="42719-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="42719-288">ADO.NET Entity Framework のパフォーマンスの調査–パート2</span><span class="sxs-lookup"><span data-stu-id="42719-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="42719-289">ADO.NET Entity Framework のパフォーマンスの比較</span><span class="sxs-lookup"><span data-stu-id="42719-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="42719-290">参照</span><span class="sxs-lookup"><span data-stu-id="42719-290">See also</span></span>

- [<span data-ttu-id="42719-291">開発および配置に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="42719-291">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
