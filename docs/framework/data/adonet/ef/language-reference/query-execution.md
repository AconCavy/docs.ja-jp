---
title: クエリの実行
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c0e6cf23-63ac-47dd-bfe9-d5bdca826fac
ms.openlocfilehash: e372744eea3eed7fc3f7ee9c8bbdd711c95b586e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79149974"
---
# <a name="query-execution"></a><span data-ttu-id="2100b-102">クエリの実行</span><span class="sxs-lookup"><span data-stu-id="2100b-102">Query Execution</span></span>
<span data-ttu-id="2100b-103">ユーザーによって作成された LINQ クエリは、コマンド ツリーに変換されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-103">After a LINQ query is created by a user, it is converted to a command tree.</span></span> <span data-ttu-id="2100b-104">コマンド ツリーは、Entity Framework と互換性のあるクエリの表現です。</span><span class="sxs-lookup"><span data-stu-id="2100b-104">A command tree is a representation of a query that is compatible with the Entity Framework.</span></span> <span data-ttu-id="2100b-105">コマンド ツリーは、その後データ ソースに対して実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-105">The command tree is then executed against the data source.</span></span> <span data-ttu-id="2100b-106">クエリの実行時には、すべてのクエリ式 (つまりクエリの全コンポーネント) が評価されます。これには結果の具体化で使用される式も含まれます。</span><span class="sxs-lookup"><span data-stu-id="2100b-106">At query execution time, all query expressions (that is, all components of the query) are evaluated, including those expressions that are used in result materialization.</span></span>  
  
 <span data-ttu-id="2100b-107">クエリ式が評価されるタイミングはさまざまです。</span><span class="sxs-lookup"><span data-stu-id="2100b-107">At what point query expressions are executed can vary.</span></span> <span data-ttu-id="2100b-108">LINQ クエリは、クエリ変数の作成時ではなく、常にクエリ変数の反復処理時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-108">LINQ queries are always executed when the query variable is iterated over, not when the query variable is created.</span></span> <span data-ttu-id="2100b-109">これを*遅延実行*と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="2100b-109">This is called *deferred execution*.</span></span> <span data-ttu-id="2100b-110">クエリを即時に実行することもできます。これは、クエリの結果をキャッシュする場合に有効です。</span><span class="sxs-lookup"><span data-stu-id="2100b-110">You can also force a query to execute immediately, which is useful for caching query results.</span></span> <span data-ttu-id="2100b-111">このことについては、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="2100b-111">This is described later in this topic.</span></span>  
  
 <span data-ttu-id="2100b-112">LINQ to Entities クエリを実行すると、クエリ内の一部の式がサーバー上で実行され、別の一部の式がクライアント上でローカルに実行される場合があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-112">When a LINQ to Entities query is executed, some expressions in the query might be executed on the server and some parts might be executed locally on the client.</span></span> <span data-ttu-id="2100b-113">クライアント側での式の評価は、サーバー上でクエリが実行される前に行われます。</span><span class="sxs-lookup"><span data-stu-id="2100b-113">Client-side evaluation of an expression takes place before the query is executed on the server.</span></span> <span data-ttu-id="2100b-114">式がクライアント上で評価される場合、クエリ内の式がその評価の結果に置き換えられた後、サーバー上でクエリが実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-114">If an expression is evaluated on the client, the result of that evaluation is substituted for the expression in the query, and the query is then executed on the server.</span></span> <span data-ttu-id="2100b-115">クエリはデータ ソースに対して実行されるため、クライアントで指定された動作よりもデータ ソースの構成がオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="2100b-115">Because queries are executed on the data source, the data source configuration overrides the behavior specified in the client.</span></span> <span data-ttu-id="2100b-116">たとえば、Null 値の処理方法や、数値の有効桁数などはサーバーの設定によって異なります。</span><span class="sxs-lookup"><span data-stu-id="2100b-116">For example, null value handling and numerical precision depend on the server settings.</span></span> <span data-ttu-id="2100b-117">クエリの実行中にサーバーに対してスローされた例外は、クライアントに直接渡されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-117">Any exceptions thrown during query execution on the server are passed directly up to the client.</span></span>  

> [!TIP]
> <span data-ttu-id="2100b-118">テーブル形式のクエリ演算子の簡単な概要については、「[実行方法による標準クエリ演算子の分類 (C#)」](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2100b-118">For a convenient summary of query operators in table format, which lets you quickly identify an operator's execution behavior, see [Classification of Standard Query Operators by Manner of Execution (C#)](../../../../../csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution.md).</span></span>

## <a name="deferred-query-execution"></a><span data-ttu-id="2100b-119">クエリの遅延実行</span><span class="sxs-lookup"><span data-stu-id="2100b-119">Deferred query execution</span></span>  
 <span data-ttu-id="2100b-120">一連の値を返すクエリでは、クエリ変数そのものはクエリ結果を保持しません。クエリ変数には、クエリのコマンドが格納されるだけです。</span><span class="sxs-lookup"><span data-stu-id="2100b-120">In a query that returns a sequence of values, the query variable itself never holds the query results and only stores the query commands.</span></span> <span data-ttu-id="2100b-121">クエリ変数が `foreach` ループまたは `For Each` ループで反復処理されるまで、クエリは実行されません。</span><span class="sxs-lookup"><span data-stu-id="2100b-121">Execution of the query is deferred until the query variable is iterated over in a `foreach` or `For Each` loop.</span></span> <span data-ttu-id="2100b-122">これは*遅延実行*と呼ばれます。つまり、クエリの構築後しばらくしてクエリが実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-122">This is known as *deferred execution*; that is, query execution occurs some time after the query is constructed.</span></span> <span data-ttu-id="2100b-123">これは、任意のタイミングでクエリを実行できるということを意味します。</span><span class="sxs-lookup"><span data-stu-id="2100b-123">This means that you can execute a query as frequently as you want to.</span></span> <span data-ttu-id="2100b-124">これは、たとえば他のアプリケーションによって更新されるデータベースがある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="2100b-124">This is useful when, for example, you have a database that is being updated by other applications.</span></span> <span data-ttu-id="2100b-125">アプリケーションで、最新情報を取得するクエリを作成し、それを繰り返し実行することにより、更新のたびに最新の情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="2100b-125">In your application, you can create a query to retrieve the latest information and repeatedly execute the query, returning the updated information every time.</span></span>  
  
 <span data-ttu-id="2100b-126">遅延実行により、複数のクエリを組み合わせたり、クエリを拡張したりすることが可能となります。</span><span class="sxs-lookup"><span data-stu-id="2100b-126">Deferred execution enables multiple queries to be combined or a query to be extended.</span></span> <span data-ttu-id="2100b-127">クエリを拡張して新しい操作を追加すると、その変更が最終的な実行時に反映されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-127">When a query is extended, it is modified to include the new operations, and the eventual execution will reflect the changes.</span></span> <span data-ttu-id="2100b-128">次の例の最初のクエリでは、すべての製品が返されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-128">In the following example, the first query returns all the products.</span></span> <span data-ttu-id="2100b-129">2 つ目のクエリでは、サイズが "L" のすべての製品を返すように、`Where` を使って 1 つ目のクエリを拡張しています。</span><span class="sxs-lookup"><span data-stu-id="2100b-129">The second query extends the first by using `Where` to return all the products of size "L":</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#composing1)]
 [!code-vb[DP L2E Conceptual Examples#Composing1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#composing1)]  
  
 <span data-ttu-id="2100b-130">クエリが実行された後、後続のすべてのクエリでメモリ内の LINQ 演算子が使用されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-130">After a query has been executed all successive queries will use the in-memory LINQ operators.</span></span> <span data-ttu-id="2100b-131">`foreach` ステートメントや `For Each` ステートメントを使用することによって、または LINQ 変換演算子の 1 つを呼び出すことによって、クエリ変数を反復処理すると、即時実行が発生します。</span><span class="sxs-lookup"><span data-stu-id="2100b-131">Iterating over the query variable by using a `foreach` or `For Each` statement or by calling one of the LINQ conversion operators will cause immediate execution.</span></span> <span data-ttu-id="2100b-132">これらの変換演算子には、<xref:System.Linq.Enumerable.ToList%2A>、<xref:System.Linq.Enumerable.ToArray%2A>、<xref:System.Linq.Enumerable.ToLookup%2A>、<xref:System.Linq.Enumerable.ToDictionary%2A> などがあります。</span><span class="sxs-lookup"><span data-stu-id="2100b-132">These conversion operators include the following: <xref:System.Linq.Enumerable.ToList%2A>, <xref:System.Linq.Enumerable.ToArray%2A>, <xref:System.Linq.Enumerable.ToLookup%2A>, and <xref:System.Linq.Enumerable.ToDictionary%2A>.</span></span>  
  
## <a name="immediate-query-execution"></a><span data-ttu-id="2100b-133">クエリの即時実行</span><span class="sxs-lookup"><span data-stu-id="2100b-133">Immediate Query Execution</span></span>  
 <span data-ttu-id="2100b-134">一連の値を生成するクエリの遅延実行とは対照的に、シングルトン値を返すクエリは直ちに実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-134">In contrast to the deferred execution of queries that produce a sequence of values, queries that return a singleton value are executed immediately.</span></span> <span data-ttu-id="2100b-135">シングルトン クエリの例としては、<xref:System.Linq.Enumerable.Average%2A>、<xref:System.Linq.Enumerable.Count%2A>、<xref:System.Linq.Enumerable.First%2A>、<xref:System.Linq.Enumerable.Max%2A> があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-135">Some examples of singleton queries are <xref:System.Linq.Enumerable.Average%2A>, <xref:System.Linq.Enumerable.Count%2A>, <xref:System.Linq.Enumerable.First%2A>, and <xref:System.Linq.Enumerable.Max%2A>.</span></span> <span data-ttu-id="2100b-136">これらのシングルトン クエリは、結果を計算するためにはシーケンスを生成する必要があるため、直ちに実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-136">These execute immediately because the query must produce a sequence to calculate the singleton result.</span></span> <span data-ttu-id="2100b-137">即時実行は強制することもできます。</span><span class="sxs-lookup"><span data-stu-id="2100b-137">You can also force immediate execution.</span></span> <span data-ttu-id="2100b-138">これはクエリの結果をキャッシュする場合などに便利です。</span><span class="sxs-lookup"><span data-stu-id="2100b-138">This is useful when you want to cache the results of a query.</span></span> <span data-ttu-id="2100b-139">クエリまたはクエリ変数で <xref:System.Linq.Enumerable.ToList%2A> メソッド、<xref:System.Linq.Enumerable.ToDictionary%2A> メソッド、または <xref:System.Linq.Enumerable.ToArray%2A> メソッドを呼び出すと、シングルトン値を生成しないクエリの即時実行を強制できます。</span><span class="sxs-lookup"><span data-stu-id="2100b-139">To force immediate execution of a query that does not produce a singleton value, you can call the <xref:System.Linq.Enumerable.ToList%2A> method, the <xref:System.Linq.Enumerable.ToDictionary%2A> method, or the <xref:System.Linq.Enumerable.ToArray%2A> method on a query or query variable.</span></span> <span data-ttu-id="2100b-140">次の例では、<xref:System.Linq.Enumerable.ToArray%2A> メソッドを使用して、シーケンスを配列として即時評価します。</span><span class="sxs-lookup"><span data-stu-id="2100b-140">The following example uses the <xref:System.Linq.Enumerable.ToArray%2A> method to immediately evaluate a sequence into an array.</span></span>  
  
 [!code-csharp[DP L2E Examples#ToArray](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Examples/CS/Program.cs#toarray)]
 [!code-vb[DP L2E Examples#ToArray](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Examples/VB/Module1.vb#toarray)]  
  
 <span data-ttu-id="2100b-141">また、`foreach` ループまたは `For Each` ループをクエリ式の直後に配置して実行を強制することも、<xref:System.Linq.Enumerable.ToList%2A> または <xref:System.Linq.Enumerable.ToArray%2A> を呼び出すことにより、単一のコレクション オブジェクト内のすべてのデータをキャッシュすることにより、実行を強制することもできます。</span><span class="sxs-lookup"><span data-stu-id="2100b-141">You could also force execution by putting the `foreach` or `For Each` loop immediately after the query expression, but by calling <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> you cache all the data in a single collection object.</span></span>  
  
## <a name="store-execution"></a><span data-ttu-id="2100b-142">ストア実行</span><span class="sxs-lookup"><span data-stu-id="2100b-142">Store Execution</span></span>  
 <span data-ttu-id="2100b-143">一般的に、LINQ to Entities の式はサーバー上で評価されるため、式の動作がデータ ソースのセマンティクスではなく、共通言語ランタイム (CLR) セマンティクスに従っているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="2100b-143">In general, expressions in LINQ to Entities are evaluated on the server, and the behavior of the expression should not be expected to follow common language runtime (CLR) semantics, but those of the data source.</span></span> <span data-ttu-id="2100b-144">ただし、これには式がクライアント上で実行された場合などの例外があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-144">There are exceptions to this, however, such as when the expression is executed on the client.</span></span> <span data-ttu-id="2100b-145">これは、サーバーとクライアントが異なるタイム ゾーンに存在する場合など、予期しない結果をもたらすことがあります。</span><span class="sxs-lookup"><span data-stu-id="2100b-145">This could cause unexpected results, for example when the server and client are in different time zones.</span></span>  
  
 <span data-ttu-id="2100b-146">クエリ内の一部の式はクライアント上で実行される場合があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-146">Some expressions in the query might be executed on the client.</span></span> <span data-ttu-id="2100b-147">通常、ほとんどのクエリ実行はサーバーで発生するものと見なされます。</span><span class="sxs-lookup"><span data-stu-id="2100b-147">In general, most query execution is expected to occur on the server.</span></span> <span data-ttu-id="2100b-148">データ ソースにマップされたクエリ要素に対して実行されたメソッドの他に、クエリにはローカルで実行できる式が含まれる場合がよくあります。</span><span class="sxs-lookup"><span data-stu-id="2100b-148">Aside from methods executed against query elements mapped to the data source, there are often expressions in the query that can be executed locally.</span></span> <span data-ttu-id="2100b-149">クエリ式のローカルでの実行では、クエリ実行または結果の作成で使用できる値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-149">Local execution of a query expression yields a value that can be used in the query execution or result construction.</span></span>  
  
 <span data-ttu-id="2100b-150">値のバインド、サブ式、終了からのサブクエリ、およびクエリ結果へのオブジェクトの具体化などの特定の操作は、常にクライアントで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-150">Certain operations are always executed on the client, such as binding of values, sub expressions, sub queries from closures, and materialization of objects into query results.</span></span> <span data-ttu-id="2100b-151">その最終的な結果として、これらの要素 (パラメーター値など) は実行中には更新できなくなります。</span><span class="sxs-lookup"><span data-stu-id="2100b-151">The net effect of this is that these elements (for example, parameter values) cannot be updated during the execution.</span></span> <span data-ttu-id="2100b-152">匿名型は、データ ソースでインラインで作成できますが、必ずしもそれを想定することはできません。</span><span class="sxs-lookup"><span data-stu-id="2100b-152">Anonymous types can be constructed inline on the data source, but should not be assumed to do so.</span></span> <span data-ttu-id="2100b-153">インラインのグループはデータ ソースでも作成できますが、すべてのインスタンスでそれが可能であると見なすことはできません。</span><span class="sxs-lookup"><span data-stu-id="2100b-153">Inline groupings can be constructed in the data source, as well, but this should not be assumed in every instance.</span></span> <span data-ttu-id="2100b-154">通常、サーバー上で何を作成できるかについて想定しないことが賢明です。</span><span class="sxs-lookup"><span data-stu-id="2100b-154">In general, it is best not to make any assumptions about what is constructed on the server.</span></span>  
  
 <span data-ttu-id="2100b-155">このセクションでは、コードをクライアント上でローカルに実行するシナリオについて説明します。</span><span class="sxs-lookup"><span data-stu-id="2100b-155">This section describes the scenarios in which code is executed locally on the client.</span></span> <span data-ttu-id="2100b-156">ローカルで実行される式の種類の詳細については、「 [LINQ to Entities クエリの式](expressions-in-linq-to-entities-queries.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2100b-156">For more information about which types of expressions are executed locally, see [Expressions in LINQ to Entities Queries](expressions-in-linq-to-entities-queries.md).</span></span>  
  
### <a name="literals-and-parameters"></a><span data-ttu-id="2100b-157">リテラルとパラメーター</span><span class="sxs-lookup"><span data-stu-id="2100b-157">Literals and Parameters</span></span>  
 <span data-ttu-id="2100b-158">次の例に示した `orderID` 変数などのローカル変数は、クライアントで評価されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-158">Local variables, such as the `orderID` variable in the following example, are evaluated on the client.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#literalparameter1)]
 [!code-vb[DP L2E Conceptual Examples#LiteralParameter1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#literalparameter1)]  
  
 <span data-ttu-id="2100b-159">メソッド パラメーターもクライアントで評価されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-159">Method parameters are also evaluated on the client.</span></span> <span data-ttu-id="2100b-160">下の `orderID` メソッドに渡される `MethodParameterExample` パラメーターがその例です。</span><span class="sxs-lookup"><span data-stu-id="2100b-160">The `orderID` parameter passed into the `MethodParameterExample` method, below, is an example.</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#methodparameterexample)]
 [!code-vb[DP L2E Conceptual Examples#MethodParameterExample](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#methodparameterexample)]  
  
### <a name="casting-literals-on-the-client"></a><span data-ttu-id="2100b-161">クライアントでのリテラルのキャスト</span><span class="sxs-lookup"><span data-stu-id="2100b-161">Casting Literals on the Client</span></span>  
 <span data-ttu-id="2100b-162">`null` から CLR 型へのキャストは、次のようにクライアントで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-162">Casting from `null` to a CLR type is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#nullcasttostring)]
 [!code-vb[DP L2E Conceptual Examples#NullCastToString](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#nullcasttostring)]  
  
 <span data-ttu-id="2100b-163">Null 値が許容される <xref:System.Decimal> などの型へのキャストは、次のようにクライアントで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-163">Casting to a type, such as a nullable <xref:System.Decimal>, is executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#casttonullable)]
 [!code-vb[DP L2E Conceptual Examples#CastToNullable](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#casttonullable)]  
  
### <a name="constructors-for-literals"></a><span data-ttu-id="2100b-164">リテラルのコンストラクター</span><span class="sxs-lookup"><span data-stu-id="2100b-164">Constructors for Literals</span></span>  
 <span data-ttu-id="2100b-165">概念モデル型にマップできる新しい CLR 型は、次のようにクライアントで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-165">New CLR types that can be mapped to conceptual model types are executed on the client:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#constructorforliteral)]
 [!code-vb[DP L2E Conceptual Examples#ConstructorForLiteral](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#constructorforliteral)]  
  
 <span data-ttu-id="2100b-166">新しい配列もクライアントで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-166">New arrays are also executed on the client.</span></span>  
  
## <a name="store-exceptions"></a><span data-ttu-id="2100b-167">ストアの例外</span><span class="sxs-lookup"><span data-stu-id="2100b-167">Store Exceptions</span></span>  
 <span data-ttu-id="2100b-168">クエリ実行時に発生したストア エラーはすべてクライアントに渡され、マッピングも処理もされません。</span><span class="sxs-lookup"><span data-stu-id="2100b-168">Any store errors that are encountered during query execution are passed up to the client, and are not mapped or handled.</span></span>  
  
## <a name="store-configuration"></a><span data-ttu-id="2100b-169">ストアの構成</span><span class="sxs-lookup"><span data-stu-id="2100b-169">Store Configuration</span></span>  
 <span data-ttu-id="2100b-170">ストアでクエリが実行される場合、ストアの構成はすべてのクライアント動作をオーバーライドし、ストア セマンティクスはすべての演算および式で表現されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-170">When the query executes on the store, the store configuration overrides all client behaviors, and store semantics are expressed for all operations and expressions.</span></span> <span data-ttu-id="2100b-171">これにより、Null 比較、GUID 順序付け、precise 以外のデータ型 (浮動小数点型や <xref:System.DateTime> など) を含む演算の精度や正確性、および文字列型演算などの領域において、CLR とストアの実行間で違いが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-171">This can result in a difference in behavior between CLR and store execution in areas such as null comparisons, GUID ordering, precision and accuracy of operations involving non-precise data types (such as floating point types or <xref:System.DateTime>), and string operations.</span></span> <span data-ttu-id="2100b-172">クエリ結果を調べる場合にはこのことに留意することが重要です。</span><span class="sxs-lookup"><span data-stu-id="2100b-172">It is important to keep this in mind when examining query results.</span></span>  
  
 <span data-ttu-id="2100b-173">CLR および SQL Server 間での動作の違いの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="2100b-173">For example, the following are some differences in behavior between the CLR and SQL Server:</span></span>  
  
- <span data-ttu-id="2100b-174">SQL Server は CLR とは異なる方法で GUID を順序付けます。</span><span class="sxs-lookup"><span data-stu-id="2100b-174">SQL Server orders GUIDs differently than the CLR.</span></span>  
  
- <span data-ttu-id="2100b-175">SQL Server で Decimal 型を扱う場合は、結果の精度でも差違が発生する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="2100b-175">There can also be differences in result precision when dealing with the Decimal type on SQL Server.</span></span> <span data-ttu-id="2100b-176">これは、SQL Server の decimal 型の固定有効桁数の要件によります。</span><span class="sxs-lookup"><span data-stu-id="2100b-176">This is due to the fixed precision requirements of the SQL Server decimal type.</span></span> <span data-ttu-id="2100b-177">たとえば、<xref:System.Decimal> 値 0.0、0.0、および 1.0 の平均は、クライアント上のメモリでは 0.3333333333333333333333333333 ですが、ストアでは 0.333333 です (SQL Server の decimal 型の既定の有効桁数に基づきます)。</span><span class="sxs-lookup"><span data-stu-id="2100b-177">For example, the average of <xref:System.Decimal> values 0.0, 0.0, and 1.0 is 0.3333333333333333333333333333 in memory on the client, but 0.333333 in the store (based on the default precision for SQL Server’s decimal type).</span></span>  
  
- <span data-ttu-id="2100b-178">SQL Server では、一部の文字列比較演算も CLR とは異なった方法で処理されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-178">Some string comparison operations are also handled differently in SQL Server than in the CLR.</span></span> <span data-ttu-id="2100b-179">文字列比較の動作は、サーバー上の照合順序の設定によって異なります。</span><span class="sxs-lookup"><span data-stu-id="2100b-179">String comparison behavior depends on the collation settings on the server.</span></span>  
  
- <span data-ttu-id="2100b-180">LINQ to Entities クエリに含まれる関数呼び出しまたはメソッド呼び出しは、Entity Framework の正規関数にマップされ、その後 Transact-SQL に変換され、SQL Server データベースで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-180">Function or method calls, when included in a LINQ to Entities query, are mapped to canonical functions in the Entity Framework, which are then translated to Transact-SQL and executed on the SQL Server database.</span></span> <span data-ttu-id="2100b-181">マップされたこれらの関数が表す動作は、基本クラス ライブラリでの実装とは異なる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="2100b-181">There are cases when the behavior these mapped functions exhibit might differ from the implementation in the base class libraries.</span></span> <span data-ttu-id="2100b-182">たとえば、空の文字列をパラメーターとして <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A> メソッドおよび <xref:System.String.EndsWith%2A> メソッドを呼び出すと、CLR での実行では `true` が返されますが、SQL Server での実行では `false` が返されます。</span><span class="sxs-lookup"><span data-stu-id="2100b-182">For example, calling the <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.EndsWith%2A> methods with an empty string as a parameter will return `true` when executed in the CLR, but will return `false` when executed in SQL Server.</span></span> <span data-ttu-id="2100b-183">また、末尾の空白のみが異なる 2 つの文字列は SQL Server では同じと見なされますが、CLR では同じではないと見なされるため、<xref:System.String.EndsWith%2A> メソッドは、異なる結果を返す場合があります。</span><span class="sxs-lookup"><span data-stu-id="2100b-183">The <xref:System.String.EndsWith%2A> method can also return different results because SQL Server considers two strings to be equal if they only differ in trailing white space, whereas the CLR considers them to be not equal.</span></span> <span data-ttu-id="2100b-184">この例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="2100b-184">This is illustrated by the following example:</span></span>  
  
 [!code-csharp[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DP L2E Conceptual Examples/CS/Program.cs#canonicalfuncvsclrbasetype)]
 [!code-vb[DP L2E Conceptual Examples#CanonicalFuncVsCLRBaseType](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DP L2E Conceptual Examples/VB/Module1.vb#canonicalfuncvsclrbasetype)]
