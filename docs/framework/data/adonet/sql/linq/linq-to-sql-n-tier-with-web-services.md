---
title: Web サービスを使用した LINQ to SQL N 層
ms.date: 03/30/2017
ms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2
ms.openlocfilehash: 7a52c17c58df24235a5691c84df159dbea3a8d25
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/03/2020
ms.locfileid: "75634587"
---
# <a name="linq-to-sql-n-tier-with-web-services"></a><span data-ttu-id="34e66-102">Web サービスを使用した LINQ to SQL N 層</span><span class="sxs-lookup"><span data-stu-id="34e66-102">LINQ to SQL N-Tier with Web Services</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="34e66-103">は、特に Web サービスなどの疎結合データアクセス層 (DAL) の中間層で使用するために設計されています。</span><span class="sxs-lookup"><span data-stu-id="34e66-103">is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service.</span></span> <span data-ttu-id="34e66-104">プレゼンテーション層が ASP.NET Web ページである場合、中間層の <xref:System.Web.UI.WebControls.LinqDataSource> とユーザー インターフェイスとのデータ転送を管理するために [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] Web サーバー コントロールを使用します。</span><span class="sxs-lookup"><span data-stu-id="34e66-104">If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier.</span></span> <span data-ttu-id="34e66-105">プレゼンテーション層が ASP.NET ページでない場合には、中間層とプレゼンテーション層の両方で、データのシリアル化と逆シリアル化を管理するための追加の操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="34e66-105">If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.</span></span>  
  
## <a name="setting-up-linq-to-sql-on-the-middle-tier"></a><span data-ttu-id="34e66-106">中間層での LINQ to SQL のセットアップ</span><span class="sxs-lookup"><span data-stu-id="34e66-106">Setting up LINQ to SQL on the Middle Tier</span></span>  
 <span data-ttu-id="34e66-107">Web サービスまたは n 層アプリケーションでは、中間層にデータ コンテキストおよびエンティティのクラスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="34e66-107">In a Web service or n-tier application, the middle tier contains the data context and the entity classes.</span></span> <span data-ttu-id="34e66-108">これらのクラスは、ドキュメントの他の部分で説明されているように、手動で作成することも、SQLMetal またはオブジェクトリレーショナルデザイナーを使用して作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="34e66-108">You can create these classes manually, or by using either SQLMetal.exe or the Object Relational Designer as described elsewhere in the documentation.</span></span> <span data-ttu-id="34e66-109">オプションとして、デザイン時にエンティティ クラスをシリアル化可能にすることができます。</span><span class="sxs-lookup"><span data-stu-id="34e66-109">At design time, you have the option to make the entity classes serializable.</span></span> <span data-ttu-id="34e66-110">詳細については、「[方法: エンティティをシリアル化できるようにする](how-to-make-entities-serializable.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="34e66-110">For more information, see [How to: Make Entities Serializable](how-to-make-entities-serializable.md).</span></span> <span data-ttu-id="34e66-111">別の方法として、シリアル化するデータをカプセル化するクラスのセットを個別に作成し、LINQ クエリでデータを返すときにそれらのシリアル化可能な型に射影する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="34e66-111">Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your LINQ queries.</span></span>  
  
 <span data-ttu-id="34e66-112">その後、データの取得、挿入、更新のためにクライアントが呼び出すメソッドを持つインターフェイスを定義します。</span><span class="sxs-lookup"><span data-stu-id="34e66-112">You then define the interface with the methods that the clients will call to retrieve, insert and update data.</span></span> <span data-ttu-id="34e66-113">インターフェイスメソッドは、LINQ クエリをラップします。</span><span class="sxs-lookup"><span data-stu-id="34e66-113">The interface methods wrap your LINQ queries.</span></span> <span data-ttu-id="34e66-114">任意のシリアル化技法を使って、リモート メソッド呼び出しとデータのシリアル化を扱うことができます。</span><span class="sxs-lookup"><span data-stu-id="34e66-114">You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data.</span></span> <span data-ttu-id="34e66-115">唯一の要件として、たとえば標準の Northwind オブジェクト モデルにおける Customers と Orders のように、循環型または双方向のリレーションシップがオブジェクト モデルに存在する場合は、それをサポートするシリアライザーを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="34e66-115">The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it.</span></span> <span data-ttu-id="34e66-116">Windows Communication Foundation (WCF) の <xref:System.Runtime.Serialization.DataContractSerializer> は双方向リレーションシップをサポートしますが、WCF 以外の Web サービスで使用される XmlSerializer はこれをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="34e66-116">The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not.</span></span> <span data-ttu-id="34e66-117">XmlSerializer の使用を選択する場合には、オブジェクト モデルに循環型リレーションシップが存在しないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="34e66-117">If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.</span></span>  
  
 <span data-ttu-id="34e66-118">Windows Communication Foundation の詳細については、「 [Visual Studio でのサービスと WCF Data Services の Windows Communication Foundation](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="34e66-118">For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).</span></span>  
  
 <span data-ttu-id="34e66-119">ビジネス ルールまたは他のドメイン固有のロジックを実装するために、<xref:System.Data.Linq.DataContext> 上の部分クラスとメソッド、およびエンティティ クラスを使用して [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] ランタイム イベント内にフックします。</span><span class="sxs-lookup"><span data-stu-id="34e66-119">Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events.</span></span> <span data-ttu-id="34e66-120">詳細については、「 [N 層ビジネスロジックの実装](implementing-business-logic-linq-to-sql.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="34e66-120">For more information, see [Implementing N-Tier Business Logic](implementing-business-logic-linq-to-sql.md).</span></span>  
  
## <a name="defining-the-serializable-types"></a><span data-ttu-id="34e66-121">シリアル化可能な型の定義</span><span class="sxs-lookup"><span data-stu-id="34e66-121">Defining the Serializable Types</span></span>  
 <span data-ttu-id="34e66-122">クライアントまたはプレゼンテーション層には、中間層から受け取るクラスについての型定義が必要です。</span><span class="sxs-lookup"><span data-stu-id="34e66-122">The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier.</span></span> <span data-ttu-id="34e66-123">これらの型は、それ自体、エンティティ クラスにすることも可能です。または、リモート処理用にエンティティ クラスのいくつかのフィールドだけをラップする特殊クラスにすることも可能です。</span><span class="sxs-lookup"><span data-stu-id="34e66-123">Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting.</span></span> <span data-ttu-id="34e66-124">どのような場合でも、[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] は、プレゼンテーション層がこれらの型定義をどのように取得するかを完全には考慮しません。</span><span class="sxs-lookup"><span data-stu-id="34e66-124">In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions.</span></span> <span data-ttu-id="34e66-125">たとえば、プレゼンテーション層は、WCF を使用して型を自動生成する場合があります。または、型が定義されている DLL のコピーを持っている場合や、単に独自の型を定義する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="34e66-125">For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.</span></span>  
  
## <a name="retrieving-and-inserting-data"></a><span data-ttu-id="34e66-126">データの取得と挿入</span><span class="sxs-lookup"><span data-stu-id="34e66-126">Retrieving and Inserting Data</span></span>  
 <span data-ttu-id="34e66-127">中間層は、プレゼンテーション層がデータにアクセスする方法を指定するインターフェイスを定義します。</span><span class="sxs-lookup"><span data-stu-id="34e66-127">The middle tier defines an interface that specifies how the presentation tier accesses the data.</span></span> <span data-ttu-id="34e66-128">たとえば `GetProductByID(int productID)`、`GetCustomers()` などです。</span><span class="sxs-lookup"><span data-stu-id="34e66-128">For example `GetProductByID(int productID)`, or `GetCustomers()`.</span></span> <span data-ttu-id="34e66-129">中間層では、通常、メソッド本体が <xref:System.Data.Linq.DataContext> の新しいインスタンスを作成し、1 つ以上のテーブルに対するクエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="34e66-129">On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table.</span></span> <span data-ttu-id="34e66-130">その後、中間層は <xref:System.Collections.Generic.IEnumerable%601> として結果を返します。`T` は、エンティティ クラス、またはシリアル化で使用される他の型です。</span><span class="sxs-lookup"><span data-stu-id="34e66-130">The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization.</span></span> <span data-ttu-id="34e66-131">プレゼンテーション層は、中間層との間でクエリ変数を直接やり取りすることはありません。</span><span class="sxs-lookup"><span data-stu-id="34e66-131">The presentation tier never sends or receives query variables directly to or from the middle tier.</span></span> <span data-ttu-id="34e66-132">2 つの層は、値、オブジェクト、および具象データのコレクションをやり取りします。</span><span class="sxs-lookup"><span data-stu-id="34e66-132">The two tiers exchange values, objects, and collections of concrete data.</span></span> <span data-ttu-id="34e66-133">コレクションを受け取った後、プレゼンテーション層は LINQ to Objects を使用して必要に応じてクエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="34e66-133">After it has received a collection, the presentation tier can use LINQ to Objects to query it if necessary.</span></span>  
  
 <span data-ttu-id="34e66-134">データの挿入時に、プレゼンテーション層は新しいオブジェクトを構築して中間層にそれを送ることができます。または、プレゼンテーション層から渡される値に基づいて中間層にオブジェクトを構築させることもできます。</span><span class="sxs-lookup"><span data-stu-id="34e66-134">When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides.</span></span> <span data-ttu-id="34e66-135">一般的に、n 層アプリケーションでのデータの取得と挿入は、2 層アプリケーションでの処理と似ています。</span><span class="sxs-lookup"><span data-stu-id="34e66-135">In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications.</span></span> <span data-ttu-id="34e66-136">詳細については、「[データベースのクエリ](querying-the-database.md)」および「[データ変更の作成と送信](making-and-submitting-data-changes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="34e66-136">For more information, see [Querying the Database](querying-the-database.md) and [Making and Submitting Data Changes](making-and-submitting-data-changes.md).</span></span>  
  
## <a name="tracking-changes-for-updates-and-deletes"></a><span data-ttu-id="34e66-137">更新と削除における変更内容の追跡</span><span class="sxs-lookup"><span data-stu-id="34e66-137">Tracking Changes for Updates and Deletes</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="34e66-138">は、タイムスタンプ (RowVersion ともいう) および元の値に基づくオプティミスティック コンカレンシーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="34e66-138">supports optimistic concurrency based on timestamps (also named RowVersions) and on original values.</span></span> <span data-ttu-id="34e66-139">データベース テーブルにタイムスタンプが存在すると、更新と削除のために、中間層とプレゼンテーション層で実行する必要のある追加の処理はあまりありません。</span><span class="sxs-lookup"><span data-stu-id="34e66-139">If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier.</span></span> <span data-ttu-id="34e66-140">しかし、元の値を使ってオプティミスティック コンカレンシー チェックを行う必要がある場合には、プレゼンテーション層はこれらの値を追跡して、更新時にそれを送り返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="34e66-140">However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates.</span></span> <span data-ttu-id="34e66-141">これは、プレゼンテーション層上のエンティティに対する変更内容が中間層で追跡されないためです。</span><span class="sxs-lookup"><span data-stu-id="34e66-141">This is because changes that were made to entities on the presentation tier are not tracked on the middle tier.</span></span> <span data-ttu-id="34e66-142">実際、エンティティの最初の取得とその後の更新は、通常、<xref:System.Data.Linq.DataContext> のまったく別の 2 つのインスタンスによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="34e66-142">In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>.</span></span>  
  
 <span data-ttu-id="34e66-143">プレゼンテーション層での変更箇所が多いほど、これらの変更を追跡して中間層にパッケージとして戻す操作が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="34e66-143">The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier.</span></span> <span data-ttu-id="34e66-144">変更内容をやり取りするメカニズムの実装は、完全にアプリケーションに依存しています。</span><span class="sxs-lookup"><span data-stu-id="34e66-144">The implementation of a mechanism for communicating changes is completely up to the application.</span></span> <span data-ttu-id="34e66-145">唯一の要件は、オプティミスティック コンカレンシー チェックに必要な元の値が [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] に渡されなければならないということです。</span><span class="sxs-lookup"><span data-stu-id="34e66-145">The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks.</span></span>  
  
 <span data-ttu-id="34e66-146">詳細については、「 [N 層アプリケーションでのデータの取得と CUD の操作 (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="34e66-146">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="34e66-147">関連項目</span><span class="sxs-lookup"><span data-stu-id="34e66-147">See also</span></span>

- [<span data-ttu-id="34e66-148">LINQ to SQL を使用する n 層アプリケーションとリモート アプリケーション</span><span class="sxs-lookup"><span data-stu-id="34e66-148">N-Tier and Remote Applications with LINQ to SQL</span></span>](n-tier-and-remote-applications-with-linq-to-sql.md)
- <span data-ttu-id="34e66-149">[LinqDataSource Web サーバーコントロールの概要](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="34e66-149">[LinqDataSource Web Server Control Overview](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))</span></span>
