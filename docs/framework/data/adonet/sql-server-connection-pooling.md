---
title: SQL Server 接続プール
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07
ms.openlocfilehash: 149511bd4e84baabf11eca014257127b587830df
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79148999"
---
# <a name="sql-server-connection-pooling-adonet"></a><span data-ttu-id="c1415-102">SQL Server の接続プール (ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="c1415-102">SQL Server Connection Pooling (ADO.NET)</span></span>
<span data-ttu-id="c1415-103">通常、データベース サーバーへの接続は、時間のかかるいくつかの手順で構成されています。</span><span class="sxs-lookup"><span data-stu-id="c1415-103">Connecting to a database server typically consists of several time-consuming steps.</span></span> <span data-ttu-id="c1415-104">ソケットまたは名前付きパイプなどの物理チャネルの確立、サーバーとの最初のハンドシェイクの実行、接続文字列の情報の解析、サーバーによる接続の認証、現在のトランザクションへ参加するための検証などの手順を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="c1415-104">A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.</span></span>  
  
 <span data-ttu-id="c1415-105">実際には、ほとんどのアプリケーションで、1 つまたはいくつかの違いがあるだけの構成を接続に使用しています。</span><span class="sxs-lookup"><span data-stu-id="c1415-105">In practice, most applications use only one or a few different configurations for connections.</span></span> <span data-ttu-id="c1415-106">つまり、アプリケーションの実行時に、多数の同一の接続が繰り返し開かれ、閉じられているのです。</span><span class="sxs-lookup"><span data-stu-id="c1415-106">This means that during application execution, many identical connections will be repeatedly opened and closed.</span></span> <span data-ttu-id="c1415-107">接続を開くコストを最小限に抑えるために、ADO.NETは*接続プール*と呼ばれる最適化手法を使用します。</span><span class="sxs-lookup"><span data-stu-id="c1415-107">To minimize the cost of opening connections, ADO.NET uses an optimization technique called *connection pooling*.</span></span>  
  
 <span data-ttu-id="c1415-108">接続プールは、新しく開く必要のある接続の数を減らします。</span><span class="sxs-lookup"><span data-stu-id="c1415-108">Connection pooling reduces the number of times that new connections must be opened.</span></span> <span data-ttu-id="c1415-109">*プーラー*は、物理接続の所有権を保持します。</span><span class="sxs-lookup"><span data-stu-id="c1415-109">The *pooler* maintains ownership of the physical connection.</span></span> <span data-ttu-id="c1415-110">プーラーは、任意の接続構成それぞれのアクティブな接続のセットをそのまま保持して、接続を管理します。</span><span class="sxs-lookup"><span data-stu-id="c1415-110">It manages connections by keeping alive a set of active connections for each given connection configuration.</span></span> <span data-ttu-id="c1415-111">この接続の `Open` を呼び出すと、プーラーは、プールに使用可能な接続があるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="c1415-111">Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool.</span></span> <span data-ttu-id="c1415-112">プールされた接続が使用できる場合は、新しい接続を開く代わりに、プールされた接続を呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="c1415-112">If a pooled connection is available, it returns it to the caller instead of opening a new connection.</span></span> <span data-ttu-id="c1415-113">アプリケーションが接続で `Close` を呼び出すと、プーラーは接続を閉じる代わりに、プールされたアクティブな接続のセットに接続を返します。</span><span class="sxs-lookup"><span data-stu-id="c1415-113">When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it.</span></span> <span data-ttu-id="c1415-114">接続がプールに返されると、その接続は、次の `Open` 呼び出しで再度使用できる状態になります。</span><span class="sxs-lookup"><span data-stu-id="c1415-114">Once the connection is returned to the pool, it is ready to be reused on the next `Open` call.</span></span>  
  
 <span data-ttu-id="c1415-115">同じ構成を持つ接続のみをプールすることができます。</span><span class="sxs-lookup"><span data-stu-id="c1415-115">Only connections with the same configuration can be pooled.</span></span> <span data-ttu-id="c1415-116">ADO.NETは、構成ごとに 1 つずつ、複数のプールを同時に保持します。</span><span class="sxs-lookup"><span data-stu-id="c1415-116">ADO.NET keeps several pools at the same time, one for each configuration.</span></span> <span data-ttu-id="c1415-117">接続は接続文字列によってプール内で区別されます。また、統合セキュリティを使用している場合は、Windows ID によっても区別されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-117">Connections are separated into pools by connection string, and by Windows identity when integrated security is used.</span></span> <span data-ttu-id="c1415-118">接続がプールされるかどうかは、その接続がトランザクションに参加しているかどうかにも依存します。</span><span class="sxs-lookup"><span data-stu-id="c1415-118">Connections are also pooled based on whether they are enlisted in a transaction.</span></span> <span data-ttu-id="c1415-119"><xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A> を使用すると、<xref:System.Data.SqlClient.SqlCredential> インスタンスは接続プールに影響します。</span><span class="sxs-lookup"><span data-stu-id="c1415-119">When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool.</span></span> <span data-ttu-id="c1415-120">ユーザー ID とパスワードが同じでも、<xref:System.Data.SqlClient.SqlCredential> のインスタンスごとに異なる接続プールが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-120">Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same.</span></span>  
  
 <span data-ttu-id="c1415-121">接続をプールすると、アプリケーションのパフォーマンスとスケーラビリティを大幅に改善できます。</span><span class="sxs-lookup"><span data-stu-id="c1415-121">Pooling connections can significantly enhance the performance and scalability of your application.</span></span> <span data-ttu-id="c1415-122">デフォルトでは、接続プールはADO.NETで有効になっています。</span><span class="sxs-lookup"><span data-stu-id="c1415-122">By default, connection pooling is enabled in ADO.NET.</span></span> <span data-ttu-id="c1415-123">明示的に無効にしない限り、プーラーは、アプリケーションで接続が開かれたり、閉じられたりする際に接続を最適化します。</span><span class="sxs-lookup"><span data-stu-id="c1415-123">Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application.</span></span> <span data-ttu-id="c1415-124">また、接続プール機能の動作を制御する接続文字列修飾子を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="c1415-124">You can also supply several connection string modifiers to control connection pooling behavior.</span></span> <span data-ttu-id="c1415-125">詳細については、このトピックで後述する「接続文字列キーワードによる接続プールの制御」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-125">For more information, see "Controlling Connection Pooling with Connection String Keywords" later in this topic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c1415-126">接続プールが有効になっている場合とタイムアウト エラーや他のログイン エラーが発生した場合は、例外がスローされ、それ以降に接続を試みると、5 秒間の "ブロック期間" 中失敗します。</span><span class="sxs-lookup"><span data-stu-id="c1415-126">When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the "blocking period".</span></span> <span data-ttu-id="c1415-127">ブロック期間内にアプリケーションが接続を試みると、最初の例外が再度スローされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-127">If the application attempts to connect within the blocking period, the first exception will be thrown again.</span></span> <span data-ttu-id="c1415-128">ブロック期間の終了後も失敗が続く場合は、最大 1 分として、新しいブロック期間は前のブロック期間の 2 倍の長さになります。</span><span class="sxs-lookup"><span data-stu-id="c1415-128">Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.</span></span>  
  
## <a name="pool-creation-and-assignment"></a><span data-ttu-id="c1415-129">プールの作成と割り当て</span><span class="sxs-lookup"><span data-stu-id="c1415-129">Pool Creation and Assignment</span></span>  
 <span data-ttu-id="c1415-130">接続が最初に開かれると、完全一致のアルゴリズムに基づいて接続プールが作成され、接続内の接続文字列に関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="c1415-130">When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection.</span></span> <span data-ttu-id="c1415-131">各接続プールが別の接続文字列に関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="c1415-131">Each connection pool is associated with a distinct connection string.</span></span> <span data-ttu-id="c1415-132">新しい接続が開かれたとき、接続文字列が既存のプールと完全に一致しない場合は、新しいプールが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-132">When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created.</span></span> <span data-ttu-id="c1415-133">接続は、プロセス、アプリケーション ドメイン、接続文字列、Windows ID (統合セキュリティを使用している場合) ごとにプールされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-133">Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity.</span></span> <span data-ttu-id="c1415-134">また、接続文字列は完全に一致していることが必要です。同じ接続に対してキーワードを異なる順序で指定すると別々にプールされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-134">Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.</span></span>  
  
 <span data-ttu-id="c1415-135">3 つの新しい <xref:System.Data.SqlClient.SqlConnection> オブジェクトを作成し、2 つの接続プールだけでこの 3 つのオブジェクトを管理する C# の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c1415-135">In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them.</span></span> <span data-ttu-id="c1415-136">1 番目の接続文字列と 2 番目の接続文字列では、`Initial Catalog` に割り当てる値が異なります。</span><span class="sxs-lookup"><span data-stu-id="c1415-136">Note that the first and second connection strings differ by the value assigned for `Initial Catalog`.</span></span>  
  
```csharp
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // Pool A is created.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=pubs"))  
    {  
        connection.Open();
        // Pool B is created because the connection strings differ.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();
        // The connection string matches pool A.  
    }  
```  
  
 <span data-ttu-id="c1415-137">接続文字列で `MinPoolSize` が指定されていない、またはゼロに指定されている場合、プール内の接続は、アクティブではない一定の期間後に閉じられます。</span><span class="sxs-lookup"><span data-stu-id="c1415-137">If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity.</span></span> <span data-ttu-id="c1415-138">ただし、`MinPoolSize` がゼロより大きい値に設定されている場合、接続プールは、`AppDomain` がアンロードされ、プロセスが終了するまで破棄されません。</span><span class="sxs-lookup"><span data-stu-id="c1415-138">However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends.</span></span> <span data-ttu-id="c1415-139">アクティブでないプールまたは空のプールを維持するためには、最小限のシステム オーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="c1415-139">Maintenance of inactive or empty pools involves minimal system overhead.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c1415-140">フェールオーバーなど、致命的なエラーが発生すると、プールは自動的にクリアされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-140">The pool is automatically cleared when a fatal error occurs, such as a failover.</span></span>  
  
## <a name="adding-connections"></a><span data-ttu-id="c1415-141">接続の追加</span><span class="sxs-lookup"><span data-stu-id="c1415-141">Adding Connections</span></span>  
 <span data-ttu-id="c1415-142">一意の接続文字列ごとに 1 つの接続プールが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-142">A connection pool is created for each unique connection string.</span></span> <span data-ttu-id="c1415-143">プールが作成された段階で、複数の接続オブジェクトが作成されてそのプールへ追加され、最小プール サイズ要件を満たします。</span><span class="sxs-lookup"><span data-stu-id="c1415-143">When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied.</span></span> <span data-ttu-id="c1415-144">必要に応じて、指定された最大プール サイズ (既定は 100) に達するまで、接続がプールへ追加されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-144">Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default).</span></span> <span data-ttu-id="c1415-145">接続が終了または破棄されると、その接続は解放され、プールに戻されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-145">Connections are released back into the pool when they are closed or disposed.</span></span>  
  
 <span data-ttu-id="c1415-146"><xref:System.Data.SqlClient.SqlConnection> オブジェクトが要求されると、プールに使用可能な接続がある場合はプールから取得されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-146">When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available.</span></span> <span data-ttu-id="c1415-147">使用可能な接続とは、サーバーへの有効なリンクを持つ接続のうち、使用中でないか、一致するトランザクション コンテキストを持っているか、またはどのトランザクション コンテキストにも関連付けられていない接続のことです。</span><span class="sxs-lookup"><span data-stu-id="c1415-147">To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.</span></span>  
  
 <span data-ttu-id="c1415-148">接続プーラーは、接続がプールに解放されたときに接続の再割り当てを行って、接続に対する要求に応えます。</span><span class="sxs-lookup"><span data-stu-id="c1415-148">The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool.</span></span> <span data-ttu-id="c1415-149">最大プール サイズに達すると、使用可能な接続を取得できなくなり、要求はキューに置かれます。</span><span class="sxs-lookup"><span data-stu-id="c1415-149">If the maximum pool size has been reached and no usable connection is available, the request is queued.</span></span> <span data-ttu-id="c1415-150">プーラーは、タイムアウト (既定は 15 秒) に達するまで接続の再利用を試みます。</span><span class="sxs-lookup"><span data-stu-id="c1415-150">The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds).</span></span> <span data-ttu-id="c1415-151">接続がタイムアウトになる前に、プーラーが要求を満たすことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-151">If the pooler cannot satisfy the request before the connection times out, an exception is thrown.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="c1415-152">接続がプールに返されるようにするために、接続を使い終えたら必ず接続を終了することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c1415-152">We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool.</span></span> <span data-ttu-id="c1415-153">これは`Close`、`Dispose``Connection`オブジェクトの or メソッドを使用するか、C# の`using`ステートメント内のすべての接続を開くか、Visual Basic`Using`のステートメントを使用して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="c1415-153">You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic.</span></span> <span data-ttu-id="c1415-154">明示的に終了されていない接続は、プールに追加したり返したりすることができないことがあります。</span><span class="sxs-lookup"><span data-stu-id="c1415-154">Connections that are not explicitly closed might not be added or returned to the pool.</span></span> <span data-ttu-id="c1415-155">詳細については、「[ステートメントの使用](../../../csharp/language-reference/keywords/using-statement.md)」または「方法: Visual Basic 用[のシステム リソースを破棄する](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-155">For more information, see [using Statement](../../../csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c1415-156">クラスの `Close` メソッド内で `Dispose`、`Connection`、またはその他のマネージド オブジェクトの `DataReader` または `Finalize` を呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="c1415-156">Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class.</span></span> <span data-ttu-id="c1415-157">終了処理では、クラスに直接所有されているアンマネージ リソースだけを解放してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-157">In a finalizer, only release unmanaged resources that your class owns directly.</span></span> <span data-ttu-id="c1415-158">クラスがアンマネージ リソースを所有していない場合は、クラス定義に `Finalize` メソッドを含めないでください。</span><span class="sxs-lookup"><span data-stu-id="c1415-158">If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition.</span></span> <span data-ttu-id="c1415-159">詳細については、「[ガベージ コレクション](../../../standard/garbage-collection/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-159">For more information, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
<span data-ttu-id="c1415-160">接続の開始と終了に関連するイベントの詳細については、SQL Server のドキュメントの「[ログイン イベント クラスの監査](/sql/relational-databases/event-classes/audit-login-event-class)」および「[監査ログアウト イベント クラス](/sql/relational-databases/event-classes/audit-logout-event-class)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-160">For more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation.</span></span>  
  
## <a name="removing-connections"></a><span data-ttu-id="c1415-161">接続の削除</span><span class="sxs-lookup"><span data-stu-id="c1415-161">Removing Connections</span></span>  
 <span data-ttu-id="c1415-162">接続プール機能は、アイドル状態の時間が約 4-8 分になったか、サーバーとの接続が切断されたことをプール機能が検出した場合に、プールからの接続を削除します。</span><span class="sxs-lookup"><span data-stu-id="c1415-162">The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed.</span></span> <span data-ttu-id="c1415-163">サーバーとの通信を試みた後にのみ、切断されたサーバー接続が検出可能になることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-163">Note that a severed connection can be detected only after attempting to communicate with the server.</span></span> <span data-ttu-id="c1415-164">接続がサーバーに接続していないことがわかると、その接続は無効としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-164">If a connection is found that is no longer connected to the server, it is marked as invalid.</span></span> <span data-ttu-id="c1415-165">無効な接続は、閉じられるか、または再利用された場合のみ、接続プールから削除されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-165">Invalid connections are removed from the connection pool only when they are closed or reclaimed.</span></span>  
  
 <span data-ttu-id="c1415-166">既に存在しないサーバーへの接続が存在する場合は、接続プーラーが、その接続が切断されていることをまだ検出せず、無効というマークを付けていない状況のときでも、プールからその接続を削除できます。</span><span class="sxs-lookup"><span data-stu-id="c1415-166">If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid.</span></span> <span data-ttu-id="c1415-167">この機能は、接続がまだ有効であることを確認するオーバーヘッドによってサーバーへのラウンド トリップが実行されることにより、プーラーの利点が失われてしまうことを防ぐためにあります。</span><span class="sxs-lookup"><span data-stu-id="c1415-167">This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur.</span></span> <span data-ttu-id="c1415-168">この状況が発生した場合は、接続の使用を最初に試みたときに接続が切断されていることが検出され、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-168">When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.</span></span>  
  
## <a name="clearing-the-pool"></a><span data-ttu-id="c1415-169">プールのクリア</span><span class="sxs-lookup"><span data-stu-id="c1415-169">Clearing the Pool</span></span>  
 <span data-ttu-id="c1415-170">ADO.NET 2.0 では、プールをクリアする<xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A>2<xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>つの新しいメソッドが導入されました: と .</span><span class="sxs-lookup"><span data-stu-id="c1415-170">ADO.NET 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>.</span></span> <span data-ttu-id="c1415-171">`ClearAllPools` は、指定されたプロバイダーの接続プールをクリアし、`ClearPool` は、特定の接続に関連付けられた接続プールをクリアします。</span><span class="sxs-lookup"><span data-stu-id="c1415-171">`ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection.</span></span> <span data-ttu-id="c1415-172">これらのメソッドが呼び出されたときに使用中の接続がある場合は、適切にマーク付けされ、</span><span class="sxs-lookup"><span data-stu-id="c1415-172">If there are connections being used at the time of the call, they are marked appropriately.</span></span> <span data-ttu-id="c1415-173">接続が閉じられるとプールに返されずに破棄されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-173">When they are closed, they are discarded instead of being returned to the pool.</span></span>  
  
## <a name="transaction-support"></a><span data-ttu-id="c1415-174">トランザクションのサポート</span><span class="sxs-lookup"><span data-stu-id="c1415-174">Transaction Support</span></span>  
 <span data-ttu-id="c1415-175">接続はプールから取り出され、トランザクション コンテキストに基づいて割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c1415-175">Connections are drawn from the pool and assigned based on transaction context.</span></span> <span data-ttu-id="c1415-176">接続文字列で `Enlist=false` が指定されていない限り、接続プールは、接続を <xref:System.Transactions.Transaction.Current%2A> コンテキストの中に参加させます。</span><span class="sxs-lookup"><span data-stu-id="c1415-176">Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context.</span></span> <span data-ttu-id="c1415-177">接続が閉じられ、参加した `System.Transactions` トランザクションと共にプールに返されると、同じ `System.Transactions` トランザクションを持つ接続プールに対する次の要求でも、使用可能であれば同じ接続を返すように接続が保持されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-177">When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available.</span></span> <span data-ttu-id="c1415-178">このような要求が発行された場合で、なおかつ、プールされた接続が使用できない場合は、プールの非トランザクション部分から接続を取り出して参加させます。</span><span class="sxs-lookup"><span data-stu-id="c1415-178">If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted.</span></span> <span data-ttu-id="c1415-179">プールのどちらの領域にも使用できる接続がない場合は、新しい接続を作成して参加させます。</span><span class="sxs-lookup"><span data-stu-id="c1415-179">If no connections are available in either area of the pool, a new connection is created and enlisted.</span></span>  
  
 <span data-ttu-id="c1415-180">接続が終了すると、その接続は解放されてプールへ返り、さらに、そのトランザクション コンテキストに基づいて特定のサブプールへ返ります。</span><span class="sxs-lookup"><span data-stu-id="c1415-180">When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context.</span></span> <span data-ttu-id="c1415-181">そのため、分散トランザクションが保留状態である場合を含め、エラーを発生させることなく、開発者が接続を終了させることは可能です。</span><span class="sxs-lookup"><span data-stu-id="c1415-181">Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending.</span></span> <span data-ttu-id="c1415-182">これにより、分散トランザクションを後でコミットまたは中止できます。</span><span class="sxs-lookup"><span data-stu-id="c1415-182">This allows you to commit or abort the distributed transaction later.</span></span>  
  
## <a name="controlling-connection-pooling-with-connection-string-keywords"></a><span data-ttu-id="c1415-183">接続文字列キーワードによる接続プールの制御</span><span class="sxs-lookup"><span data-stu-id="c1415-183">Controlling Connection Pooling with Connection String Keywords</span></span>  
 <span data-ttu-id="c1415-184">`ConnectionString` オブジェクトの <xref:System.Data.SqlClient.SqlConnection> プロパティは、接続プール ロジックの動作を調整するために使用できる接続文字列キーおよび値のペアをサポートします。</span><span class="sxs-lookup"><span data-stu-id="c1415-184">The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic.</span></span> <span data-ttu-id="c1415-185">詳細については、<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-185">For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.</span></span>  
  
## <a name="pool-fragmentation"></a><span data-ttu-id="c1415-186">プールの断片化</span><span class="sxs-lookup"><span data-stu-id="c1415-186">Pool Fragmentation</span></span>  
 <span data-ttu-id="c1415-187">プールの断片化は、プロセスが終了するまで解放されないプールを多数作成できる Web アプリケーションの多くで一般的な問題です。</span><span class="sxs-lookup"><span data-stu-id="c1415-187">Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits.</span></span> <span data-ttu-id="c1415-188">これにより、多数の接続が開いたままになってメモリを消費し、パフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="c1415-188">This leaves a large number of connections open and consuming memory, which results in poor performance.</span></span>  
  
### <a name="pool-fragmentation-due-to-integrated-security"></a><span data-ttu-id="c1415-189">統合セキュリティによるプールの断片化</span><span class="sxs-lookup"><span data-stu-id="c1415-189">Pool Fragmentation Due to Integrated Security</span></span>  
 <span data-ttu-id="c1415-190">接続は、接続文字列とユーザー ID に基づいてプールされます。</span><span class="sxs-lookup"><span data-stu-id="c1415-190">Connections are pooled according to the connection string plus the user identity.</span></span> <span data-ttu-id="c1415-191">したがって、Web サイトで基本認証または Windows 認証を使用していて、統合セキュリティ ログインを使用している場合は、1 ユーザーにつき 1 つのプールが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c1415-191">Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user.</span></span> <span data-ttu-id="c1415-192">これによって、単一のユーザーによる後続のデータベース要求のパフォーマンスが向上しますが、他のユーザーによって作成された接続は使用できません。</span><span class="sxs-lookup"><span data-stu-id="c1415-192">Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users.</span></span> <span data-ttu-id="c1415-193">また、1 ユーザーにつき少なくとも 1 つの接続がデータベース サーバーに存在することになります。</span><span class="sxs-lookup"><span data-stu-id="c1415-193">It also results in at least one connection per user to the database server.</span></span> <span data-ttu-id="c1415-194">これは、開発者がセキュリティおよび監査要件に対して、特定の Web アプリケーションのアーキテクチャに重点を置く必要があるために起こる副作用です。</span><span class="sxs-lookup"><span data-stu-id="c1415-194">This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.</span></span>  
  
### <a name="pool-fragmentation-due-to-many-databases"></a><span data-ttu-id="c1415-195">多数のデータベースによるプールの断片化</span><span class="sxs-lookup"><span data-stu-id="c1415-195">Pool Fragmentation Due to Many Databases</span></span>  
 <span data-ttu-id="c1415-196">インターネット サービス プロバイダーの多くは、1 つのサーバー上で複数の Web サイトをホストしています。</span><span class="sxs-lookup"><span data-stu-id="c1415-196">Many Internet service providers host several Web sites on a single server.</span></span> <span data-ttu-id="c1415-197">インターネット サービス プロバイダーは、1 つのデータベースを使用してフォーム認証ログインを確認し、そのユーザーまたはユーザー グループの特定のデータベースへの接続を開きます。</span><span class="sxs-lookup"><span data-stu-id="c1415-197">They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users.</span></span> <span data-ttu-id="c1415-198">認証データベースへの接続はプールされ、すべてのユーザーが使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="c1415-198">The connection to the authentication database is pooled and used by everyone.</span></span> <span data-ttu-id="c1415-199">ただし、各データベースに対して個別の接続のプールが存在するため、サーバーへの接続数が増加します。</span><span class="sxs-lookup"><span data-stu-id="c1415-199">However, there is a separate pool of connections to each database, which increase the number of connections to the server.</span></span>  
  
 <span data-ttu-id="c1415-200">これもまた、アプリケーションのデザインの副作用です。</span><span class="sxs-lookup"><span data-stu-id="c1415-200">This is also a side-effect of the application design.</span></span> <span data-ttu-id="c1415-201">SQL Server に接続するときにセキュリティを損なうことなく、この副作用を回避する比較的簡単な方法があります。</span><span class="sxs-lookup"><span data-stu-id="c1415-201">There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server.</span></span> <span data-ttu-id="c1415-202">各ユーザーまたはグループの個別のデータベースに接続する代わりに、サーバー上の同じデータベースに接続してから、Transact-SQL USE ステートメントを実行して目的のデータベースに変更します。</span><span class="sxs-lookup"><span data-stu-id="c1415-202">Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the Transact-SQL USE statement to change to the desired database.</span></span> <span data-ttu-id="c1415-203">`master` データベースへの最初の接続を作成し、`databaseName` 文字列変数で指定した目的のデータベースに切り替えるコードを次に示します。</span><span class="sxs-lookup"><span data-stu-id="c1415-203">The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable.</span></span>  
  
```vb  
' Assumes that command is a valid SqlCommand object and that  
' connectionString connects to master.  
    command.Text = "USE DatabaseName"  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    command.ExecuteNonQuery()  
End Using  
```  
  
```csharp  
// Assumes that command is a SqlCommand object and that  
// connectionString connects to master.  
command.Text = "USE DatabaseName";  
using (SqlConnection connection = new SqlConnection(  
  connectionString))  
  {  
    connection.Open();  
    command.ExecuteNonQuery();  
  }  
```  
  
## <a name="application-roles-and-connection-pooling"></a><span data-ttu-id="c1415-204">アプリケーション ロールおよび接続プール</span><span class="sxs-lookup"><span data-stu-id="c1415-204">Application Roles and Connection Pooling</span></span>  
 <span data-ttu-id="c1415-205">`sp_setapprole` システム ストアド プロシージャの呼び出しにより SQL Server のアプリケーション ロールが起動された後は、その接続のセキュリティ コンテキストをリセットすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c1415-205">After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset.</span></span> <span data-ttu-id="c1415-206">ただし、プールを有効した場合は、プールに接続が返され、プール接続が再利用されると、エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="c1415-206">However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused.</span></span> <span data-ttu-id="c1415-207">詳細については、サポート技術情報の記事[「OLE DB リソース プーリングで SQL アプリケーション ロールエラーが発生しました](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-207">For more information, see the Knowledge Base article, "[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)."</span></span>  
  
### <a name="application-role-alternatives"></a><span data-ttu-id="c1415-208">アプリケーション ロールに代わる方法</span><span class="sxs-lookup"><span data-stu-id="c1415-208">Application Role Alternatives</span></span>  
 <span data-ttu-id="c1415-209">アプリケーション ロールに代わるセキュリティ メカニズムの使用をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c1415-209">We recommend that you take advantage of security mechanisms that you can use instead of application roles.</span></span> <span data-ttu-id="c1415-210">詳細については、「 [SQL Server でのアプリケーション ロールの作成](./sql/creating-application-roles-in-sql-server.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c1415-210">For more information, see [Creating Application Roles in SQL Server](./sql/creating-application-roles-in-sql-server.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c1415-211">関連項目</span><span class="sxs-lookup"><span data-stu-id="c1415-211">See also</span></span>

- [<span data-ttu-id="c1415-212">接続のプール</span><span class="sxs-lookup"><span data-stu-id="c1415-212">Connection Pooling</span></span>](connection-pooling.md)
- [<span data-ttu-id="c1415-213">SQL Server と ADO.NET</span><span class="sxs-lookup"><span data-stu-id="c1415-213">SQL Server and ADO.NET</span></span>](./sql/index.md)
- [<span data-ttu-id="c1415-214">パフォーマンス カウンター</span><span class="sxs-lookup"><span data-stu-id="c1415-214">Performance Counters</span></span>](performance-counters.md)
- [<span data-ttu-id="c1415-215">ADO.NET の概要</span><span class="sxs-lookup"><span data-stu-id="c1415-215">ADO.NET Overview</span></span>](ado-net-overview.md)
