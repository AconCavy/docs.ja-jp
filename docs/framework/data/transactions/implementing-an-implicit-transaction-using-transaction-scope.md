---
title: トランザクション スコープを使用した暗黙的なトランザクションの実装
description: .NET で TransactionScope クラスを使用して暗黙的なトランザクションを実装します。 このクラスでは、トランザクションに参加しているマークをコードのブロックに付けることができます。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
ms.openlocfilehash: ff2fe64156d5d72773549d78b2e29631905cbb10
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/24/2020
ms.locfileid: "91186862"
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a><span data-ttu-id="e1583-104">トランザクション スコープを使用した暗黙的なトランザクションの実装</span><span class="sxs-lookup"><span data-stu-id="e1583-104">Implementing an Implicit Transaction using Transaction Scope</span></span>

<span data-ttu-id="e1583-105"><xref:System.Transactions.TransactionScope> クラスを使用すると、コード ブロックがトランザクションに参加しているものとして簡単にマークすることができ、トランザクション自体と対話する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-105">The <xref:System.Transactions.TransactionScope> class provides a simple way to mark a block of code as participating in a transaction, without requiring you to interact with the transaction itself.</span></span> <span data-ttu-id="e1583-106">トランザクション スコープは、アンビエント トランザクションを自動的に選択して管理することができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-106">A transaction scope can select and manage the ambient transaction automatically.</span></span> <span data-ttu-id="e1583-107">トランザクション アプリケーションを開発する際は、使いやすさと効率の点から、<xref:System.Transactions.TransactionScope> クラスを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e1583-107">Due to its ease of use and efficiency, it is recommended that you use the <xref:System.Transactions.TransactionScope> class when developing a transaction application.</span></span>  
  
 <span data-ttu-id="e1583-108">また、リソースをトランザクションに明示的に参加させる必要がありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-108">In addition, you do not need to enlist resources explicitly with the transaction.</span></span> <span data-ttu-id="e1583-109"><xref:System.Transactions> リソース マネージャー (SQL Server 2005 など) は、スコープによって作成されたアンビエント トランザクションを検出して、自動的に参加することができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-109">Any <xref:System.Transactions> resource manager (such as SQL Server 2005) can detect the existence of an ambient transaction created by the scope and automatically enlist.</span></span>  
  
## <a name="creating-a-transaction-scope"></a><span data-ttu-id="e1583-110">トランザクション スコープの作成</span><span class="sxs-lookup"><span data-stu-id="e1583-110">Creating a transaction scope</span></span>  

 <span data-ttu-id="e1583-111">次のサンプルは、<xref:System.Transactions.TransactionScope> クラスの簡単な使用法を示しています。</span><span class="sxs-lookup"><span data-stu-id="e1583-111">The following sample shows a simple usage of the <xref:System.Transactions.TransactionScope> class.</span></span>  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 <span data-ttu-id="e1583-112">新しい <xref:System.Transactions.TransactionScope> オブジェクトを作成すると、トランザクション スコープが開始されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-112">The transaction scope is started once you create a new <xref:System.Transactions.TransactionScope> object.</span></span>  <span data-ttu-id="e1583-113">コード サンプルで示されているように、`using` ステートメントを使用してスコープを作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e1583-113">As illustrated in the code sample, it is recommended that you create scopes with a `using` statement.</span></span> <span data-ttu-id="e1583-114">`using` ステートメントは C# と Visual Basic の両方で使用でき、`try`...`finally` ブロックと同じように機能して、スコープが適切に破棄されるようにします。</span><span class="sxs-lookup"><span data-stu-id="e1583-114">The `using` statement is available both in C# and in Visual Basic, and works like a `try`...`finally` block to ensure that the scope is disposed of properly.</span></span>  
  
 <span data-ttu-id="e1583-115"><xref:System.Transactions.TransactionScope> をインスタンス化すると、参加するトランザクションがトランザクション マネージャーによって決定されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-115">When you instantiate <xref:System.Transactions.TransactionScope>, the transaction manager determines which transaction to participate in.</span></span> <span data-ttu-id="e1583-116">いったん決定されると、このスコープは常にそのトランザクションに参加します。</span><span class="sxs-lookup"><span data-stu-id="e1583-116">Once determined, the scope always participates in that transaction.</span></span> <span data-ttu-id="e1583-117">この決定は 2 つの要因に基づいて行われます。1 つはアンビエント トランザクションが存在するかどうか、もう 1 つはコンストラクターの `TransactionScopeOption` パラメーターの値です。</span><span class="sxs-lookup"><span data-stu-id="e1583-117">The decision is based on two factors: whether an ambient transaction is present and the value of the `TransactionScopeOption` parameter in the constructor.</span></span> <span data-ttu-id="e1583-118">アンビエント トランザクションとは、実行するコードが含まれているトランザクションのことです。</span><span class="sxs-lookup"><span data-stu-id="e1583-118">The ambient transaction is the transaction within which your code executes.</span></span> <span data-ttu-id="e1583-119"><xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> クラスの静的 <xref:System.Transactions.Transaction> プロパティを呼び出すことによってアンビエント トランザクションへの参照を取得できます。</span><span class="sxs-lookup"><span data-stu-id="e1583-119">You can obtain a reference to the ambient transaction by calling the static <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> property of the <xref:System.Transactions.Transaction> class.</span></span> <span data-ttu-id="e1583-120">このパラメーターの使用法の詳細については、このトピックの「[TransactionScopeOption を使用したトランザクション フローの管理](#ManageTxFlow)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e1583-120">For more information on how this parameter is used, see the [Managing transaction flow using TransactionScopeOption](#ManageTxFlow) section of this topic.</span></span>  
  
## <a name="completing-a-transaction-scope"></a><span data-ttu-id="e1583-121">トランザクション スコープの完了</span><span class="sxs-lookup"><span data-stu-id="e1583-121">Completing a transaction scope</span></span>  

 <span data-ttu-id="e1583-122">アプリケーションがトランザクション内で実行する必要のあるすべての作業を完了したら、トランザクションをコミットできることをトランザクション マネージャーに知らせるために、<xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> メソッドを一度だけ呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-122">When your application completes all the work it wants to perform in a transaction, you should call the <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWithType> method only once to inform the transaction manager that it is acceptable to commit the transaction.</span></span> <span data-ttu-id="e1583-123">`using` ブロックの最後のステートメントとして <xref:System.Transactions.TransactionScope.Complete%2A> の呼び出しを配置するのは非常によい方法です。</span><span class="sxs-lookup"><span data-stu-id="e1583-123">It is very good practice to put the call to <xref:System.Transactions.TransactionScope.Complete%2A> as the last statement in the `using` block.</span></span>  
  
 <span data-ttu-id="e1583-124">この呼び出しを行わないと、トランザクション マネージャーは、システム障害が発生したかまたはトランザクションのスコープ内で例外がスローされたと解釈するため、トランザクションが中止されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-124">Failing to call this method aborts the transaction, because the transaction manager interprets this as a system failure, or equivalent to an exception thrown within the scope of the transaction.</span></span> <span data-ttu-id="e1583-125">ただし、このメソッドを呼び出したからといって必ずしもトランザクションのコミットが保証されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-125">However, calling this method does not guarantee that the transaction wil be committed.</span></span> <span data-ttu-id="e1583-126">これはトランザクション マネージャーにステータスを通知する手段にすぎません。</span><span class="sxs-lookup"><span data-stu-id="e1583-126">It is merely a way of informing the transaction manager of your status.</span></span> <span data-ttu-id="e1583-127"><xref:System.Transactions.TransactionScope.Complete%2A> メソッドを呼び出した後は、<xref:System.Transactions.Transaction.Current%2A> プロパティを使用してアンビエント トランザクションにアクセスできなくなります。アクセスしようとすると例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-127">After calling the <xref:System.Transactions.TransactionScope.Complete%2A> method, you can no longer access the ambient transaction by using the <xref:System.Transactions.Transaction.Current%2A> property, and attempting to do so will result in an exception being thrown.</span></span>  
  
 <span data-ttu-id="e1583-128"><xref:System.Transactions.TransactionScope> オブジェクトによって最初にトランザクションが作成された場合、トランザクション マネージャーでトランザクションが実際にコミットされる処理は、`using` ブロックの最後のコード行の後で行われます。</span><span class="sxs-lookup"><span data-stu-id="e1583-128">If the <xref:System.Transactions.TransactionScope> object created the transaction initially, the actual work of committing the transaction by the transaction manager occurs after the last line of code in the `using` block.</span></span> <span data-ttu-id="e1583-129">このオブジェクトによってトランザクションが作成されていない場合、<xref:System.Transactions.CommittableTransaction.Commit%2A> オブジェクトの所有者によって <xref:System.Transactions.CommittableTransaction> が呼び出されるたびにコミットが発生します。</span><span class="sxs-lookup"><span data-stu-id="e1583-129">If it did not create the transaction, the commit occurs whenever <xref:System.Transactions.CommittableTransaction.Commit%2A> is called by the owner of the <xref:System.Transactions.CommittableTransaction> object.</span></span> <span data-ttu-id="e1583-130">その時点で、トランザクション マネージャーによってリソース マネージャーが呼び出され、<xref:System.Transactions.TransactionScope> オブジェクトの <xref:System.Transactions.TransactionScope.Complete%2A> メソッドが呼び出されたかどうかに基づいて、コミットするかロールバックするかが通知されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-130">At that point the transaction manager calls the resource managers and informs them to either commit or rollback, based on whether the <xref:System.Transactions.TransactionScope.Complete%2A> method was called on the <xref:System.Transactions.TransactionScope> object.</span></span>  
  
 <span data-ttu-id="e1583-131">`using` ステートメントを使用すると、例外が発生した場合でも必ず <xref:System.Transactions.TransactionScope> オブジェクトの <xref:System.Transactions.TransactionScope.Dispose%2A> メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-131">The `using` statement ensures that the <xref:System.Transactions.TransactionScope.Dispose%2A> method of the <xref:System.Transactions.TransactionScope> object is called even if an exception occurs.</span></span> <span data-ttu-id="e1583-132"><xref:System.Transactions.TransactionScope.Dispose%2A> メソッドは、トランザクション スコープの末尾を表します。</span><span class="sxs-lookup"><span data-stu-id="e1583-132">The <xref:System.Transactions.TransactionScope.Dispose%2A> method marks the end of the transaction scope.</span></span> <span data-ttu-id="e1583-133">このメソッドの呼び出し後に発生した例外は、トランザクションに影響しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-133">Exceptions that occur after calling this method may not affect the transaction.</span></span> <span data-ttu-id="e1583-134">また、このメソッドはアンビエント トランザクションを前の状態に復元します。</span><span class="sxs-lookup"><span data-stu-id="e1583-134">This method also restores the ambient transaction to it previous state.</span></span>  
  
 <span data-ttu-id="e1583-135">スコープがトランザクションを作成し、そのトランザクションが中止された場合は、<xref:System.Transactions.TransactionAbortedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-135">A <xref:System.Transactions.TransactionAbortedException> is thrown if the scope creates the transaction, and the transaction is aborted.</span></span> <span data-ttu-id="e1583-136">トランザクション マネージャーがコミットを判断できない場合は、<xref:System.Transactions.TransactionInDoubtException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-136">A <xref:System.Transactions.TransactionInDoubtException> is thrown if the transaction manager cannot reach a Commit decision.</span></span> <span data-ttu-id="e1583-137">トランザクションがコミットされた場合は、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="e1583-137">No exception is thrown if the transaction is committed.</span></span>  
  
## <a name="rolling-back-a-transaction"></a><span data-ttu-id="e1583-138">トランザクションのロールバック</span><span class="sxs-lookup"><span data-stu-id="e1583-138">Rolling back a transaction</span></span>  

 <span data-ttu-id="e1583-139">トランザクションをロールバックする場合は、トランザクション スコープ内で <xref:System.Transactions.TransactionScope.Complete%2A> メソッドを呼び出さないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="e1583-139">If you want to rollback a transaction, you should not call the <xref:System.Transactions.TransactionScope.Complete%2A> method within the transaction scope.</span></span> <span data-ttu-id="e1583-140">たとえば、スコープ内で例外をスローすると、</span><span class="sxs-lookup"><span data-stu-id="e1583-140">For example, you can throw an exception within the scope.</span></span> <span data-ttu-id="e1583-141">スコープが参加しているトランザクションがロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-141">The transaction in which it participates in will be rolled back.</span></span>  
  
## <a name="managing-transaction-flow-using-transactionscopeoption"></a><a name="ManageTxFlow"></a> <span data-ttu-id="e1583-142">TransactionScopeOption を使用したトランザクション フローの管理</span><span class="sxs-lookup"><span data-stu-id="e1583-142">Managing transaction flow using TransactionScopeOption</span></span>  

 <span data-ttu-id="e1583-143">次の例にある <xref:System.Transactions.TransactionScope> メソッドのように、独自のスコープを使用するメソッド内から、`RootMethod` を使用するメソッドを呼び出すことによって、トランザクション スコープを入れ子にすることができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-143">Transaction scope can be nested by calling a method that uses a <xref:System.Transactions.TransactionScope> from within a method that uses its own scope, as is the case with the `RootMethod` method in the following example,</span></span>  
  
```csharp  
void RootMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        SomeMethod();
        scope.Complete();
    }
}

void SomeMethod()
{
    using(TransactionScope scope = new TransactionScope())
    {
        /* Perform transactional work here */
        scope.Complete();
    }
}
```  
  
 <span data-ttu-id="e1583-144">最上位のトランザクション スコープをルート スコープと呼びます。</span><span class="sxs-lookup"><span data-stu-id="e1583-144">The top-most transaction scope is referred to as the root scope.</span></span>  
  
 <span data-ttu-id="e1583-145"><xref:System.Transactions.TransactionScope> クラスには、スコープのトランザクション動作を定義する <xref:System.Transactions.TransactionScopeOption> 型の列挙体を受け入れる、いくつかのオーバーロードされたコンストラクターがあります。</span><span class="sxs-lookup"><span data-stu-id="e1583-145">The <xref:System.Transactions.TransactionScope> class provides several overloaded constructors that accept an enumeration of the type <xref:System.Transactions.TransactionScopeOption>, which defines the transactional behavior of the scope.</span></span>  
  
 <span data-ttu-id="e1583-146"><xref:System.Transactions.TransactionScope> オブジェクトには次の 3 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="e1583-146">A <xref:System.Transactions.TransactionScope> object has three options:</span></span>  
  
- <span data-ttu-id="e1583-147">アンビエント トランザクションに参加します (存在しない場合は新規に作成します)。</span><span class="sxs-lookup"><span data-stu-id="e1583-147">Join the ambient transaction, or create a new one if one does not exist.</span></span>  
  
- <span data-ttu-id="e1583-148">新しいルート スコープになります。つまり、新しいトランザクションを開始して、そのトランザクションをそれ自身のスコープ内の新しいアンビエント トランザクションにします。</span><span class="sxs-lookup"><span data-stu-id="e1583-148">Be a new root scope, that is, start a new transaction and have that transaction be the new ambient transaction inside its own scope.</span></span>  
  
- <span data-ttu-id="e1583-149">どのトランザクションにも参加しません。</span><span class="sxs-lookup"><span data-stu-id="e1583-149">Not take part in a transaction at all.</span></span> <span data-ttu-id="e1583-150">その結果、アンビエント トランザクションは存在しません。</span><span class="sxs-lookup"><span data-stu-id="e1583-150">There is no ambient transaction as a result.</span></span>  
  
 <span data-ttu-id="e1583-151">スコープが <xref:System.Transactions.TransactionScopeOption.Required> でインスタンス化された場合、アンビエント トランザクションが存在しているときは、スコープはそのトランザクションに参加します。</span><span class="sxs-lookup"><span data-stu-id="e1583-151">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Required>, and an ambient transaction is present, the scope joins that transaction.</span></span> <span data-ttu-id="e1583-152">一方、アンビエント トランザクションが存在しないときは、スコープは新しいトランザクションを作成して、ルート スコープになります。</span><span class="sxs-lookup"><span data-stu-id="e1583-152">If, on the other hand, there is no ambient transaction, then the scope creates a new transaction, and become the root scope.</span></span> <span data-ttu-id="e1583-153">これが既定値です。</span><span class="sxs-lookup"><span data-stu-id="e1583-153">This is the default value.</span></span> <span data-ttu-id="e1583-154"><xref:System.Transactions.TransactionScopeOption.Required> を使用した場合、スコープがルートのときでも、アンビエント トランザクションに参加するだけのときでも、スコープ内のコードは異なる動作をする必要がありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-154">When <xref:System.Transactions.TransactionScopeOption.Required> is used, the code inside the scope does not need to behave differently whether it is the root or just joining the ambient transaction.</span></span> <span data-ttu-id="e1583-155">いずれの場合にもスコープ内のコードは同じ動作をします。</span><span class="sxs-lookup"><span data-stu-id="e1583-155">It should operate identically in both cases.</span></span>  
  
 <span data-ttu-id="e1583-156">スコープが <xref:System.Transactions.TransactionScopeOption.RequiresNew> でインスタンス化された場合は、常にルート スコープです。</span><span class="sxs-lookup"><span data-stu-id="e1583-156">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.RequiresNew>, it is always the root scope.</span></span> <span data-ttu-id="e1583-157">スコープが新しいトランザクションを開始し、そのトランザクションがスコープ内の新しいアンビエント トランザクションになります。</span><span class="sxs-lookup"><span data-stu-id="e1583-157">It starts a new transaction, and its transaction becomes the new ambient transaction inside the scope.</span></span>  
  
 <span data-ttu-id="e1583-158">スコープが <xref:System.Transactions.TransactionScopeOption.Suppress> でインスタンス化された場合は、アンビエント トランザクションの有無にかかわらず、スコープがトランザクションに参加することはありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-158">If the scope is instantiated with <xref:System.Transactions.TransactionScopeOption.Suppress>, it never takes part in a transaction, regardless of whether an ambient transaction is present.</span></span> <span data-ttu-id="e1583-159">この値でインスタンス化されたスコープの場合は、スコープのアンビエント トランザクションは常に `null` になります。</span><span class="sxs-lookup"><span data-stu-id="e1583-159">A scope instantiated with this value always have `null` as its ambient transaction.</span></span>  
  
 <span data-ttu-id="e1583-160">上記のオプションを要約すると、次の表のようになります。</span><span class="sxs-lookup"><span data-stu-id="e1583-160">The above options are summarized in the following table.</span></span>  
  
|<span data-ttu-id="e1583-161">TransactionScopeOption</span><span class="sxs-lookup"><span data-stu-id="e1583-161">TransactionScopeOption</span></span>|<span data-ttu-id="e1583-162">アンビエント トランザクション</span><span class="sxs-lookup"><span data-stu-id="e1583-162">Ambient Transaction</span></span>|<span data-ttu-id="e1583-163">スコープの参加</span><span class="sxs-lookup"><span data-stu-id="e1583-163">The scope takes part in</span></span>|  
|----------------------------|-------------------------|-----------------------------|  
|<span data-ttu-id="e1583-164">必須</span><span class="sxs-lookup"><span data-stu-id="e1583-164">Required</span></span>|<span data-ttu-id="e1583-165">いいえ</span><span class="sxs-lookup"><span data-stu-id="e1583-165">No</span></span>|<span data-ttu-id="e1583-166">新規トランザクション (ルートになる)</span><span class="sxs-lookup"><span data-stu-id="e1583-166">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="e1583-167">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="e1583-167">Requires New</span></span>|<span data-ttu-id="e1583-168">いいえ</span><span class="sxs-lookup"><span data-stu-id="e1583-168">No</span></span>|<span data-ttu-id="e1583-169">新規トランザクション (ルートになる)</span><span class="sxs-lookup"><span data-stu-id="e1583-169">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="e1583-170">Suppress</span><span class="sxs-lookup"><span data-stu-id="e1583-170">Suppress</span></span>|<span data-ttu-id="e1583-171">いいえ</span><span class="sxs-lookup"><span data-stu-id="e1583-171">No</span></span>|<span data-ttu-id="e1583-172">トランザクションなし</span><span class="sxs-lookup"><span data-stu-id="e1583-172">No Transaction</span></span>|  
|<span data-ttu-id="e1583-173">必須</span><span class="sxs-lookup"><span data-stu-id="e1583-173">Required</span></span>|<span data-ttu-id="e1583-174">はい</span><span class="sxs-lookup"><span data-stu-id="e1583-174">Yes</span></span>|<span data-ttu-id="e1583-175">アンビエント トランザクション</span><span class="sxs-lookup"><span data-stu-id="e1583-175">Ambient  Transaction</span></span>|  
|<span data-ttu-id="e1583-176">RequiresNew</span><span class="sxs-lookup"><span data-stu-id="e1583-176">Requires New</span></span>|<span data-ttu-id="e1583-177">はい</span><span class="sxs-lookup"><span data-stu-id="e1583-177">Yes</span></span>|<span data-ttu-id="e1583-178">新規トランザクション (ルートになる)</span><span class="sxs-lookup"><span data-stu-id="e1583-178">New Transaction (will be the root)</span></span>|  
|<span data-ttu-id="e1583-179">Suppress</span><span class="sxs-lookup"><span data-stu-id="e1583-179">Suppress</span></span>|<span data-ttu-id="e1583-180">はい</span><span class="sxs-lookup"><span data-stu-id="e1583-180">Yes</span></span>|<span data-ttu-id="e1583-181">トランザクションなし</span><span class="sxs-lookup"><span data-stu-id="e1583-181">No Transaction</span></span>|  
  
 <span data-ttu-id="e1583-182"><xref:System.Transactions.TransactionScope> オブジェクトが既存のアンビエント トランザクションに参加した場合、スコープ オブジェクトを破棄してもトランザクションが終了しないことがあります (スコープがトランザクションを中止した場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="e1583-182">When a <xref:System.Transactions.TransactionScope> object joins an existing ambient transaction, disposing of the scope object may not end the transaction, unless the scope aborts the transaction.</span></span> <span data-ttu-id="e1583-183">アンビエント トランザクションがルート スコープによって作成されたものである場合は、ルート スコープが破棄されたときのみ、トランザクションの <xref:System.Transactions.CommittableTransaction.Commit%2A> が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-183">If the ambient transaction was created by a root scope, only when the root scope is disposed of, does <xref:System.Transactions.CommittableTransaction.Commit%2A> get called on the transaction.</span></span> <span data-ttu-id="e1583-184">トランザクションが手動で作成されたものである場合は、中止されるか、その作成者によってコミットされたときに、そのトランザクションは終了します。</span><span class="sxs-lookup"><span data-stu-id="e1583-184">If the transaction was created manually, the transaction ends when it is either aborted, or committed by its creator.</span></span>  
  
 <span data-ttu-id="e1583-185">次の例は、入れ子になった 3 つのスコープ オブジェクトを作成する <xref:System.Transactions.TransactionScope> オブジェクトを示しています。各スコープ オブジェクトは異なる <xref:System.Transactions.TransactionScopeOption> 値でインスタンス化しています。</span><span class="sxs-lookup"><span data-stu-id="e1583-185">The following example shows a <xref:System.Transactions.TransactionScope> object that creates three nested scope objects, each instantiated with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
//Default is Required
{
    using(TransactionScope scope2 = new TransactionScope(TransactionScopeOption.Required))
    {
        //...
    }

    using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        //...  
    }
  
    using(TransactionScope scope4 = new TransactionScope(TransactionScopeOption.Suppress))
    {
        //...  
    }
}
```  
  
 <span data-ttu-id="e1583-186">このコード例では、アンビエント トランザクションがない状態で、新しいスコープ `scope1` を <xref:System.Transactions.TransactionScopeOption.Required> で作成しています。</span><span class="sxs-lookup"><span data-stu-id="e1583-186">The example shows a code block without any ambient transaction creating a new scope (`scope1`) with <xref:System.Transactions.TransactionScopeOption.Required>.</span></span> <span data-ttu-id="e1583-187">スコープ `scope1` は、新しいトランザクション (トランザクション A) を作成し、トランザクション A をアンビエント トランザクションにするため、ルート スコープになります。</span><span class="sxs-lookup"><span data-stu-id="e1583-187">The scope `scope1` is a root scope as it creates a new transaction (Transaction A) and makes Transaction A the ambient transaction.</span></span> <span data-ttu-id="e1583-188">`Scope1` では次に、さらに 3 つのオブジェクトが、それぞれ異なる <xref:System.Transactions.TransactionScopeOption> 値で作成されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-188">`Scope1` then creates three more objects, each with a different <xref:System.Transactions.TransactionScopeOption> value.</span></span> <span data-ttu-id="e1583-189">たとえば、`scope2` は <xref:System.Transactions.TransactionScopeOption.Required> で作成されますが、アンビエント トランザクションがあるため、`scope1` によって作成された最初のトランザクションに参加します。</span><span class="sxs-lookup"><span data-stu-id="e1583-189">For example, `scope2` is created with <xref:System.Transactions.TransactionScopeOption.Required>, and since there is an ambient transaction, it joins the first transaction created by `scope1`.</span></span> <span data-ttu-id="e1583-190">`scope3` は新しいトランザクションのルート スコープです。`scope4` にはアンビエント トランザクションがありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-190">Note that `scope3` is the root scope of a new transaction, and that `scope4` has no ambient transaction.</span></span>  
  
 <span data-ttu-id="e1583-191"><xref:System.Transactions.TransactionScopeOption> の既定値でかつ最もよく使用される値は <xref:System.Transactions.TransactionScopeOption.Required> ですが、その他の各値にはそれぞれ固有の用途があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-191">Although the default and most commonly used value of <xref:System.Transactions.TransactionScopeOption> is <xref:System.Transactions.TransactionScopeOption.Required>, each of the other values has its unique purpose.</span></span>  

### <a name="non-transactional-code-inside-a-transaction-scope"></a><span data-ttu-id="e1583-192">トランザクション スコープ内の非トランザクション コード</span><span class="sxs-lookup"><span data-stu-id="e1583-192">Non-transactional code inside a transaction scope</span></span>

 <span data-ttu-id="e1583-193"><xref:System.Transactions.TransactionScopeOption.Suppress> は、コード セクションによって実行されている操作を保持する必要があり、操作が失敗した場合にアンビエント トランザクションを中止したくない場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="e1583-193"><xref:System.Transactions.TransactionScopeOption.Suppress> is useful when you want to preserve the operations performed by the code section, and do not want to abort the ambient transaction if the operations fail.</span></span> <span data-ttu-id="e1583-194">たとえば、ログの記録や監査操作を実行する場合や、アンビエント トランザクションがコミットしても中止してもサブスクライバーにイベントを公開する場合などです。</span><span class="sxs-lookup"><span data-stu-id="e1583-194">For example, when you want to perform logging or audit operations, or when you want to publish events to subscribers regardless of whether your ambient transaction commits or aborts.</span></span> <span data-ttu-id="e1583-195">次の例で示すように、この値を使用すれば、トランザクション スコープ内に非トランザクション コード セクションを置くことができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-195">This value allows you to have a non-transactional code section inside a transaction scope, as shown in the following example.</span></span>  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())
{
    try
    {
        //Start of non-transactional section
        using(TransactionScope scope2 = new
            TransactionScope(TransactionScopeOption.Suppress))  
        {  
            //Do non-transactional work here  
        }  
        //Restores ambient transaction here
   }
   catch {}  
   //Rest of scope1
}
```  
  
### <a name="voting-inside-a-nested-scope"></a><span data-ttu-id="e1583-196">入れ子になったスコープ内での選択</span><span class="sxs-lookup"><span data-stu-id="e1583-196">Voting inside a nested scope</span></span>  

 <span data-ttu-id="e1583-197">入れ子になったスコープはルート スコープのアンビエント トランザクションに参加できますが、入れ子になったスコープ内で <xref:System.Transactions.TransactionScope.Complete%2A> を呼び出してもルート スコープには影響がありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-197">Although a nested scope can join the ambient transaction of the root scope, calling <xref:System.Transactions.TransactionScope.Complete%2A> in the nested scope has no affect on the root scope.</span></span> <span data-ttu-id="e1583-198">ルート スコープから、入れ子になった最後のスコープまで、すべてのスコープがトランザクションのコミットを選択した場合にのみ、トランザクションはコミットされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-198">Only if all the scopes from the root scope down to the last nested scope vote to commit the transaction, will the transaction be committed.</span></span> <span data-ttu-id="e1583-199">入れ子になったスコープで <xref:System.Transactions.TransactionScope.Complete%2A> を呼び出さないと、アンビエント トランザクションが即時に中止されるため、ルート スコープに影響します。</span><span class="sxs-lookup"><span data-stu-id="e1583-199">Not calling <xref:System.Transactions.TransactionScope.Complete%2A> in a nested scope will affect the root scope as the ambient transaction will immediately be aborted.</span></span>  
  
## <a name="setting-the-transactionscope-timeout"></a><span data-ttu-id="e1583-200">TransactionScope タイムアウトの設定</span><span class="sxs-lookup"><span data-stu-id="e1583-200">Setting the TransactionScope timeout</span></span>  

 <span data-ttu-id="e1583-201"><xref:System.Transactions.TransactionScope> のオーバーロードされたコンストラクターのいくつかは、トランザクションのタイムアウトを制御するために使用される <xref:System.TimeSpan> 型の値を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="e1583-201">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a value of type <xref:System.TimeSpan>, which is used to control the timeout of the transaction.</span></span> <span data-ttu-id="e1583-202">タイムアウトをゼロに設定すると、タイムアウトは無期限になります。</span><span class="sxs-lookup"><span data-stu-id="e1583-202">A timeout set to zero means an infinite timeout.</span></span> <span data-ttu-id="e1583-203">無期限のタイムアウトは主にデバッグに役立ちます。つまり、コードをステップ実行することによってビジネス ロジックの問題を切り分け、問題の究明を試みている間はデバッグするトランザクションがタイムアウトにならないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-203">Infinite timeout is useful mostly for debugging, when you want to isolate a problem in your business logic by stepping through your code, and you do not want the transaction you debug to time out while you attempt to locate the problem.</span></span> <span data-ttu-id="e1583-204">タイムアウト値を無期限にすると、トランザクションのデッドロックに対する保護機能がオーバーライドされるため、上記以外の目的でこれを使用する場合は十分注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-204">Be extremely careful using the infinite timeout value in all other cases, because it overrides the safeguards against transaction deadlocks.</span></span>  
  
 <span data-ttu-id="e1583-205">次の 2 つの場合は、通常、<xref:System.Transactions.TransactionScope> タイムアウトを既定以外の値に設定します。</span><span class="sxs-lookup"><span data-stu-id="e1583-205">You typically set the <xref:System.Transactions.TransactionScope> timeout to values other than default in two cases.</span></span> <span data-ttu-id="e1583-206">第 1 は、開発時に、中止されたトランザクションをアプリケーションがどう処理するかをテストする場合です。</span><span class="sxs-lookup"><span data-stu-id="e1583-206">The first is during development, when you want to test the way your application handles aborted transactions.</span></span> <span data-ttu-id="e1583-207">タイムアウトを小さい値 (1 ミリ秒など) に設定すると、トランザクションが失敗するため、エラー処理コードを確認できます。</span><span class="sxs-lookup"><span data-stu-id="e1583-207">By setting the timeout to a small value (such as one millisecond), you cause your transaction to fail and can thus observe your error handling code.</span></span> <span data-ttu-id="e1583-208">第 2 は、スコープがリソース競合に関与した結果、デッドロックの発生が考えられるときに、既定のタイムアウト値より小さい値に設定する場合です。</span><span class="sxs-lookup"><span data-stu-id="e1583-208">The second case in which you set the value to be less than the default timeout is when you believe that the scope is involved in resource contention, resulting in deadlocks.</span></span> <span data-ttu-id="e1583-209">この場合は、できるだけ早くトランザクションを中止して、既定のタイムアウトが満了するのを待ちません。</span><span class="sxs-lookup"><span data-stu-id="e1583-209">In that case, you want to abort the transaction as soon as possible and not wait for the default timeout to expire.</span></span>  
  
 <span data-ttu-id="e1583-210">アンビエント トランザクションに参加するスコープが、アンビエント トランザクションのタイムアウト設定値より小さいタイムアウト値を指定すると、<xref:System.Transactions.TransactionScope> オブジェクトに対して、後から指定した短い方のタイムアウトが適用され、スコープは指定した時間内に終了する必要があります。終了しない場合、トランザクションは自動的に中止されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-210">When a scope joins an ambient transaction but specifies a smaller timeout than the one the ambient transaction is set to, the new, shorter timeout is enforced on the <xref:System.Transactions.TransactionScope> object, and the scope must end within the nested time specified, or the transaction is automatically aborted.</span></span> <span data-ttu-id="e1583-211">入れ子になったスコープのタイムアウトがアンビエント トランザクションのタイムアウトより長い場合は、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="e1583-211">If the nested scope's timeout is more than that of the ambient transaction, it has no effect.</span></span>  
  
## <a name="setting-the-transactionscope-isolation-level"></a><span data-ttu-id="e1583-212">TransactionScope 分離レベルの設定</span><span class="sxs-lookup"><span data-stu-id="e1583-212">Setting the TransactionScope isolation level</span></span>  

 <span data-ttu-id="e1583-213"><xref:System.Transactions.TransactionScope> のオーバーロードされたコンストラクターのいくつかは、タイムアウト値の他にも、分離レベルを指定する <xref:System.Transactions.TransactionOptions> 型の構造体を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="e1583-213">Some of the overloaded constructors of <xref:System.Transactions.TransactionScope> accept a structure of type <xref:System.Transactions.TransactionOptions> to specify an isolation level, in addition to a timeout value.</span></span> <span data-ttu-id="e1583-214">既定では、トランザクションは <xref:System.Transactions.IsolationLevel.Serializable> に設定された分離レベルで実行されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-214">By default, the transaction executes with isolation level set to <xref:System.Transactions.IsolationLevel.Serializable>.</span></span> <span data-ttu-id="e1583-215"><xref:System.Transactions.IsolationLevel.Serializable> 以外の分離レベルは、読み取り集中型のシステムの場合によく使用されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-215">Selecting an isolation level other than <xref:System.Transactions.IsolationLevel.Serializable> is commonly used for read-intensive systems.</span></span> <span data-ttu-id="e1583-216">そのためには、トランザクション処理理論とトランザクション自体の動作、関連するコンカレンシーの問題、およびシステム整合性の影響をよく理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-216">This requires a solid understanding of transaction processing theory and the semantics of the transaction itself, the concurrency issues involved, and the consequences for system consistency.</span></span>  
  
 <span data-ttu-id="e1583-217">さらに、すべてのリソース マネージャーがすべての分離レベルをサポートするわけではなく、構成されたレベルより高いレベルのトランザクションへの参加をリソース マネージャーが選択する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="e1583-217">In addition, not all resource managers support all levels of isolation, and they may elect to take part in the transaction at a higher level than the one configured.</span></span>  
  
 <span data-ttu-id="e1583-218"><xref:System.Transactions.IsolationLevel.Serializable> を除くすべての分離レベルは、他のトランザクションが同じ情報にアクセスすることで生じる不整合の影響を受けやすくなっています。</span><span class="sxs-lookup"><span data-stu-id="e1583-218">Every isolation level besides <xref:System.Transactions.IsolationLevel.Serializable> is susceptible to inconsistency resulting from other transactions accessing the same information.</span></span> <span data-ttu-id="e1583-219">分離レベルごとの違いは、読み取りロックおよび書き込みロックの使用方法にあります。</span><span class="sxs-lookup"><span data-stu-id="e1583-219">The difference between the different isolation levels is in the way read and write locks are used.</span></span> <span data-ttu-id="e1583-220">ロックには、トランザクションがリソース マネージャーのデータにアクセスするときのみ保持できるか、トランザクションがコミットまたは中止されるまで保持できるかの 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-220">A lock can be held only when the transaction accesses the data in the resource manager, or it can be held until the transaction is committed or aborted.</span></span> <span data-ttu-id="e1583-221">前者はスループットの面で優れており、後者は整合性の面で優れています。</span><span class="sxs-lookup"><span data-stu-id="e1583-221">The former is better for throughput, the latter for consistency.</span></span> <span data-ttu-id="e1583-222">2 種類のロックと 2 種類の操作 (読み取り/書き込み) から、4 つの基本分離レベルが構成されます。</span><span class="sxs-lookup"><span data-stu-id="e1583-222">The two kinds of locks and the two kinds of operations (read/write) give four basic isolation levels.</span></span> <span data-ttu-id="e1583-223">詳細については、「<xref:System.Transactions.IsolationLevel>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e1583-223">See <xref:System.Transactions.IsolationLevel> for more information.</span></span>  
  
 <span data-ttu-id="e1583-224">入れ子になった <xref:System.Transactions.TransactionScope> オブジェクトを使用する場合、入れ子になったすべてのスコープがアンビエント トランザクションに参加するときには、必ず同じ分離レベルを使用するようにそれらのスコープを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e1583-224">When using nested <xref:System.Transactions.TransactionScope> objects, all nested scopes must be configured to use exactly the same isolation level if they want to join the ambient transaction.</span></span> <span data-ttu-id="e1583-225">入れ子になった <xref:System.Transactions.TransactionScope> オブジェクトがアンビエント トランザクションに参加するときに、別の分離レベルが指定された場合は、<xref:System.ArgumentException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e1583-225">If a nested <xref:System.Transactions.TransactionScope> object tries to join the ambient transaction yet it specifies a different isolation level, an <xref:System.ArgumentException> is thrown.</span></span>  
  
## <a name="interop-with-com"></a><span data-ttu-id="e1583-226">COM+ との相互運用</span><span class="sxs-lookup"><span data-stu-id="e1583-226">Interop with COM+</span></span>  

 <span data-ttu-id="e1583-227">新しい <xref:System.Transactions.TransactionScope> インスタンスを作成する際には、いずれかのコンストラクターで <xref:System.Transactions.EnterpriseServicesInteropOption> 列挙体を使用して、COM+ との対話方法を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="e1583-227">When you create a new <xref:System.Transactions.TransactionScope> instance, you can use the <xref:System.Transactions.EnterpriseServicesInteropOption> enumeration in one of the constructors to specify how to interact with COM+.</span></span> <span data-ttu-id="e1583-228">詳しくは、「[Enterprise Services および COM+ トランザクションとの相互運用性](interoperability-with-enterprise-services-and-com-transactions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="e1583-228">For more information on this, see [Interoperability with Enterprise Services and COM+ Transactions](interoperability-with-enterprise-services-and-com-transactions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e1583-229">関連項目</span><span class="sxs-lookup"><span data-stu-id="e1583-229">See also</span></span>

- <xref:System.Transactions.Transaction.Clone%2A>
- <xref:System.Transactions.TransactionScope>
