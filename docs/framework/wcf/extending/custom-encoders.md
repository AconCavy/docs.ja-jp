---
title: カスタム エンコーダー
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: c2ad0c947afd293d0923faa3e9d914b6911ce941
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/26/2020
ms.locfileid: "96254780"
---
# <a name="custom-encoders"></a><span data-ttu-id="343d4-102">カスタム エンコーダー</span><span class="sxs-lookup"><span data-stu-id="343d4-102">Custom Encoders</span></span>

<span data-ttu-id="343d4-103">このトピックでは、カスタム エンコーダーを作成する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="343d4-103">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="343d4-104">Windows Communication Foundation (WCF) では、 *バインディング* を使用して、エンドポイント間でネットワーク経由でデータを転送する方法を指定します。</span><span class="sxs-lookup"><span data-stu-id="343d4-104">In Windows Communication Foundation (WCF), you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="343d4-105">バインディングは、 *バインド要素* のシーケンスで構成されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-105">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="343d4-106">バインディングには、セキュリティ、必須の *メッセージエンコーダー* のバインド要素、必須のトランスポートバインド要素など、オプションのプロトコルバインド要素が含まれます。</span><span class="sxs-lookup"><span data-stu-id="343d4-106">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="343d4-107">メッセージ エンコーダーは、メッセージ エンコーディング バインド要素で表されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-107">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="343d4-108">WCF には、バイナリ、メッセージ伝送最適化メカニズム (MTOM)、テキストという3つのメッセージエンコーダーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="343d4-108">Three message encoders are included in WCF: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="343d4-109">メッセージ エンコーディング バインド要素は、送信する <xref:System.ServiceModel.Channels.Message> をシリアル化してそれをトランスポートに渡すか、シリアル化された形式のメッセージをトランスポートから受信して、それをプロトコル層 (ある場合) またはアプリケーション (プロトコル層がない場合) に渡します。</span><span class="sxs-lookup"><span data-stu-id="343d4-109">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="343d4-110">メッセージ エンコーダーは、<xref:System.ServiceModel.Channels.Message> インスタンスと物理メッセージ形式を相互に変換します。</span><span class="sxs-lookup"><span data-stu-id="343d4-110">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="343d4-111">エンコーダーは、チャネル スタックのトランスポート層の上に位置すると説明されていますが、トランスポート層の内部に存在します。</span><span class="sxs-lookup"><span data-stu-id="343d4-111">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="343d4-112">トランスポート (HTTP など) は、トランスポート標準の要件に従ってメッセージの書式設定を行います。</span><span class="sxs-lookup"><span data-stu-id="343d4-112">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="343d4-113">エンコーダー (テキスト XML など) は、単にメッセージのエンコードを行います。</span><span class="sxs-lookup"><span data-stu-id="343d4-113">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="343d4-114">既存のクライアントまたはサーバーに接続する場合、特定のメッセージ エンコーディングを使用する選択ができない場合があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-114">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="343d4-115">ただし、WCF サービスは、それぞれが異なるメッセージエンコーダーを持つ複数のエンドポイントを介してアクセスできるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="343d4-115">However, WCF services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="343d4-116">1 つのエンコーダーでサービスの対象ユーザー全体を網羅しない場合、複数のエンドポイントにサービスを公開することを検討します。</span><span class="sxs-lookup"><span data-stu-id="343d4-116">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="343d4-117">これによりクライアント アプリケーションはそのアプリケーションに最も適したエンドポイントを選択できます。</span><span class="sxs-lookup"><span data-stu-id="343d4-117">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="343d4-118">複数のエンドポイントを使用することにより、さまざまなメッセージ エンコーダーの利点を他のバインド要素と組み合わせることが可能になります。</span><span class="sxs-lookup"><span data-stu-id="343d4-118">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="343d4-119">システム指定のエンコーダー</span><span class="sxs-lookup"><span data-stu-id="343d4-119">System-Provided Encoders</span></span>  

 <span data-ttu-id="343d4-120">WCF には、最も一般的なアプリケーションシナリオに対応するように設計された、システム指定のバインディングがいくつか用意されています。</span><span class="sxs-lookup"><span data-stu-id="343d4-120">WCF provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="343d4-121">これらのバインディングは、それぞれトランスポート、メッセージ エンコーダー、その他のオプション (セキュリティなど) を組み合わせます。</span><span class="sxs-lookup"><span data-stu-id="343d4-121">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="343d4-122">このトピック `Text` では、 `Binary` WCF に含まれる、、およびメッセージエンコーダーを拡張する方法、または独自のカスタムエンコーダーを作成する方法について説明し `MTOM` ます。</span><span class="sxs-lookup"><span data-stu-id="343d4-122">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in WCF, or create your own custom encoder.</span></span> <span data-ttu-id="343d4-123">テキスト メッセージ エンコーダーは、通常の XML のエンコーディングに加えて、SOAP のエンコーディングもサポートします。</span><span class="sxs-lookup"><span data-stu-id="343d4-123">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="343d4-124">テキスト メッセージ エンコーダーの通常の XML エンコーディング モードは、テキスト ベースの SOAP エンコーディングと区別するために、POX ("Plain Old XML") エンコーダーと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="343d4-124">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 <span data-ttu-id="343d4-125">システム指定のバインディングによって提供されるバインド要素の組み合わせの詳細については、「 [トランスポートの選択](../feature-details/choosing-a-transport.md)」の対応するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="343d4-125">For more information about the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="343d4-126">システム標準のエンコーダーの操作方法</span><span class="sxs-lookup"><span data-stu-id="343d4-126">How to Work with System-Provided Encoders</span></span>  

 <span data-ttu-id="343d4-127">エンコーディングは、<xref:System.ServiceModel.Channels.MessageEncodingBindingElement> からの派生クラスを使用してバインディングに追加します。</span><span class="sxs-lookup"><span data-stu-id="343d4-127">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 <span data-ttu-id="343d4-128">WCF には、 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> テキスト、バイナリ、およびメッセージ伝送最適化機構 (MTOM) のエンコーディングに使用できるクラスから派生した次の種類のバインド要素が用意されています。</span><span class="sxs-lookup"><span data-stu-id="343d4-128">WCF provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
- <span data-ttu-id="343d4-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> : 相互運用性は最も高く、効率は最も低い、XML メッセージ用のエンコーダー。</span><span class="sxs-lookup"><span data-stu-id="343d4-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="343d4-130">Web サービスまたは Web サービス クライアントは、一般に、テキスト形式の XML を認識できます。</span><span class="sxs-lookup"><span data-stu-id="343d4-130">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="343d4-131">ただし、大きいブロックのバイナリ データをテキストとして転送するのは効率的ではありません。</span><span class="sxs-lookup"><span data-stu-id="343d4-131">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
- <span data-ttu-id="343d4-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> : バイナリベースの XML メッセージで使用される、文字エンコーディングおよびメッセージのバージョン管理を指定するバインド要素を表します。</span><span class="sxs-lookup"><span data-stu-id="343d4-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="343d4-133">これは、最も効率的なエンコードオプションですが、WCF エンドポイントでのみサポートされているため、相互運用性は最も少なくなります。</span><span class="sxs-lookup"><span data-stu-id="343d4-133">This is most efficient of the encoding options, but the least interoperable, because it is only supported by WCF endpoints.</span></span>  
  
- <span data-ttu-id="343d4-134"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> : Message Transmission Optimization Mechanism (MTOM) エンコードを使用するメッセージの文字エンコードおよびメッセージ バージョン管理を指定するバインド要素を表します。</span><span class="sxs-lookup"><span data-stu-id="343d4-134"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="343d4-135">MTOM は、WCF メッセージでバイナリ データを転送するための効率的なテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="343d4-135">MTOM is an efficient technology for transmitting binary data in WCF messages.</span></span> <span data-ttu-id="343d4-136">MTOM エンコーダーは、効率と相互運用性のバランスをとろうとします。</span><span class="sxs-lookup"><span data-stu-id="343d4-136">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="343d4-137">MTOM エンコーディングは、ほとんどの XML をテキスト形式で転送しますが、大きいサイズのバイナリ データ ブロックはテキストに変換せずにそのまま転送することによって最適化します。</span><span class="sxs-lookup"><span data-stu-id="343d4-137">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="343d4-138">バインド要素は、バイナリ、MTOM、またはテキストの <xref:System.ServiceModel.Channels.MessageEncoderFactory> を作成します。</span><span class="sxs-lookup"><span data-stu-id="343d4-138">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="343d4-139">ファクトリは、バイナリ、MTOM、またはテキストの <xref:System.ServiceModel.Channels.MessageEncoderFactory> を作成します。</span><span class="sxs-lookup"><span data-stu-id="343d4-139">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="343d4-140">通常、インスタンスは 1 つだけあります。</span><span class="sxs-lookup"><span data-stu-id="343d4-140">Typically, there is only a single instance.</span></span> <span data-ttu-id="343d4-141">ただし、セッションを使用すると、異なるエンコーダーを各セッションに提供できます。</span><span class="sxs-lookup"><span data-stu-id="343d4-141">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="343d4-142">バイナリ エンコーダーでは、これを利用して動的ディクショナリ (XML インフラストラクチャを参照) を調整します。</span><span class="sxs-lookup"><span data-stu-id="343d4-142">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="343d4-143"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> メソッドと <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> メソッドは、エンコーダーのコアです。</span><span class="sxs-lookup"><span data-stu-id="343d4-143">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="343d4-144">このメソッドは、ストリームまたは <xref:System.Byte> 配列からのメッセージの読み取りに対応します。</span><span class="sxs-lookup"><span data-stu-id="343d4-144">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="343d4-145">バイト配列は、トランスポートをバッファー モードで操作している場合に使用されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-145">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="343d4-146">メッセージはストリームに常に書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="343d4-146">Messages are always written to streams.</span></span> <span data-ttu-id="343d4-147">トランスポートでメッセージをバッファーする必要がある場合は、バッファリングを行うストリームが提供されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-147">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="343d4-148">残りのメンバーは、サポート コンテンツ、メディア タイプ、および <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A> を処理します。</span><span class="sxs-lookup"><span data-stu-id="343d4-148">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="343d4-149">トランスポートは、このエンコーダー メソッドを呼び出して、受信メッセージがデコード可能かどうかをテストするか、または送信メッセージがこのエンコーダーに対して有効かどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="343d4-149">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="343d4-150">3 つのそれぞれのエンコーダー実装は、特定のエンコーディングに関連するプロパティを追加し、完全に構成可能です。</span><span class="sxs-lookup"><span data-stu-id="343d4-150">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="343d4-151">また、エンコーダーは、安全な既定値を持つリーダーのクォータも公開しています。</span><span class="sxs-lookup"><span data-stu-id="343d4-151">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="343d4-152">クォータの詳細については、XML インフラストラクチャを参照してください。</span><span class="sxs-lookup"><span data-stu-id="343d4-152">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="343d4-153">システム標準のエンコーダーの機能</span><span class="sxs-lookup"><span data-stu-id="343d4-153">Features of System-Provided Encoders</span></span>  

 <span data-ttu-id="343d4-154">システム標準のエンコーダーは多くの機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="343d4-154">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="343d4-155">Pooling</span><span class="sxs-lookup"><span data-stu-id="343d4-155">Pooling</span></span>  

 <span data-ttu-id="343d4-156">各エンコーダー実装は、可能な限りプールを試みます。</span><span class="sxs-lookup"><span data-stu-id="343d4-156">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="343d4-157">マネージド コードのパフォーマンスを向上するには、割り当てを減らすことが重要です。</span><span class="sxs-lookup"><span data-stu-id="343d4-157">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="343d4-158">このプールを実現するには、実装で `SynchronizedPool` クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="343d4-158">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="343d4-159">C# ファイルには、このクラスで使用する追加の最適化に関する記述を含めます。</span><span class="sxs-lookup"><span data-stu-id="343d4-159">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="343d4-160">メッセージごとに新しい <xref:System.Xml.XmlDictionaryReader> および <xref:System.Xml.XmlDictionaryWriter> インスタンスを割り当てるのを避けるため、これらのインスタンスをプールして再初期化します。</span><span class="sxs-lookup"><span data-stu-id="343d4-160"><xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="343d4-161">リーダーについては、`OnClose` の呼び出し時に `Close()` コールバックでリーダーが再利用されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-161">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="343d4-162">また、エンコーダーでは、メッセージを作成するときに使用するいくつかのメッセージ状態オブジェクトが再利用されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-162">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="343d4-163">このプールのサイズは、`MaxReadPoolSize` から派生した 3 つの各クラスの `MaxWritePoolSize` プロパティと <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> プロパティによって構成可能です。</span><span class="sxs-lookup"><span data-stu-id="343d4-163">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="343d4-164">バイナリ エンコーディング</span><span class="sxs-lookup"><span data-stu-id="343d4-164">Binary Encoding</span></span>  

 <span data-ttu-id="343d4-165">バイナリ エンコーディングでセッションを使用する場合、動的ディクショナリの文字列をメッセージの受信者と通信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-165">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="343d4-166">これを行うには、メッセージのプレフィックスに動的ディクショナリの文字列を指定します。</span><span class="sxs-lookup"><span data-stu-id="343d4-166">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="343d4-167">受信側では、その文字列を取り除いて、セッションに追加し、メッセージ処理を行います。</span><span class="sxs-lookup"><span data-stu-id="343d4-167">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="343d4-168">ディクショナリの文字列を正しく渡すには、トランスポートをバッファーする必要があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-168">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="343d4-169">文字列は、内部 `AddSessionInformationToMessage` メソッドによってメッセージに追加されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-169">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="343d4-170">文字列は、メッセージの先頭に UTF-8 として追加され、その長さがプレフィックスに指定されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-170">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="343d4-171">次にディクショナリ ヘッダー全体のプレフィックスにそのデータ長が指定されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-171">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="343d4-172">内部 `ExtractSessionInformationFromMessage` メソッドにより逆操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-172">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="343d4-173">動的ディクショナリ キーの処理に加え、バッファーされセッションの多いメッセージが独自の方法で受信されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-173">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="343d4-174">ドキュメントでリーダーを作成して処理する代わりに、バイナリ エンコーダーは、内部 `MessagePatterns` クラスを使用してバイナリ ストリームを分解します。</span><span class="sxs-lookup"><span data-stu-id="343d4-174">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="343d4-175">概念として、ほとんどのメッセージには、WCF によって生成されたときに特定の順序で表示される特定のヘッダーのセットがあります。</span><span class="sxs-lookup"><span data-stu-id="343d4-175">The idea is that most messages have a certain set of headers that show up in a certain order when generated by WCF.</span></span> <span data-ttu-id="343d4-176">想定を基にしたパターン システムによりメッセージは分割されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-176">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="343d4-177">成功した場合は、XML の解析を行わずに <xref:System.ServiceModel.Channels.MessageHeaders> オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="343d4-177">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="343d4-178">成功しなかった場合は、標準の方法に戻ります。</span><span class="sxs-lookup"><span data-stu-id="343d4-178">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="343d4-179">MTOM エンコーディング</span><span class="sxs-lookup"><span data-stu-id="343d4-179">MTOM Encoding</span></span>  

 <span data-ttu-id="343d4-180"><xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> クラスには、<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A> という追加の構成プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="343d4-180">The <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> class has an additional configuration property called <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>.</span></span> <span data-ttu-id="343d4-181">これには、メッセージ読み取り中にバッファーできるデータ量の上限が設けられています。</span><span class="sxs-lookup"><span data-stu-id="343d4-181">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="343d4-182">すべての MIME パートを 1 つのメッセージに再アセンブルするために、XML 情報セット (Infoset) または他の MIME パートをバッファーすることが必要な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="343d4-182">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="343d4-183">HTTP を正しく操作するために、内部 MTOM メッセージ エンコーダーのクラスでは、`GetContentType` (内部) や `WriteMessage` (パブリックで、オーバーライド可能) の内部 API がいくつか用意されています。</span><span class="sxs-lookup"><span data-stu-id="343d4-183">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="343d4-184">HTTP ヘッダーの値を MIME ヘッダーの値と一致させるには、多くの通信を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-184">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="343d4-185">内部的には、MTOM メッセージエンコーダーは、WCF のテキストリーダーを使用します。これは、テキストエンコーダーに似ています。</span><span class="sxs-lookup"><span data-stu-id="343d4-185">Internally, the MTOM message encoder uses WCF's text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="343d4-186">主な違いは、Base-64 エンコーディングに変換せずにメッセージ バイトに埋め込むことで、大きいサイズのバイナリ (バイナリ ラージ オブジェクト (BLOB) と呼びます) を最適化する点です。</span><span class="sxs-lookup"><span data-stu-id="343d4-186">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="343d4-187">代わりに、この BLOB は抽出され、MIME 添付として参照されます。</span><span class="sxs-lookup"><span data-stu-id="343d4-187">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="343d4-188">独自のエンコーダーの作成</span><span class="sxs-lookup"><span data-stu-id="343d4-188">Writing your own Encoder</span></span>  

 <span data-ttu-id="343d4-189">独自のカスタム メッセージ エンコーダーを実装するには、次の抽象基本クラスのカスタム実装を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-189">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
- <xref:System.ServiceModel.Channels.MessageEncoder>  
  
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="343d4-190">メッセージのメモリ内表現からストリームに書き込むことのできる表現への変換は、 <xref:System.ServiceModel.Channels.MessageEncoder> クラスにカプセル化されており、このクラスは、特定の種類の XML エンコーディングをサポートする XML リーダーおよび XML ライターに対するファクトリとして機能します。</span><span class="sxs-lookup"><span data-stu-id="343d4-190">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
- <span data-ttu-id="343d4-191">オーバーライドを必要とする、このクラスの主要なメソッドを次に示します。</span><span class="sxs-lookup"><span data-stu-id="343d4-191">The key methods of this class that you must override are:</span></span>  
  
- <span data-ttu-id="343d4-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>。<xref:System.ServiceModel.Channels.MessageEncodingBindingElement> オブジェクトを受け取り、それを <xref:System.IO.Stream> オブジェクトに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="343d4-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
- <span data-ttu-id="343d4-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>。<xref:System.IO.Stream> オブジェクトと最大ヘッダー サイズを受け取り、<xref:System.ServiceModel.Channels.Message> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="343d4-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="343d4-194">これらのメソッドに記述するコードは、標準トランスポート プロトコルとカスタマイズしたエンコーディングの間の変換処理です。</span><span class="sxs-lookup"><span data-stu-id="343d4-194">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="343d4-195">次に、カスタム エンコーダーを作成するファクトリ クラスをコーディングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="343d4-195">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="343d4-196"><xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> をオーバーライドして、独自のカスタム <xref:System.ServiceModel.Channels.MessageEncoder> のインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="343d4-196">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="343d4-197">次に、<xref:System.ServiceModel.Channels.MessageEncoderFactory> メソッドをオーバーライドしてこのファクトリのインスタンスを返すようにすることで、サービスまたはクライアントの構成に使用されるバインド要素スタックにカスタム <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> を接続します。</span><span class="sxs-lookup"><span data-stu-id="343d4-197">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="343d4-198">WCF に用意されている、 [カスタムメッセージエンコーダー: カスタムテキストエンコーダー](../samples/custom-message-encoder-custom-text-encoder.md) とカスタム [メッセージエンコーダー: 圧縮エンコーダー](../samples/custom-message-encoder-compression-encoder.md)の2つのサンプルが用意されています。</span><span class="sxs-lookup"><span data-stu-id="343d4-198">There are two samples provided with WCF that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="343d4-199">関連項目</span><span class="sxs-lookup"><span data-stu-id="343d4-199">See also</span></span>

- <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>
- <xref:System.ServiceModel.Channels.MessageEncoderFactory>
- <xref:System.ServiceModel.Channels.MessageEncoder>
- [<span data-ttu-id="343d4-200">データ転送のアーキテクチャの概要</span><span class="sxs-lookup"><span data-stu-id="343d4-200">Data Transfer Architectural Overview</span></span>](../feature-details/data-transfer-architectural-overview.md)
- [<span data-ttu-id="343d4-201">メッセージ エンコーダーを選択する</span><span class="sxs-lookup"><span data-stu-id="343d4-201">Choosing a Message Encoder</span></span>](../feature-details/choosing-a-message-encoder.md)
- [<span data-ttu-id="343d4-202">トランスポートの選択</span><span class="sxs-lookup"><span data-stu-id="343d4-202">Choosing a Transport</span></span>](../feature-details/choosing-a-transport.md)
