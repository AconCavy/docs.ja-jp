---
title: サービス コントラクトの設計
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- service contracts [WCF]
ms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd
ms.openlocfilehash: 27f867bbf079c2e202d93425ddb951fc0df7784a
ms.sourcegitcommit: 628e8147ca10187488e6407dab4c4e6ebe0cac47
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/15/2019
ms.locfileid: "72318382"
---
# <a name="designing-service-contracts"></a><span data-ttu-id="fc9da-102">サービス コントラクトの設計</span><span class="sxs-lookup"><span data-stu-id="fc9da-102">Designing Service Contracts</span></span>
<span data-ttu-id="fc9da-103">ここでは、サービス コントラクトの概要、定義方法、使用できる操作 (および基になるメッセージ交換の影響)、使用するデータ型、およびシナリオの要件を満たす操作を設計する際に役立つその他の問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-103">This topic describes what service contracts are, how they are defined, what operations are available (and the implications for the underlying message exchanges), what data types are used, and other issues that help you design operations that satisfy the requirements of your scenario.</span></span>  
  
## <a name="creating-a-service-contract"></a><span data-ttu-id="fc9da-104">サービス コントラクトの作成</span><span class="sxs-lookup"><span data-stu-id="fc9da-104">Creating a Service Contract</span></span>  
 <span data-ttu-id="fc9da-105">サービスは複数の操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-105">Services expose a number of operations.</span></span> <span data-ttu-id="fc9da-106">Windows Communication Foundation (WCF) アプリケーションでは、メソッドを作成し、<xref:System.ServiceModel.OperationContractAttribute> 属性を使用して操作を定義します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-106">In Windows Communication Foundation (WCF) applications, define the operations by creating a method and marking it with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="fc9da-107">次に、サービス コントラクトを作成するために、<xref:System.ServiceModel.ServiceContractAttribute> 属性でマークされたインターフェイス内で操作を宣言するか、この属性でマークされたクラス内で操作を定義することにより、操作をグループ化します</span><span class="sxs-lookup"><span data-stu-id="fc9da-107">Then, to create a service contract, group together your operations, either by declaring them within an interface marked with the <xref:System.ServiceModel.ServiceContractAttribute> attribute, or by defining them in a class marked with the same attribute.</span></span> <span data-ttu-id="fc9da-108">(基本的な例については、「[方法: サービスコントラクトを定義](how-to-define-a-wcf-service-contract.md)する」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="fc9da-108">(For a basic example, see [How to: Define a Service Contract](how-to-define-a-wcf-service-contract.md).)</span></span>  
  
 <span data-ttu-id="fc9da-109"><xref:System.ServiceModel.OperationContractAttribute> 属性を持たないメソッドはサービス操作ではなく、WCF サービスによって公開されません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-109">Any methods that do not have a <xref:System.ServiceModel.OperationContractAttribute> attribute are not service operations and are not exposed by WCF services.</span></span>  
  
 <span data-ttu-id="fc9da-110">ここでは、サービス コントラクトの設計時に決定すべき以下のポイントについて説明します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-110">This topic describes the following decision points when designing a service contract:</span></span>  
  
- <span data-ttu-id="fc9da-111">クラスとインターフェイスのどちらを使用するか</span><span class="sxs-lookup"><span data-stu-id="fc9da-111">Whether to use classes or interfaces.</span></span>  
  
- <span data-ttu-id="fc9da-112">交換するデータ型の指定方法</span><span class="sxs-lookup"><span data-stu-id="fc9da-112">How to specify the data types you want to exchange.</span></span>  
  
- <span data-ttu-id="fc9da-113">使用できる交換パターンの種類</span><span class="sxs-lookup"><span data-stu-id="fc9da-113">The types of exchange patterns you can use.</span></span>  
  
- <span data-ttu-id="fc9da-114">コントラクトのセキュリティ要件の部分を明示的に作成できるかどうか</span><span class="sxs-lookup"><span data-stu-id="fc9da-114">Whether you can make explicit security requirements part of the contract.</span></span>  
  
- <span data-ttu-id="fc9da-115">操作の入力と出力の制限</span><span class="sxs-lookup"><span data-stu-id="fc9da-115">The restrictions for operation inputs and outputs.</span></span>  
  
## <a name="classes-or-interfaces"></a><span data-ttu-id="fc9da-116">クラスとインターフェイス</span><span class="sxs-lookup"><span data-stu-id="fc9da-116">Classes or Interfaces</span></span>  
 <span data-ttu-id="fc9da-117">クラスとインターフェイスはどちらも機能のグループ化を表し、その両方を使用して WCF サービスコントラクトを定義できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-117">Both classes and interfaces represent a grouping of functionality and, therefore, both can be used to define a WCF service contract.</span></span> <span data-ttu-id="fc9da-118">ただし、インターフェイスはサービス コントラクトを直接モデル化するため、インターフェイスを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fc9da-118">However, it is recommended that you use interfaces because they directly model service contracts.</span></span> <span data-ttu-id="fc9da-119">実装のないインターフェイスは、特定のシグネチャを持つメソッドのグループ化を定義しているにすぎません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-119">Without an implementation, interfaces do no more than define a grouping of methods with certain signatures.</span></span> <span data-ttu-id="fc9da-120">サービスコントラクトインターフェイスを実装し、WCF サービスを実装しました。</span><span class="sxs-lookup"><span data-stu-id="fc9da-120">Implement a service contract interface and you have implemented a WCF service.</span></span>  
  
 <span data-ttu-id="fc9da-121">サービス コントラクト インターフェイスには、次のようにマネージド インターフェイスのあらゆる利点がもたらされます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-121">All the benefits of managed interfaces apply to service contract interfaces:</span></span>  
  
- <span data-ttu-id="fc9da-122">サービス コントラクト インターフェイスでは、他のサービス コントラクト インターフェイスをいくつでも拡張できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-122">Service contract interfaces can extend any number of other service contract interfaces.</span></span>  
  
- <span data-ttu-id="fc9da-123">これらのサービス コントラクト インターフェイスを実装することにより、1 つのクラスでサービス コントラクトをいくつでも実装できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-123">A single class can implement any number of service contracts by implementing those service contract interfaces.</span></span>  
  
- <span data-ttu-id="fc9da-124">インターフェイスの実装を変更することにより、同じサービス コントラクトを引き続き使用したまま、そのコントラクトの実装を変更できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-124">You can modify the implementation of a service contract by changing the interface implementation, while the service contract remains the same.</span></span>  
  
- <span data-ttu-id="fc9da-125">以前のインターフェイスと新しいインターフェイスを実装することで、サービスをバージョン管理できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-125">You can version your service by implementing the old interface and the new one.</span></span> <span data-ttu-id="fc9da-126">以前のクライアントは元のバージョンに接続し、新しいクライアントは新しいバージョンに接続できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-126">Old clients connect to the original version, while newer clients can connect to the newer version.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fc9da-127">他のサービス コントラクト インターフェイスから継承した場合、操作のプロパティ (名前や名前空間など) をオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-127">When inheriting from other service contract interfaces, you cannot override operation properties, such as the name or namespace.</span></span> <span data-ttu-id="fc9da-128">これを行う場合は、現在のサービス コントラクトに新しい操作を作成します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-128">If you attempt to do so, you create a new operation in the current service contract.</span></span>  
  
 <span data-ttu-id="fc9da-129">インターフェイスを使用してサービスコントラクトを作成する例については、「[方法: コントラクトインターフェイスを使用してサービスを作成](./feature-details/how-to-create-a-service-with-a-contract-interface.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-129">For an example of using an interface to create a service contract, see [How to: Create a Service with a Contract Interface](./feature-details/how-to-create-a-service-with-a-contract-interface.md).</span></span>  
  
 <span data-ttu-id="fc9da-130">クラスを使用すると、サービス コントラクトの定義と実装を一度に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-130">You can, however, use a class to define a service contract and implement that contract at the same time.</span></span> <span data-ttu-id="fc9da-131"><xref:System.ServiceModel.ServiceContractAttribute> と <xref:System.ServiceModel.OperationContractAttribute> をそれぞれクラスとクラスのメソッドに直接適用してサービスを作成する方法には、サービスを迅速かつ簡単に作成できるという利点があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-131">The advantage of creating your services by applying <xref:System.ServiceModel.ServiceContractAttribute> and <xref:System.ServiceModel.OperationContractAttribute> directly to the class and the methods on the class, respectively, is speed and simplicity.</span></span> <span data-ttu-id="fc9da-132">欠点は、マネージド クラスでは複数の継承をサポートしていないため、サービス コントラクトを一度に 1 つしか実装できないことです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-132">The disadvantages are that managed classes do not support multiple inheritance, and as a result they can only implement one service contract at a time.</span></span> <span data-ttu-id="fc9da-133">また、クラスまたはメソッド シグネチャに変更を加えると、そのサービスのパブリック コントラクトが変更されるため、変更されていないクライアントがサービスを使用できなくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-133">In addition, any modification to the class or method signatures modifies the public contract for that service, which can prevent unmodified clients from using your service.</span></span> <span data-ttu-id="fc9da-134">詳細については、「[サービスコントラクトの実装](implementing-service-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-134">For more information, see [Implementing Service Contracts](implementing-service-contracts.md).</span></span>  
  
 <span data-ttu-id="fc9da-135">クラスを使用してサービスコントラクトを作成し、同時に実装する例については、「[方法: コントラクトクラスを使用してサービスを作成](./feature-details/how-to-create-a-wcf-contract-with-a-class.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-135">For an example that uses a class to create a service contract and implements it at the same time, see [How to: Create a Service with a Contract Class](./feature-details/how-to-create-a-wcf-contract-with-a-class.md).</span></span>  
  
 <span data-ttu-id="fc9da-136">これで、サービス コントラクトを定義する際に、インターフェイスを使用した場合とクラスを使用した場合の違いがわかりました。</span><span class="sxs-lookup"><span data-stu-id="fc9da-136">At this point, you should understand the difference between defining your service contract by using an interface and by using a class.</span></span> <span data-ttu-id="fc9da-137">次に、サービスとクライアント間で受け渡しできるデータを決定します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-137">The next step is deciding what data can be passed back and forth between a service and its clients.</span></span>  
  
## <a name="parameters-and-return-values"></a><span data-ttu-id="fc9da-138">パラメーターと戻り値</span><span class="sxs-lookup"><span data-stu-id="fc9da-138">Parameters and Return Values</span></span>  
 <span data-ttu-id="fc9da-139">各操作は戻り値とパラメーターを持ちます (戻り値とパラメーターが `void` の場合も含まれます)。</span><span class="sxs-lookup"><span data-stu-id="fc9da-139">Each operation has a return value and a parameter, even if these are `void`.</span></span> <span data-ttu-id="fc9da-140">ただし、オブジェクトへの参照をオブジェクト間で渡すことができるローカル メソッドとは異なり、サービス操作ではオブジェクトへの参照を渡しません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-140">However, unlike a local method, in which you can pass references to objects from one object to another, service operations do not pass references to objects.</span></span> <span data-ttu-id="fc9da-141">代わりに、オブジェクトのコピーを渡します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-141">Instead, they pass copies of the objects.</span></span>  
  
 <span data-ttu-id="fc9da-142">これが重要なのは、パラメーターまたは戻り値で使用される各型がシリアル化可能でなければならないためです。つまり、その型のオブジェクトをバイト ストリームに変換でき、バイト ストリームからオブジェクトに変換できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-142">This is significant because each type used in a parameter or return value must be serializable; that is, it must be possible to convert an object of that type into a stream of bytes and from a stream of bytes into an object.</span></span>  
  
 <span data-ttu-id="fc9da-143">プリミティブ型は既定でシリアル化可能であり、.NET Framework の多くの型も同様です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-143">Primitive types are serializable by default, as are many types in the .NET Framework.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fc9da-144">操作シグネチャのパラメーター名の値はコントラクトに含まれ、大文字と小文字が区別されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-144">The value of the parameter names in the operation signature are part of the contract and are case sensitive.</span></span> <span data-ttu-id="fc9da-145">ローカルでは同じパラメーター名を使用するが、公開されるメタデータでは名前を変更する場合は、<xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-145">If you want to use the same parameter name locally but modify the name in the published metadata, see the <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.</span></span>  
  
#### <a name="data-contracts"></a><span data-ttu-id="fc9da-146">データ コントラクト</span><span class="sxs-lookup"><span data-stu-id="fc9da-146">Data Contracts</span></span>  
 <span data-ttu-id="fc9da-147">Windows Communication Foundation (WCF) アプリケーションなどのサービス指向アプリケーションは、Microsoft と Microsoft 以外の両方のプラットフォームで最も多くのクライアントアプリケーションと相互運用できるように設計されています。</span><span class="sxs-lookup"><span data-stu-id="fc9da-147">Service-oriented applications like Windows Communication Foundation (WCF) applications are designed to interoperate with the widest possible number of client applications on both Microsoft and non-Microsoft platforms.</span></span> <span data-ttu-id="fc9da-148">最大限の相互運用性を実現するために、使用する型を <xref:System.Runtime.Serialization.DataContractAttribute> 属性と <xref:System.Runtime.Serialization.DataMemberAttribute> 属性でマークして、データ コントラクトを作成することをお勧めします。データ コントラクトは、サービス コントラクトの一部であり、サービス操作で交換するデータを記述したものです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-148">For the widest possible interoperability, it is recommended that you mark your types with the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create a data contract, which is the portion of the service contract that describes the data that your service operations exchange.</span></span>  
  
 <span data-ttu-id="fc9da-149">データ コントラクトは opt-in 方式のコントラクトです。つまり、データ コントラクト属性を明示的に適用しない限り、型またはデータ メンバーはシリアル化されません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-149">Data contracts are opt-in style contracts: No type or data member is serialized unless you explicitly apply the data contract attribute.</span></span> <span data-ttu-id="fc9da-150">データ コントラクトはマネージド コードのアクセス スコープとして関連付けられていません。プライベートのデータ メンバーはシリアル化され、パブリックにアクセスされる他の場所に送信されます</span><span class="sxs-lookup"><span data-stu-id="fc9da-150">Data contracts are unrelated to the access scope of the managed code: Private data members can be serialized and sent elsewhere to be accessed publicly.</span></span> <span data-ttu-id="fc9da-151">(データコントラクトの基本的な例については、「[方法: クラスまたは構造体の基本的なデータコントラクトを作成](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md)する」を参照してください)。WCF では、基になる SOAP メッセージの定義を処理します。これにより、操作の機能を有効にすると共に、メッセージの本文との間でデータ型をシリアル化することができます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-151">(For a basic example of a data contract, see [How to: Create a Basic Data Contract for a Class or Structure](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md).) WCF handles the definition of the underlying SOAP messages that enable the operation's functionality as well as the serialization of your data types into and out of the body of the messages.</span></span> <span data-ttu-id="fc9da-152">使用するデータ型がシリアル化可能であれば、操作の設計時に、基盤となるメッセージ交換インフラストラクチャについて考える必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-152">As long as your data types are serializable, you do not need to think about the underlying message exchange infrastructure when designing your operations.</span></span>  
  
 <span data-ttu-id="fc9da-153">一般的な WCF アプリケーションでは、<xref:System.Runtime.Serialization.DataContractAttribute> と <xref:System.Runtime.Serialization.DataMemberAttribute> の属性を使用して操作のデータコントラクトを作成しますが、他のシリアル化メカニズムを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-153">Although the typical WCF application uses the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> attributes to create data contracts for operations, you can use other serialization mechanisms.</span></span> <span data-ttu-id="fc9da-154"><xref:System.Runtime.Serialization.ISerializable>、<xref:System.SerializableAttribute>、および <xref:System.Xml.Serialization.IXmlSerializable> の各標準機構はすべて、基になる SOAP メッセージへのデータ型のシリアル化を処理します。このメッセージはアプリケーション間でデータ型を伝達します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-154">The standard <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> and <xref:System.Xml.Serialization.IXmlSerializable> mechanisms all work to handle the serialization of your data types into the underlying SOAP messages that carry them from one application to another.</span></span> <span data-ttu-id="fc9da-155">使用するデータ型で特別なサポートが必要な場合は、さらに多くのシリアル化方法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-155">You can employ more serialization strategies if your data types require special support.</span></span> <span data-ttu-id="fc9da-156">WCF アプリケーションでのデータ型のシリアル化の選択肢の詳細については、「[サービスコントラクトでのデータ転送の指定](./feature-details/specifying-data-transfer-in-service-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-156">For more information about the choices for serialization of data types in WCF applications, see [Specifying Data Transfer in Service Contracts](./feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
#### <a name="mapping-parameters-and-return-values-to-message-exchanges"></a><span data-ttu-id="fc9da-157">メッセージ交換へのパラメーターと戻り値のマッピング</span><span class="sxs-lookup"><span data-stu-id="fc9da-157">Mapping Parameters and Return Values to Message Exchanges</span></span>  
 <span data-ttu-id="fc9da-158">サービス操作は、特定の標準セキュリティ、トランザクション、およびセッション関連の機能をサポートするためにアプリケーションが必要とするデータに加え、アプリケーション データをやり取りする SOAP メッセージの基になる交換によってサポートされます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-158">Service operations are supported by an underlying exchange of SOAP messages that transfer application data back and forth, in addition to the data required by the application to support certain standard security, transaction, and session-related features.</span></span> <span data-ttu-id="fc9da-159">この場合、サービス操作の署名によって、データ転送をサポートできる特定の基になる*メッセージ交換パターン*(mep) と、操作に必要な機能が決まります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-159">Because this is the case, the signature of a service operation dictates a certain underlying *message exchange pattern* (MEP) that can support the data transfer and the features an operation requires.</span></span> <span data-ttu-id="fc9da-160">WCF プログラミングモデルでは、要求/応答、一方向、および双方向のメッセージパターンの3つのパターンを指定できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-160">You can specify three patterns in the WCF programming model: request/reply, one-way, and duplex message patterns.</span></span>  
  
##### <a name="requestreply"></a><span data-ttu-id="fc9da-161">要求/応答</span><span class="sxs-lookup"><span data-stu-id="fc9da-161">Request/Reply</span></span>  
 <span data-ttu-id="fc9da-162">要求/応答パターンでは、要求の送信側 (クライアント アプリケーション) は、その要求に関連付けられた応答を受信します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-162">A request/reply pattern is one in which a request sender (a client application) receives a reply with which the request is correlated.</span></span> <span data-ttu-id="fc9da-163">このパターンでは、1 つの操作において、1 つ以上のパラメーターを操作に渡し、戻り値を呼び出し元に返すことができるため、このパターンが既定の MEP となります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-163">This is the default MEP because it supports an operation in which one or more parameters are passed to the operation and a return value is passed back to the caller.</span></span> <span data-ttu-id="fc9da-164">たとえば、次の C# コード例は、文字列を 1 つ受け取り、文字列を返す基本的なサービス操作を示しています。</span><span class="sxs-lookup"><span data-stu-id="fc9da-164">For example, the following C# code example shows a basic service operation that takes one string and returns a string.</span></span>  
  
```csharp  
[OperationContractAttribute]  
string Hello(string greeting);  
```  
  
 <span data-ttu-id="fc9da-165">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-165">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute()>  
Function Hello (ByVal greeting As String) As String  
```  
  
 <span data-ttu-id="fc9da-166">この操作シグネチャは、基になるメッセージ交換の形式を指定しています。</span><span class="sxs-lookup"><span data-stu-id="fc9da-166">This operation signature dictates the form of underlying message exchange.</span></span> <span data-ttu-id="fc9da-167">関連付けが存在しない場合、WCF は戻り値の対象となる操作を特定できません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-167">If no correlation existed, WCF cannot determine for which operation the return value is intended.</span></span>  
  
 <span data-ttu-id="fc9da-168">別の基になるメッセージパターンを指定していない場合は、`void` (Visual Basic で`Nothing`) を返すサービス操作でも、要求/応答メッセージ交換が行われることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-168">Note that unless you specify a different underlying message pattern, even service operations that return `void` (`Nothing` in Visual Basic) are request/reply message exchanges.</span></span> <span data-ttu-id="fc9da-169">クライアントが操作を非同期で呼び出していない場合、通常、メッセージが空の場合でも、戻りメッセージを受信するまでクライアントは処理を中止します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-169">The result for your operation is that unless a client invokes the operation asynchronously, the client stops processing until the return message is received, even though that message is empty in the normal case.</span></span> <span data-ttu-id="fc9da-170">クライアントが応答で空のメッセージを受信するまで制御が戻らない操作の C# コード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-170">The following C# code example shows an operation that does not return until the client has received an empty message in response.</span></span>  
  
```csharp  
[OperationContractAttribute]  
void Hello(string greeting);  
```  
  
 <span data-ttu-id="fc9da-171">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-171">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute()>  
Sub Hello (ByVal greeting As String)  
```  
  
 <span data-ttu-id="fc9da-172">上記の例では、実行に時間のかかる操作の場合に、クライアントのパフォーマンスと応答性が低下するおそれがありますが、要求/応答操作で `void` を返す場合でも、この操作には利点があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-172">The preceding example can slow client performance and responsiveness if the operation takes a long time to perform, but there are advantages to request/reply operations even when they return `void`.</span></span> <span data-ttu-id="fc9da-173">最も明らかな利点は、応答メッセージで SOAP エラーを返すことが可能であるということです。これにより、通信と処理のどちらで発生したかに関係なく、サービス関連の何らかのエラー状態が発生したことがわかります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-173">The most obvious one is that SOAP faults can be returned in the response message, which indicates that some service-related error condition has occurred, whether in communication or processing.</span></span> <span data-ttu-id="fc9da-174">サービス コントラクトに指定された SOAP エラーは、<xref:System.ServiceModel.FaultException%601> オブジェクトとしてクライアント アプリケーションに渡されます。このオブジェクトの型パラメーターは、サービス コントラクトで指定された型です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-174">SOAP faults that are specified in a service contract are passed to the client application as a <xref:System.ServiceModel.FaultException%601> object, where the type parameter is the type specified in the service contract.</span></span> <span data-ttu-id="fc9da-175">これにより、クライアントに WCF サービスのエラー状態が簡単に通知されるようになります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-175">This makes notifying clients about error conditions in WCF services easy.</span></span> <span data-ttu-id="fc9da-176">例外、SOAP エラー、およびエラー処理の詳細については、「[コントラクトとサービスのエラーの指定と処理](specifying-and-handling-faults-in-contracts-and-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-176">For more information about exceptions, SOAP faults, and error handling, see [Specifying and Handling Faults in Contracts and Services](specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="fc9da-177">要求/応答サービスとクライアントの例については、「[方法: 要求/応答コントラクトを作成](./feature-details/how-to-create-a-request-reply-contract.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-177">To see an example of a request/reply service and client, see [How to: Create a Request-Reply Contract](./feature-details/how-to-create-a-request-reply-contract.md).</span></span> <span data-ttu-id="fc9da-178">要求/応答パターンに関する問題の詳細については、「[要求/応答サービス](./feature-details/request-reply-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-178">For more information about issues with the request-reply pattern, see [Request-Reply Services](./feature-details/request-reply-services.md).</span></span>  
  
##### <a name="one-way"></a><span data-ttu-id="fc9da-179">一方向</span><span class="sxs-lookup"><span data-stu-id="fc9da-179">One-way</span></span>  
 <span data-ttu-id="fc9da-180">WCF サービスアプリケーションのクライアントが操作の完了を待機せず、SOAP エラーを処理しない場合、操作は一方向のメッセージパターンを指定できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-180">If the client of a WCF service application should not wait for the operation to complete and does not process SOAP faults, the operation can specify a one-way message pattern.</span></span> <span data-ttu-id="fc9da-181">一方向の操作とは、クライアントが操作を呼び出し、WCF によってメッセージがネットワークに書き込まれた後も処理を続行する操作です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-181">A one-way operation is one in which a client invokes an operation and continues processing after WCF writes the message to the network.</span></span> <span data-ttu-id="fc9da-182">通常、これは、送信メッセージで送信するデータが膨大な量でない限り、(データ送信時にエラーが発生しなければ) クライアントはほぼすぐに実行を続けることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-182">Typically this means that unless the data being sent in the outbound message is extremely large the client continues running almost immediately (unless there is an error sending the data).</span></span> <span data-ttu-id="fc9da-183">この種のメッセージ交換パターンでは、クライアントからサービス アプリケーションへのイベントのような動作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="fc9da-183">This type of message exchange pattern supports event-like behavior from a client to a service application.</span></span>  
  
 <span data-ttu-id="fc9da-184">1 つのメッセージを送信し、何も受信しないメッセージ交換では、`void` 以外の戻り値を指定したサービス操作をサポートすることはできません。この場合、<xref:System.InvalidOperationException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-184">A message exchange in which one message is sent and none are received cannot support a service operation that specifies a return value other than `void`; in this case an <xref:System.InvalidOperationException> exception is thrown.</span></span>  
  
 <span data-ttu-id="fc9da-185">戻りメッセージがないということは、処理または通信時のエラーを示すために SOAP エラーを返すこともできないということです</span><span class="sxs-lookup"><span data-stu-id="fc9da-185">No return message also means that there can be no SOAP fault returned to indicate any errors in processing or communication.</span></span> <span data-ttu-id="fc9da-186">(操作が一方向操作の場合にエラー情報を伝達するには、双方向メッセージ交換パターンが必要です)。</span><span class="sxs-lookup"><span data-stu-id="fc9da-186">(Communicating error information when operations are one-way operations requires a duplex message exchange pattern.)</span></span>  
  
 <span data-ttu-id="fc9da-187">`void` を返す操作で一方向メッセージ交換を指定するには、次の C# コード例に示すように、<xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> プロパティを `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-187">To specify a one-way message exchange for an operation that returns `void`, set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as in the following C# code example.</span></span>  
  
```csharp  
[OperationContractAttribute(IsOneWay=true)]  
void Hello(string greeting);  
```  
  
 <span data-ttu-id="fc9da-188">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-188">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<OperationContractAttribute(IsOneWay := True)>  
Sub Hello (ByVal greeting As String)  
```  
  
 <span data-ttu-id="fc9da-189">このメソッドは、前述の要求/応答の例と同じです。ただし、<xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> プロパティを `true` に設定するということは、メソッドは同じでも、サービス操作は戻りメッセージを送信せず、送信メッセージがチャネル レイヤーに渡されると、すぐにクライアントに制御が戻ることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-189">This method is identical to the preceding request/reply example, but setting the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true` means that although the method is identical, the service operation does not send a return message and clients return immediately once the outbound message has been handed to the channel layer.</span></span> <span data-ttu-id="fc9da-190">例については、「[方法: 一方向コントラクトを作成](./feature-details/how-to-create-a-one-way-contract.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-190">For an example, see [How to: Create a One-Way Contract](./feature-details/how-to-create-a-one-way-contract.md).</span></span> <span data-ttu-id="fc9da-191">一方向のパターンの詳細については、「[一方向サービス](./feature-details/one-way-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-191">For more information about the one-way pattern, see [One-Way Services](./feature-details/one-way-services.md).</span></span>  
  
##### <a name="duplex"></a><span data-ttu-id="fc9da-192">二重</span><span class="sxs-lookup"><span data-stu-id="fc9da-192">Duplex</span></span>  
 <span data-ttu-id="fc9da-193">双方向パターンの特徴は、一方向メッセージングと要求/応答メッセージングのどちらを使用しているかに関係なく、サービスとクライアントが共に独立して、相互にメッセージを送信できるという点です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-193">A duplex pattern is characterized by the ability of both the service and the client to send messages to each other independently whether using one-way or request/reply messaging.</span></span> <span data-ttu-id="fc9da-194">二方向通信のこの形式は、サービスがクライアントと直接通信する必要がある場合や、イベントのような動作など、メッセージを交換するどちらの側も非同期で動作できるようにする場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-194">This form of two-way communication is useful for services that must communicate directly to the client or for providing an asynchronous experience to either side of a message exchange, including event-like behavior.</span></span>  
  
 <span data-ttu-id="fc9da-195">双方向パターンでは、クライアントと通信するための機構が別途必要になるため、要求/応答パターンや一方向パターンに比べると若干複雑になります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-195">The duplex pattern is slightly more complex than the request/reply or one-way patterns because of the additional mechanism for communicating with the client.</span></span>  
  
 <span data-ttu-id="fc9da-196">双方向コントラクトを設計する場合、コールバック コントラクトも設計し、そのコールバック コントラクトの型を、サービス コントラクトをマークする <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> 属性の <xref:System.ServiceModel.ServiceContractAttribute> プロパティに割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-196">To design a duplex contract, you must also design a callback contract and assign the type of that callback contract to the <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> property of the <xref:System.ServiceModel.ServiceContractAttribute> attribute that marks your service contract.</span></span>  
  
 <span data-ttu-id="fc9da-197">双方向パターンを実装するには、クライアントで呼び出されるメソッド宣言を含む 2 つ目のインターフェイスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-197">To implement a duplex pattern, you must create a second interface that contains the method declarations that are called on the client.</span></span>  
  
 <span data-ttu-id="fc9da-198">サービスを作成する例と、そのサービスにアクセスするクライアントの例については、「[方法: 双方向コントラクトを作成](./feature-details/how-to-create-a-duplex-contract.md)する」および「[方法: 双方向コントラクトを使用してサービスにアクセスする](./feature-details/how-to-access-services-with-a-duplex-contract.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-198">For an example of creating a service, and a client that accesses that service, see [How to: Create a Duplex Contract](./feature-details/how-to-create-a-duplex-contract.md) and [How to: Access Services with a Duplex Contract](./feature-details/how-to-access-services-with-a-duplex-contract.md).</span></span> <span data-ttu-id="fc9da-199">実際のサンプルについては、「[双](./samples/duplex.md)方向」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-199">For a working sample, see [Duplex](./samples/duplex.md).</span></span> <span data-ttu-id="fc9da-200">双方向コントラクトの使用に関する問題の詳細については、「[双方向サービス](./feature-details/duplex-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-200">For more information about issues using duplex contracts, see [Duplex Services](./feature-details/duplex-services.md).</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="fc9da-201">サービスは、双方向メッセージを受信すると、その受信メッセージの `ReplyTo` 要素を参照して応答の送信先を決定します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-201">When a service receives a duplex message, it looks at the `ReplyTo` element in that incoming message to determine where to send the reply.</span></span> <span data-ttu-id="fc9da-202">メッセージの受信に使用するチャネルがセキュリティで保護されていない場合、信頼関係のないクライアントが対象コンピューターの `ReplyTo` を使用して悪意のあるメッセージを送信し、その対象コンピューターのサービス拒否 (DOS: Denial Of Service) を引き起こすおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-202">If the channel that is used to receive the message is not secured, then an untrusted client could send a malicious message with a target machine's `ReplyTo`, leading to a denial of service (DOS) of that target machine.</span></span>  
  
##### <a name="out-and-ref-parameters"></a><span data-ttu-id="fc9da-203">Out パラメーターと Ref パラメーター</span><span class="sxs-lookup"><span data-stu-id="fc9da-203">Out and Ref Parameters</span></span>  
 <span data-ttu-id="fc9da-204">ほとんどの場合、パラメーター (Visual Basic では`ByVal`) を使用して、`out` および `ref` のパラメーター (`ByRef` で Visual Basic) を `in` できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-204">In most cases, you can use `in` parameters (`ByVal` in Visual Basic) and `out` and `ref` parameters (`ByRef` in Visual Basic).</span></span> <span data-ttu-id="fc9da-205">`out` パラメーターと `ref` パラメーターは、操作からデータが返されることを示すため、操作シグネチャが `void` を返す場合でも、次のような操作シグネチャによって要求/応答操作が必要であることを指定します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-205">Because both `out` and `ref` parameters indicate that data is returned from an operation, an operation signature such as the following specifies that a request/reply operation is required even though the operation signature returns `void`.</span></span>  
  
```csharp  
[ServiceContractAttribute]  
public interface IMyContract  
{  
  [OperationContractAttribute]  
  public void PopulateData(ref CustomDataType data);  
}  
```  
  
 <span data-ttu-id="fc9da-206">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-206">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface IMyContract  
  <OperationContractAttribute()> _  
  Public Sub PopulateData(ByRef data As CustomDataType)  
End Interface  
```  
  
 <span data-ttu-id="fc9da-207">唯一の例外は、シグネチャに特定の構造体が含まれている場合です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-207">The only exceptions are those cases in which your signature has a particular structure.</span></span> <span data-ttu-id="fc9da-208">たとえば、<xref:System.ServiceModel.NetMsmqBinding> バインディングを使用してクライアントと通信できるのは、操作の宣言に使用されたメソッドが `void` を返す場合だけです。戻り値、`ref` パラメーター、または `out` パラメーターのいずれであるかに関係なく、出力値を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-208">For example, you can use the <xref:System.ServiceModel.NetMsmqBinding> binding to communicate with clients only if the method used to declare an operation returns `void`; there can be no output value, whether it is a return value, `ref`, or `out` parameter.</span></span>  
  
 <span data-ttu-id="fc9da-209">また、`out` パラメーターまたは `ref` パラメーターを使用する場合、操作には基になる応答メッセージが必要です。このメッセージが変更されたオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-209">In addition, using `out` or `ref` parameters requires that the operation have an underlying response message to carry back the modified object.</span></span> <span data-ttu-id="fc9da-210">操作が一方向操作の場合、実行時に <xref:System.InvalidOperationException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-210">If your operation is a one-way operation, an <xref:System.InvalidOperationException> exception is thrown at runtime.</span></span>  
  
### <a name="specify-message-protection-level-on-the-contract"></a><span data-ttu-id="fc9da-211">コントラクトでのメッセージ保護レベルの指定</span><span class="sxs-lookup"><span data-stu-id="fc9da-211">Specify Message Protection Level on the Contract</span></span>  
 <span data-ttu-id="fc9da-212">コントラクトの設計時に、コントラクトを実装するサービスのメッセージ保護レベルも決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-212">When designing your contract, you must also decide the message protection level of services that implement your contract.</span></span> <span data-ttu-id="fc9da-213">これは、メッセージ セキュリティをコントラクトのエンドポイントのバインディングに適用する場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-213">This is necessary only if message security is applied to the binding in the contract's endpoint.</span></span> <span data-ttu-id="fc9da-214">バインディングのセキュリティが無効になっている場合 (つまり、システム指定のバインディングで <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> の値が <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType> に設定されている場合)、コントラクトのメッセージ保護レベルを決定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-214">If the binding has security turned off (that is, if the system-provided binding sets the <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> to the value <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>) then you do not have to decide on the message protection level for the contract.</span></span> <span data-ttu-id="fc9da-215">ほとんどの場合、メッセージ レベルのセキュリティが適用されたシステム指定のバインディングは、十分な保護レベルを備えているため、操作ごとまたはメッセージごとに保護レベルを検討する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-215">In most cases, system-provided bindings with message-level security applied provide a sufficient protection level and you do not have to consider the protection level for each operation or for each message.</span></span>  
  
 <span data-ttu-id="fc9da-216">保護レベルは、サービスをサポートするメッセージ (またはメッセージ部分) が署名されるのか、署名および暗号化されるのか、または署名と暗号化なしで送信されるのかを指定する値です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-216">The protection level is a value that specifies whether the messages (or message parts) that support a service are signed, signed and encrypted, or sent without signatures or encryption.</span></span> <span data-ttu-id="fc9da-217">保護レベルは、さまざまなスコープ (サービス レベル、特定の操作、その操作内のメッセージ、またはメッセージ部分) で設定できます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-217">The protection level can be set at various scopes: At the service level, for a particular operation, for a message within that operation, or a message part.</span></span> <span data-ttu-id="fc9da-218">あるスコープで設定された値は、明示的にオーバーライドしない限り、そのスコープよりも小さなスコープの既定値になります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-218">Values set at one scope become the default value for smaller scopes unless explicitly overridden.</span></span> <span data-ttu-id="fc9da-219">コントラクトに必要とされる最小限の保護レベルをバインド構成で提供できない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-219">If a binding configuration cannot provide the required minimum protection level for the contract, an exception is thrown.</span></span> <span data-ttu-id="fc9da-220">保護レベルの値がコントラクトで明示的に設定されていない場合、バインディングのメッセージ セキュリティが有効であれば、バインド構成によってすべてのメッセージの保護レベルが制御されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-220">And when no protection level values are explicitly set on the contract, the binding configuration controls the protection level for all messages if the binding has message security.</span></span> <span data-ttu-id="fc9da-221">これが既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-221">This is the default behavior.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="fc9da-222">一般に、コントラクトのさまざまなスコープを完全な保護レベルである <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> よりも下のレベルに明示的に設定するかどうかは、パフォーマンスの向上と引き換えに、ある程度のセキュリティで妥協できるかどうかという判断によって決まります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-222">Deciding whether to explicitly set various scopes of a contract to less than the full protection level of <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> is generally a decision that trades some degree of security for increased performance.</span></span> <span data-ttu-id="fc9da-223">このような場合、操作および操作で交換するデータの価値に焦点を絞って判断を下す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-223">In these cases, your decisions must revolve around your operations and the value of the data they exchange.</span></span> <span data-ttu-id="fc9da-224">詳細については、「[サービスのセキュリティ保護](securing-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-224">For more information, see [Securing Services](securing-services.md).</span></span>  
  
 <span data-ttu-id="fc9da-225">たとえば、次のコード例では、<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> も、コントラクトの <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> プロパティも設定していません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-225">For example, the following code example does not set either the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> or the <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> property on the contract.</span></span>  
  
```csharp  
[ServiceContract]  
public interface ISampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute]  
  public int GetInt();    
}  
```  
  
 <span data-ttu-id="fc9da-226">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-226">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface ISampleService  
  
  <OperationContractAttribute()> _  
  Public Function GetString()As String  
  
  <OperationContractAttribute()> _  
  Public Function GetData() As Integer  
  
End Interface  
```  
  
 <span data-ttu-id="fc9da-227">既定の `ISampleService` (既定の <xref:System.ServiceModel.WSHttpBinding> は <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>) を使用するエンドポイントの <xref:System.ServiceModel.SecurityMode.Message> 実装とやり取りする場合は、暗号化と署名が既定の保護レベルであるため、すべてのメッセージが暗号化および署名されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-227">When interacting with an `ISampleService` implementation in an endpoint with a default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>), all messages are encrypted and signed because this is the default protection level.</span></span> <span data-ttu-id="fc9da-228">ただし、既定の `ISampleService` (既定の <xref:System.ServiceModel.BasicHttpBinding> は <xref:System.ServiceModel.SecurityMode>) を使用して <xref:System.ServiceModel.SecurityMode.None> サービスを使用すると、すべてのメッセージがテキストとして送信されます。これは、このバインディングにはセキュリティがないため、保護レベルが無視されるためです (つまり、メッセージの暗号化も署名も行われません)。</span><span class="sxs-lookup"><span data-stu-id="fc9da-228">However, when an `ISampleService` service is used with a default <xref:System.ServiceModel.BasicHttpBinding> (the default <xref:System.ServiceModel.SecurityMode>, which is <xref:System.ServiceModel.SecurityMode.None>), all messages are sent as text because there is no security for this binding and so the protection level is ignored (that is, the messages are neither encrypted nor signed).</span></span> <span data-ttu-id="fc9da-229"><xref:System.ServiceModel.SecurityMode> を <xref:System.ServiceModel.SecurityMode.Message> に変更すると、これがこのバインディングの既定の保護レベルになるため、これらのメッセージは暗号化および署名されるようになります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-229">If the <xref:System.ServiceModel.SecurityMode> was changed to <xref:System.ServiceModel.SecurityMode.Message>, then these messages would be encrypted and signed (because that would now be the binding's default protection level).</span></span>  
  
 <span data-ttu-id="fc9da-230">コントラクトの保護要件を明示的に指定または調整する場合は、<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> プロパティ (またはより小さなスコープの `ProtectionLevel` プロパティのいずれか) をサービス コントラクトに必要なレベルに設定します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-230">If you want to explicitly specify or adjust the protection requirements for your contract, set the <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> property (or any of the `ProtectionLevel` properties at a smaller scope) to the level your service contract requires.</span></span> <span data-ttu-id="fc9da-231">この場合、明示的な設定を使用するには、使用するスコープに少なくともその設定をサポートするバインディングが必要です。</span><span class="sxs-lookup"><span data-stu-id="fc9da-231">In this case, using an explicit setting requires the binding to support that setting at a minimum for the scope used.</span></span> <span data-ttu-id="fc9da-232">たとえば、次のコード例では、<xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> 操作の `GetGuid` の値を明示的に指定しています。</span><span class="sxs-lookup"><span data-stu-id="fc9da-232">For example, the following code example specifies one <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> value explicitly, for the `GetGuid` operation.</span></span>  
  
```csharp  
[ServiceContract]  
public interface IExplicitProtectionLevelSampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  
  public int GetInt();    
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  
  public int GetGuid();    
}  
```  
  
 <span data-ttu-id="fc9da-233">次のコードは同等の Visual Basic コードです。</span><span class="sxs-lookup"><span data-stu-id="fc9da-233">The following is the equivalent Visual Basic code.</span></span>  
  
```vb  
<ServiceContract()> _   
Public Interface IExplicitProtectionLevelSampleService   
    <OperationContract()> _   
    Public Function GetString() As String   
    End Function   
  
    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _   
    Public Function GetInt() As Integer   
    End Function   
  
    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _   
    Public Function GetGuid() As Integer   
    End Function   
  
End Interface  
```  
  
 <span data-ttu-id="fc9da-234">この `IExplicitProtectionLevelSampleService` コントラクトを実装し、既定の <xref:System.ServiceModel.WSHttpBinding> (既定の <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> は <xref:System.ServiceModel.SecurityMode.Message>) を使用するエンドポイントを持つサービスの動作は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-234">A service that implements this `IExplicitProtectionLevelSampleService` contract and has an endpoint that uses the default <xref:System.ServiceModel.WSHttpBinding> (the default <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType>, which is <xref:System.ServiceModel.SecurityMode.Message>) has the following behavior:</span></span>  
  
- <span data-ttu-id="fc9da-235">`GetString` 操作のメッセージは、暗号化および署名されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-235">The `GetString` operation messages are encrypted and signed.</span></span>  
  
- <span data-ttu-id="fc9da-236">`GetInt` 操作のメッセージは、暗号化も署名もされない (プレーン) テキストとして送信されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-236">The `GetInt` operation messages are sent as unencrypted and unsigned (that is, plain) text.</span></span>  
  
- <span data-ttu-id="fc9da-237">`GetGuid` 操作の <xref:System.Guid?displayProperty=nameWithType> は、暗号化および署名されたメッセージで返されます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-237">The `GetGuid` operation <xref:System.Guid?displayProperty=nameWithType> is returned in a message that is encrypted and signed.</span></span>  
  
 <span data-ttu-id="fc9da-238">保護レベルとその使用方法の詳細については、「[保護レベル](understanding-protection-level.md)について」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-238">For more information about protection levels and how to use them, see [Understanding Protection Level](understanding-protection-level.md).</span></span> <span data-ttu-id="fc9da-239">セキュリティの詳細については、「サービスのセキュリティ[保護](securing-services.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-239">For more information about security, see [Securing Services](securing-services.md).</span></span>  
  
##### <a name="other-operation-signature-requirements"></a><span data-ttu-id="fc9da-240">操作シグネチャのその他の要件</span><span class="sxs-lookup"><span data-stu-id="fc9da-240">Other Operation Signature Requirements</span></span>  
 <span data-ttu-id="fc9da-241">アプリケーションの一部の機能では、特定の種類の操作シグネチャを必要とします。</span><span class="sxs-lookup"><span data-stu-id="fc9da-241">Some application features require a particular kind of operation signature.</span></span> <span data-ttu-id="fc9da-242">たとえば、<xref:System.ServiceModel.NetMsmqBinding> バインディングは、永続的なサービスとクライアントをサポートします。永続的なサービスとクライアントでは、通信の途中でアプリケーションを再起動し、メッセージを失うことなく、アプリケーションが中止された場所を検出できます</span><span class="sxs-lookup"><span data-stu-id="fc9da-242">For example, the <xref:System.ServiceModel.NetMsmqBinding> binding supports durable services and clients, in which an application can restart in the middle of communication and pick up where it left off without missing any messages.</span></span> <span data-ttu-id="fc9da-243">(詳細については、「 [WCF のキュー](./feature-details/queues-in-wcf.md)」を参照してください)。ただし、持続性のある操作では、`in` パラメーターを1つだけ受け取り、戻り値を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="fc9da-243">(For more information, see [Queues in WCF](./feature-details/queues-in-wcf.md).) However, durable operations must take only one `in` parameter and have no return value.</span></span>  
  
 <span data-ttu-id="fc9da-244">もう 1 つの例として、操作における <xref:System.IO.Stream> 型の使用が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="fc9da-244">Another example is the use of <xref:System.IO.Stream> types in operations.</span></span> <span data-ttu-id="fc9da-245"><xref:System.IO.Stream> パラメーターにはメッセージの本文全体が含まれるため、入力または出力 (つまり、`ref` パラメーター、`out` パラメーター、または戻り値) が <xref:System.IO.Stream> 型である場合、操作で指定された入力または出力に限定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-245">Because the <xref:System.IO.Stream> parameter includes the entire message body, if an input or an output (that is, `ref` parameter, `out` parameter, or return value) is of type <xref:System.IO.Stream>, then it must be the only input or output specified in your operation.</span></span> <span data-ttu-id="fc9da-246">また、パラメーターまたは戻り値の型は <xref:System.IO.Stream>、<xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType>、<xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType> のいずれかである必要があります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-246">In addition, the parameter or return type must be either <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType>, or <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fc9da-247">ストリームの詳細については、「 [Large Data And Streaming](./feature-details/large-data-and-streaming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fc9da-247">For more information about streams, see [Large Data and Streaming](./feature-details/large-data-and-streaming.md).</span></span>  
  
##### <a name="names-namespaces-and-obfuscation"></a><span data-ttu-id="fc9da-248">名前、名前空間、および隠ぺい</span><span class="sxs-lookup"><span data-stu-id="fc9da-248">Names, Namespaces, and Obfuscation</span></span>  
 <span data-ttu-id="fc9da-249">コントラクトおよび操作の定義内の .NET 型の名前や名前空間は、コントラクトが WSDL に変換されるとき、およびコントラクト メッセージが作成および送信されるときに重要になります。</span><span class="sxs-lookup"><span data-stu-id="fc9da-249">The names and namespaces of the .NET types in the definition of contracts and operations are significant when contracts are converted into WSDL and when contract messages are created and sent.</span></span> <span data-ttu-id="fc9da-250">したがって、サービス コントラクトの名前と名前空間は、`Name`、`Namespace`、<xref:System.ServiceModel.ServiceContractAttribute>、<xref:System.ServiceModel.OperationContractAttribute> などの、すべてのサポート対象コントラクト属性や、他のコントラクト属性の <xref:System.Runtime.Serialization.DataContractAttribute> プロパティと <xref:System.Runtime.Serialization.DataMemberAttribute> プロパティを使用して明示的に設定することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fc9da-250">Therefore, it is strongly recommended that service contract names and namespaces are explicitly set using the `Name` and `Namespace` properties of all supporting contract attributes such as the <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>,  <xref:System.Runtime.Serialization.DataMemberAttribute>, and other contract attributes.</span></span>  
  
 <span data-ttu-id="fc9da-251">この 1 つの結果として、名前と名前空間が明示的に設定されていない場合、アセンブリで IL 難読化を使用すると、コントラクトの型名と名前空間が変更され、その結果、WSDL が変更され、通常はネットワークでのメッセージ交換に失敗します。</span><span class="sxs-lookup"><span data-stu-id="fc9da-251">One result of this is that if the names and namespaces are not explicitly set, the use of IL obfuscation on the assembly alters the contract type names and namespaces and results in modified WSDL and wire exchanges that typically fail.</span></span> <span data-ttu-id="fc9da-252">コントラクトの名前と名前空間を明示的に設定せずに難読化を使用する場合は、<xref:System.Reflection.ObfuscationAttribute> 属性と <xref:System.Reflection.ObfuscateAssemblyAttribute> 属性を使用して、コントラクトの型名と名前空間が変更されないようにします。</span><span class="sxs-lookup"><span data-stu-id="fc9da-252">If you do not set the contract names and namespaces explicitly but do intend to use obfuscation, use the <xref:System.Reflection.ObfuscationAttribute> and <xref:System.Reflection.ObfuscateAssemblyAttribute> attributes to prevent the modification of the contract type names and namespaces.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fc9da-253">参照</span><span class="sxs-lookup"><span data-stu-id="fc9da-253">See also</span></span>

- [<span data-ttu-id="fc9da-254">方法 : 要求/応答コントラクトを作成する</span><span class="sxs-lookup"><span data-stu-id="fc9da-254">How to: Create a Request-Reply Contract</span></span>](./feature-details/how-to-create-a-request-reply-contract.md)
- [<span data-ttu-id="fc9da-255">方法 : 一方向コントラクトを作成する</span><span class="sxs-lookup"><span data-stu-id="fc9da-255">How to: Create a One-Way Contract</span></span>](./feature-details/how-to-create-a-one-way-contract.md)
- [<span data-ttu-id="fc9da-256">方法 : 双方向コントラクトを作成する</span><span class="sxs-lookup"><span data-stu-id="fc9da-256">How to: Create a Duplex Contract</span></span>](./feature-details/how-to-create-a-duplex-contract.md)
- [<span data-ttu-id="fc9da-257">Specifying Data Transfer in Service Contracts</span><span class="sxs-lookup"><span data-stu-id="fc9da-257">Specifying Data Transfer in Service Contracts</span></span>](./feature-details/specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="fc9da-258">コントラクトおよびサービスのエラーの指定と処理</span><span class="sxs-lookup"><span data-stu-id="fc9da-258">Specifying and Handling Faults in Contracts and Services</span></span>](specifying-and-handling-faults-in-contracts-and-services.md)
- [<span data-ttu-id="fc9da-259">セッションの使用</span><span class="sxs-lookup"><span data-stu-id="fc9da-259">Using Sessions</span></span>](using-sessions.md)
- [<span data-ttu-id="fc9da-260">同期操作と非同期操作</span><span class="sxs-lookup"><span data-stu-id="fc9da-260">Synchronous and Asynchronous Operations</span></span>](synchronous-and-asynchronous-operations.md)
- [<span data-ttu-id="fc9da-261">信頼できるサービス</span><span class="sxs-lookup"><span data-stu-id="fc9da-261">Reliable Services</span></span>](reliable-services.md)
- [<span data-ttu-id="fc9da-262">サービスとトランザクション</span><span class="sxs-lookup"><span data-stu-id="fc9da-262">Services and Transactions</span></span>](services-and-transactions.md)
