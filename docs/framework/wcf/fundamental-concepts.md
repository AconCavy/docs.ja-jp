---
title: Windows Communication Foundation の基本概念
ms.date: 03/30/2017
helpviewer_keywords:
- WCF [WCF], concepts
- concepts [WCF]
- fundamentals [WCF]
- Windows Communication Foundation [WCF], concepts
ms.assetid: 3e7e0afd-7913-499d-bafb-eac7caacbc7a
ms.openlocfilehash: 8aceb94de4ed879834fd9ba833083c54ba1b4174
ms.sourcegitcommit: 127343afce8422bfa944c8b0c4ecc8f79f653255
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/25/2019
ms.locfileid: "67348349"
---
# <a name="fundamental-windows-communication-foundation-concepts"></a>Windows Communication Foundation の基本概念

このドキュメントでは、Windows Communication Foundation (WCF) のアーキテクチャの概要を説明します。 ここでは、主要概念およびこれらの概念がどのように組み合わされているかについて説明します。 最も単純な WCF サービスとクライアントの作成に関するチュートリアルについては、次を参照してください。[チュートリアル入門](../../../docs/framework/wcf/getting-started-tutorial.md)します。 WCF プログラミングについては、次を参照してください。[基本的な WCF プログラミング](../../../docs/framework/wcf/basic-wcf-programming.md)します。

## <a name="wcf-fundamentals"></a>WCF の基礎

WCF では、サービスとクライアント間のメッセージを送信するシステムを作成するため、ランタイムおよび一連の Api です。 同じコンピューター システム上、または別の企業内にあり、インターネット経由でアクセスするシステム上の他のアプリケーションと通信するアプリケーションを作成する場合にも、同じインフラストラクチャと API が使用されます。

### <a name="messaging-and-endpoints"></a>メッセージングとエンドポイント

WCF は、プログラミング モデルで一貫した方法で表現できます (たとえば、HTTP 要求またはメッセージ キュー (MSMQ とも呼ばれます) のメッセージ) のメッセージとしてモデル化できるメッセージ ベースの通信と何かの概念に基づいています。 これにより、さまざまなトランスポート機構にわたり統一された API が実現します。

モデルを識別するため_クライアント_、通信を開始するアプリケーションと_サービス_、アプリケーションの通信と、対応するクライアントが待機します。通信します。 1 つのアプリケーションがクライアントとサービスの両方の役割を果たすことができます。 例については、次を参照してください。[双方向サービス](../../../docs/framework/wcf/feature-details/duplex-services.md)と[ピア ツー ピア ネットワー キング](../../../docs/framework/wcf/feature-details/peer-to-peer-networking.md)します。

メッセージは、エンドポイント間で送信されます。 _エンドポイント_メッセージが送信または受信場所 (あるいはその両方) は、メッセージ交換に必要なすべての情報が定義されます。 サービスは、1 つ以上のアプリケーション エンドポイント (および 0 個以上のインフラストラクチャ エンドポイント) を公開し、クライアントは、サービスのエンドポイントのいずれかと互換性のあるエンドポイントを作成します。

_エンドポイント_メッセージを送信する必要があります、どのように送信する必要があります、およびメッセージがどのような標準ベースの方法でについて説明します。 サービスは、適切な WCF クライアントとの通信を生成するクライアントで処理できるメタデータとしてこの情報を公開できます_スタック_します。

### <a name="communication-protocols"></a>通信プロトコル

1 つの必須通信スタックの要素は、_トランスポート プロトコル_します。 一般的なトランスポート (HTTP や TCP など) を使用して、イントラネットおよびインターネット上でメッセージを送信できます。 メッセージ キュー アプリケーションおよびピア ネットワーク メッシュのノードとの通信をサポートする他のトランスポートも含まれます。 WCF の組み込み拡張ポイントを使用して、複数のトランスポート機構を追加できます。

通信スタックのもう 1 つの必須要素はエンコードです。エンコードは、特定のメッセージをどのように書式設定するかを指定します。 WCF には、次のエンコードが用意されています。

- テキスト エンコード。相互運用可能なエンコードです。

- MTOM (Message Transmission Optimization Mechanism) エンコード。これは、サービスとの間で構造化されていないバイナリ データを効率的に送信するための相互運用可能な方法です。

- バイナリ エンコード。このエンコードを使用すると、転送を効率的に行うことができます。

WCF の組み込み拡張ポイントを使用して、複数のエンコード メカニズムが (たとえば、圧縮エンコード) を追加できます。

### <a name="message-patterns"></a>メッセージ パターン

WCF では、要求/応答、一方向と双方向通信など、いくつかのメッセージング パターンをサポートします。 各種トランスポートがサポートするメッセージング パターンはそれぞれに異なるため、サポートされる対話の種類に影響します。 WCF Api とランタイムは安全かつ確実にメッセージを送信することも役立ちます。

## <a name="wcf-terms"></a>WCF の用語

その他の概念と、WCF のドキュメントで使用される用語次に示します。

**メッセージ**  
 独立したデータ単位は、本文やヘッダーなどの複数の部分で構成できます。

**サービス**  
 1 つ以上のエンドポイントを公開する構造体です。各エンドポイントは、1 つ以上のサービス操作を公開します。

**エンドポイント**  
 メッセージを送信または受信 (または送受信) する場所となる構造体です。 ある場所 (アドレス)、メッセージを送信できる、メッセージを送信する方法について説明します。 通信メカニズム (バインド) の仕様を定義して、一連の送信または受信できるメッセージの定義 (またはその両方) から成るどのようなメッセージを送信できるを記述する場所 (サービス コントラクト)。

WCF サービスは、エンドポイントの集まりとして外部に公開されます。

**アプリケーション エンドポイント**  
 アプリケーションによって公開されるエンドポイントです。アプリケーション エンドポイントは、アプリケーションで実装されるサービス コントラクトに対応しています。

**インフラストラクチャ エンドポイント**  
 サービス コントラクトに関連しないサービスで必要とされる機能または提供される機能を促進するために、インフラストラクチャによって公開されるエンドポイントです。 たとえば、サービスは、メタデータ情報を提供するインフラストラクチャ エンドポイントを持つ場合があります。

**Address**  
 メッセージを受信する場所を指定します。 アドレスは、URI (Uniform Resource Identifier) として指定されます。 URI のスキーマ部分では、そのアドレスに到達するために使用するトランスポート機構 (HTTP、TCP など) を指定します。 URI の階層部分には一意の場所が含まれ、その形式はトランスポート機構によって異なります。

エンドポイント アドレスにより、サービスのエンドポイントごとに一意のエンドポイント アドレスを作成できます。また、一定の条件下では、エンドポイント間でアドレスを共有することもできます。 既定以外のポートで HTTPS プロトコルを使用するアドレスの例を次に示します。

```
HTTPS://cohowinery:8005/ServiceModelSamples/CalculatorService
```

**バインド**  
 エンドポイントが外部と通信する方法を定義します。 バインディングは、バインド要素と呼ばれる一連のコンポーネントで構成されます。各バインド要素を "積み重ねる" ことで、通信インフラストラクチャが作成されます。 バインディングでは、少なくともトランスポート (HTTP や TCP など) と使用するエンコード (テキストやバイナリなど) が定義されます。 バインディングには、メッセージをセキュリティで保護するために使用するセキュリティ機構や、エンドポイントが使用するメッセージ パターンなどの詳細を指定したバインディング要素を含めることができます。 詳細については、次を参照してください。[サービスを構成する](../../../docs/framework/wcf/configuring-services.md)します。

**バインド要素**  
 バインディングの特定の部分 (トランスポート、エンコード、インフラストラクチャ レベルのプロトコル (WS-ReliableMessaging など) の実装、通信スタックのその他のコンポーネントなど) を表します。

**ビヘイビアー**  
 サービス、エンドポイント、特定の操作、またはクライアントの実行時のさまざまな状況を制御するコンポーネントです。 動作はスコープに従ってグループ化されます。共通動作は、すべてのエンドポイントにグローバルに作用し、サービス動作は、サービスに関連する側面にのみ作用します。また、エンドポイントの動作は、エンドポイントに関連するプロパティにのみ作用し、操作レベルの動作は特定の操作に作用します。 たとえば、サービス動作の 1 つである調整では、メッセージの数が多すぎて処理しきれないおそれがある場合に、サービスでどのように対処するかを指定します。 一方、エンドポイントの動作は、セキュリティ資格情報の検索方法や検索場所など、エンドポイントに関連する側面だけを制御します。

**システム指定のバインディング**  
 WCF には、システム指定のバインディングが多数用意されています。 これらは、特定のシナリオ用に最適化されたバインディング要素の集まりです。 たとえば、<xref:System.ServiceModel.WSHttpBinding>はさまざまな ws-を実装するサービスとの相互運用用に設計された\*仕様。 これらの定義済みバインディングでは、特定のシナリオに適切に適用できるオプションだけが提供されるため、時間を節約できます。 定義済みバインディングが要件を満たさない場合は、独自のカスタム バインドを作成できます。

**構成とコーディング**  
 アプリケーションは、コーディング、構成、またはこの 2 つの組み合わせによって制御できます。 構成には、コードの作成後、再コンパイルを必要とせずに、開発者以外のユーザー (ネットワーク管理者など) がクライアントとサービスのパラメーターを設定できるという利点があります。 構成では、エンドポイント アドレスなどの値を設定できるだけでなく、エンドポイント、バインディング、および動作の追加が可能であるため、制御を強化することもできます。 コーディングの場合、開発者はサービスまたはクライアントのすべてのコンポーネントに対する厳密な制御を保持できます。構成によって行われた設定を検査し、必要に応じてコードによってオーバーライドできます。

**サービス操作**  
 操作の機能を実装するためにサービスのコードに定義された手順です。 この操作は、WCF クライアントのメソッドとしてクライアントに公開されます。 メソッドは、値を返すこともあれば、任意の数の引数を受け取ることもあります。また、引数を受け取らず、応答を返さないこともあります。 たとえば、単純な "Hello" という機能を持つ操作をクライアントの存在の通知として使用したり、一連の操作を開始するために使用したりできます。

**サービス コントラクト**  
 関連する複数の操作を 1 つの機能単位に関連付けます。 コントラクトでは、サービスの名前空間や対応するコールバック コントラクトなど、サービス レベルの設定を定義できます。 ほとんどの場合、開発者が選択したプログラミング言語でインターフェイスを作成し、このインターフェイスに <xref:System.ServiceModel.ServiceContractAttribute> 属性を適用することによって、コントラクトを定義します。 実際のサービス コードは、インターフェイスを実装することによって作成されます。

**操作コントラクト**  
 操作コントラクトは、操作のパラメーターと戻り値の型を定義します。 サービス コントラクトを定義するインターフェイスの作成時に、コントラクトに含まれる各メソッド定義に <xref:System.ServiceModel.OperationContractAttribute> 属性を適用することによって、操作コントラクトを表します。 各操作は、単一のメッセージを取得し、単一のメッセージを返すようにモデル化することも、一連の型を取得し、型を返すようにモデル化することもできます。 後者の場合、その操作用に交換する必要のあるメッセージの形式がシステムによって決定されます。

**メッセージ コントラクト**  
 メッセージの形式を記述します。 たとえば、メッセージ要素をヘッダーと本文のどちらに入れるか、メッセージのどの要素にどのレベルのセキュリティを適用するかなどを宣言します。

**エラー コントラクト**  
 サービス操作に関連付けることにより、呼び出し元に返すことのできるエラーを示すことができます。 操作には、0 個以上のエラーを関連付けることができます。 これらのエラーは、プログラミング モデルで例外としてモデル化される SOAP エラーです。

**データ コントラクト**  
 サービスが使用するデータ型のメタデータの記述。 これにより、他のサービスをそのサービスと相互運用できます。 このデータ型は、パラメーターや戻り値など、メッセージの任意の部分で使用することができます。 サービスが単純型だけを使用している場合、データ コントラクトを明示的に使用する必要はありません。

**ホスティング**  
 サービスは、何らかのプロセス内でホストされている必要があります。 A_ホスト_は、サービスの有効期間を制御するアプリケーションです。 サービスは、自己ホスト型であっても、既存のホスティング プロセスによって管理されていてもかまいません。

**自己ホスト型サービス**  
 開発者が作成したプロセス アプリケーション内で実行されるサービスです。 開発者は、サービスの有効期間を制御し、サービスのプロパティを設定します。また、サービスを開き (サービスをリッスン モードに設定する)、サービスを閉じることも開発者が行います。

**ホスト プロセス**  
 サービスをホストするように設計されたアプリケーションです。 ホスティング プロセスには、インターネット インフォメーション サービス (IIS)、Windows アクティブ化サービス (WAS)、Windows サービスなどがあります。 これらのホスト シナリオでは、ホストがサービスの有効期間を制御します。 たとえば、IIS を使用して、サービス アセンブリや構成ファイルを格納する仮想ディレクトリを設定できます。 メッセージを受信すると、IIS はサービスを開始し、その有効期間を制御します。

**インスタンス化**  
 サービスには、インスタンス化モデルが含まれます。 インスタンス化モデルには、1 つの CLR オブジェクトがすべてのクライアントにサービスを提供する "単一モデル"、クライアント呼び出しを処理するために、呼び出しごとに新しい CLR オブジェクトが作成される "呼び出しモデル"、CLR オブジェクトのセットがセッションごとに 1 つ作成される "セッション モデル" の 3 つのモデルがあります。 インスタンス化モデルの選択は、アプリケーション要件とサービスの予想される使用パターンによって異なります。

**クライアント アプリケーション**  
 1 つ以上のエンドポイントとメッセージを交換するプログラムです。 クライアント アプリケーションは、WCF クライアントのインスタンスを作成し、WCF クライアントのメソッドを呼び出すことによって開始されます。 1 つのアプリケーションがクライアントとサービスの両方として機能できることに注意してください。

**チャネル**  
 バインディング要素の具象実装です。 バインディングは構成を表し、チャネルはその構成に関連付けられた実装です。 したがって、各バインディング要素に関連付けられたチャネルが存在します。 チャネルが積み重ねられて、バインディングの具象実装 (チャネル スタック) が作成されます。

**WCF クライアント**  
 メソッドとして、サービス操作を公開するクライアント アプリケーション構造体 (Visual Basic または Visual など、好みの言語のプログラミング、.NET Framework でC#)。 サービスをホストするアプリケーションも含め、すべてのアプリケーションが WCF クライアントをホストできます。 したがって、他のサービスの WCF クライアントを含むサービスを作成できます。

使用して、WCF クライアントを自動的に生成することができます、 [ServiceModel メタデータ ユーティリティ ツール (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)メタデータを公開する実行中のサービスを指し示すようとします。

**メタデータ**  
 サービスで、外部エンティティがそのサービスと通信するために認識しておく必要のあるサービスの特性を示します。 使用できるメタデータ、 [ServiceModel メタデータ ユーティリティ ツール (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) WCF クライアントおよび付随する構成サービスとの対話に使用できるクライアント アプリケーションを生成します。

サービスが公開するメタデータには、サービスのデータ コントラクトが定義された XML スキーマ ドキュメントと、サービスのメソッドが記載された WSDL ドキュメントが含まれます。

メタデータを有効にすると、WCF によってサービスとそのエンドポイントが検査され、サービスのメタデータが自動的に生成されます。 サービスからメタデータを公開するには、メタデータの動作を明示的に有効にする必要があります。

**セキュリティ**  
 WCF では、機密性 (盗聴を防ぐためのメッセージの暗号化)、整合性 (メッセージの改ざんの検出するための手段)、認証 (サーバーとクライアントの検証の場合)、および承認 (コントロールへのアクセスが含まれていますリソースの場合)。 TLS over HTTP (HTTPS とも呼ばれます) など、いずれか活用の既存のセキュリティ メカニズムによって、または 1 つまたは複数のさまざまな ws-を実装することによって、これらの関数が用意されています\*セキュリティ仕様。

**トランスポート セキュリティ モード**  
 トランスポート層の機構 (HTTPS など) によって、機密性、整合性、および認証を提供することを示します。 HTTPS のようなトランスポートを使用する場合、このモードには、パフォーマンスの面で効率的であることと、インターネットで普及しているため、十分に認識されているという利点があります。 欠点は、この種のセキュリティは通信パスの各ホップで個別に適用されるため、通信が "Man-in-the-middle" 攻撃の影響を受けやすくなることです。

**メッセージ セキュリティ モード**  
 という名前の仕様など、セキュリティ仕様の 1 つ以上実装することによってセキュリティが提供されることを指定します[Web Services Security:。SOAP Message Security](https://go.microsoft.com/fwlink/?LinkId=94684)します。 各メッセージには、メッセージ送信中のセキュリティを確保し、受信側による改ざんの検出とメッセージの復号化を可能にするために必要な機構が含まれます。 この意味で、セキュリティはすべてのメッセージ内にカプセル化されるため、複数のホップにわたるエンド ツー エンドのセキュリティが実現します。 複数の種類のメッセージの資格情報を含めることがもセキュリティ情報では、メッセージの一部になる、ため (と呼ばれる、_クレーム_)。 この方法には、送信元と送信先の間の複数のトランスポートを含め、どのトランスポート上でもメッセージを安全に送信できるという利点もあります。 この方法の欠点は、使用される暗号化機構が複雑であるため、パフォーマンスに影響することです。

**メッセージ資格情報のセキュリティ モードで転送します。**  
 トランスポート層を使用してメッセージの機密性、認証、および整合性を提供します。各メッセージには、メッセージの受信側で必要とされる複数の資格情報 (クレーム) を含めることができます。

**WS-\***  
 WCF に実装された一連の Web サービス (WS) 仕様 (WS-Security や WS-ReliableMessaging など) の略称です。

## <a name="see-also"></a>関連項目

- [Windows Communication Foundation とは](../../../docs/framework/wcf/whats-wcf.md)
- [Windows Communication Foundation のアーキテクチャ](../../../docs/framework/wcf/architecture.md)
