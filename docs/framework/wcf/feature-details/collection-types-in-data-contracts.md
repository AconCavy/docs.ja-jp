---
title: データ コントラクトのコレクション型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579750"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="a9fb0-102">データ コントラクトのコレクション型</span><span class="sxs-lookup"><span data-stu-id="a9fb0-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="a9fb0-103">*"コレクション"* は、特定の型の項目のリストです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="a9fb0-104">.NET Framework では、このようなリストは、配列またはその他のさまざまな型 (ジェネリックリスト、ジェネリック <xref:System.ComponentModel.BindingList%601> 、 <xref:System.Collections.Specialized.StringCollection> 、または) を使用して表すことができ <xref:System.Collections.ArrayList> ます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="a9fb0-105">たとえば、コレクションでは指定された顧客のアドレスのリストを保持できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="a9fb0-106">これらのコレクションは、実際の型に関係なく、 *リスト コレクション*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="a9fb0-107">コレクションには、ある項目 ("キー") と別の項目 ("値") の関連付けを表す特殊な形式のものがあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="a9fb0-108">.NET Framework では、これらはやジェネリックディクショナリなどの型によって表され <xref:System.Collections.Hashtable> ます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="a9fb0-109">たとえば、関連付けコレクションでは、都市 ("キー") をその人口 ("値") に関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="a9fb0-110">これらのコレクションは、実際の型に関係なく、 *ディクショナリ コレクション*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="a9fb0-111">データ コントラクト モデルでは、コレクションは特別な扱いを受けます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="a9fb0-112">配列やジェネリック コレクションを含め、 <xref:System.Collections.IEnumerable> インターフェイスを実装する型はコレクションとして認識されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="a9fb0-113">これらの中で、 <xref:System.Collections.IDictionary> インターフェイスまたはジェネリック <xref:System.Collections.Generic.IDictionary%602> インターフェイスを実装する型がディクショナリ コレクションであり、他はすべてリスト コレクションです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="a9fb0-114">メソッドとパラメーターなしのコンストラクターを持つなど、コレクション型の追加要件については、以降の `Add` セクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="a9fb0-115">これにより、コレクション型を確実にシリアル化および逆シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="a9fb0-116">これは、ジェネリック <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (パラメーターなしのコンストラクターがないため) など、一部のコレクションが直接サポートされないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="a9fb0-117">これらの制限を回避する方法については、このトピックで後述する「コレクション インターフェイス型と読み取り専用コレクションの使用」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="a9fb0-118">コレクションに含まれる型は、データ コントラクト型である必要があります。それ以外の場合は、シリアル化可能な型であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="a9fb0-119">詳細については、「[データコントラクトシリアライザーでサポートされる型](types-supported-by-the-data-contract-serializer.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="a9fb0-120">とは何か、有効なコレクションと見なされないもの、およびコレクションをシリアル化する方法の詳細については、このトピックの「コレクションの高度な規則」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="a9fb0-121">交換可能なコレクション</span><span class="sxs-lookup"><span data-stu-id="a9fb0-121">Interchangeable Collections</span></span>

<span data-ttu-id="a9fb0-122">同じ型のすべてのリスト コレクションは、同じデータ コントラクトを持つと見なされます (このトピックで後述するように、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を使用してカスタマイズされている場合を除きます)。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="a9fb0-123">たとえば、次のデータ コントラクトは等価です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="a9fb0-124">この 2 つのデータ コントラクトでは、いずれも次のコードに似た XML が生成されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="a9fb0-125">コレクションの可換性により、たとえば、サーバーではパフォーマンスを確保するように最適化されたコレクション型を使用し、クライアントではユーザー インターフェイス コンポーネントにバインドするよう設計されたコレクション型を使用することが可能です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="a9fb0-126">リスト コレクションと同様に、( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性によってカスタマイズされている場合を除き) キーおよび値の型が同じであるすべてのディクショナリ コレクションは、同じデータ コントラクトを持つと見なされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="a9fb0-127">コレクションの等価性に関する限り、重要となるのはデータ コントラクト型のみであり、.NET 型は影響しません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="a9fb0-128">つまり、Type1 と Type2 のデータ コントラクトが等価であれば、Type1 のコレクションは Type2 のコレクションと等価と見なされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="a9fb0-129">非ジェネリック コレクションは、 `Object`型のジェネリック コレクションと同じデータ コントラクトを持つと見なされます</span><span class="sxs-lookup"><span data-stu-id="a9fb0-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="a9fb0-130">(たとえば、 <xref:System.Collections.ArrayList> と <xref:System.Collections.Generic.List%601> のジェネリック `Object` のデータ コントラクトは同じです)。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="a9fb0-131">コレクション インターフェイス型と読み取り専用コレクションの使用</span><span class="sxs-lookup"><span data-stu-id="a9fb0-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="a9fb0-132">コレクション インターフェイス型 (<xref:System.Collections.IEnumerable>、 <xref:System.Collections.IDictionary>、ジェネリック <xref:System.Collections.Generic.IDictionary%602>、またはこれらのインターフェイスから派生したインターフェイス) も、実際のコレクション型のコレクション データ コントラクトと等価のコレクション データ コントラクトを持つと見なされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="a9fb0-133">したがって、シリアル化する型をコレクション インターフェイス型として宣言できます。この結果は、実際のコレクション型を使用した場合と同じになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="a9fb0-134">たとえば、次のデータ コントラクトは等価です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="a9fb0-135">シリアル化の実行時には、宣言された型がインターフェイスの場合、使用される実際のインスタンスの型はそのインターフェイスを実装する任意の型になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="a9fb0-136">(パラメーターなしのコンストラクターとメソッドを持つ) 前に説明した制限 `Add` は適用されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="a9fb0-137">たとえば、ジェネリック <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 型のデータ メンバーを直接宣言できない場合でも、Customer2 のアドレスを Address のジェネリック <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>のインスタンスに設定できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="a9fb0-138">逆シリアル化の実行時には、宣言された型がインターフェイスの場合、宣言されたインターフェイスを実装する型がシリアル化エンジンによって選択され、インスタンス化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="a9fb0-139">既知の型機構 (「[データコントラクトの既知の型](data-contract-known-types.md)」で説明されています) は、ここでは無効です。型の選択は WCF に組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="a9fb0-140">コレクション型のカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-140">Customizing Collection Types</span></span>

<span data-ttu-id="a9fb0-141">コレクション型は、複数の用途を持つ <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を使用することによってカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="a9fb0-142">コレクション型をカスタマイズすると、コレクションの可換性が損なわれるため、一般に、できるだけこの属性を適用しないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="a9fb0-143">この問題の詳細については、このトピックで後述する「コレクションの高度な規則」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="a9fb0-144">コレクション データ コントラクトの名前付け</span><span class="sxs-lookup"><span data-stu-id="a9fb0-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="a9fb0-145">コレクション型の名前付け規則は、「 [Data Contract Names](data-contract-names.md)」で説明する通常のデータ コントラクト型の名前付けの規則に似ていますが、重要な違いがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="a9fb0-146">名前をカスタマイズする際に、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性ではなく、 <xref:System.Runtime.Serialization.DataContractAttribute> 属性を使用します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="a9fb0-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性にも、 `Name` プロパティと `Namespace` プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="a9fb0-148"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を適用しない場合、コレクション型の既定の名前と名前空間は、コレクションに含まれる型の名前と名前空間によって決まります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="a9fb0-149">これらは、コレクション型自体の名前と名前空間の影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="a9fb0-150">型の一例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="a9fb0-151">これらの型のデータ コントラクト名は、"CustomerList1" や "StringList1" ではなく、どちらも "ArrayOfstring" になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="a9fb0-152">つまり、ルート レベルでこれらの型のどちらをシリアル化しても、次のコードのような XML が生成されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="a9fb0-153">この名前付け規則が選択されたのは、文字列のリストを表すカスタマイズされていないすべての型が同じデータ コントラクトと XML 表現を持つことができるようにするためです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="a9fb0-154">これにより、コレクションの可換性が実現されています。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="a9fb0-155">この例では、CustomerList1 と StringList1 は完全に交換可能です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="a9fb0-156">ただし、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を適用すると、この属性でプロパティが設定されていない場合でも、コレクションはカスタマイズされたコレクション データ コントラクトになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="a9fb0-157">この場合、コレクション データ コントラクトの名前と名前空間は、コレクション型自体によって決まります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="a9fb0-158">型の一例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="a9fb0-159">シリアル化すると、生成される XML は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="a9fb0-160">これは、カスタマイズされていない型の XML 表現と等価ではなくなっていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="a9fb0-161">`Name` プロパティと `Namespace` プロパティを使用して、名前付けをさらにカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="a9fb0-162">次のクラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="a9fb0-163">生成される XML は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="a9fb0-164">詳細については、このトピックで後述する「コレクションの高度な規則」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="a9fb0-165">リスト コレクション内の反復される要素名のカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="a9fb0-166">リスト コレクションには、反復されるエントリが含まれています。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-166">List collections contain repeating entries.</span></span> <span data-ttu-id="a9fb0-167">通常、反復される各エントリは、コレクションに含まれる型のデータ コントラクト名に従って名前が付けられた要素として表されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="a9fb0-168">`CustomerList` の各例では、コレクションに文字列が含まれていました。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="a9fb0-169">文字列プリミティブ型のデータコントラクト名は "string" であるため、繰り返し要素は "" でした \<string> 。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="a9fb0-170">ただし、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 属性の <xref:System.Runtime.Serialization.CollectionDataContractAttribute> プロパティを使用すると、この反復される要素名をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="a9fb0-171">型の一例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="a9fb0-172">生成される XML は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="a9fb0-173">反復される要素の名前空間は、コレクション データ コントラクトの名前空間と常に同じです。前述のように、コレクション データ コントラクトの名前空間は、 `Namespace` プロパティを使用してカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="a9fb0-174">ディクショナリ コレクションのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="a9fb0-175">ディクショナリ コレクションは、基本的にエントリのリストです。各エントリにはキーが含まれ、その後に値が続きます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="a9fb0-176">通常のリストと同様に、反復される要素に対応する要素名は、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> プロパティを使用して変更できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="a9fb0-177">また、キーと値を表す要素名は、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> プロパティと <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> プロパティを使用して変更できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="a9fb0-178">これらの要素の名前空間は、コレクション データ コントラクトの名前空間と同じです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="a9fb0-179">型の一例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="a9fb0-180">シリアル化すると、生成される XML は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="a9fb0-181">ディクショナリコレクションの詳細については、このトピックで後述する「コレクションの高度な規則」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="a9fb0-182">コレクションと既知の型</span><span class="sxs-lookup"><span data-stu-id="a9fb0-182">Collections and Known Types</span></span>

<span data-ttu-id="a9fb0-183">コレクション型を、他のコレクションまたはコレクション インターフェイスの代わりにポリモーフィックに使用する場合は、既知の型に追加する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="a9fb0-184">たとえば、 <xref:System.Collections.IEnumerable> 型のデータ メンバーを宣言し、このデータ メンバーを使用して <xref:System.Collections.ArrayList>のインスタンスを送信する場合、 <xref:System.Collections.ArrayList> を既知の型に追加する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="a9fb0-185">コレクションを、コレクション型以外の型の代わりにポリモーフィックに使用する場合は、コレクションを既知の型に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="a9fb0-186">たとえば、 `Object` 型のデータ メンバーを宣言し、このデータ メンバーを使用して <xref:System.Collections.ArrayList>のインスタンスを送信する場合は、 <xref:System.Collections.ArrayList> を既知の型に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="a9fb0-187">この場合、等価のコレクションをポリモーフィックにシリアル化することはできません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="a9fb0-188">たとえば、前述の例で、 <xref:System.Collections.ArrayList> を既知の型のリストに追加すると、 `Array of Object` クラスが等価のデータ コントラクトを持っていても、これを割り当てることはできなくなります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="a9fb0-189">これは、コレクション型以外の型のシリアル化における、通常の既知の型の動作と変わりません。しかし、コレクションが等価であることはごく一般的なことであるため、コレクションに関しては、この動作を理解しておくことが特に重要となります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="a9fb0-190">シリアル化では、指定されたデータ コントラクトの特定のスコープで許可される既知の型は 1 つだけであり、等価のコレクションはすべて同じデータ コントラクトを持ちます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="a9fb0-191">つまり、前述の例では、同じスコープで <xref:System.Collections.ArrayList> と `Array of Object` の両方を既知の型に追加することはできません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="a9fb0-192">先ほども説明したように、これはコレクション型以外の型での既知の型の動作と同じですが、コレクションではこの動作を理解しておくことが特に重要です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="a9fb0-193">コレクションの内容に既知の型が必要になることもあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="a9fb0-194">たとえば、 <xref:System.Collections.ArrayList> に `Type1` と `Type2`のインスタンスを実際に含める場合、この両方の型を既知の型に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="a9fb0-195">コレクションと既知の型を使用して、適切に構築されたオブジェクト グラフの例を次に示します</span><span class="sxs-lookup"><span data-stu-id="a9fb0-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="a9fb0-196">(この例には、多少不自然な部分があります。実際のアプリケーションでは、通常、次のデータ メンバーを `Object`として定義することはないため、既知の型やポリモーフィズムの問題が発生することはありません)。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="a9fb0-197">逆シリアル化では、宣言された型がコレクション型の場合、実際に送信された型に関係なく、宣言された型がインスタンス化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="a9fb0-198">宣言された型がコレクション インターフェイスの場合は、既知の型に関係なく、インスタンス化される型がデシリアライザーによって選択されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="a9fb0-199">また、逆シリアル化では、宣言された型がコレクション型ではないときにコレクション型を送信する場合、既知の型リストから一致するコレクション型が選択されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="a9fb0-200">逆シリアル化では、コレクション インターフェイス型を既知の型のリストに追加できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="a9fb0-201">この場合、逆シリアル化エンジンによって、インスタンス化する型が再度選択されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="a9fb0-202">コレクションと NetDataContractSerializer クラス</span><span class="sxs-lookup"><span data-stu-id="a9fb0-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="a9fb0-203"><xref:System.Runtime.Serialization.NetDataContractSerializer> クラスの使用時には、配列ではないカスタマイズされていないコレクション型 ( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を使用していないコレクション型) は、その特殊な意味を失います。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="a9fb0-204"><xref:System.SerializableAttribute> 属性でマークされたカスタマイズされていないコレクション型でも、 <xref:System.Runtime.Serialization.NetDataContractSerializer> 属性または <xref:System.SerializableAttribute> インターフェイスの規則に従って、 <xref:System.Runtime.Serialization.ISerializable> クラスによってシリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="a9fb0-205"><xref:System.Runtime.Serialization.NetDataContractSerializer> クラスを使用している場合でも、カスタマイズされたコレクション型、コレクション インターフェイス、および配列は、コレクションとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="a9fb0-206">コレクションとスキーマ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-206">Collections and Schema</span></span>

<span data-ttu-id="a9fb0-207">すべての等価のコレクションは、XML スキーマ定義言語 (XSD: XML Schema Definition Language) スキーマで同様に表現されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="a9fb0-208">このため、生成されたクライアント コードでもサーバーと同じコレクション型になることは通常ありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="a9fb0-209">たとえば、サーバーで Integer データ メンバーのジェネリック <xref:System.Collections.Generic.List%601> を含むデータ コントラクトを使用していても、生成されたクライアント コードでは、この同じデータ メンバーが整数の配列になることがあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="a9fb0-210">ディクショナリコレクションは、ディクショナリであることを示す WCF 固有のスキーマ注釈でマークされます。それ以外の場合、キーと値を持つエントリを含む単純なリストと区別できません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="a9fb0-211">データ コントラクト スキーマでのコレクションの表現方法の正確な記述については、「 [Data Contract Schema Reference](data-contract-schema-reference.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="a9fb0-212">既定では、コードをインポートする際に、カスタマイズされていないコレクションの型は生成されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="a9fb0-213">リスト コレクション型のデータ メンバーは配列としてインポートされ、ディクショナリ コレクション型のデータ メンバーはジェネリック ディクショナリとしてインポートされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="a9fb0-214">ただし、カスタマイズされたコレクションの場合、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性でマークされた個別の型が生成されます</span><span class="sxs-lookup"><span data-stu-id="a9fb0-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="a9fb0-215">(スキーマのカスタマイズされたコレクション型は、既定の名前空間、名前、繰り返し要素名、またはキー/値要素名を使用しないものです)。これらの型は、リスト型のジェネリックから派生する空の型 <xref:System.Collections.Generic.List%601> と、ディクショナリ型のジェネリックディクショナリです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="a9fb0-216">たとえば、サーバーで次のような型を使用するとします。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="a9fb0-217">スキーマをエクスポートし、再度インポートすると、生成されるクライアント コードは次のようになります (わかりやすくするために、プロパティの代わりにフィールドを示しています)。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="a9fb0-218">生成されるコードで、既定の型と異なる型を使用することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="a9fb0-219">たとえば、データ メンバーをユーザー インターフェイス コンポーネントにバインドしやすくするために、データ メンバーの通常の配列ではなく、ジェネリック <xref:System.ComponentModel.BindingList%601> を使用することがあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="a9fb0-220">生成するコレクション型を選択するには、スキーマをインポートするときに、使用するコレクション型のリストを <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> オブジェクトの <xref:System.Runtime.Serialization.ImportOptions> プロパティに渡します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="a9fb0-221">これらの型は、 *"参照されるコレクション型"* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="a9fb0-222">ジェネリック型を参照する場合は、完全なオープン ジェネリックまたは完全なクローズ ジェネリックであることが必要です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="a9fb0-223">Svcutil.exe ツールを使用すると、 **/collectionType** コマンド ライン スイッチ (短縮形: **/ct**) を使用して、この参照を実現できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="a9fb0-224">**/reference** スイッチ (短縮形: **/r**) を使用して、参照されるコレクション型のアセンブリも指定する必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="a9fb0-225">型がジェネリックの場合は、型の後に逆引用符とジェネリック パラメーターの数を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="a9fb0-226">\`引用符 () は、単一引用符 (') 文字と混同しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="a9fb0-227">参照されるコレクション型を複数指定するには、 **/collectionType** スイッチを複数回使用します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="a9fb0-228">たとえば、すべてのリストをジェネリック <xref:System.Collections.Generic.List%601>としてインポートするには、次のように指定します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="a9fb0-229">コレクションをインポートするときに、参照されるコレクション型のこのリストがスキャンされ、最も一致するコレクションが見つかると、そのコレクションがデータ メンバー型 (カスタマイズされていないコレクションの場合)、または派生元となる基本型 (カスタマイズされたコレクションの場合) として使用されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="a9fb0-230">ディクショナリはディクショナリと照合され、リストはリストと照合されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="a9fb0-231">たとえば、参照される型のリストにジェネリック <xref:System.ComponentModel.BindingList%601> と <xref:System.Collections.Hashtable> を追加した場合、前述の例で生成されるクライアント コードは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="a9fb0-232">参照されるコレクション型の一部として、コレクション インターフェイス型を指定できますが、無効なコレクション型 ( `Add` メソッドまたはパブリック コンストラクターを持たないコレクション型など) を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="a9fb0-233">クローズ ジェネリック型は、合致度が最も高いと見なされます</span><span class="sxs-lookup"><span data-stu-id="a9fb0-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="a9fb0-234">(非ジェネリック型は、 `Object`のクローズ ジェネリックと同等に扱われます)。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="a9fb0-235">たとえば、 <xref:System.Collections.Generic.List%601> のジェネリック <xref:System.DateTime>、ジェネリック <xref:System.ComponentModel.BindingList%601> (オープン ジェネリック)、および <xref:System.Collections.ArrayList> が参照されるコレクション型である場合、次のようなコードが生成されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="a9fb0-236">リスト コレクションの場合、以下の表内のケースだけがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="a9fb0-237">参照される型</span><span class="sxs-lookup"><span data-stu-id="a9fb0-237">Referenced type</span></span>|<span data-ttu-id="a9fb0-238">参照される型で実装されるインターフェイス</span><span class="sxs-lookup"><span data-stu-id="a9fb0-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="a9fb0-239">例</span><span class="sxs-lookup"><span data-stu-id="a9fb0-239">Example</span></span>|<span data-ttu-id="a9fb0-240">型の処理</span><span class="sxs-lookup"><span data-stu-id="a9fb0-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="a9fb0-241">非ジェネリックまたはクローズ ジェネリック (任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="a9fb0-242">非ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="a9fb0-243">or</span><span class="sxs-lookup"><span data-stu-id="a9fb0-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="a9fb0-244">ここでは、T= `int`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-244">where T= `int`</span></span>|<span data-ttu-id="a9fb0-245">`Object` のクローズ ジェネリック (例 : `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="a9fb0-246">非ジェネリックまたはクローズ ジェネリック (コレクション型と必ずしも一致するわけではない任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="a9fb0-247">クローズ ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="a9fb0-248">or</span><span class="sxs-lookup"><span data-stu-id="a9fb0-248">or</span></span><br /><br /> <span data-ttu-id="a9fb0-249">`MyType<T> : IList<string>` ここでは、T=`int`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="a9fb0-250">クローズ ジェネリック (例 : `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="a9fb0-251">任意の数のパラメーターを持つクローズ ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="a9fb0-252">型のパラメーターのいずれかを使用するオープン ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="a9fb0-253">ここでは、T=`int`、U=`string`、V=`bool`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="a9fb0-254">クローズ ジェネリック (例 : `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="a9fb0-255">パラメーターを 1 つ持つオープン ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-255">Open generic with one parameter</span></span>|<span data-ttu-id="a9fb0-256">型のパラメーターを使用するオープン ジェネリック</span><span class="sxs-lookup"><span data-stu-id="a9fb0-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="a9fb0-257">`MyType<T> : IList<T>`、T はオープン</span><span class="sxs-lookup"><span data-stu-id="a9fb0-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="a9fb0-258">オープン ジェネリック (例 : `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="a9fb0-259">型が複数のリスト コレクション インターフェイスを実装している場合、以下の制限が適用されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="a9fb0-260">型が、異なる型のジェネリック <xref:System.Collections.Generic.IEnumerable%601> (またはその派生インターフェイス) を複数回実装している場合、その型は有効な参照されるコレクション型とは見なされず、無視されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="a9fb0-261">これは、一部の実装が無効であったり、オープン ジェネリックを使用していたりする場合も該当します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="a9fb0-262">たとえば、型が <xref:System.Collections.Generic.IEnumerable%601> のジェネリック `int` と、T のジェネリック <xref:System.Collections.Generic.IEnumerable%601> を実装している場合、 `int` の参照されるコレクションとしても、その他の型の参照されるコレクションとしても使用されることはありません。この場合、型が `Add` を受け入れる `int` メソッドと T 型のパラメーターを受け入れる `Add` メソッドのいずれか、または両方を持っているかどうかは関係ありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="a9fb0-263">型がジェネリック コレクション インターフェイスと <xref:System.Collections.IList>を実装している場合、ジェネリック コレクション インターフェイスが <xref:System.Object>型のクローズ ジェネリックでない限り、参照されるコレクション型として使用されることはありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="a9fb0-264">ディクショナリ コレクションの場合、以下の表内のケースだけがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="a9fb0-265">参照される型</span><span class="sxs-lookup"><span data-stu-id="a9fb0-265">Referenced type</span></span>|<span data-ttu-id="a9fb0-266">参照される型で実装されるインターフェイス</span><span class="sxs-lookup"><span data-stu-id="a9fb0-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="a9fb0-267">例</span><span class="sxs-lookup"><span data-stu-id="a9fb0-267">Example</span></span>|<span data-ttu-id="a9fb0-268">型の処理</span><span class="sxs-lookup"><span data-stu-id="a9fb0-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="a9fb0-269">非ジェネリックまたはクローズ ジェネリック (任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="a9fb0-270">or</span><span class="sxs-lookup"><span data-stu-id="a9fb0-270">or</span></span><br /><br /> <span data-ttu-id="a9fb0-271">`MyType<T> : IDictionary` ここでは、T=`int`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="a9fb0-272">クローズ ジェネリック `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="a9fb0-273">クローズ ジェネリック (任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a9fb0-274"><xref:System.Collections.Generic.IDictionary%602>、クローズ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="a9fb0-275">`MyType<T> : IDictionary<string, bool>` ここでは、T=`int`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="a9fb0-276">クローズ ジェネリック (例 : `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="a9fb0-277">クローズ ジェネリック (任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a9fb0-278">ジェネリック <xref:System.Collections.Generic.IDictionary%602>、キーまたは値の一方がクローズ。もう一方はオープンで、型のパラメーターのいずれかを使用</span><span class="sxs-lookup"><span data-stu-id="a9fb0-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="a9fb0-279">`MyType<T,U,V> : IDictionary<string,V>` ここでは、T=`int`、U=`float`、V=`bool`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="a9fb0-280">or</span><span class="sxs-lookup"><span data-stu-id="a9fb0-280">or</span></span><br /><br /> <span data-ttu-id="a9fb0-281">`MyType<Z> : IDictionary<Z,bool>` ここでは、Z=`string`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="a9fb0-282">クローズ ジェネリック (例 : `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="a9fb0-283">クローズ ジェネリック (任意の数のパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="a9fb0-284">ジェネリック <xref:System.Collections.Generic.IDictionary%602>、キーと値の両方がオープンであり、それぞれ型のパラメーターのいずれかを使用</span><span class="sxs-lookup"><span data-stu-id="a9fb0-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="a9fb0-285">`MyType<T,U,V> : IDictionary<V,U>` ここでは、T=`int`、U=`bool`、V=`string`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="a9fb0-286">クローズ ジェネリック (例 : `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="a9fb0-287">オープン ジェネリック (2 つのパラメーター)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-287">Open generic (two parameters)</span></span>|<span data-ttu-id="a9fb0-288">ジェネリック <xref:System.Collections.Generic.IDictionary%602>、オープン、型のジェネリック パラメーターの両方をその出現順に使用</span><span class="sxs-lookup"><span data-stu-id="a9fb0-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="a9fb0-289">`MyType<K,V> : IDictionary<K,V>`、K と V は共にオープン</span><span class="sxs-lookup"><span data-stu-id="a9fb0-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="a9fb0-290">オープン ジェネリック (例 : `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="a9fb0-291">型が <xref:System.Collections.IDictionary> とジェネリック <xref:System.Collections.Generic.IDictionary%602>の両方を実装している場合、ジェネリック <xref:System.Collections.Generic.IDictionary%602> だけが考慮されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="a9fb0-292">部分的なジェネリック型の参照はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="a9fb0-293">重複は許可されていません。たとえば、 <xref:System.Collections.Generic.List%601> のジェネリック `Integer` と、 `Integer` のジェネリック コレクションの両方を <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>に追加することはできません。これは、スキーマで整数のリストが見つかったときに、どちらを使用するかを判断できなくなるためです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="a9fb0-294">もっとも、このような重複が検出されるのは、それが問題になるような型がスキーマ中にある場合だけです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="a9fb0-295">たとえば、インポートしているスキーマ中に整数のリストがない場合に、 <xref:System.Collections.Generic.List%601> のジェネリック `Integer` と `Integer` のジェネリック コレクションの両方が <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>にあっても問題はありませんが、いずれも使用されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="a9fb0-296">コレクションの高度な規則</span><span class="sxs-lookup"><span data-stu-id="a9fb0-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="a9fb0-297">コレクションのシリアル化</span><span class="sxs-lookup"><span data-stu-id="a9fb0-297">Serializing Collections</span></span>

<span data-ttu-id="a9fb0-298">コレクションのシリアル化規則を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="a9fb0-299">コレクション型は、組み合わせる (コレクションのコレクションを持つ) ことができます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="a9fb0-300">ジャグ配列は、コレクションのコレクションとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="a9fb0-301">多次元配列はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="a9fb0-302">バイト配列と <xref:System.Xml.XmlNode> の配列は、コレクションではなく、プリミティブとして扱われる特殊な配列の型です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="a9fb0-303">バイト配列をシリアル化すると、バイトごとの個別の要素ではなく、Base64 でエンコードされたデータのチャンクを含む単一の XML 要素が生成されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="a9fb0-304">の配列の処理方法の詳細については <xref:System.Xml.XmlNode> 、「[データコントラクトの XML 型と ADO.NET 型](xml-and-ado-net-types-in-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="a9fb0-305">これらの特殊な型もコレクションに参加できます。バイト配列の配列の場合、複数の XML 要素が生成され、各要素に Base64 でエンコードされたデータのチャンクが含まれます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="a9fb0-306"><xref:System.Runtime.Serialization.DataContractAttribute> 属性をコレクション型に適用した場合、型はコレクションとしてではなく、通常のデータ コントラクト型として扱われるようになります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="a9fb0-307">コレクション型が <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスを実装している場合、次の規則が適用されます。 `myType:IList<string>, IXmlSerializable`型と仮定します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="a9fb0-308">宣言型が `IList<string>`の場合、この型はリストとしてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="a9fb0-309">宣言型が `myType`の場合、この型は `IXmlSerializable`としてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="a9fb0-310">宣言型が `IXmlSerializable`の場合は、既知の型のリストに `IXmlSerializable`を追加しているときにのみ、この型が `myType` としてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="a9fb0-311">コレクションは、以下の表に示すメソッドを使用してシリアル化および逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="a9fb0-312">コレクション型の実装</span><span class="sxs-lookup"><span data-stu-id="a9fb0-312">Collection type implements</span></span>|<span data-ttu-id="a9fb0-313">シリアル化で呼び出されるメソッド</span><span class="sxs-lookup"><span data-stu-id="a9fb0-313">Method(s) called on serialization</span></span>|<span data-ttu-id="a9fb0-314">逆シリアル化で呼び出されるメソッド</span><span class="sxs-lookup"><span data-stu-id="a9fb0-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="a9fb0-315">ジェネリック <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="a9fb0-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="a9fb0-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="a9fb0-317">ジェネリック Add</span><span class="sxs-lookup"><span data-stu-id="a9fb0-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="a9fb0-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="a9fb0-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="a9fb0-319">ジェネリック <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="a9fb0-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="a9fb0-320">ジェネリック <xref:System.Collections.Generic.IList%601> インデクサー</span><span class="sxs-lookup"><span data-stu-id="a9fb0-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="a9fb0-321">ジェネリック Add</span><span class="sxs-lookup"><span data-stu-id="a9fb0-321">Generic Add</span></span>|
|<span data-ttu-id="a9fb0-322">ジェネリック <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="a9fb0-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="a9fb0-323">列挙子</span><span class="sxs-lookup"><span data-stu-id="a9fb0-323">Enumerator</span></span>|<span data-ttu-id="a9fb0-324">ジェネリック Add</span><span class="sxs-lookup"><span data-stu-id="a9fb0-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="a9fb0-325"><xref:System.Collections.IList> インデクサー</span><span class="sxs-lookup"><span data-stu-id="a9fb0-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="a9fb0-326">ジェネリック <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="a9fb0-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="a9fb0-327">適切な型 (ジェネリック パラメーターの型、またはその基本型のいずれか) のパラメーターを 1 つ受け取る `Add` という非静的メソッド。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="a9fb0-328">このようなメソッドは、シリアル化と逆シリアル化の両方で、シリアライザーがコレクション型をコレクションとして処理するために必要になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="a9fb0-329"><xref:System.Collections.IEnumerable> (およびこのインターフェイスから派生した <xref:System.Collections.ICollection>)</span><span class="sxs-lookup"><span data-stu-id="a9fb0-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="a9fb0-330">`Add` 型のパラメーターを 1 つ受け取る `Object`という非静的メソッド。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="a9fb0-331">このようなメソッドは、シリアル化と逆シリアル化の両方で、シリアライザーがコレクション型をコレクションとして処理するために必要になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="a9fb0-332">前の表に示すコレクション インターフェイスは、優先度の高いものから順に並べられています。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="a9fb0-333">たとえば、型が <xref:System.Collections.IList> とジェネリック <xref:System.Collections.Generic.IEnumerable%601>の両方を実装している場合、 <xref:System.Collections.IList> の規則に従って、コレクションがシリアル化および逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="a9fb0-334">逆シリアル化では、最初に、パラメーターなしのコンストラクターを呼び出して型のインスタンスを作成することにより、すべてのコレクションを逆シリアル化します。これは、シリアル化と逆シリアル化の両方で、シリアライザーがコレクション型をコレクションとして処理するために必要です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="a9fb0-335">同じジェネリック コレクション インターフェイスが複数回実装されており (型が <xref:System.Collections.Generic.ICollection%601> のジェネリック `Integer` と、 <xref:System.Collections.Generic.ICollection%601> のジェネリック <xref:System.String>の両方を実装している場合など)、優先度がより高いインターフェイスが見つからない場合は、コレクションが有効なコレクションとして扱われません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="a9fb0-336">コレクション型には <xref:System.SerializableAttribute> 属性を適用でき、 <xref:System.Runtime.Serialization.ISerializable> インターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="a9fb0-337">これらはいずれも無視されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-337">Both of these are ignored.</span></span> <span data-ttu-id="a9fb0-338">ただし、型がコレクション型の要件を完全に満たしていない場合 ( `Add` メソッドがないなど)、その型はコレクション型と見なされないため、 <xref:System.SerializableAttribute> 属性と <xref:System.Runtime.Serialization.ISerializable> インターフェイスを使用して、型をシリアル化できるかどうかが判断されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="a9fb0-339">コレクションをカスタマイズするために、コレクションに <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を適用した場合、上記の <xref:System.SerializableAttribute> 代替機構は除去されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="a9fb0-340">カスタマイズされたコレクションがコレクション型の要件を満たしていない場合には、代わりに <xref:System.Runtime.Serialization.InvalidDataContractException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="a9fb0-341">多くの場合、例外文字列には、指定された型が有効なコレクションと見なされない理由 (メソッドなし、パラメーターなしのコンストラクターなど) を説明する情報が含まれます。そのため、多くの場合、 `Add` デバッグのために属性を適用すると便利です <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="a9fb0-342">コレクションの名前付け</span><span class="sxs-lookup"><span data-stu-id="a9fb0-342">Collection Naming</span></span>

<span data-ttu-id="a9fb0-343">コレクションの名前付け規則を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="a9fb0-344">すべてのディクショナリコレクションデータコントラクトの既定の名前空間、およびプリミティブ型を含むリストコレクションデータコントラクトの既定の名前空間は、 `http://schemas.microsoft.com/2003/10/Serialization/Arrays` 名前空間を使用してオーバーライドされない限り、になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="a9fb0-345">このために、組み込みの XSD 型に割り当てられた型と、 `char`、 `Timespan`、および `Guid` の各型がプリミティブと見なされます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="a9fb0-346">Namespace を使用してオーバーライドしていない場合、プリミティブ型以外の型を含むコレクション型の既定の名前空間は、コレクションに含まれる型のデータ コントラクト名前空間と同じです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="a9fb0-347">Name を使用してオーバーライドしていない場合、リスト コレクション データ コントラクトの既定の名前は、文字列 "ArrayOf" とコレクションに含まれる型のデータ コントラクト名を組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="a9fb0-348">たとえば、Integers のジェネリック List のデータ コントラクト名は "ArrayOfint" です。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="a9fb0-349">`Object` のデータ コントラクト名は "anyType" であることに留意してください。したがって、 <xref:System.Collections.ArrayList> のような非ジェネリック リストのデータ コントラクト名は、"ArrayOfanyType" になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="a9fb0-350">`Name`を使用してオーバーライドしていない場合、ディクショナリ コレクション データ コントラクトの既定の名前は、文字列 "ArrayOfKeyValueOf"、キーの型のデータ コントラクト名、および値の型のデータ コントラクト名をこの順番で組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="a9fb0-351">たとえば、String と Integer のジェネリック ディクショナリのデータ コントラクト名は、"ArrayOfKeyValueOfstringint" になります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="a9fb0-352">また、キーの型と値の型がいずれもプリミティブ型ではない場合は、キーおよび値の型のデータ コントラクト名前空間の名前空間ハッシュが名前に付加されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="a9fb0-353">名前空間ハッシュの詳細については、「[データコントラクト名](data-contract-names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="a9fb0-354">各ディクショナリ コレクション データ コントラクトには、ディクショナリの 1 エントリを表すコンパニオン データ コントラクトが存在します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="a9fb0-355">コンパニオン データ コントラクトの名前は、"ArrayOf" プレフィックスを除いたディクショナリ データ コントラクトの名前と同じです。また、名前空間は、ディクショナリ データ コントラクトの名前空間と同じです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="a9fb0-356">たとえば、"ArrayOfKeyValueOfstringint" ディクショナリ データ コントラクトの場合、"KeyValueofstringint" データ コントラクトがディクショナリの 1 エントリを表します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="a9fb0-357">次のセクションで説明するように、このデータ コントラクトの名前は、 `ItemName` プロパティを使用してカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="a9fb0-358">「 [Data Contract Names](data-contract-names.md)」に記載されたジェネリック型の名前付け規則は、コレクション型にすべて適用されます。つまり、Name 内の中かっこを使用してジェネリック型パラメーターを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="a9fb0-359">ただし、かっこ内の数値は、コレクションに含まれる型ではなく、ジェネリック パラメーターを指すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="a9fb0-360">コレクションのカスタマイズ</span><span class="sxs-lookup"><span data-stu-id="a9fb0-360">Collection Customization</span></span>

<span data-ttu-id="a9fb0-361"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を次のように使用することは禁止されています。次のように使用すると、 <xref:System.Runtime.Serialization.InvalidDataContractException> 例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="a9fb0-362"><xref:System.Runtime.Serialization.DataContractAttribute> 属性が既に適用されている型、またはその派生型のいずれかに <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を適用する。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="a9fb0-363"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> インターフェイスを実装する型に <xref:System.Xml.Serialization.IXmlSerializable> 属性を適用する。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="a9fb0-364">コレクション型以外の型に <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を適用する。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="a9fb0-365">ディクショナリ型以外の型に適用された <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 属性で、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> または <xref:System.Runtime.Serialization.CollectionDataContractAttribute> の設定を試みる。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="a9fb0-366">ポリモーフィズム規則</span><span class="sxs-lookup"><span data-stu-id="a9fb0-366">Polymorphism Rules</span></span>

<span data-ttu-id="a9fb0-367">既に説明したように、 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性を使用してコレクションをカスタマイズすると、コレクションの可換性を妨げることがあります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="a9fb0-368">カスタマイズされた 2 つのコレクション型を等価と見なすことができるのは、それらの名前、名前空間、項目名、およびキーと値の名前 (ディクショナリ コレクションの場合) が一致する場合だけです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="a9fb0-369">カスタマイズが原因で、あるコレクション データ コントラクトを使用する必要があるところに、誤って別のコレクション データ コントラクトが使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="a9fb0-370">このような状況は回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-370">This should be avoided.</span></span> <span data-ttu-id="a9fb0-371">次の型を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="a9fb0-372">この場合、 `Marks1` のインスタンスは `testMarks`に割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="a9fb0-373">ただし、 `Marks2` は使用しないようにする必要があります。そのデータ コントラクトは、 `IList<int>` データ コントラクトと等価とは見なされないからです。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="a9fb0-374">データコントラクト名は、"ArrayOfint" ではなく "Marks2" で、繰り返し要素名は "" であり、"" ではあり \<mark> ません \<int> 。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="a9fb0-375">以下の表に、コレクションのポリモーフィックな割り当てに適用される規則を示します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="a9fb0-376">宣言された型</span><span class="sxs-lookup"><span data-stu-id="a9fb0-376">Declared type</span></span>|<span data-ttu-id="a9fb0-377">カスタマイズされていないコレクションの割り当て</span><span class="sxs-lookup"><span data-stu-id="a9fb0-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="a9fb0-378">カスタマイズされたコレクションの割り当て</span><span class="sxs-lookup"><span data-stu-id="a9fb0-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="a9fb0-379">Object</span><span class="sxs-lookup"><span data-stu-id="a9fb0-379">Object</span></span>|<span data-ttu-id="a9fb0-380">コントラクト名はシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-380">Contract name is serialized.</span></span>|<span data-ttu-id="a9fb0-381">コントラクト名はシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a9fb0-382">カスタマイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-382">Customization is used.</span></span>|
|<span data-ttu-id="a9fb0-383">コレクション インターフェイス</span><span class="sxs-lookup"><span data-stu-id="a9fb0-383">Collection interface</span></span>|<span data-ttu-id="a9fb0-384">コントラクト名はシリアル化されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-384">Contract name is not serialized.</span></span>|<span data-ttu-id="a9fb0-385">コントラクト名はシリアル化されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="a9fb0-386">カスタマイズは使用されません。\*</span><span class="sxs-lookup"><span data-stu-id="a9fb0-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="a9fb0-387">カスタマイズされていないコレクション</span><span class="sxs-lookup"><span data-stu-id="a9fb0-387">Non-customized collection</span></span>|<span data-ttu-id="a9fb0-388">コントラクト名はシリアル化されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-388">Contract name is not serialized.</span></span>|<span data-ttu-id="a9fb0-389">コントラクト名はシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a9fb0-390">カスタマイズが使用されます\*\*。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="a9fb0-391">カスタマイズされたコレクション</span><span class="sxs-lookup"><span data-stu-id="a9fb0-391">Customized collection</span></span>|<span data-ttu-id="a9fb0-392">コントラクト名はシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-392">Contract name is serialized.</span></span> <span data-ttu-id="a9fb0-393">カスタマイズは使用されません。\*\*</span><span class="sxs-lookup"><span data-stu-id="a9fb0-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="a9fb0-394">コントラクト名はシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="a9fb0-395">割り当てられた型のカスタマイズが使用されます。\*\*</span><span class="sxs-lookup"><span data-stu-id="a9fb0-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="a9fb0-396">\*クラスでは <xref:System.Runtime.Serialization.NetDataContractSerializer> 、この場合、カスタマイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="a9fb0-397">また、 <xref:System.Runtime.Serialization.NetDataContractSerializer> クラスは、このケースで実際の型名もシリアル化するため、逆シリアル化も予期されたとおりに機能します。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="a9fb0-398">\*\*このような場合、スキーマが無効なインスタンスになるため、回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="a9fb0-399">コントラクト名をシリアル化する場合、割り当てるコレクション型が既知の型リストに含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="a9fb0-400">逆に言うと、名前をシリアル化しない場合は、既知の型リストに型を追加する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="a9fb0-401">派生型の配列は、基本型の配列に代入できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="a9fb0-402">この場合、反復される各要素について、派生型のコントラクト名がシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="a9fb0-403">たとえば、 `Book` 型が `LibraryItem`型から派生している場合、 `Book` の配列を `LibraryItem`の配列に代入できます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="a9fb0-404">これは、他のコレクション型には適用されません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-404">This does not apply to other collection types.</span></span> <span data-ttu-id="a9fb0-405">たとえば、 `Generic List of Book` を `Generic List of LibraryItem`に代入することはできません。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="a9fb0-406">ただし、 `Generic List of LibraryItem` インスタンスを含む `Book` を代入することはできます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="a9fb0-407">配列の場合も、配列ではない場合も、 `Book` は既知の型リストに含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="a9fb0-408">コレクションとオブジェクト参照の保存</span><span class="sxs-lookup"><span data-stu-id="a9fb0-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="a9fb0-409">シリアライザーがオブジェクト参照を保存するモードで機能している場合、オブジェクト参照の保存はコレクションにも適用されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="a9fb0-410">具体的には、コレクション全体と、コレクションに含まれる個々の項目の両方のオブジェクト ID が保存されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="a9fb0-411">ディクショナリの場合、キーと値のペア オブジェクトと、個々のキー オブジェクトおよび値オブジェクトのオブジェクト ID が保存されます。</span><span class="sxs-lookup"><span data-stu-id="a9fb0-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="a9fb0-412">関連項目</span><span class="sxs-lookup"><span data-stu-id="a9fb0-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
