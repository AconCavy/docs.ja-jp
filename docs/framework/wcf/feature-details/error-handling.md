---
title: エラー処理
ms.date: 03/30/2017
ms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf
ms.openlocfilehash: f6c0d676a37648678b2b726a46a6238ccc1b3331
ms.sourcegitcommit: eff6adb61852369ab690f3f047818c90580e7eb1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2019
ms.locfileid: "72004887"
---
# <a name="error-handling-in-windows-communication-foundation-wcf"></a><span data-ttu-id="0a151-102">Windows Communication Foundation でのエラー処理 (WCF)</span><span class="sxs-lookup"><span data-stu-id="0a151-102">Error handling in Windows Communication Foundation (WCF)</span></span>

<span data-ttu-id="0a151-103">サービスで予期しない例外やエラーが発生した場合、例外処理ソリューションを設計する方法は複数あります。</span><span class="sxs-lookup"><span data-stu-id="0a151-103">When a service encounters an unexpected exception or error, there are multiple ways to design an exception-handling solution.</span></span> <span data-ttu-id="0a151-104">1つの "適切" または "ベストプラクティス" のエラー処理ソリューションはありませんが、1つの考慮すべき有効なパスが複数あります。</span><span class="sxs-lookup"><span data-stu-id="0a151-104">While there is no single "correct" or "best practice" error-handling solution, there are multiple valid paths for one to consider.</span></span> <span data-ttu-id="0a151-105">通常は、次のリストの複数のアプローチを組み合わせるハイブリッドソリューションを実装することをお勧めします。これは、WCF 実装の複雑さ、例外の種類と頻度、処理されたものと処理されていない性質によって異なります。例外と、関連するトレース、ログ、またはポリシーの要件。</span><span class="sxs-lookup"><span data-stu-id="0a151-105">It is normally recommended that one implement a hybrid solution that combines multiple approaches from the list below, depending on the complexity of the WCF implementation, the type and frequency of the exceptions, the handled vs. unhandled nature of the exceptions, and any associated tracing, logging, or policy requirements.</span></span>

<span data-ttu-id="0a151-106">これらのソリューションについては、このセクションの残りの部分で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="0a151-106">These solutions are explained more deeply in the rest of this section.</span></span>

## <a name="the-microsoft-enterprise-library"></a><span data-ttu-id="0a151-107">Microsoft Enterprise Library</span><span class="sxs-lookup"><span data-stu-id="0a151-107">The Microsoft Enterprise Library</span></span>

<span data-ttu-id="0a151-108">Microsoft Enterprise Library Exception Handling Application Block は、共通の設計パターンを実装し、エンタープライズ アプリケーションのすべてのアーキテクチャ レイヤーで発生する例外を処理するための一貫した戦略を策定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="0a151-108">The Microsoft Enterprise Library Exception Handling Application Block helps implement common design patterns and create a consistent strategy for processing exceptions that occur in all architectural layers of an enterprise application.</span></span> <span data-ttu-id="0a151-109">これは、アプリケーション コンポーネントの catch ステートメントに含まれる一般的なコードをサポートするように設計されています。</span><span class="sxs-lookup"><span data-stu-id="0a151-109">It is designed to support the typical code contained in catch statements in application components.</span></span> <span data-ttu-id="0a151-110">開発者は、アプリケーション全体で同一の catch ブロックにこのコード (例外情報をログに記録するコードなど) を繰り返し使用する代わりに、Exception Handling Application Block を使用すると、このロジックを再利用可能な例外ハンドラーとしてカプセル化できます。</span><span class="sxs-lookup"><span data-stu-id="0a151-110">Instead of repeating this code (such as code that logs exception information) in identical catch blocks throughout an application, the Exception Handling Application Block allows developers to encapsulate this logic as reusable exception handlers.</span></span>

<span data-ttu-id="0a151-111">このライブラリには、すぐに使用できる Fault Contract Exception Handler が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0a151-111">This Library includes out-of-the-box a Fault Contract Exception Handler.</span></span> <span data-ttu-id="0a151-112">この例外ハンドラーは、WCF サービスの境界で使用するように設計されており、例外から新しいエラーコントラクトを生成します。</span><span class="sxs-lookup"><span data-stu-id="0a151-112">This exception handler is designed for use at WCF service boundaries, and generates a new Fault Contract from the exception.</span></span>

<span data-ttu-id="0a151-113">アプリケーション ブロックは、よく使用されるベスト プラクティスを組み込み、アプリケーション全体の例外処理に共通の方法を提供することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="0a151-113">Application blocks aim to incorporate commonly used best practices and provide a common approach for exception handling throughout your application.</span></span> <span data-ttu-id="0a151-114">その一方で、独自に開発されたカスタム エラー ハンドラーやエラー コントラクトが非常に便利な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="0a151-114">On the other hand, custom error handlers and fault contracts developed on one’s own can also be very useful.</span></span> <span data-ttu-id="0a151-115">たとえば、カスタムエラーハンドラーを使用すると、すべての例外を FaultExceptions に自動的に昇格させ、ログ記録機能をアプリケーションに追加することができます。</span><span class="sxs-lookup"><span data-stu-id="0a151-115">For instance, custom error handlers provide an excellent opportunity to automatically promote all exceptions to FaultExceptions and also to add logging capabilities to your application.</span></span>

<span data-ttu-id="0a151-116">詳細については、 [Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10))を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0a151-116">For more information, please see [Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10)).</span></span>

## <a name="dealing-with-expected-exceptions"></a><span data-ttu-id="0a151-117">予期される例外の処理</span><span class="sxs-lookup"><span data-stu-id="0a151-117">Dealing with expected exceptions</span></span>

<span data-ttu-id="0a151-118">適切な対処方法は、すべての操作または関連する拡張ポイントで予期される例外をキャッチし、それらを回復できるかどうかを判断して、FaultException\<T > に適切なカスタムエラーを返すことです。</span><span class="sxs-lookup"><span data-stu-id="0a151-118">The proper course of action is to catch expected exceptions in every operation or relevant extensibility point, decide whether they can be recovered from, and return the proper custom fault in a FaultException\<T>.</span></span>
  
## <a name="dealing-with-unexpected-exceptions-using-an-ierrorhandler"></a><span data-ttu-id="0a151-119">IErrorHandler を使用した予期しない例外の処理</span><span class="sxs-lookup"><span data-stu-id="0a151-119">Dealing with unexpected exceptions using an IErrorHandler</span></span>

<span data-ttu-id="0a151-120">予期しない例外に対処するには、IErrorHandler の "フック" を行うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0a151-120">To deal with unexpected exceptions, the recommended course of action is to "hook" an IErrorHandler.</span></span> <span data-ttu-id="0a151-121">エラーハンドラーは、チャネルレイヤーではなく、WCF ランタイムレベル ("サービスモデル" レイヤー) でのみ例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="0a151-121">Error handlers only catch exceptions at the WCF runtime level (the "service model" layer), not at the channel layer.</span></span> <span data-ttu-id="0a151-122">チャネル レベルで IErrorHandler をフックする唯一の方法は、カスタム チャネルを作成することです。ただし、これはほとんどのシナリオで推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="0a151-122">The only way to hook an IErrorHandler at the channel level is to create a custom channel, which is not recommended in most scenarios.</span></span>

<span data-ttu-id="0a151-123">"予期しない例外" は、通常、回復不可能な例外でも処理の例外でもありません。その代わりに、予期しないユーザー例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="0a151-123">An "unexpected exception" is generally neither an irrecoverable exception nor a processing exception; it is, instead, an unexpected user exception.</span></span> <span data-ttu-id="0a151-124">回復不可能な例外 (メモリ不足の例外など) は、通常、[サービスモデル例外ハンドラー](xref:System.ServiceModel.Dispatcher.ExceptionHandler)によって自動的に処理されますが、通常は正常に処理されません。このような例外を処理する唯一の理由は、追加のログを記録するか、標準の例外をクライアントに返すことです。</span><span class="sxs-lookup"><span data-stu-id="0a151-124">An irrecoverable exception (such as an out-of-memory exception) – one generally handled by the [Service Model Exception Handler](xref:System.ServiceModel.Dispatcher.ExceptionHandler) automatically – cannot generally be handled gracefully, and the only reason to handle such an exception at all may be do additional logging or to return a standard exception to the client.</span></span> <span data-ttu-id="0a151-125">処理例外は、シリアル化、エンコーダー、フォーマッタ レベルなどのメッセージの処理中に発生します。通常、この例外は IErrorHandler では処理できません。これは、一般的に、このような例外が発生するまでにエラー ハンドラーの介入が早すぎるか、遅すぎることが原因です。</span><span class="sxs-lookup"><span data-stu-id="0a151-125">A processing exception occurs in the processing of the message – for example, at the serialization, encoder, or formatter level – generally cannot be handled at an IErrorHandler, because it is generally either too early or too late for the error handler to intervene by the time these exceptions occur.</span></span> <span data-ttu-id="0a151-126">同様に、トランスポート例外も IErrorHandler では処理できません。</span><span class="sxs-lookup"><span data-stu-id="0a151-126">Similarly, transport exceptions cannot be handled at an IErrorHandler.</span></span>

<span data-ttu-id="0a151-127">IErrorHandler を使用すると、例外がスローされたときのアプリケーションの動作を明示的に制御できます。</span><span class="sxs-lookup"><span data-stu-id="0a151-127">With an IErrorHandler, you can explicitly control the behavior of your application when an exception is thrown.</span></span> <span data-ttu-id="0a151-128">次のような操作が可能です。</span><span class="sxs-lookup"><span data-stu-id="0a151-128">You may:</span></span>  

1. <span data-ttu-id="0a151-129">クライアントにエラーを送信するかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="0a151-129">Decide whether or not to send a fault to the client.</span></span>

2. <span data-ttu-id="0a151-130">例外をエラーに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="0a151-130">Replace an exception with a fault.</span></span>

3. <span data-ttu-id="0a151-131">エラーを別のエラーに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="0a151-131">Replace a fault with another fault.</span></span>

4. <span data-ttu-id="0a151-132">ログ記録またはトレースを実行します。</span><span class="sxs-lookup"><span data-stu-id="0a151-132">Perform logging or tracing.</span></span>

5. <span data-ttu-id="0a151-133">その他のカスタムアクティビティを実行します。</span><span class="sxs-lookup"><span data-stu-id="0a151-133">Perform other custom activities.</span></span>

<span data-ttu-id="0a151-134">カスタム エラー ハンドラーは、サービスのチャネル ディスパッチャーの ErrorHandlers プロパティに追加することでインストールできます。</span><span class="sxs-lookup"><span data-stu-id="0a151-134">One can install a custom error handler by adding it to the ErrorHandlers property of the channel dispatchers for your service.</span></span>  <span data-ttu-id="0a151-135">複数のエラー ハンドラーを設定することができ、これらはこのコレクションに追加された順序で呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0a151-135">It is possible to have more than one error handler and they are called in the order they are added to this collection.</span></span>

<span data-ttu-id="0a151-136">IErrorHandler.ProvideFault は、クライアントに送信されるエラー メッセージを制御します。</span><span class="sxs-lookup"><span data-stu-id="0a151-136">IErrorHandler.ProvideFault controls the fault message that is sent to the client.</span></span> <span data-ttu-id="0a151-137">このメソッドは、サービスの操作によってスローされた例外の種類に関係なく呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0a151-137">This method is called regardless of the type of the exception thrown by an operation in your service.</span></span> <span data-ttu-id="0a151-138">ここで操作を実行しない場合、WCF は既定の動作を想定し、カスタムエラーハンドラーが配置されていないかのように続行します。</span><span class="sxs-lookup"><span data-stu-id="0a151-138">If no operation is performed here, WCF assumes its default behavior and continues as if there were no custom error handlers in place.</span></span>

<span data-ttu-id="0a151-139">この方法を使用する可能性がある場合として、クライアントに送信される前の例外をエラーに変換するための一元的な場所を作成する場合があります (インスタンスが破棄されておらず、チャネルが Faulted 状態に移行していないことを確認します)。</span><span class="sxs-lookup"><span data-stu-id="0a151-139">One area that you could perhaps use this approach is when you want to create a central place for converting exceptions to faults before they are sent to the client (ensuring that the instance is not disposed and the channel is not moved to the Faulted state).</span></span>

<span data-ttu-id="0a151-140">IErrorHandler メソッドは、通常、エラーログ、システム通知、アプリケーションのシャットダウンなどのエラー関連の動作を実装するために使用されます。IErrorHandler は、サービス内の複数の場所で呼び出すことができます。また、エラーがスローされた場所によっては、HandleError メソッドが操作と同じスレッドによって呼び出されないこともあります。この点については保証されません。</span><span class="sxs-lookup"><span data-stu-id="0a151-140">The IErrorHandler.HandleError method is usually used to implement error-related behaviors such as error logging, system notifications, shutting down the application, etc. IErrorHandler.HandleError can be called at multiple places inside the service, and depending on where the error is thrown, the HandleError method may or may not be called by the same thread as the operation; no guarantees are made in this regard.</span></span>

## <a name="dealing-with-exceptions-outside-wcf"></a><span data-ttu-id="0a151-141">WCF 以外の例外の処理</span><span class="sxs-lookup"><span data-stu-id="0a151-141">Dealing with exceptions outside WCF</span></span>

<span data-ttu-id="0a151-142">多くの場合、構成の例外、データベース接続文字列の例外、およびその他の同様の例外は、WCF アプリケーションのコンテキスト内で発生する可能性がありますが、これらの例外自体は、サービス モデルまたは Web サービス自体が原因で発生する例外ではありません。</span><span class="sxs-lookup"><span data-stu-id="0a151-142">Often, configuration exceptions, database connection string exceptions, and other similar exceptions may occur within the context of a WCF application, but are themselves are not exceptions caused by the service model or the web service itself.</span></span> <span data-ttu-id="0a151-143">これらの例外は、web サービス外部の "通常の" 例外であり、環境内の他の外部例外を処理する場合と同様に処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a151-143">These exceptions are "regular" exceptions external to the web service, and should be handled just as other external exceptions in the environment are to be handled.</span></span>

## <a name="tracing-exceptions"></a><span data-ttu-id="0a151-144">例外のトレース</span><span class="sxs-lookup"><span data-stu-id="0a151-144">Tracing exceptions</span></span>

<span data-ttu-id="0a151-145">トレースは、すべての例外が表示される可能性のある唯一の "キャッチオール" の場所です。</span><span class="sxs-lookup"><span data-stu-id="0a151-145">Tracing is the only "catch-all" place where one can potentially see all exceptions.</span></span> <span data-ttu-id="0a151-146">例外のトレースとログの詳細については、「トレースとログ」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0a151-146">For more information on tracing and logging exceptions, see Tracing and Logging.</span></span>

## <a name="uri-template-errors-when-using-webgetattribute-and-webinvokeattribute"></a><span data-ttu-id="0a151-147">WebGetAttribute と WebInvokeAttribute を使用した場合の URI テンプレート エラー</span><span class="sxs-lookup"><span data-stu-id="0a151-147">URI template errors when using WebGetAttribute and WebInvokeAttribute</span></span>

<span data-ttu-id="0a151-148">WebGet 属性と WebInvoke 属性を使用すると、要求アドレスのコンポーネントを操作パラメーターにマップする URI テンプレートを指定できます。</span><span class="sxs-lookup"><span data-stu-id="0a151-148">The WebGet and WebInvoke attributes allow you to specify a URI template that maps components of the request address to operation parameters.</span></span> <span data-ttu-id="0a151-149">たとえば、URI テンプレートが "weather/{state}/{city}" の場合は、要求アドレスがリテラル トークン、state という名前のパラメーター、および city という名前にマップされます。</span><span class="sxs-lookup"><span data-stu-id="0a151-149">For example, the URI template "weather/{state}/{city}" maps the request address into literal tokens, a parameter named state, and a parameter named city.</span></span> <span data-ttu-id="0a151-150">その後、これらのパラメーターは、名前によって、操作の仮パラメーターの一部にバインドされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="0a151-150">These parameters might then be bound by name to some of the formal parameters of the operation.</span></span>

<span data-ttu-id="0a151-151">テンプレート パラメーターが URI 内の文字列の形式で表されるのに対し、型指定されたコントラクトの仮パラメーターは文字列以外の型である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="0a151-151">The template parameters appear in the form of strings within the URI while the formal parameters of a typed contract might be of non-string types.</span></span> <span data-ttu-id="0a151-152">そのため、操作が呼び出される前に変換を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="0a151-152">Therefore, a conversion needs to take place before the operation can be invoked.</span></span> <span data-ttu-id="0a151-153">[変換形式のテーブル](wcf-web-http-programming-model-overview.md)を使用できます。</span><span class="sxs-lookup"><span data-stu-id="0a151-153">A [table of conversion formats](wcf-web-http-programming-model-overview.md) is available.</span></span>

<span data-ttu-id="0a151-154">ただし、変換に失敗した場合は、失敗したことを操作に認識させる方法はありません。</span><span class="sxs-lookup"><span data-stu-id="0a151-154">However, if the conversion fails, then there's no way to let the operation know that something has gone wrong.</span></span> <span data-ttu-id="0a151-155">代わりに、型変換は、ディスパッチ エラーの形式で表示されます。</span><span class="sxs-lookup"><span data-stu-id="0a151-155">The type conversion instead surfaces in the form of a dispatch failure.</span></span>

<span data-ttu-id="0a151-156">型変換のディスパッチ エラーは、エラー ハンドラーをインストールすることで、その他多くの種類のディスパッチ エラーと同様に調査できます。</span><span class="sxs-lookup"><span data-stu-id="0a151-156">A type conversion dispatch failure can be inspected the same as with many other types of dispatch failures by installing an error handler.</span></span> <span data-ttu-id="0a151-157">IErrorHandler 機能拡張ポイントは、サービス レベルの例外を処理するために呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0a151-157">The IErrorHandler extensibility point is called to handle service-level exceptions.</span></span> <span data-ttu-id="0a151-158">そこから、呼び出し元に返される応答を選択できます (カスタム タスクとレポートを実行することもできます)。</span><span class="sxs-lookup"><span data-stu-id="0a151-158">From there, the response to be sent back to the caller – as well as perform any custom tasks and reporting – may be chosen.</span></span>

## <a name="see-also"></a><span data-ttu-id="0a151-159">参照</span><span class="sxs-lookup"><span data-stu-id="0a151-159">See also</span></span>

- [<span data-ttu-id="0a151-160">基本的な WCF プログラミング</span><span class="sxs-lookup"><span data-stu-id="0a151-160">Basic WCF Programming</span></span>](../basic-wcf-programming.md)
