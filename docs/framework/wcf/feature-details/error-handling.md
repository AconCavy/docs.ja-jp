---
title: エラー処理
ms.date: 03/30/2017
ms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf
ms.openlocfilehash: 34f4f11176b3827ec3e4622944ffe02be5207df9
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "61856687"
---
# <a name="error-handling"></a>エラー処理
## <a name="error-handling-in-windows-communication-foundation"></a>Windows Communication Foundation でのエラー処理  
 サービスで予期しない例外やエラーが発生した場合、例外処理ソリューションを設計する方法は複数あります。 ありません「正しい」または「最善」エラー処理ソリューションでは、考慮すべき 1 つの複数の有効なパスがあります。 通常どおりの未処理の性質と WCF の実装、種類と、処理、例外の頻度の複雑さに応じて、以下の一覧から複数の方法を組み合わせたハイブリッド ソリューションを実装していずれかのことをお勧めします例外、および関連するトレース、ログ記録、またはポリシーの要件。  
  
 これらのソリューションについては、このセクションの残りの部分で詳しく説明します。  
  
### <a name="the-microsoft-enterprise-library"></a>Microsoft Enterprise Library  
 Microsoft Enterprise Library Exception Handling Application Block は、共通の設計パターンを実装し、エンタープライズ アプリケーションのすべてのアーキテクチャ レイヤーで発生する例外を処理するための一貫した戦略を策定するのに役立ちます。 これは、アプリケーション コンポーネントの catch ステートメントに含まれる一般的なコードをサポートするように設計されています。 開発者は、アプリケーション全体で同一の catch ブロックにこのコード (例外情報をログに記録するコードなど) を繰り返し使用する代わりに、Exception Handling Application Block を使用すると、このロジックを再利用可能な例外ハンドラーとしてカプセル化できます。  
  
 このライブラリには、すぐに使用できる Fault Contract Exception Handler が含まれています。 この例外ハンドラーは、Windows® Communication Foundation (WCF) のサービス境界で使用することを目的に設計されており、例外から新しいエラー コントラクトを生成します。  
  
 アプリケーション ブロックは、よく使用されるベスト プラクティスを組み込み、アプリケーション全体の例外処理に共通の方法を提供することを目的としています。 その一方で、独自に開発されたカスタム エラー ハンドラーやエラー コントラクトが非常に便利な場合もあります。 たとえば、カスタム エラー ハンドラーは、FaultExceptions にすべての例外を自動的に昇格させると、アプリケーションにログ機能を追加する絶好の機会を提供します。  
  
 詳細についてを参照してください[Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10))します。  
  
### <a name="dealing-with-expected-exceptions"></a>予期される例外の処理  
 各操作または関連する機能拡張ポイントにおいて予期される例外をキャッチから、回復できる、FaultException で適切なカスタム エラーを返すかどうかを決定する一連の適切な措置は、\<T >  
  
### <a name="dealing-with-unexpected-exceptions-using-an-ierrorhandler"></a>IErrorHandler を使用した予期しない例外の処理  
 予期しない例外を処理するには、推奨される一連の措置は、IErrorHandler を「フック」です。 エラー ハンドラーは、チャネル層ではなく WCF ランタイム レベル (「サービス モデル」層) でのみ例外をキャッチします。 チャネル レベルで IErrorHandler をフックする唯一の方法は、カスタム チャネルを作成することです。ただし、これはほとんどのシナリオで推奨されていません。  
  
 「予期しない例外」は、一般に、回復不可能な例外も処理例外です。代わりに、予期しないユーザー例外。 回復不可能な例外 (メモリ不足の例外など) – 1 つ一般的にによって処理される、[サービス モデル例外ハンドラー](xref:System.ServiceModel.Dispatcher.ExceptionHandler) – 自動的に一般に処理できない正常にし、このような例外を処理する唯一の理由追加のログ記録がすべての可能性がありますまたは標準の例外をクライアントに戻ります。 処理例外は、シリアル化、エンコーダー、フォーマッタ レベルなどのメッセージの処理中に発生します。通常、この例外は IErrorHandler では処理できません。これは、一般的に、このような例外が発生するまでにエラー ハンドラーの介入が早すぎるか、遅すぎることが原因です。 同様に、トランスポート例外も IErrorHandler では処理できません。  
  
 IErrorHandler を使用すると、例外がスローされたときのアプリケーションの動作を明示的に制御できます。 次のような操作が可能です。  
  
1. クライアントにエラーを送信するかどうかを決定する  
  
2. 例外をエラーに置き換える  
  
3. エラーを別のエラーに置き換える  
  
4. ログまたはトレースを実行する  
  
5. 他のカスタム アクティビティを実行する  
  
 カスタム エラー ハンドラーは、サービスのチャネル ディスパッチャーの ErrorHandlers プロパティに追加することでインストールできます。  複数のエラー ハンドラーを設定することができ、これらはこのコレクションに追加された順序で呼び出されます。  
  
 IErrorHandler.ProvideFault は、クライアントに送信されるエラー メッセージを制御します。 このメソッドは、サービスの操作によってスローされた例外の種類に関係なく呼び出されます。 ここで操作が実行されない場合、WCF は、その既定の動作を想定し、カスタム エラー ハンドラーが存在しないかのように続行します。  
  
 この方法を使用する可能性がある場合として、クライアントに送信される前の例外をエラーに変換するための一元的な場所を作成する場合があります (インスタンスが破棄されておらず、チャネルが Faulted 状態に移行していないことを確認します)。  
  
 通常、IErrorHandler.HandleError メソッドは、エラー ログ記録、システム通知、アプリケーションのシャットダウンなど、エラー関連の動作を実装するために使用されます。IErrorHandler.HandleError は、サービス内の複数の場所で呼び出すことができます。エラーがスローされた場所に応じて、HandleError メソッドは操作と同じスレッドから呼び出される場合と呼び出されない場合があります (この点について保証はありません)。  
  
### <a name="dealing-with-exceptions-outside-wcf"></a>WCF 外部での例外の処理  
 多くの場合、構成の例外、データベース接続文字列の例外、およびその他の同様の例外は、WCF アプリケーションのコンテキスト内で発生する可能性がありますが、これらの例外自体は、サービス モデルまたは Web サービス自体が原因で発生する例外ではありません。 これらの例外は、外部 web サービスに"regular"の例外し、環境内の他の外部の例外処理と同様に処理する必要があります。  
  
### <a name="tracing-exceptions"></a>例外のトレース  
 トレースは、すべての例外が 1 つに表示されるとできる可能性がありますのみ「キャッチ オール」場所です。 例外のトレースとログの詳細については、「トレースとログ」を参照してください。  
  
### <a name="uri-template-errors-when-using-webgetattribute-and-webinvokeattribute"></a>WebGetAttribute と WebInvokeAttribute を使用した場合の URI テンプレート エラー  
 WebGet 属性と WebInvoke 属性を使用すると、要求アドレスのコンポーネントを操作パラメーターにマップする URI テンプレートを指定できます。 たとえば、URI テンプレートが "weather/{state}/{city}" の場合は、要求アドレスがリテラル トークン、state という名前のパラメーター、および city という名前にマップされます。 その後、これらのパラメーターは、名前によって、操作の仮パラメーターの一部にバインドされる場合があります。  
  
 テンプレート パラメーターが URI 内の文字列の形式で表されるのに対し、型指定されたコントラクトの仮パラメーターは文字列以外の型である可能性があります。 そのため、操作が呼び出される前に変換を行う必要があります。 A[変換形式のテーブル](wcf-web-http-programming-model-overview.md)は使用できます。  
  
 ただし、変換に失敗した場合は、失敗したことを操作に認識させる方法はありません。 代わりに、型変換は、ディスパッチ エラーの形式で表示されます。  
  
 型変換のディスパッチ エラーは、エラー ハンドラーをインストールすることで、その他多くの種類のディスパッチ エラーと同様に調査できます。 IErrorHandler 機能拡張ポイントは、サービス レベルの例外を処理するために呼び出されます。 そこから、呼び出し元に返される応答を選択できます (カスタム タスクとレポートを実行することもできます)。  
  
## <a name="see-also"></a>関連項目

- [基本的な WCF プログラミング](../basic-wcf-programming.md)
