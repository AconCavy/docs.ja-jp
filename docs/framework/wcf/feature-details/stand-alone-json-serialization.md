---
title: DataContractJsonSerializer を使用したスタンドアロン JSON シリアル化
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 6bd075405a3bca0cc64dda90225526096b6fa8e3
ms.sourcegitcommit: 71b8f5a2108a0f1a4ef1d8d75c5b3e129ec5ca1e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/29/2020
ms.locfileid: "84202389"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="1d37f-102">DataContractJsonSerializer を使用したスタンドアロン JSON シリアル化</span><span class="sxs-lookup"><span data-stu-id="1d37f-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="1d37f-103">この記事では、について説明 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="1d37f-104">JSON のシリアル化と逆シリアル化を含むほとんどのシナリオでは、Api を使用することをお勧めし[ます。](../../../standard/serialization/system-text-json-overview.md)</span><span class="sxs-lookup"><span data-stu-id="1d37f-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="1d37f-105">JSON (JavaScript Object Notation) は、ブラウザー内の Web ページで実行される JavaScript コードで使用するために特別に設計されたデータ形式です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="1d37f-106">これは Windows Communication Foundation (WCF) で作成された ASP.NET AJAX サービスによって使用される既定のデータ形式です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="1d37f-107">この形式は、ASP.NET と統合せずに AJAX サービスを作成する場合にも使用できます。この場合、XML が既定のデータ形式になりますが、JSON を選択することもできます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="1d37f-108">JSON をサポートする必要はあっても AJAX サービスを作成する予定はない場合は、<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> を使用することで、.NET オブジェクトを JSON データに直接シリアル化したり、このようなデータを .NET 型のインスタンスに逆シリアル化したりできます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="1d37f-109">これを行う方法の詳細については、「[方法: JSON データをシリアル化および逆シリアル化](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="1d37f-110">JSON を使用する場合、一部例外はありますが、<xref:System.Runtime.Serialization.DataContractSerializer> でサポートされているものと同じ .NET 型 がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="1d37f-111">サポートされている型の一覧については、「[データコントラクトシリアライザーでサポートされる型](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="1d37f-112">これには、ほとんどのプリミティブ型、ほとんどの配列型とコレクション型、<xref:System.Runtime.Serialization.DataContractAttribute> と <xref:System.Runtime.Serialization.DataMemberAttribute> を使用する複合型などがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="1d37f-113">.NET 型から JSON 型へのマッピング</span><span class="sxs-lookup"><span data-stu-id="1d37f-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="1d37f-114">シリアル化および逆シリアル化の手順でマップされる場合の .NET 型と JSON/JavaScript 型の対応表を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="1d37f-115">.NET 型</span><span class="sxs-lookup"><span data-stu-id="1d37f-115">.NET Types</span></span>|<span data-ttu-id="1d37f-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="1d37f-116">JSON/JavaScript</span></span>|<span data-ttu-id="1d37f-117">ノート</span><span class="sxs-lookup"><span data-stu-id="1d37f-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="1d37f-118">すべての数値型 (<xref:System.Int32>、<xref:System.Decimal>、<xref:System.Double> など)</span><span class="sxs-lookup"><span data-stu-id="1d37f-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="1d37f-119">数値</span><span class="sxs-lookup"><span data-stu-id="1d37f-119">Number</span></span>|<span data-ttu-id="1d37f-120">`Double.NaN`、`Double.PositiveInfinity`、`Double.NegativeInfinity` などの特殊な値はサポートされていないため、無効な JSON になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="1d37f-121">数値</span><span class="sxs-lookup"><span data-stu-id="1d37f-121">Number</span></span>|<span data-ttu-id="1d37f-122">このトピックの「列挙体と JSON」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="1d37f-123">ブール値</span><span class="sxs-lookup"><span data-stu-id="1d37f-123">Boolean</span></span>|--|
|<span data-ttu-id="1d37f-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="1d37f-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="1d37f-125">文字列</span><span class="sxs-lookup"><span data-stu-id="1d37f-125">String</span></span>|--|
|<span data-ttu-id="1d37f-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="1d37f-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="1d37f-127">文字列</span><span class="sxs-lookup"><span data-stu-id="1d37f-127">String</span></span>|<span data-ttu-id="1d37f-128">JSON でのこれらの型の形式は、XML の場合と同じです (実質的には、ISO 8601 の期間形式の TimeSpan、"12345678-abcd-abcd-890AB" 形式の GUID、"" などの自然文字列形式の URI http://www.example.com )。</span><span class="sxs-lookup"><span data-stu-id="1d37f-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="1d37f-129">詳細については、「[データコントラクトスキーマのリファレンス](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="1d37f-130">文字列</span><span class="sxs-lookup"><span data-stu-id="1d37f-130">String</span></span>|<span data-ttu-id="1d37f-131">形式は "name:namespace" です (最初のコロンの前が名前です)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="1d37f-132">名前または名前空間が存在しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="1d37f-133">名前空間がない場合、コロンも省略されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="1d37f-134"><xref:System.Array> 型の <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="1d37f-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="1d37f-135">数値の配列型</span><span class="sxs-lookup"><span data-stu-id="1d37f-135">Array of numbers</span></span>|<span data-ttu-id="1d37f-136">各数値は、1 バイトの値を表します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="1d37f-137">DateTime 型または文字列型</span><span class="sxs-lookup"><span data-stu-id="1d37f-137">DateTime or String</span></span>|<span data-ttu-id="1d37f-138">このトピックの「日付/時刻と JSON」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="1d37f-139">複合型</span><span class="sxs-lookup"><span data-stu-id="1d37f-139">Complex type</span></span>|<span data-ttu-id="1d37f-140">このトピックの「日付/時刻と JSON」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="1d37f-141">XML 型および ADO.NET 型 (<xref:System.Xml.XmlElement>、</span><span class="sxs-lookup"><span data-stu-id="1d37f-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="1d37f-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="1d37f-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="1d37f-143"><xref:System.Xml.XmlNode> の配列、</span><span class="sxs-lookup"><span data-stu-id="1d37f-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="1d37f-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="1d37f-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="1d37f-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="1d37f-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="1d37f-146">文字列</span><span class="sxs-lookup"><span data-stu-id="1d37f-146">String</span></span>|<span data-ttu-id="1d37f-147">このトピックの「XML 型と JSON」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="1d37f-148">空の複合型</span><span class="sxs-lookup"><span data-stu-id="1d37f-148">Empty complex type</span></span>|--|
|<span data-ttu-id="1d37f-149">コレクション、ディクショナリ、および配列</span><span class="sxs-lookup"><span data-stu-id="1d37f-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="1d37f-150">配列</span><span class="sxs-lookup"><span data-stu-id="1d37f-150">Array</span></span>|<span data-ttu-id="1d37f-151">このトピックの「コレクション、ディクショナリ、および配列」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="1d37f-152">複合型 (<xref:System.Runtime.Serialization.DataContractAttribute> または <xref:System.SerializableAttribute> が適用された型)</span><span class="sxs-lookup"><span data-stu-id="1d37f-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="1d37f-153">複合型</span><span class="sxs-lookup"><span data-stu-id="1d37f-153">Complex type</span></span>|<span data-ttu-id="1d37f-154">データ メンバーは、JavaScript 複合型のメンバーになります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="1d37f-155"><xref:System.Runtime.Serialization.ISerializable> インターフェイスを実装する複合型</span><span class="sxs-lookup"><span data-stu-id="1d37f-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="1d37f-156">複合型</span><span class="sxs-lookup"><span data-stu-id="1d37f-156">Complex type</span></span>|<span data-ttu-id="1d37f-157">他の複合型と同じですが、一部の <xref:System.Runtime.Serialization.ISerializable> 型はサポートされません。このトピックの「高度な情報」の「ISerializable のサポート」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="1d37f-158">任意の型の `Null` 値</span><span class="sxs-lookup"><span data-stu-id="1d37f-158">`Null` value for any type</span></span>|<span data-ttu-id="1d37f-159">Null</span><span class="sxs-lookup"><span data-stu-id="1d37f-159">Null</span></span>|<span data-ttu-id="1d37f-160">Null 許容値型もサポートされており、null 非許容の値型と同じように JSON にマップされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="1d37f-161">列挙体と JSON</span><span class="sxs-lookup"><span data-stu-id="1d37f-161">Enumerations and JSON</span></span>

<span data-ttu-id="1d37f-162">列挙メンバー値は、JSON では数値として処理されるため、列挙メンバー値がメンバー名として含まれているデータ コントラクトでの処理方法とは異なります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="1d37f-163">データコントラクト処理の詳細については、「[データコントラクトの列挙型](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="1d37f-164">たとえば、`public enum Color {red, green, blue, yellow, pink}` の場合、`yellow` をシリアル化すると、文字列の "yellow" ではなく、数字の 3 が生成されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="1d37f-165">`enum` のメンバーはすべて、シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-165">All `enum` members are serializable.</span></span> <span data-ttu-id="1d37f-166"><xref:System.Runtime.Serialization.EnumMemberAttribute> 属性と <xref:System.NonSerializedAttribute> 属性は、使用しても無視されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="1d37f-167">存在しない `enum` 値を逆シリアル化できます。たとえば、値 87 に対応する色の名前が定義されていなくても、この値を上記の Color 列挙値に逆シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="1d37f-168">フラグ `enum` は特殊ではなく、他の `enum` と同様に処理されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="1d37f-169">日付時刻 とJSON</span><span class="sxs-lookup"><span data-stu-id="1d37f-169">Dates/Times and JSON</span></span>

<span data-ttu-id="1d37f-170">JSON 形式では、日付と時刻を直接サポートしていません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="1d37f-171">ただし、日付と時刻は使用されることが非常に多いため、ASP.NET AJAX ではこれらの型を特別にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="1d37f-172">ASP.NET AJAX プロキシを使用する場合、.NET の <xref:System.DateTime> 型は JavaScript の `DateTime` 型に完全に対応します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="1d37f-173">ASP.NET を使用しない場合、JSON では、<xref:System.DateTime> 型はこのトピックの「高度な情報」で説明する特殊な形式の文字列として表されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="1d37f-174">JSON では、<xref:System.DateTimeOffset> が複合型 {"DateTime":dateTime,"OffsetMinutes":offsetMinutes} として表現されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="1d37f-175">`offsetMinutes` メンバーは、当該イベントの場所に関連付けられたグリニッジ標準時 (GMT) (協定世界時 (UTC) とも呼ばれます) からの現地時刻のオフセットです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="1d37f-176">`dateTime` メンバーは、当該イベントが発生した時点のインスタンスを表します (この場合も、ASP.NET AJAX を使用しているときは JavaScript の `DateTime` になり、使用していないときは文字列になります)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="1d37f-177">シリアル化時には、`dateTime` メンバーは常に GMT でシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="1d37f-178">したがって、ニューヨーク時間の午前 3 時を示す場合、`dateTime` の時刻コンポーネントは 8:00 AM であり、`offsetMinutes` は 300 (GMT マイナス 300 分 (5 時間)) です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="1d37f-179"><xref:System.DateTime> オブジェクトと <xref:System.DateTimeOffset> オブジェクトを JSON にシリアル化した場合、ミリ秒の精度までしか情報は保持されません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="1d37f-180">1 ミリ秒未満の値 (マイクロ秒/ナノ秒) は、シリアル化時に失われます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="1d37f-181">XML 型と JSON</span><span class="sxs-lookup"><span data-stu-id="1d37f-181">XML Types and JSON</span></span>

<span data-ttu-id="1d37f-182">XML 型は JSON 文字列になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="1d37f-183">たとえば、XElement 型のデータメンバー "q" にが含まれている場合、 \<abc/> JSON は {"q": " \<abc/> "} です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="1d37f-184">XML のラップ方法を指定する特別なルールがいくつかあります。詳細については、このトピックで後述する「高度な情報」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="1d37f-185">ASP.NET AJAX を使用している場合に、JavaScript で文字列ではなく XML DOM を使用するときは、<xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> で <xref:System.ServiceModel.Web.WebGetAttribute> プロパティを XML に設定するか、<xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> で <xref:System.ServiceModel.Web.WebInvokeAttribute> プロパティを XML に設定します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="1d37f-186">コレクション、ディクショナリ、および配列</span><span class="sxs-lookup"><span data-stu-id="1d37f-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="1d37f-187">コレクション、ディクショナリ、および配列は、JSON ではすべて配列として表されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="1d37f-188"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> を使用するカスタマイズは、JSON 表現では無視されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="1d37f-189">ディクショナリは、直接 JSON を操作する手段ではありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="1d37f-190">\<string,object>WCF では、他の JSON テクノロジを使用する場合と同じ方法で辞書をサポートすることはできません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="1d37f-191">たとえば、ディクショナリで "abc" が "xyz" にマップされ、"def" が 42 にマップされている場合、JSON 表現では {"abc":"xyz","def":42} ではなく、[{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="1d37f-192">JSON を直接使用する (厳密なコントラクトをあらかじめ定義せずに、キーと値に動的にアクセスする) 場合、いくつかのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="1d37f-193">[弱い型指定の JSON のシリアル化 (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md)サンプルの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="1d37f-194"><xref:System.Runtime.Serialization.ISerializable> インターフェイスと逆シリアル化コンストラクターを使用することを検討します。この 2 つの機構を使用すると、シリアル化と逆シリアル化の実行時にそれぞれ JSON のキーと値のペアにアクセスできます。ただし、これらの機構は、部分信頼シナリオでは機能しません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="1d37f-195">シリアライザーを使用する代わりに、 [JSON と XML 間のマッピング](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="1d37f-196">シリアル化のコンテキストでの*ポリモーフィズム*とは、基本型が想定されている派生型をシリアル化する機能を指します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="1d37f-197">コレクションをポリモーフィックに使用する場合は (コレクションを <xref:System.Object> に割り当てる場合など)、JSON 固有の特別なルールがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="1d37f-198">この問題については、後の「高度な情報」で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="1d37f-199">追加情報</span><span class="sxs-lookup"><span data-stu-id="1d37f-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="1d37f-200">データ メンバーの順序</span><span class="sxs-lookup"><span data-stu-id="1d37f-200">Order of Data Members</span></span>

<span data-ttu-id="1d37f-201">JSON を使用する際、データ メンバーの順序は重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="1d37f-202">具体的には、<xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> が設定されていても、JSON データを任意の順序で逆シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="1d37f-203">JSON の型</span><span class="sxs-lookup"><span data-stu-id="1d37f-203">JSON Types</span></span>

<span data-ttu-id="1d37f-204">JSON の型は、逆シリアル化時には前述の表と一致する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="1d37f-205">たとえば、`Int` は通常 JSON の数値にマップされますが、JSON 文字列に有効な数値が含まれていれば、その文字列から正常に逆シリアル化することもできます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="1d37f-206">つまり、"q" という `Int` データ メンバーが存在する場合は、{"q":42} も {"q":"42"} も有効です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="1d37f-207">ポリモーフィズム</span><span class="sxs-lookup"><span data-stu-id="1d37f-207">Polymorphism</span></span>

<span data-ttu-id="1d37f-208">ポリモーフィックなシリアル化は、基本型が必要な場合に派生型をシリアル化できることで成り立ちます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="1d37f-209">これは、XML シリアル化のサポートと比較して、WCF による JSON のシリアル化に対してサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="1d37f-210">たとえば、 `MyDerivedType` が想定されている場所をシリアル化し `MyBaseType` たり、が予想されるをシリアル化したりでき `Int` `Object` ます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="1d37f-211">複合型を逆シリアル化する場合を除き、基本型が必要な場合に派生型を逆シリアル化すると、型情報が失われることがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="1d37f-212">たとえば、<xref:System.Uri> が必要な場合に <xref:System.Object> をシリアル化すると、JSON 文字列になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="1d37f-213">この文字列を <xref:System.Object> に逆シリアル化した場合、.NET の <xref:System.String> が返されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="1d37f-214">デシリアライザーは、この文字列が最初は <xref:System.Uri> 型であったことを認識していません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="1d37f-215">通常、<xref:System.Object> を必要とするときに、すべての JSON 文字列が .NET 文字列として逆シリアル化されます。また、.NET のコレクション、ディクショナリ、および配列のシリアル化に使用するすべての JSON 配列は、実際の元の型に関係なく、<xref:System.Array> 型の .NET <xref:System.Object> として逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="1d37f-216">JSON のブール型は .NET の <xref:System.Boolean> にマップされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="1d37f-217">ただし、<xref:System.Object> が必要な場合、JSON の数値型は .NET の <xref:System.Int32>、<xref:System.Decimal>、または <xref:System.Double> の型として逆シリアル化されます。この場合、最も適切な型が自動的に選択されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="1d37f-218">インターフェイス型に逆シリアル化する場合、<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> は、宣言された型がオブジェクトである場合と同様に逆シリアル化します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="1d37f-219">独自の基本型と派生型を使用している場合は、通常、<xref:System.Runtime.Serialization.KnownTypeAttribute>、<xref:System.ServiceModel.ServiceKnownTypeAttribute>、または同等の機構を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="1d37f-220">たとえば、戻り値を持つ操作があり、 `Animal` 実際にのインスタンス (から派生) が返された場合は、 `Cat` `Animal` <xref:System.Runtime.Serialization.KnownTypeAttribute> を型またはのに適用 `Animal` <xref:System.ServiceModel.ServiceKnownTypeAttribute> して、これらの `Cat` 属性の型を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="1d37f-221">詳細については、「[データコントラクトの既知の型](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="1d37f-222">ポリモーフィックなシリアル化のしくみの詳細、およびポリモーフィックなシリアル化を使用するときに留意する必要のある制限事項については、このトピックで後述する「高度な情報」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="1d37f-223">バージョン管理</span><span class="sxs-lookup"><span data-stu-id="1d37f-223">Versioning</span></span>

<span data-ttu-id="1d37f-224"><xref:System.Runtime.Serialization.IExtensibleDataObject> インターフェイスをはじめとするデータ コントラクトのバージョン管理機能は、JSON で完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="1d37f-225">また、ほとんどの場合、ある形式 (XML など) で型を逆シリアル化した後、その型を別の形式 (JSON など) にシリアル化しても、<xref:System.Runtime.Serialization.IExtensibleDataObject> にデータを保持できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="1d37f-226">詳細については、「[上位互換性のあるデータ コントラクト](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="1d37f-227">JSON は順序なしであるため、順序情報は失われることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="1d37f-228">また、JSON では、同じキー名を持つ複数のキーと値のペアをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="1d37f-229"><xref:System.Runtime.Serialization.IExtensibleDataObject> でのすべての操作は、本質的にポリモーフィックです。つまり、派生型はすべての型の基本型である <xref:System.Object> に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="1d37f-230">URL 内の JSON</span><span class="sxs-lookup"><span data-stu-id="1d37f-230">JSON in URLs</span></span>

<span data-ttu-id="1d37f-231">(<xref:System.ServiceModel.Web.WebGetAttribute> 属性を使用して) HTTP GET 動詞と共に ASP.NET AJAX エンドポイントを使用する場合、受信パラメーターは、メッセージ本文ではなく要求 URL に配置されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="1d37f-232">JSON は要求 URL でもサポートされています。そのため、" `Int` number" という名前のと `Person` "p" という複合型を受け取る操作がある場合、url は次の url のようになります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="1d37f-233">ASP.NET AJAX Script Manager コントロールとプロキシを使用してサービスを呼び出すと、この URL はプロキシによって自動的に生成されるため、確認することはできません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="1d37f-234">JSON は、ASP.NET AJAX エンドポイントを使用しない URL では使用できません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="1d37f-235">詳細情報</span><span class="sxs-lookup"><span data-stu-id="1d37f-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="1d37f-236">ISerializable のサポート</span><span class="sxs-lookup"><span data-stu-id="1d37f-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="1d37f-237">サポートされる ISerializable 型とサポートされない ISerializable 型</span><span class="sxs-lookup"><span data-stu-id="1d37f-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="1d37f-238">通常、JSON をシリアル化または逆シリアル化するときに、<xref:System.Runtime.Serialization.ISerializable> インターフェイスを実装する型は完全にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="1d37f-239">ただし、これらの型の一部 (一部の .NET Framework 型を含みます) は、次のような JSON 固有のシリアル化の側面が原因で正しく逆シリアル化されない方法で実装されています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="1d37f-240"><xref:System.Runtime.Serialization.ISerializable> では、個々のデータ メンバーの型は事前にはわかりません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="1d37f-241">このため、型をオブジェクトに逆シリアル化する場合と同様のポリモーフィックな状況になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="1d37f-242">前述のように、これは JSON で型情報が失われる原因となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="1d37f-243">たとえば、`enum` 実装で <xref:System.Runtime.Serialization.ISerializable> をシリアル化した型を (適切にキャストせずに) `enum` に直接逆シリアル化しようとした場合、逆シリアル化は失敗します。これは、`enum` は JSON の数値型を使用してシリアル化されますが、JSON の数値型は .NET の組み込みの数値型 (Int32、Decimal、または Double) に逆シリアル化されるためです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="1d37f-244">そのため、この数値が `enum` 値を表すために使用されているという情報が失われます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="1d37f-245"><xref:System.Runtime.Serialization.ISerializable> 型が逆シリアル化コンストラクターで特定の順序の逆シリアル化に依存する場合も、一部の JSON データの逆シリアル化に失敗する場合があります。これは、ほとんどの JSON シリアライザーが特定の順序を保証しないためです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="1d37f-246">ファクトリ型</span><span class="sxs-lookup"><span data-stu-id="1d37f-246">Factory Types</span></span>

<span data-ttu-id="1d37f-247"><xref:System.Runtime.Serialization.IObjectReference> インターフェイスは JSON で一般にサポートされますが、"ファクトリ型" 機能 (<xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> から、このインターフェイスを実装する型とは異なる型のインスタンスを返す機能) を必要とする型はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="1d37f-248">DateTime ワイヤ形式</span><span class="sxs-lookup"><span data-stu-id="1d37f-248">DateTime Wire Format</span></span>

<span data-ttu-id="1d37f-249"><xref:System.DateTime> 値は、"/Date(700000+0500)/" 形式の JSON 文字列として表されます。ここで、最初の数値 (この例では 700000) は GMT タイム ゾーンのミリ秒数であり、1970 年 1 月 1 日午前 0 時以降の (夏時間ではなく) 通常時間です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="1d37f-250">これより前の時間を表すために、この数値が負の値になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="1d37f-251">この例の "+0500" で構成される部分は省略可能であり、<xref:System.DateTimeKind.Local> の時刻を示します。つまり、逆シリアル化時にローカル タイム ゾーンに変換される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="1d37f-252">この部分が指定されていない場合、時刻は <xref:System.DateTimeKind.Utc> として逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="1d37f-253">実際の数値 (この例では "0500") と記号 (+ または -) は無視されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="1d37f-254"><xref:System.DateTime> をシリアル化すると、<xref:System.DateTimeKind.Local> と <xref:System.DateTimeKind.Unspecified> の時刻はオフセットして書き込まれ、<xref:System.DateTimeKind.Utc> はオフセットせずに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="1d37f-255">ASP.NET AJAX クライアントの JavaScript コードにより、このような文字列は JavaScript の `DateTime` インスタンスに自動的に変換されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="1d37f-256">類似する形式で .NET の <xref:System.DateTime> 型ではない他の文字列が存在する場合、これらの文字列も変換されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="1d37f-257">変換は、"/" 文字がエスケープされている場合 (つまり、JSON が "/ \\ Date (700000 + 0500)/") の場合にのみ行われ \\ ます。このため、WCF の JSON エンコーダー (によって有効 <xref:System.ServiceModel.WebHttpBinding> ) は常に "/" 文字をエスケープします。</span><span class="sxs-lookup"><span data-stu-id="1d37f-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="1d37f-258">JSON 文字列内の XML</span><span class="sxs-lookup"><span data-stu-id="1d37f-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="1d37f-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="1d37f-259">XmlElement</span></span>

<span data-ttu-id="1d37f-260"><xref:System.Xml.XmlElement> は、ラップされずにそのままの状態でシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="1d37f-261">たとえば、を含む型のデータメンバー "x" は、次のように <xref:System.Xml.XmlElement> \<abc/> 表されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="1d37f-262">XmlNode の配列</span><span class="sxs-lookup"><span data-stu-id="1d37f-262">Arrays of XmlNode</span></span>

<span data-ttu-id="1d37f-263"><xref:System.Array> 型の <xref:System.Xml.XmlNode> オブジェクトは、この型の標準のデータ コントラクト名前空間にある ArrayOfXmlNode という要素にラップされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="1d37f-264">"x" が、"value" と空の要素ノード "M" を含む名前空間 "ns" にある、属性ノード "N" を含む配列である場合、次のように表されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="1d37f-265">XmlNode 配列の先頭 (他の要素の前) にある空の名前空間の属性はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="1d37f-266">XElement と DataSet を含む IXmlSerializable 型</span><span class="sxs-lookup"><span data-stu-id="1d37f-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="1d37f-267"><xref:System.Runtime.Serialization.ISerializable> 型は、"コンテンツ型"、"DataSet 型"、および "要素型" に細分化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="1d37f-268">これらの型の定義については、「[データコントラクトの XML 型と ADO.NET 型](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="1d37f-269">"コンテンツ" 型と "DataSet" 型は、前のセクションで説明した <xref:System.Array> の <xref:System.Xml.XmlNode> オブジェクトと同様にシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="1d37f-270">これらの型は、その型のデータ コントラクトの名前と名前空間に対応する名前と名前空間を持つ要素にラップされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="1d37f-271"><xref:System.Xml.Linq.XElement> などの "要素" 型は、このトピックで既に説明した <xref:System.Xml.XmlElement> と同様に、そのままの状態でシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="1d37f-272">ポリモーフィズム</span><span class="sxs-lookup"><span data-stu-id="1d37f-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="1d37f-273">型情報の保持</span><span class="sxs-lookup"><span data-stu-id="1d37f-273">Preserving Type Information</span></span>

<span data-ttu-id="1d37f-274">前述のように、ポリモーフィズムは JSON でサポートされていますが、いくつかの制限があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="1d37f-275">JavaScript は厳密に型指定されていない言語であるため、通常、型 ID は問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="1d37f-276">ただし、厳密に型指定されたシステム (.NET) と厳密に型指定されていないシステム (JavaScript) との間で通信を行うために JSON を使用する場合は、型 id を保持すると便利です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-276">However, when using JSON to communicate between a strongly typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="1d37f-277">たとえば、"Square" と "Circle" というデータ コントラクト名を持つ型が "Shape" というデータ コントラクト名を持つ型から派生したとします。</span><span class="sxs-lookup"><span data-stu-id="1d37f-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="1d37f-278">"Circle" が .NET から JavaScript に送信され、後で "Shape" を必要とする .NET メソッドに返された場合、該当のオブジェクトが本来は "Circle" であったことが .NET 側でわかれば役立ちます。そうでない場合、派生型に固有の情報 ("Circle" のデータ メンバー "radius" など) が失われることがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="1d37f-279">型 ID を保持するために、複合型を JSON にシリアル化するときに "型ヒント" を追加できます。デシリアライザーはこのヒントを認識し、適切に動作します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="1d37f-280">"型ヒント" は、"type" というキー名を持つ JSON のキーと値のペアです \_ \_ (2 つのアンダースコアの後に "type" という単語が続きます)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="1d37f-281">値は、"DataContractName:DataContractNamespace" 形式の JSON 文字列です (最初のコロンまでが名前です)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="1d37f-282">前述の例の "Circle" は、次のようにシリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="1d37f-283">型ヒントは、XML スキーマ インスタンス標準で定義された `xsi:type` 属性によく似ており、XML をシリアル化または逆シリアル化するときに使用されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="1d37f-284">\_ \_ 型ヒントと競合する可能性があるため、"type" というデータメンバーは禁止されています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="1d37f-285">型ヒントのサイズの削減</span><span class="sxs-lookup"><span data-stu-id="1d37f-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="1d37f-286">JSON メッセージのサイズを小さくするために、既定のデータコントラクトの名前空間プレフィックス ( `http://schemas.datacontract.org/2004/07/` ) は "#" 文字に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="1d37f-287">(この置換を元に戻せるようにするために、エスケープ規則が使用されます。名前空間の先頭文字が "#" または "" である場合は、"" という文字が追加 \\ され \\ ます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="1d37f-288">したがって、"Circle" が .NET 名前空間 "MyApp. Shapes" の型である場合、その既定のデータコントラクト名前空間はに `http://schemas.datacontract.org/2004/07/MyApp` なります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="1d37f-289">形状と JSON 表現は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="1d37f-290">逆シリアル化では、切り捨てられた (#MyApp の) 名前と完全 ( <http://schemas.datacontract.org/2004/07/MyApp.Shapes> ) 名の両方が認識されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-290">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="1d37f-291">JSON オブジェクト内での型ヒントの位置</span><span class="sxs-lookup"><span data-stu-id="1d37f-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="1d37f-292">JSON 表現では、型ヒントは最初に出現する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="1d37f-293">JSON の処理でキーと値のペアの順序が重要となるのはこの場合だけです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="1d37f-294">たとえば、型ヒントの次の指定方法は無効です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="1d37f-295"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>WCF と ASP.NET AJAX の両方のクライアントページでは、常に type ヒントが最初に生成されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="1d37f-296">複合型にのみ適用される型ヒント</span><span class="sxs-lookup"><span data-stu-id="1d37f-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="1d37f-297">複合型以外の型の型ヒントを出力する方法はありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="1d37f-298">たとえば、戻り値の型が <xref:System.Object> である操作で Circle を返す場合、前に示したような JSON 表現が可能であり、型情報は保持されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="1d37f-299">ただし、Uri が返される場合、JSON 表現は文字列であり、この文字列が Uri を表すために使用されているという情報は失われます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="1d37f-300">これは、プリミティブ型だけでなく、コレクションと配列にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="1d37f-301">型ヒントが出力される状況</span><span class="sxs-lookup"><span data-stu-id="1d37f-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="1d37f-302">型ヒントにより、メッセージ サイズが大幅に増加することがあります (これを軽減する 1 つの方法として、可能であれば短いデータ コントラクト名前空間を使用します)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="1d37f-303">そのため、次のルールによって型ヒントを出力するかどうかが制御されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="1d37f-304">ASP.NET AJAX を使用する場合、基本型と派生型の割り当てが存在しない場合でも (Circle を Circle に割り当てる場合など)、型ヒントは可能である限り常に出力されます </span><span class="sxs-lookup"><span data-stu-id="1d37f-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="1d37f-305">(これは、厳密に型指定されていない JSON 環境から厳密に型指定された .NET 環境への呼び出しプロセスを完全に有効にするために必要ですが、情報が失われることはありません)。</span><span class="sxs-lookup"><span data-stu-id="1d37f-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="1d37f-306">ASP.NET と統合せずに AJAX サービスを使用する場合、基本型と派生型の割り当てが存在する場合にのみ、型ヒントが出力されます。つまり、Circle を Shape または <xref:System.Object> に割り当てるときは出力されますが、Circle に割り当てるときには出力されません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="1d37f-307">この場合、JavaScript クライアントを適切に実装するために必要な最小限の情報しか提供されないため、パフォーマンスは向上しますが、適切に設計されていないクライアントでの型情報の損失を防ぐことはできません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="1d37f-308">クライアントでこの問題に対処することを避ける必要がある場合は、サーバーで基本型と派生型の割り当てを一切行わないようにします。</span><span class="sxs-lookup"><span data-stu-id="1d37f-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="1d37f-309"><xref:System.Runtime.Serialization.DataContractSerializer> 型を使用する場合、`alwaysEmitTypeInformation` コンストラクター パラメーターを使用すると、上記の 2 つのモードのいずれかを選択できます。既定値は "`false`" (必要な場合にのみ型情報を出力) です。</span><span class="sxs-lookup"><span data-stu-id="1d37f-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="1d37f-310">重複するデータ メンバー名</span><span class="sxs-lookup"><span data-stu-id="1d37f-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="1d37f-311">派生型情報は、基本型情報と共に同じ JSON オブジェクト内に存在しますが、任意の順序で出現する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="1d37f-312">たとえば、は次のように `Shape` 表現できます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="1d37f-313">Circle は、次のように表されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="1d37f-314">基本型に `Shape` "" というデータメンバーも含まれている場合は `radius` 、(JSON オブジェクトが繰り返しキー名を持つことはできないため) 両方のシリアル化が競合し、逆シリアル化が行われます ("radius" がまたはを参照しているかどうかは不明確であるため) `Shape.radius` `Circle.radius` 。</span><span class="sxs-lookup"><span data-stu-id="1d37f-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="1d37f-315">そのため、データ コントラクト クラスでは、"プロパティの隠ぺい" (基本クラスと派生クラスに同じ名前のデータ メンバーが存在する) という概念は一般に推奨されていませんが、JSON では実際には禁止されています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="1d37f-316">ポリモーフィズムと IXmlSerializable 型</span><span class="sxs-lookup"><span data-stu-id="1d37f-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="1d37f-317"><xref:System.Xml.Serialization.IXmlSerializable> 型は、既知の型の要件を満たしている限り、通常のデータ コントラクト規則に従って、通常どおり相互にポリモーフィックな割り当てを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="1d37f-318">ただし、<xref:System.Xml.Serialization.IXmlSerializable> の代わりに <xref:System.Object> 型をシリアル化すると、結果が JSON 文字列になるため、型情報が失われることになります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="1d37f-319">ポリモーフィズムと一部のインターフェイス型</span><span class="sxs-lookup"><span data-stu-id="1d37f-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="1d37f-320"><xref:System.Xml.Serialization.IXmlSerializable> ではないコレクション型以外の型 (<xref:System.Xml.Serialization.IXmlSerializable> を除きます) が必要な場合、コレクション型または <xref:System.Object> を実装する型をシリアル化することは禁止されています。</span><span class="sxs-lookup"><span data-stu-id="1d37f-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="1d37f-321">たとえば、というカスタムインターフェイス `IMyInterface` や、 `MyType` 型と型の両方を実装する型を使用し <xref:System.Collections.Generic.IEnumerable%601> `int` `IMyInterface` ます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="1d37f-322">`MyType`戻り値の型がである操作から戻ることは禁止されてい `IMyInterface` ます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="1d37f-323">これは、は `MyType` JSON 配列としてシリアル化する必要があり、型ヒントが必要であり、型ヒントを配列に含めることができず、複合型を使用する場合に限ります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="1d37f-324">既知の型と構成</span><span class="sxs-lookup"><span data-stu-id="1d37f-324">Known Types and Configuration</span></span>

<span data-ttu-id="1d37f-325"><xref:System.Runtime.Serialization.DataContractSerializer> が使用する既知の型機構は、<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> の場合と同様にすべてサポートされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="1d37f-326">どちらのシリアライザーも [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) 、構成ファイルによって追加された既知の型を検出するために、同じ構成要素をで読み取ります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="1d37f-327">Object に割り当てられたコレクション</span><span class="sxs-lookup"><span data-stu-id="1d37f-327">Collections Assigned to Object</span></span>

<span data-ttu-id="1d37f-328">Object に割り当てられたコレクションは、<xref:System.Collections.Generic.IEnumerable%601> を実装するコレクションと同様にシリアル化されます。複合型の場合は、各エントリに型ヒントが含まれた JSON 配列になります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="1d37f-329">たとえば、 <xref:System.Collections.Generic.List%601> `Shape` に割り当てられた型のは <xref:System.Object> 次のようになります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="1d37f-330"><xref:System.Object> に逆シリアル化するときは、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="1d37f-331">`Shape`は既知の型リストに含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="1d37f-332"><xref:System.Collections.Generic.List%601>既知の型の型 `Shape` がある場合、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="1d37f-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="1d37f-333">この場合、シリアル化時に既知の型に追加する必要はないことに注意してください `Shape` 。これは自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="1d37f-334">コレクションは、 <xref:System.Array> インスタンスを含む型のとして逆シリアル化され <xref:System.Object> `Shape` ます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="1d37f-335">基本コレクションに割り当てられた派生コレクション</span><span class="sxs-lookup"><span data-stu-id="1d37f-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="1d37f-336">派生コレクションを基本コレクションに割り当てると、通常、そのコレクションは基本型のコレクションと同様にシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="1d37f-337">ただし、派生コレクションの項目の型を基本コレクションの項目の型に割り当てることができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1d37f-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="1d37f-338">型ヒントとディクショナリ</span><span class="sxs-lookup"><span data-stu-id="1d37f-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="1d37f-339">ディクショナリを <xref:System.Object> に割り当てると、ディクショナリに含まれる Key および Value の各エントリは、<xref:System.Object> に割り当てられている場合と同様に処理され、型ヒントを取得します。</span><span class="sxs-lookup"><span data-stu-id="1d37f-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="1d37f-340">ディクショナリ型をシリアル化した場合、"Key" メンバーと "Value" メンバーを含む JSON オブジェクトは、`alwaysEmitTypeInformation` 設定の影響を受けません。オブジェクトに型ヒントが含まれるのは、前述のコレクション ルールで必要とされる場合だけです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="1d37f-341">JSON の有効なキー名</span><span class="sxs-lookup"><span data-stu-id="1d37f-341">Valid JSON Key Names</span></span>

<span data-ttu-id="1d37f-342">シリアライザーは、無効な XML 名のキー名を XML エンコードします。</span><span class="sxs-lookup"><span data-stu-id="1d37f-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="1d37f-343">たとえば、"123" という名前のデータメンバーには、"x0031 x0032 x0033" のようなエンコードされた名前が付けら \_ \_ \_ \_ \_ \_ れます。これは、"123" が無効な XML 要素名 (数字で始まる) であるためです。</span><span class="sxs-lookup"><span data-stu-id="1d37f-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="1d37f-344">XML 名が有効ではない一部の国際文字セットでも、同様の状況が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1d37f-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="1d37f-345">JSON 処理での XML のこの影響の詳細については、「 [json と Xml 間のマッピング](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1d37f-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1d37f-346">関連項目</span><span class="sxs-lookup"><span data-stu-id="1d37f-346">See also</span></span>

- [<span data-ttu-id="1d37f-347">JSON などのデータ転送形式のサポート</span><span class="sxs-lookup"><span data-stu-id="1d37f-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
