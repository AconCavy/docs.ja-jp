---
title: XmlSerializer クラスの使用
description: WCF がクライアントとサービスの間で送信される XML にアプリケーションのデータをシリアル化するために使用する XmlSerializer について説明します。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: f7473de3f34ba543b4fabfe93167ea267f16dda5
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246384"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="51dd8-103">XmlSerializer クラスの使用</span><span class="sxs-lookup"><span data-stu-id="51dd8-103">Using the XmlSerializer Class</span></span>

<span data-ttu-id="51dd8-104">Windows Communication Foundation (WCF) では、2つの異なるシリアル化テクノロジを使用して、アプリケーション内のデータを、クライアントとサービスの間で送信される XML に変換できます。これは、シリアル化と呼ばれるプロセスです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-104">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="51dd8-105">既定としての DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="51dd8-105">DataContractSerializer as the Default</span></span>

<span data-ttu-id="51dd8-106">既定では、WCF はクラスを使用して <xref:System.Runtime.Serialization.DataContractSerializer> データ型をシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-106">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="51dd8-107">このシリアライザーは、次の型をサポートします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-107">This serializer supports the following types:</span></span>

- <span data-ttu-id="51dd8-108">プリミティブ型 (整数、文字列、バイト配列など) や、プリミティブとして処理される <xref:System.Xml.XmlElement> や <xref:System.DateTime> などの特殊な型。</span><span class="sxs-lookup"><span data-stu-id="51dd8-108">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="51dd8-109">データ コントラクト型 (<xref:System.Runtime.Serialization.DataContractAttribute> 属性でマークされた型)。</span><span class="sxs-lookup"><span data-stu-id="51dd8-109">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="51dd8-110"><xref:System.SerializableAttribute> インターフェイスを実装する型など、<xref:System.Runtime.Serialization.ISerializable> 属性でマークされた型。</span><span class="sxs-lookup"><span data-stu-id="51dd8-110">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="51dd8-111"><xref:System.Xml.Serialization.IXmlSerializable> インターフェイスを実装する型。</span><span class="sxs-lookup"><span data-stu-id="51dd8-111">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="51dd8-112">多くのジェネリック コレクション型を含む多くの共通コレクション型。</span><span class="sxs-lookup"><span data-stu-id="51dd8-112">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="51dd8-113">多くの .NET Framework 型は、後者の2つのカテゴリに分類されるため、シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-113">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="51dd8-114">シリアル化可能な型の配列もシリアル化可能です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-114">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="51dd8-115">完全な一覧については、「[サービスコントラクトでのデータ転送の指定](specifying-data-transfer-in-service-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-115">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="51dd8-116"><xref:System.Runtime.Serialization.DataContractSerializer>新しい WCF サービスを記述するには、データコントラクト型と共に使用されるを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-116">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="51dd8-117">詳細については、「[データコントラクトの使用](using-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-117">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="51dd8-118">XmlSerializer クラスを使用する場合</span><span class="sxs-lookup"><span data-stu-id="51dd8-118">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="51dd8-119">WCF では、クラスもサポートさ <xref:System.Xml.Serialization.XmlSerializer> れています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-119">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="51dd8-120"><xref:System.Xml.Serialization.XmlSerializer>クラスは WCF に固有ではありません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-120">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="51dd8-121">これは、ASP.NET Web サービスが使用するのと同じシリアル化エンジンです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-121">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="51dd8-122"><xref:System.Xml.Serialization.XmlSerializer> クラスでは、<xref:System.Runtime.Serialization.DataContractSerializer> クラスよりもサポートされる型の範囲がずっと狭くなりますが、結果の XML に対する制御の柔軟性に優れています。また、XML スキーマ定義言語 (XSD) 標準のサポート範囲が広く、</span><span class="sxs-lookup"><span data-stu-id="51dd8-122">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="51dd8-123">シリアル化可能な型で宣言型属性が要求されません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-123">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="51dd8-124">詳細については、.NET Framework のドキュメントの XML シリアル化に関するトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-124">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="51dd8-125"><xref:System.Xml.Serialization.XmlSerializer> クラスは、データ コントラクト型をサポートしません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-125">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="51dd8-126">Svcutil.exe または Visual Studio の**サービス参照の追加**機能を使用して、サードパーティのサービスのクライアントコードを生成したり、サードパーティのスキーマにアクセスしたりする場合は、適切なシリアライザーが自動的に選択されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-126">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="51dd8-127">スキーマに <xref:System.Runtime.Serialization.DataContractSerializer> との互換性がない場合は、<xref:System.Xml.Serialization.XmlSerializer> が選択されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-127">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="51dd8-128">XmlSerializer への手動切り替え</span><span class="sxs-lookup"><span data-stu-id="51dd8-128">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="51dd8-129"><xref:System.Xml.Serialization.XmlSerializer> に手動で切り替える必要が生じる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-129">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="51dd8-130">たとえば、次のような場合です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-130">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="51dd8-131">アプリケーションを ASP.NET Web サービスから WCF に移行する場合は、新しいデータコントラクト型を作成するのではなく、既存の互換性のある型を再利用することが必要になる場合があり <xref:System.Xml.Serialization.XmlSerializer> ます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-131">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="51dd8-132">メッセージに表示する XML に対する正確な制御が必要で、Web サービス記述言語 (WSDL) ドキュメントが利用できない場合。たとえば、DataContractSerializer と互換性がなく、標準化および公開されている特定のスキーマに従う必要のある型を使用して、サービスを作成する場合。</span><span class="sxs-lookup"><span data-stu-id="51dd8-132">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="51dd8-133">従来の SOAP エンコード標準に従うサービスを作成する場合。</span><span class="sxs-lookup"><span data-stu-id="51dd8-133">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="51dd8-134">上記を含めた多様な状況で、次のコードに示すように、<xref:System.Xml.Serialization.XmlSerializer> 属性をサービスに適用することにより、`XmlSerializerFormatAttribute` クラスに手動で切り替えることができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-134">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="51dd8-135">セキュリティの考慮事項</span><span class="sxs-lookup"><span data-stu-id="51dd8-135">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="51dd8-136">シリアル化エンジンを切り替える場合は注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-136">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="51dd8-137">同じ型でも、使用するシリアライザーによって XML へのシリアル化方法が異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-137">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="51dd8-138">誤って、不適切なシリアライザーを使用すると、公開する意図のない型の情報が公開されるおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-138">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="51dd8-139">たとえば、<xref:System.Runtime.Serialization.DataContractSerializer> クラスは、データ コントラクト型をシリアル化する場合、<xref:System.Runtime.Serialization.DataMemberAttribute> 属性でマークされたメンバーのみをシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-139">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="51dd8-140"><xref:System.Xml.Serialization.XmlSerializer> クラスは、すべてのパブリック メンバーをシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-140">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="51dd8-141">たとえば、次のコードの型を見てください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-141">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="51dd8-142"><xref:System.Xml.Serialization.XmlSerializer> クラスが選択されているサービス コントラクトでこの型が誤って使用された場合、意図したものではなくても `creditCardNumber` メンバーがシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-142">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="51dd8-143"><xref:System.Runtime.Serialization.DataContractSerializer> クラスが既定の場合でも、<xref:System.ServiceModel.DataContractFormatAttribute> 属性をサービス コントラクト型に適用することで、このクラスをサービスに対して明示的に選択できます (ただし、この操作が必要になることはありません)。</span><span class="sxs-lookup"><span data-stu-id="51dd8-143">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="51dd8-144">サービスで使用するシリアライザーはコントラクトにとって不可欠な部分です。別のバインディングを選択しても他の構成設定に変更しても、このシリアライザーを変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-144">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="51dd8-145"><xref:System.Xml.Serialization.XmlSerializer> クラスについては、セキュリティに関する重要な考慮事項が他にもあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-145">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="51dd8-146">まず、クラスを使用するすべての WCF アプリケーション <xref:System.Xml.Serialization.XmlSerializer> が、開示から保護されたキーで署名されていることを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-146">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="51dd8-147">このことは、<xref:System.Xml.Serialization.XmlSerializer> に手動で切り替える場合と、自動切り替えが行われる場合 (Svcutil.exe やサービス参照の追加などのツールによる) の両方でお勧めします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-147">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="51dd8-148">これは、 <xref:System.Xml.Serialization.XmlSerializer> シリアル化エンジンは、アプリケーションと同じキーで署名されている限り、*事前に生成されたシリアル化アセンブリ*の読み込みをサポートするためです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-148">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="51dd8-149">署名されていないアプリケーションは、アプリケーション フォルダーやグローバル アセンブリ キャッシュに配置される事前生成済みのシリアル化アセンブリで予想される名前に、悪意のあるアセンブリが一致するという危険性に対して完全に無防備になります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-149">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="51dd8-150">もちろん、攻撃者がこのようなアクションを行うには、この 2 つの場所のいずれかに対する書き込みアクセスをまず取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-150">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="51dd8-151"><xref:System.Xml.Serialization.XmlSerializer> を使用するときに必ず存在するもう 1 つの脅威は、システムの一時フォルダーへの書き込みアクセスに関連するものです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-151">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="51dd8-152">シリアル化エンジンは、 <xref:System.Xml.Serialization.XmlSerializer> このフォルダー内に一時的な*シリアル化アセンブリ*を作成して使用します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-152">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="51dd8-153">一時フォルダーへの書き込みアクセスのあるプロセスであれば、悪意のあるコードによってこれらのシリアル化アセンブリが上書きされるおそれがあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-153">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="51dd8-154">XmlSerializer サポートのルール</span><span class="sxs-lookup"><span data-stu-id="51dd8-154">Rules for XmlSerializer support</span></span>

<span data-ttu-id="51dd8-155"><xref:System.Xml.Serialization.XmlSerializer> 互換の属性は、コントラクト操作のパラメーターまたは戻り値に直接適用できません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-155">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="51dd8-156">ただし、次のコードに示すように、型指定されたメッセージ (メッセージ コントラクトの本文) には適用できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-156">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="51dd8-157">型指定されたメッセージのメンバーに適用する場合、型指定されたメッセージ属性で競合するプロパティは、この属性によりオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-157">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="51dd8-158">たとえば、次のコードの `ElementName` は、`Name` をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-158">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="51dd8-159"><xref:System.ServiceModel.MessageHeaderArrayAttribute> の使用時は、<xref:System.Xml.Serialization.XmlSerializer> 属性はサポートされません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-159">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="51dd8-160">この場合、は、 <xref:System.Xml.Serialization.XmlSerializer> WCF より前にリリースされた次の例外をスローします。 "スキーマの最上位で宣言された要素は > 1 を持つことができません `maxOccurs` 。</span><span class="sxs-lookup"><span data-stu-id="51dd8-160">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="51dd8-161">`XmlArray` ではなく、`XmlArrayItem` または `XmlElementAttribute` を使うか、Wrapped パラメーター スタイルを使って 'more' のラッパー要素を指定してください。" という例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-161">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="51dd8-162">この例外が出力された場合は、この状況が当てはまるかどうかを調査します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-162">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="51dd8-163">WCF は、 <xref:System.Xml.Serialization.SoapIncludeAttribute> <xref:System.Xml.Serialization.XmlIncludeAttribute> メッセージコントラクトおよび操作コントラクトの属性と属性をサポートしていません。 <xref:System.Runtime.Serialization.KnownTypeAttribute> 代わりに属性を使用してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-163">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="51dd8-164">IXmlSerializable インターフェイスを実装する型</span><span class="sxs-lookup"><span data-stu-id="51dd8-164">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="51dd8-165">`IXmlSerializable` インターフェイスを実装する型は、`DataContractSerializer` で完全にサポートされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-165">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="51dd8-166">これらの型には、スキーマを制御するために必ず <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-166">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="51dd8-167">ポリモーフィック型をシリアル化する場合、<xref:System.Xml.Serialization.XmlSchemaProviderAttribute> を型に適用して、正しい型がシリアル化されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-167">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="51dd8-168">`IXmlSerializable` を実装する型には、任意のコンテンツを表す型、1 つの要素を表す型、および従来の <xref:System.Data.DataSet> 型の 3 種類があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-168">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="51dd8-169">コンテンツ型では、`XmlSchemaProviderAttribute` 属性によって指定されたスキーマ プロバイダー メソッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-169">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="51dd8-170">このメソッドから `null` が返されることはなく、属性の <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> プロパティは既定値 `false` のままになります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-170">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="51dd8-171">これは、`IXmlSerializable` 型の最も一般的な使用方法です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-171">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="51dd8-172">要素型は、`IXmlSerializable` 型が自身のルート要素名を制御する必要があるときに使用します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-172">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="51dd8-173">型を要素型としてマークするには、<xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 属性の <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> プロパティを `true` に設定するか、スキーマ プロバイダー メソッドから `null` を返します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-173">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="51dd8-174">スキーマ プロバイダー メソッドの使用は、要素型ではオプションです。`null` でメソッド名の代わりに `XmlSchemaProviderAttribute` を指定できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-174">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="51dd8-175">ただし、`IsAny` が `true` で、スキーマ プロバイダー メソッドが指定されている場合、メソッドは `null` を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-175">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="51dd8-176">従来の <xref:System.Data.DataSet> 型は、`IXmlSerializable` 属性でマークされていない `XmlSchemaProviderAttribute` 型です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-176">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="51dd8-177">これらの型は、スキーマ生成に関して <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> メソッドに依存しています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-177">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="51dd8-178">以前のバージョンの .NET Framework では、このパターンが `DataSet` 型に使用され、型指定されたデータセットからクラスが派生されます。ただし、現在、このパターンは使用されなくなっており、従来の型に対応することだけを目的としてサポートされています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-178">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="51dd8-179">このパターンに依存せず、必ず `XmlSchemaProviderAttribute` を `IXmlSerializable` 型に適用してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-179">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="51dd8-180">IXmlSerializable コンテンツ型</span><span class="sxs-lookup"><span data-stu-id="51dd8-180">IXmlSerializable Content Types</span></span>

<span data-ttu-id="51dd8-181">`IXmlSerializable` を実装しており、以前に定義したコンテンツ型である型のデータ メンバーをシリアル化すると、シリアライザーはそのデータ メンバーのラッパー要素を書き込み、<xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> メソッドに制御を渡します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-181">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="51dd8-182"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 実装により、ラッパー要素に属性が追加されるなど、任意の XML が書き込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-182">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="51dd8-183">`WriteXml` の実行後、シリアライザーは要素を閉じます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-183">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="51dd8-184">`IXmlSerializable` を実装しており、以前に定義したコンテンツ型である型のデータ メンバーを逆シリアル化すると、デシリアライザーはそのデータ メンバーのラッパー要素に XML リーダーを配置し、<xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> メソッドに制御を渡します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-184">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="51dd8-185">このメソッドは、開始タグと終了タグを含む、要素全体を読み取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-185">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="51dd8-186">`ReadXml` コードでは、要素が空の場合も忘れずに処理してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-186">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="51dd8-187">また、`ReadXml` の実装では、特定の方法で名前が付けられたラッパー要素に依存しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-187">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="51dd8-188">シリアライザーによって選択される名前は、異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-188">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="51dd8-189">`IXmlSerializable` コンテンツ型は、たとえば <xref:System.Object> 型のデータ メンバーなどに、ポリモーフィックに割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-189">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="51dd8-190">また、型インスタンスを null にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-190">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="51dd8-191">さらに、`IXmlSerializable` 型は、オブジェクト グラフの保存を有効にして <xref:System.Runtime.Serialization.NetDataContractSerializer> で使用することも可能です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-191">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="51dd8-192">これらのすべての機能では、WCF シリアライザーが特定の属性をラッパー要素にアタッチする必要があります (XML スキーマインスタンス名前空間の "nil" と "type"、WCF 固有の名前空間の "Id"、"Ref"、"Type"、"Assembly")。</span><span class="sxs-lookup"><span data-stu-id="51dd8-192">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="51dd8-193">ReadXml を実装するときに無視する属性</span><span class="sxs-lookup"><span data-stu-id="51dd8-193">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="51dd8-194">`ReadXml` コードに制御を渡す前に、デシリアライザーは、XML 要素を調べ、前述の特別な XML 属性を検出し、その属性に従って動作します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-194">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="51dd8-195">たとえば、"nil" が `true` の場合は、null 値が逆シリアル化され、`ReadXml` は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-195">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="51dd8-196">ポリモーフィズムが検出された場合は、要素のコンテンツが別の型と同様に逆シリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-196">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="51dd8-197">ポリモーフィックに割り当てられた型の `ReadXml` 実装が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-197">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="51dd8-198">どの場合も、これらの特別な属性がデシリアライザーによって処理されるため、`ReadXml` 実装ではこれらの属性を無視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-198">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="51dd8-199">IXmlSerializable コンテンツ型のスキーマに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="51dd8-199">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="51dd8-200">スキーマと `IXmlSerializable` コンテンツ型をエクスポートすると、スキーマ プロバイダー メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-200">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="51dd8-201">このスキーマ プロバイダー メソッドには、<xref:System.Xml.Schema.XmlSchemaSet> が渡されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-201">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="51dd8-202">このメソッドは、有効なスキーマをスキーマ セットに追加できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-202">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="51dd8-203">スキーマ セットには、スキーマをエクスポートした時点で既に認識されていたスキーマが格納されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-203">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="51dd8-204">スキーマ プロバイダー メソッドは、スキーマ セットに項目を追加する必要があるときに、適切な名前空間を持つ <xref:System.Xml.Schema.XmlSchema> がそのセットに既に存在するかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-204">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="51dd8-205">存在する場合、スキーマ プロバイダー メソッドは新しい項目を既存の `XmlSchema` に追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-205">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="51dd8-206">存在しない場合、新しい `XmlSchema` インスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-206">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="51dd8-207">これは、`IXmlSerializable` 型の配列を使用する場合に重要です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-207">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="51dd8-208">たとえば、`IXmlSerializable` 型を名前空間 "B" の "A" 型としてエクスポートする場合、スキーマ プロバイダー メソッドが呼び出される前に、"B" が "ArrayOfA" 型を保持するためのスキーマがスキーマ セットに既に存在している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-208">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="51dd8-209">型を <xref:System.Xml.Schema.XmlSchemaSet> に追加する以外に、コンテンツ型のスキーマ プロバイダー メソッドは null 以外の値を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-209">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="51dd8-210">このメソッドは、特定の <xref:System.Xml.XmlQualifiedName> 型で使用するスキーマ型の名前を指定する `IXmlSerializable` を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-210">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="51dd8-211">この修飾名は、その型のデータ コントラクト名および名前空間としても使用されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-211">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="51dd8-212">スキーマ プロバイダー メソッドは、スキーマ セットにまだ存在していない型であっても、復帰時に返すことができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-212">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="51dd8-213">ただし、関連するすべての型がエクスポートされる (<xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> の関連するすべての型に対して <xref:System.Runtime.Serialization.XsdDataContractExporter> メソッドが呼び出され、<xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> プロパティにアクセスする) までに、その型がスキーマ セットに存在している必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-213">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="51dd8-214">関連するすべての `Schemas` 呼び出しが実行される前に `Export` プロパティにアクセスすると、<xref:System.Xml.Schema.XmlSchemaException> が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-214">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="51dd8-215">エクスポートプロセスの詳細については、「[クラスからのスキーマのエクスポート](exporting-schemas-from-classes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-215">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="51dd8-216">スキーマ プロバイダー メソッドは、使用する <xref:System.Xml.Schema.XmlSchemaType> を返すこともできます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-216">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="51dd8-217">その型は、匿名の場合とそうでない場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-217">The type may or may not be anonymous.</span></span> <span data-ttu-id="51dd8-218">匿名の場合、`IXmlSerializable` 型のスキーマは、`IXmlSerializable` 型がデータ メンバーとして使用されるたびに匿名型としてエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-218">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="51dd8-219">`IXmlSerializable` 型には、データ コントラクト名と名前空間が引き続き保持されます </span><span class="sxs-lookup"><span data-stu-id="51dd8-219">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="51dd8-220">(これは、「[データコントラクト名](data-contract-names.md)」で説明されているように、 <xref:System.Runtime.Serialization.DataContractAttribute> 名前のカスタマイズには属性を使用できない点が異なります)。匿名でない場合は、内のいずれかの型である必要があり `XmlSchemaSet` ます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-220">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="51dd8-221">これは、型の `XmlQualifiedName` を返す場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-221">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="51dd8-222">さらに、型のグローバル要素宣言がエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-222">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="51dd8-223">型に <xref:System.Xml.Serialization.XmlRootAttribute> 属性が適用されていない場合、その要素にはデータ コントラクトと同じ名前と名前空間が使用され、その "nillable" プロパティは `true` に設定されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-223">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="51dd8-224">唯一の例外は、スキーマ名前空間 ( `http://www.w3.org/2001/XMLSchema` ) です。型のデータコントラクトがこの名前空間にある場合、スキーマ名前空間に新しい要素を追加することは禁止されているため、対応するグローバル要素は空の名前空間にあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-224">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="51dd8-225">型に `XmlRootAttribute` 属性が適用されている場合、グローバル要素宣言は、<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A>、および <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> の各プロパティを使用してエクスポートされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-225">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="51dd8-226">`XmlRootAttribute` が適用された場合の既定値は、データ コントラクト名、空白の名前空間、および `true` に設定された "nillable" です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-226">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="51dd8-227">同じグローバル要素宣言の規則が、従来のデータセット型に適用されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-227">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="51dd8-228">`XmlRootAttribute` は、カスタム コードによって追加されたグローバル要素宣言をオーバーライドできません。これには、スキーマ プロバイダー メソッドを使用して `XmlSchemaSet` に追加された場合と、従来のデータセット型に対して `GetSchema` を使用して追加された場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-228">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="51dd8-229">IXmlSerializable 要素型</span><span class="sxs-lookup"><span data-stu-id="51dd8-229">IXmlSerializable Element Types</span></span>

<span data-ttu-id="51dd8-230">`IXmlSerializable` 要素型には、`IsAny` に設定された `true` プロパティか、`null` を返すスキーマ プロバイダー メソッドのいずれかが含まれています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-230">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="51dd8-231">要素型のシリアル化と逆シリアル化は、コンテンツ型のシリアル化と逆シリアル化に非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-231">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="51dd8-232">ただし、重要な違いがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-232">However, there are some important differences:</span></span>

- <span data-ttu-id="51dd8-233">`WriteXml` の実装では、要素 (これには複数の子要素が含まれている可能性もありますが) を 1 つだけ出力することが想定されています。</span><span class="sxs-lookup"><span data-stu-id="51dd8-233">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="51dd8-234">この 1 つの要素の外側にある属性、複数の兄弟要素、またはこれらが混在したコンテンツを出力することはできません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-234">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="51dd8-235">要素は空であってもかまいません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-235">The element may be empty.</span></span>

- <span data-ttu-id="51dd8-236">`ReadXml` の実装では、ラッパー要素の読み取りは想定されていません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-236">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="51dd8-237">読み取ることが想定されているのは、`WriteXml` で生成される要素 1 つのみです。</span><span class="sxs-lookup"><span data-stu-id="51dd8-237">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="51dd8-238">要素型を一様にシリアル化する場合 (データ コントラクトのデータ メンバーとしてシリアル化する場合など) は、コンテンツ型の場合と同様に、`WriteXml` を呼び出す前にラッパー要素が出力されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-238">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="51dd8-239">ただし、`WriteXml` コンストラクターまたは `DataContractSerializer` コンストラクターによるシリアライザーの構築時にルート名と名前空間を明示的に指定しない限り、トップ レベルで要素型をシリアル化しても、通常は `NetDataContractSerializer` で書き出される要素を囲むラッパー要素が出力されることはありません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-239">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="51dd8-240">詳細については、「[シリアル化と逆シリアル化](serialization-and-deserialization.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-240">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="51dd8-241">構築時にルート名と名前空間を指定せずにトップ レベルで要素型をシリアル化した場合、<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> と <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> では基本的に何も実行されず、<xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> によって `WriteXml` が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-241">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="51dd8-242">このモードでは、シリアル化されるオブジェクトは `null` にできず、ポリモーフィックに割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-242">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="51dd8-243">また、オブジェクト グラフの保存を有効化できず、`NetDataContractSerializer` も使用できません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-243">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="51dd8-244">構築時にルート名と名前空間を指定せずにトップ レベルで要素型を逆シリアル化したときに、要素の先頭を検出できた場合は、<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> が `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-244">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="51dd8-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> パラメーターが `verifyObjectName` に設定されている `true` は、実際にオブジェクトを読み取る前の動作が `IsStartObject` と同様です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="51dd8-246">その後、`ReadObject` は制御を `ReadXml` メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-246">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="51dd8-247">要素型の場合も、エクスポートされるスキーマは、前のセクションで説明した `XmlElement` 型に対するスキーマと同じです。ただし、スキーマ プロバイダー メソッドは、コンテンツ型と同様、追加のスキーマを <xref:System.Xml.Schema.XmlSchemaSet> に追加できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-247">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="51dd8-248">要素型には `XmlRootAttribute` 属性を使用することはできないので、グローバル要素宣言は要素型に対して出力されません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-248">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="51dd8-249">XmlSerializer との相違点</span><span class="sxs-lookup"><span data-stu-id="51dd8-249">Differences from the XmlSerializer</span></span>

<span data-ttu-id="51dd8-250">`IXmlSerializable` インターフェイス、`XmlSchemaProviderAttribute` 属性、および `XmlRootAttribute` 属性は、<xref:System.Xml.Serialization.XmlSerializer> でも認識されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-250">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="51dd8-251">ただし、データ コントラクト モデルでの処理方法に違いがあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-251">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="51dd8-252">重要な違いを以下にまとめます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-252">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="51dd8-253">スキーマ プロバイダー メソッドは、`XmlSerializer` で使用できるようにするためにパブリックにする必要がありますが、データ コントラクト モデルで使用するためにパブリックにする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-253">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="51dd8-254">スキーマ プロバイダー メソッドは、データ コントラクト モデルで `IsAny` が `true` の場合に呼び出されますが、`XmlSerializer` では呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="51dd8-254">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="51dd8-255">コンテンツ型または従来のデータセット型に `XmlRootAttribute` 属性がない場合、`XmlSerializer` は、グローバル要素宣言を空白の名前空間にエクスポートします。</span><span class="sxs-lookup"><span data-stu-id="51dd8-255">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="51dd8-256">データ コントラクト モデルで通常使用される名前空間は、前に説明したとおりデータ コントラクトの名前空間です。</span><span class="sxs-lookup"><span data-stu-id="51dd8-256">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="51dd8-257">両方のシリアル化技術で使用する型を作成する場合には、これらの違いに注意してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-257">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="51dd8-258">IXmlSerializable スキーマのインポート</span><span class="sxs-lookup"><span data-stu-id="51dd8-258">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="51dd8-259">`IXmlSerializable` 型から生成されたスキーマをインポートする場合、次のような状況が考えられます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-259">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="51dd8-260">生成されるスキーマは、「[データコントラクトスキーマの参照](data-contract-schema-reference.md)」で説明されている有効なデータコントラクトスキーマである場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-260">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="51dd8-261">この場合は、スキーマを通常どおりにインポートでき、通常のデータ コントラクト型が生成されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-261">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="51dd8-262">生成されたスキーマが、有効なデータ コントラクト スキーマではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-262">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="51dd8-263">たとえば、スキーマ プロバイダー メソッドによって、データ コントラクト モデルでサポートされていない XML 属性を含むスキーマが生成されることがあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-263">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="51dd8-264">この場合、スキーマを `IXmlSerializable` 型としてインポートできます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-264">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="51dd8-265">このインポートモードは、既定では有効になっていませんが、たとえば、 `/importXmlTypes` [ServiceModel メタデータユーティリティツール (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)へのコマンドラインスイッチを使用して、簡単に有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-265">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="51dd8-266">この詳細については、「[クラスを生成するためのスキーマのインポート](importing-schema-to-generate-classes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="51dd8-266">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="51dd8-267">型インスタンスを処理するには、XML を直接操作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-267">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="51dd8-268">`XmlSerializer` の使用方法に関するトピックを参照し、より広い範囲のスキーマをサポートする別のシリアル化技術を使用することを検討することもできます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-268">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="51dd8-269">新しい型を生成する代わりに、プロキシ内の既存の `IXmlSerializable` 型を再利用できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-269">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="51dd8-270">この場合、「型を作成するためのスキーマのインポート」で説明する参照型の機能を使用して、再利用する型を示すことができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-270">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="51dd8-271">これは、Svcutil.exe で `/reference` スイッチを使用して、再利用する型を含むアセンブリを指定することに相当します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-271">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="51dd8-272">XmlSerializer の従来の動作</span><span class="sxs-lookup"><span data-stu-id="51dd8-272">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="51dd8-273">.NET Framework 4.0 以前では、XmlSerializer が C# コードをファイルに書き込むことによって、一時的なシリアル化アセンブリが生成されます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-273">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="51dd8-274">さらに、このファイルがアセンブリとしてコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-274">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="51dd8-275">この動作では、シリアライザーの起動時間が長くなるなど、望ましくない結果が生じることがあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-275">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="51dd8-276">.NET Framework 4.5 では、この動作が変更され、コンパイラを使用せずに、アセンブリが生成されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="51dd8-276">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="51dd8-277">開発者によっては、生成された C# コードを確認したい場合もあります。</span><span class="sxs-lookup"><span data-stu-id="51dd8-277">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="51dd8-278">次の構成によって、この従来の動作を使用するように指定できます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-278">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="51dd8-279">非パブリックの新しいオーバーライドを使用して派生クラスをシリアル化できないなどの互換性の問題が発生した場合は、 `XmlSerializer` 次の `XMLSerializer` 構成を使用して従来の動作に戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-279">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="51dd8-280">上記の構成の代わりに、.NET Framework 4.5 以降のバージョンを実行しているコンピューターで次の構成を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="51dd8-280">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="51dd8-281">`<xmlSerializer useLegacySerializerGeneration="true"/>`スイッチは .NET Framework 4.5 以降のバージョンを実行しているコンピューターでのみ機能します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-281">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="51dd8-282">上記の `appSettings` 方法は、すべての .NET Framework バージョンで動作します。</span><span class="sxs-lookup"><span data-stu-id="51dd8-282">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="51dd8-283">関連項目</span><span class="sxs-lookup"><span data-stu-id="51dd8-283">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="51dd8-284">サービス コントラクトでのデータ転送の指定</span><span class="sxs-lookup"><span data-stu-id="51dd8-284">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="51dd8-285">データ コントラクトの使用</span><span class="sxs-lookup"><span data-stu-id="51dd8-285">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="51dd8-286">方法: XmlSerializer を使用する WCF クライアント アプリケーションの起動時間を短縮する</span><span class="sxs-lookup"><span data-stu-id="51dd8-286">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
