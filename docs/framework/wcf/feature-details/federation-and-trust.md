---
title: フェデレーションと信頼
ms.date: 03/30/2017
helpviewer_keywords:
- federation [WCF], and trust
ms.assetid: 4bdec4f2-f8a2-4512-bdcf-14ef54b5877a
ms.openlocfilehash: 8b924a4aeb9c667592e99d65666cd8f048d34c22
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/09/2020
ms.locfileid: "84595480"
---
# <a name="federation-and-trust"></a><span data-ttu-id="d539e-102">フェデレーションと信頼</span><span class="sxs-lookup"><span data-stu-id="d539e-102">Federation and Trust</span></span>
<span data-ttu-id="d539e-103">このトピックでは、Windows Communication Foundation (WCF) でのフェデレーションアプリケーション、信頼の境界と構成、および発行済みトークンの使用に関連するさまざまな側面について説明します。</span><span class="sxs-lookup"><span data-stu-id="d539e-103">This topic covers various aspects related to federated applications, trust boundaries and configuration, and use of issued tokens in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="services-security-token-services-and-trust"></a><span data-ttu-id="d539e-104">サービス、セキュリティ トークン サービス、および信頼</span><span class="sxs-lookup"><span data-stu-id="d539e-104">Services, Security Token Services, and Trust</span></span>  
 <span data-ttu-id="d539e-105">フェデレーション エンドポイントを公開するサービスを使用する場合、通常、特定の発行者によって提供されたトークンを使用してクライアント認証を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-105">Services that expose federated endpoints typically expect clients to authenticate using a token provided by a specific issuer.</span></span> <span data-ttu-id="d539e-106">そのため、発行者の正しい資格情報を使用してサービスが構成されていることが重要です。そうでないと、サービスは発行済みトークンの署名を検証することができず、クライアントはサービスと通信できません。</span><span class="sxs-lookup"><span data-stu-id="d539e-106">It is important that the service is configured with the correct credentials for the issuer; otherwise, it will not be able to verify signatures over the issued tokens, and the client will be unable to communicate with the service.</span></span> <span data-ttu-id="d539e-107">サービスで発行者の資格情報を構成する方法の詳細については、「[方法: フェデレーションサービスで資格情報を構成する](how-to-configure-credentials-on-a-federation-service.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d539e-107">For more information about configuring issuer credentials on the service, see [How to: Configure Credentials on a Federation Service](how-to-configure-credentials-on-a-federation-service.md).</span></span>  
  
 <span data-ttu-id="d539e-108">同様に、対称キーを使用する場合も、キーがターゲット サービス用に暗号化されるため、セキュリティ トークン サービスがターゲット サービスの正しい資格情報で構成される必要があります。そうでないと、セキュリティ トークン サービスはターゲット サービス用にキーを暗号化できないため、この場合も、クライアントはサービスと通信できなくなります。</span><span class="sxs-lookup"><span data-stu-id="d539e-108">Similarly, when using symmetric keys, the keys are encrypted for the target service, so you must configure the security token service with the correct credentials for the target service; otherwise, it will be unable to encrypt the key for the target service, and again, the client will be unable to communicate with the service.</span></span>  
  
 <span data-ttu-id="d539e-109">WCF サービスは、のプロパティの値を使用して、 <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxClockSkew%2A> クライアントとサービスの間のクロックスキューを可能にします。 [SecurityBindingElement](../diagnostics/wmi/securitybindingelement.md)</span><span class="sxs-lookup"><span data-stu-id="d539e-109">WCF services use the value of the <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxClockSkew%2A> property on the [SecurityBindingElement](../diagnostics/wmi/securitybindingelement.md) to allow for clock skew between the client and service.</span></span> <span data-ttu-id="d539e-110">フェデレーションでは、`MaxClockSkew` 設定が、クライアントと、クライアントが発行済みトークンを取得したセキュリティ トークン サービスの両方の時刻のずれに対して適用されます。</span><span class="sxs-lookup"><span data-stu-id="d539e-110">In federation, the `MaxClockSkew` setting applies to clock skews between both the client and the security token service from where the client obtained the issued token.</span></span> <span data-ttu-id="d539e-111">そのため、発行済みトークンの有効期間の開始時刻と終了時刻が設定する際、セキュリティ トークン サービスで時刻のずれを許可する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d539e-111">Therefore, security token services need not make clock-skew allowances when setting the issued token's effective and expiration times.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d539e-112">時刻のずれの重要性は、発行済みトークンの有効期間が短くなるほど大きくなります。</span><span class="sxs-lookup"><span data-stu-id="d539e-112">The importance of clock skew increases as the lifetime of the issued token shortens.</span></span> <span data-ttu-id="d539e-113">トークンの有効期間が 30 分以上あれば、多くの場合、時刻のずれは大きな問題にはなりません。</span><span class="sxs-lookup"><span data-stu-id="d539e-113">In most cases, clock skew is not a significant issue if the token lifetime is 30 minutes or more.</span></span> <span data-ttu-id="d539e-114">短い有効期間が使用されるシナリオやトークンの正確な有効時間が重要となるシナリオでは、時刻のずれを考慮に入れて設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-114">Scenarios with shorter lifetimes or where the exact validity time of the token is important should be designed to take clock skew into account.</span></span>  
  
## <a name="federated-endpoints-and-time-outs"></a><span data-ttu-id="d539e-115">フェデレーション エンドポイントとタイムアウト</span><span class="sxs-lookup"><span data-stu-id="d539e-115">Federated Endpoints and Time-Outs</span></span>  
 <span data-ttu-id="d539e-116">クライアントがフェデレーション エンドポイントと通信するときは、最初にセキュリティ トークン サービスから適切なトークンを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-116">When a client communicates with a federated endpoint, it must first acquire an appropriate token from a security token service.</span></span> <span data-ttu-id="d539e-117">このセキュリティ トークン サービスがフェデレーション エンドポイントを公開している場合、クライアントは最初にそのエンドポイントの発行者からトークンを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-117">If the security token service exposes a federated endpoint, the client must first obtain a token from the issuer for that endpoint.</span></span> <span data-ttu-id="d539e-118">それぞれのトークンの取得には時間がかかり、この時間が実際のメッセージを最終的なエンドポイントに送信するときの全体的なタイムアウトの影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="d539e-118">Each token acquisition takes time, and that time is subject to the overall time-out for sending the actual message to the final endpoint.</span></span>  
  
 <span data-ttu-id="d539e-119">たとえば、クライアント側チャネルのタイムアウトが 30 秒に設定されているとします。</span><span class="sxs-lookup"><span data-stu-id="d539e-119">For example, the time-out on the client-side channel is set to 30 seconds.</span></span> <span data-ttu-id="d539e-120">またメッセージを最終的なエンドポイントに送信する前に、トークンを取得するために 2 つのトークン発行者を呼び出す必要があり、それぞれのトークンの発行に 15 秒を要するとします。</span><span class="sxs-lookup"><span data-stu-id="d539e-120">Two token issuers need to be called to retrieve tokens before sending the message to the final endpoint, and each takes 15 seconds to issue a token.</span></span> <span data-ttu-id="d539e-121">この場合、この試行は失敗し、<xref:System.TimeoutException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="d539e-121">In this case, the attempt will fail and a <xref:System.TimeoutException> is thrown.</span></span> <span data-ttu-id="d539e-122">したがって、クライアント チャネルの <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> 値は、すべての発行済みトークンを取得するのにかかる時間を含めた、十分大きな値に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-122">Thus, you need to set the <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> value on the client channel to a value large enough to include the time taken to retrieve all issued tokens.</span></span> <span data-ttu-id="d539e-123"><xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> プロパティの値が指定されていない場合、<xref:System.ServiceModel.Channels.Binding.OpenTimeout%2A> プロパティ、または <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A> プロパティ (あるいはその両方) を、すべての発行済みトークンを取得するのにかかる時間を含めた、十分大きな値に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-123">In the case where a value is not specified for the <xref:System.ServiceModel.IContextChannel.OperationTimeout%2A> property, the <xref:System.ServiceModel.Channels.Binding.OpenTimeout%2A> property or the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A> property (or both) need to be set to a value large enough to include the time taken to retrieve all issued tokens.</span></span>  
  
## <a name="token-lifetime-and-renewal"></a><span data-ttu-id="d539e-124">トークンの有効期間と更新</span><span class="sxs-lookup"><span data-stu-id="d539e-124">Token Lifetime and Renewal</span></span>  
 <span data-ttu-id="d539e-125">WCF クライアントは、サービスへの初期要求を行うときに、発行されたトークンを確認しません。</span><span class="sxs-lookup"><span data-stu-id="d539e-125">WCF clients do not check the issued token when making an initial request to a service.</span></span>  <span data-ttu-id="d539e-126">代わりに、WCF は Security Token Service を信頼して、適切な有効期間と有効期限があるトークンを発行します。</span><span class="sxs-lookup"><span data-stu-id="d539e-126">Rather, WCF trusts the security token service to issue a token with appropriate effective and expiration times.</span></span> <span data-ttu-id="d539e-127">トークンがクライアントによってキャッシュされて再使用される場合は、トークンの有効期間が、後続する要求によってチェックされ、クライアントは必要に応じてトークンを自動的に更新します。</span><span class="sxs-lookup"><span data-stu-id="d539e-127">If the token is cached by the client and reused, the token lifetime is checked on subsequent requests and the client automatically renews the token if necessary.</span></span> <span data-ttu-id="d539e-128">トークンキャッシュの詳細については、「[方法: フェデレーションクライアントを作成](how-to-create-a-federated-client.md)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d539e-128">For more information about token caching, see [How to: Create a Federated Client](how-to-create-a-federated-client.md).</span></span>  
  
 <span data-ttu-id="d539e-129">短い有効期間を指定すると、発行されるトークンまたはセキュリティコンテキストトークンに対して30秒以下の順序で、発行されたトークンを要求するとき、またはセキュリティコンテキストトークンをネゴシエートまたは更新するときに、WCF クライアントによってネゴシエーションのタイムアウトまたは他の例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d539e-129">Specifying short lifetimes, on the order of 30 seconds or less for issued tokens or security context tokens, may result in negotiation time-outs or other exceptions being thrown by WCF clients when requesting issued tokens or when negotiating or renewing security context tokens.</span></span>  
  
## <a name="issued-tokens-and-inclusionmode"></a><span data-ttu-id="d539e-130">発行済みトークンと InclusionMode</span><span class="sxs-lookup"><span data-stu-id="d539e-130">Issued Tokens and InclusionMode</span></span>  
 <span data-ttu-id="d539e-131">クライアントからフェデレーション エンドポイントに送信されたメッセージで発行済みトークンがシリアル化されるかどうかは、<xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> クラスの <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters> プロパティを設定することによって制御します。</span><span class="sxs-lookup"><span data-stu-id="d539e-131">Whether an issued token is serialized in a message sent from a client to a federated endpoint or not is controlled by setting the <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters.InclusionMode%2A> property of the <xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters> class.</span></span> <span data-ttu-id="d539e-132">このプロパティは <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode> 列挙値のいずれかに設定できますが、これはほとんどのフェデレーション シナリオでは役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="d539e-132">This property can be set to one of the <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode> enumeration values, but it is not useful in most federated scenarios.</span></span> <span data-ttu-id="d539e-133">`SecurityTokenInclusionMode.Never` 値および `SecurityTokenInclusionMode.AlwaysToInitiator` 値を設定すると、クライアントによって、セキュリティ トークンサービスによって発行されたトークンへの参照が証明書利用者に送信されます。</span><span class="sxs-lookup"><span data-stu-id="d539e-133">The `SecurityTokenInclusionMode.Never` and `SecurityTokenInclusionMode.AlwaysToInitiator` values cause the client to send a reference to the token issued by the security token service to the relying party.</span></span> <span data-ttu-id="d539e-134">証明書利用者がこの発行済みトークンのコピーを持っていない限り、トークン参照が解決されないため、認証は失敗します。</span><span class="sxs-lookup"><span data-stu-id="d539e-134">Unless the relying party possesses a copy of the issued token, authentication will fail because the token reference is not resolvable.</span></span> <span data-ttu-id="d539e-135">WCF `SecurityTokenInclusionMode.Once` はと同等として扱い `SecurityTokenInclusionMode.AlwaysToRecipient` ます。</span><span class="sxs-lookup"><span data-stu-id="d539e-135">WCF treats `SecurityTokenInclusionMode.Once` as equivalent to `SecurityTokenInclusionMode.AlwaysToRecipient`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d539e-136">関連項目</span><span class="sxs-lookup"><span data-stu-id="d539e-136">See also</span></span>

- <xref:System.ServiceModel.Security.Tokens.SecurityTokenInclusionMode>
- [<span data-ttu-id="d539e-137">方法: フェデレーション クライアントを作成する</span><span class="sxs-lookup"><span data-stu-id="d539e-137">How to: Create a Federated Client</span></span>](how-to-create-a-federated-client.md)
- [<span data-ttu-id="d539e-138">方法: フェデレーション サービスで資格情報を設定する</span><span class="sxs-lookup"><span data-stu-id="d539e-138">How to: Configure Credentials on a Federation Service</span></span>](how-to-configure-credentials-on-a-federation-service.md)
- [<span data-ttu-id="d539e-139">方法: WSFederationHttpBinding を作成する</span><span class="sxs-lookup"><span data-stu-id="d539e-139">How to: Create a WSFederationHttpBinding</span></span>](how-to-create-a-wsfederationhttpbinding.md)
