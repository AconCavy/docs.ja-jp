---
title: HTTP トランスポート セキュリティ
ms.date: 03/30/2017
ms.assetid: d3439262-c58e-4d30-9f2b-a160170582bb
ms.openlocfilehash: 4bd3fbfd39538eee4344ef0a8ca4fe61b372ab70
ms.sourcegitcommit: 09b4090b78f52fd09b0e430cd4b26576f1fdf96e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/17/2020
ms.locfileid: "76212131"
---
# <a name="http-transport-security"></a><span data-ttu-id="47eab-102">HTTP トランスポート セキュリティ</span><span class="sxs-lookup"><span data-stu-id="47eab-102">HTTP Transport Security</span></span>
<span data-ttu-id="47eab-103">トランスポートとして HTTP を使用すると、SSL (Secure Sockets Layer) によりセキュリティが提供されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-103">When using HTTP as the transport, security is provided by a Secure Sockets Layer (SSL) implementation.</span></span> <span data-ttu-id="47eab-104">SSL はクライアントに対してサービスの認証を行い、機密性 (暗号化) をチャネルに提供する技術としてインターネットで広く使用されています。</span><span class="sxs-lookup"><span data-stu-id="47eab-104">SSL is widely used on the Internet to authenticate a service to a client, and then to provide confidentiality (encryption) to the channel.</span></span> <span data-ttu-id="47eab-105">このトピックでは、SSL のしくみと Windows Communication Foundation (WCF) での実装方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="47eab-105">This topic explains how SSL works and how it is implemented in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="basic-ssl"></a><span data-ttu-id="47eab-106">基本 SSL</span><span class="sxs-lookup"><span data-stu-id="47eab-106">Basic SSL</span></span>  
 <span data-ttu-id="47eab-107">SSL の機能について一般的なシナリオを用いて説明します。ここでは、銀行の Web サイトを考えます。</span><span class="sxs-lookup"><span data-stu-id="47eab-107">How SSL works is best explained through a typical scenario, in this case, a bank's Web site.</span></span> <span data-ttu-id="47eab-108">ユーザーはユーザー名とパスワードを使用してサイトにログオンできます。</span><span class="sxs-lookup"><span data-stu-id="47eab-108">The site allows a customer to log on with a user name and password.</span></span> <span data-ttu-id="47eab-109">認証された後、ユーザーは、残高照会、支払い、口座間振り替えなどの各種取引を実行できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-109">After being authenticated, the user can perform transactions, such as view account balances, pay bills, and move money from one account to another.</span></span>  
  
 <span data-ttu-id="47eab-110">ユーザーがサイトに初めてアクセスすると、SSL メカニズムによって、ユーザーのクライアント (この場合は Internet Explorer) を使用して、*ハンドシェイク*と呼ばれる一連のネゴシエーションが開始されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-110">When a user first visits the site, the SSL mechanism begins a series of negotiations, called a *handshake*, with the user's client (in this case, Internet Explorer).</span></span> <span data-ttu-id="47eab-111">SSL は最初にユーザーに対して銀行サイトの認証を行います。</span><span class="sxs-lookup"><span data-stu-id="47eab-111">SSL first authenticates the bank site to the customer.</span></span> <span data-ttu-id="47eab-112">ユーザーを誘導してユーザー名とパスワードを入力させる "なりすまし" サイトではなく、通信先が実際のサイトであることをユーザーが最初に認識する必要があるため、この手順は不可欠です。</span><span class="sxs-lookup"><span data-stu-id="47eab-112">This is an essential step because customers must first know that they are communicating with the actual site, and not a spoof that tries to lure them into typing in their user name and password.</span></span> <span data-ttu-id="47eab-113">SSL は、VeriSign などの信頼された機関から提供される SSL 証明書を使用してこの認証を行います。</span><span class="sxs-lookup"><span data-stu-id="47eab-113">SSL does this authentication by using an SSL certificate provided by a trusted authority, such as VeriSign.</span></span> <span data-ttu-id="47eab-114">論理上は、VeriSign が銀行サイトの識別情報を保証することになります。</span><span class="sxs-lookup"><span data-stu-id="47eab-114">The logic goes like this: VeriSign vouches for the identity of the bank site.</span></span> <span data-ttu-id="47eab-115">Internet Explorer では VeriSign が信頼済みであるため、このサイトも信頼されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-115">Because Internet Explorer trusts VeriSign, the site is trusted.</span></span> <span data-ttu-id="47eab-116">VeriSign に確認する場合は、VeriSign のロゴをクリックします。</span><span class="sxs-lookup"><span data-stu-id="47eab-116">If you want to check with VeriSign, you can do so as well by clicking on the VeriSign logo.</span></span> <span data-ttu-id="47eab-117">有効期限や発行先 (銀行サイト) などの信頼性に関する報告が表示されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-117">That presents a statement of authenticity with its expiration date and who it is issued to (the bank site).</span></span>  
  
 <span data-ttu-id="47eab-118">セキュリティで保護されたセッションを開始するには、クライアントは「もしもし」と同等の情報を暗号アルゴリズムのリストと共にサーバーに送信します。サーバーはこの暗号アルゴリズムのリストを使用して署名、ハッシュの生成、暗号化と複号化を行えます。</span><span class="sxs-lookup"><span data-stu-id="47eab-118">To initiate a secure session, the client sends the equivalent of a "hello" to the server along with a list of cryptographic algorithms it can use to sign, generate hashes, and encrypt and decrypt with.</span></span> <span data-ttu-id="47eab-119">これに対して、サイトからは受信確認、およびサイトが選択したアルゴリズム スイートの 1 つが返送されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-119">In response, the site sends back an acknowledgment and its choice of one of the algorithms suites.</span></span> <span data-ttu-id="47eab-120">この初期ハンドシェイク中に、両方のパーティは nonce を送受信します。</span><span class="sxs-lookup"><span data-stu-id="47eab-120">During this initial handshake, both parties send and receive nonces.</span></span> <span data-ttu-id="47eab-121">*Nonce*は、ランダムに生成されたデータであり、サイトの公開キーと組み合わせてハッシュを作成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-121">A *nonce* is a randomly generated piece of data that is used, in combination with the site's public key, to create a hash.</span></span> <span data-ttu-id="47eab-122">*ハッシュ*とは、SHA1 などの標準アルゴリズムを使用して2つの数値から派生した新しい数値です。</span><span class="sxs-lookup"><span data-stu-id="47eab-122">A *hash* is a new number that is derived from the two numbers using a standard algorithm, such as SHA1.</span></span> <span data-ttu-id="47eab-123">(クライアントとサイトも、使用するハッシュアルゴリズムに同意するためにメッセージを交換します)。ハッシュは一意であり、メッセージを暗号化および復号化するために、クライアントとサイト間のセッションにのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-123">(The client and the site also exchange messages to agree which hash algorithm to use.) The hash is unique and is used only for the session between the client and the site to encrypt and decrypt messages.</span></span> <span data-ttu-id="47eab-124">クライアントとサービスの両方に、元の nonce と証明書の公開キーがあるので、両者で同じハッシュを生成できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-124">Both client and service have the original nonce and the certificate's public key, so both sides can generate the same hash.</span></span> <span data-ttu-id="47eab-125">したがって、クライアントがサービスから送信されたハッシュを検証するには、(a) 同意したアルゴリズムを使用してデータからハッシュを計算し、(b) サービスから送信されたハッシュと比較します。両方が一致する場合は、クライアントはハッシュが改ざんされていないことを確認できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-125">Therefore, the client validates the hash sent by the service by (a) using the agreed upon algorithm to calculate the hash from the data, and (b) comparing it to the hash sent by the service; if the two match, then the client has assurance that the hash has not been tampered with.</span></span> <span data-ttu-id="47eab-126">次にクライアントはこのハッシュを、さらに別の新しいハッシュが含まれるメッセージを暗号化するキーとして使用します。</span><span class="sxs-lookup"><span data-stu-id="47eab-126">The client can then use this hash as a key to encrypt a message that contains yet another new hash.</span></span> <span data-ttu-id="47eab-127">サービスはハッシュを使用してこのメッセージを複号化でき、最後から 2 番目のハッシュを復帰できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-127">The service can decrypt the message using the hash, and recover this second-to-final hash.</span></span> <span data-ttu-id="47eab-128">ここで、累積された情報 (nonce、公開キーなどのデータ) が両者で認識されるので、最後のハッシュ (マスター キー) を作成できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-128">The accumulated information (nonces, public key, and other data) is now known to both sides, and a final hash (or master key) can be created.</span></span> <span data-ttu-id="47eab-129">最後のキーは、最後から 2 番目のハッシュで暗号化され送信されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-129">This final key is sent encrypted using the next-to-last hash.</span></span> <span data-ttu-id="47eab-130">その後、マスターキーを使用して、セッションの残りの部分のメッセージを暗号化および復号化します。</span><span class="sxs-lookup"><span data-stu-id="47eab-130">The master key is then used to encrypt and decrypt messages for the rest of the session.</span></span> <span data-ttu-id="47eab-131">クライアントとサービスの両方で同じキーが使用されるため、これは*セッションキー*とも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="47eab-131">Because both client and service use the same key, this is also called a *session key*.</span></span>  
  
 <span data-ttu-id="47eab-132">セッション キーは、対称キーまたは "共有シークレット" としての特性も持っています。</span><span class="sxs-lookup"><span data-stu-id="47eab-132">The session key is also characterized as a symmetric key, or a "shared secret."</span></span> <span data-ttu-id="47eab-133">対称キーを使用すると、トランザクションの両側で必要となる計算が削減されるため、このキーを持つことは重要です。</span><span class="sxs-lookup"><span data-stu-id="47eab-133">Having a symmetric key is important because it reduces the computation required by both sides of the transaction.</span></span> <span data-ttu-id="47eab-134">すべてのメッセージが新しい nonce とハッシュの交換を要求した場合、パフォーマンスは低下します。</span><span class="sxs-lookup"><span data-stu-id="47eab-134">If every message demanded a new exchange of nonces and hashes, performance would deteriorate.</span></span> <span data-ttu-id="47eab-135">したがって、対称キーを使用して高い安全性と効率を確保しながらメッセージを両側に自由にフローさせることが、SSL の最終的な目標になります。</span><span class="sxs-lookup"><span data-stu-id="47eab-135">Therefore, the ultimate goal of SSL is to use a symmetric key that allows messages to flow freely between the two sides with a greater degree of security and efficiency.</span></span>  
  
 <span data-ttu-id="47eab-136">プロトコルはサイトによってさまざまなので、以上の説明では動作を簡略化しています。</span><span class="sxs-lookup"><span data-stu-id="47eab-136">The previous description is a simplified version of what happens, because the protocol may vary from site to site.</span></span> <span data-ttu-id="47eab-137">また、データ交換処理をさらに複雑にするため (保護を強化するため) に、ハンドシェイク中にクライアントとサイトの両方でアルゴリズムを組み合わせた nonce を別々に生成することもできます。</span><span class="sxs-lookup"><span data-stu-id="47eab-137">It is also possible that both the client and the site both generate nonces that are algorithmically combined during the handshake to add more complexity, and therefore protection, to the process of exchanging data.</span></span>  
  
### <a name="certificates-and-public-key-infrastructure"></a><span data-ttu-id="47eab-138">証明書および公開キー基盤</span><span class="sxs-lookup"><span data-stu-id="47eab-138">Certificates and Public Key Infrastructure</span></span>  
 <span data-ttu-id="47eab-139">ハンドシェイク中に、サービスは SSL 証明書もクライアントに送信します。</span><span class="sxs-lookup"><span data-stu-id="47eab-139">During the handshake, the service also sends its SSL certificate to the client.</span></span> <span data-ttu-id="47eab-140">証明書には、有効期限、発行元証明機関、サイトの URI (Uniform Resource Identifier) などの情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="47eab-140">The certificate contains information, such as its expiration date, issuing authority, and the site's Uniform Resource Identifier (URI).</span></span> <span data-ttu-id="47eab-141">クライアントは、この URI と最初にアクセスした URI を比較して一致するかどうかを確認し、また、日付と発行元証明機関をチェックします。</span><span class="sxs-lookup"><span data-stu-id="47eab-141">The client compares the URI to the URI it had originally contacted to ensure a match, and also checks the date and issuing authority.</span></span>  
  
 <span data-ttu-id="47eab-142">各証明書には、秘密キーと公開キーの2つのキーがあります。2つのキーは、*交換キーのペア*と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="47eab-142">Every certificate has two keys, a private key and a public key, and the two are known as an *exchange key pair*.</span></span> <span data-ttu-id="47eab-143">簡単に説明すると、秘密キーは証明書の所有者のみが認識し、公開キーは証明書から読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="47eab-143">In brief, the private key is known only to the owner of the certificate while the public key is readable from the certificate.</span></span> <span data-ttu-id="47eab-144">どちらのキーもダイジェスト、ハッシュ、その他のキーの暗号化と複号化に使用できますが、逆の操作としての使用に限られます。</span><span class="sxs-lookup"><span data-stu-id="47eab-144">Either key can be used to encrypt or decrypt a digest, hash, or other key, but only as contrary operations.</span></span> <span data-ttu-id="47eab-145">たとえば、クライアントで公開キーを使用して暗号化した場合、サイトのみが秘密キーを使用してメッセージを複号化できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-145">For example, if the client encrypts with the public key, only the site can decrypt the message using the private key.</span></span> <span data-ttu-id="47eab-146">同様に、サイトで秘密キーを使用して暗号化した場合、クライアントは公開キーを使用して複号化できます。</span><span class="sxs-lookup"><span data-stu-id="47eab-146">Similarly, if the site encrypts with the private key, the client can decrypt with the public key.</span></span> <span data-ttu-id="47eab-147">秘密キーを使用して暗号化されたメッセージのみが公開キーを使用して復号化できるため、クライアントには、秘密キーの所有者のみとメッセージ交換することが保証されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-147">This provides assurance to the client that the messages are being exchanged only with the possessor of the private key because only messages encrypted with the private key can be decrypted with the public key.</span></span> <span data-ttu-id="47eab-148">サイトには、公開キーを使用して暗号化を行っているクライアントとメッセージを交換していることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-148">The site is assured that it is exchanging messages with a client that has encrypted using the public key.</span></span> <span data-ttu-id="47eab-149">この交換は初期ハンドシェイクの場合のみセキュリティで保護されます。このため、実際の対称キーを作成する多くの試みが行われています。</span><span class="sxs-lookup"><span data-stu-id="47eab-149">This exchange is secure only for an initial handshake, however, which is why much more is done to create the actual symmetric key.</span></span> <span data-ttu-id="47eab-150">いずれにしても、すべての通信は有効な SSL 証明書を保有するサービスに依存します。</span><span class="sxs-lookup"><span data-stu-id="47eab-150">Nevertheless, all communications depend on the service having a valid SSL certificate.</span></span>  
  
## <a name="implementing-ssl-with-wcf"></a><span data-ttu-id="47eab-151">WCF を使用する SSL の実装</span><span class="sxs-lookup"><span data-stu-id="47eab-151">Implementing SSL with WCF</span></span>  
 <span data-ttu-id="47eab-152">HTTP トランスポートセキュリティ (または SSL) は、WCF の外部に提供されます。</span><span class="sxs-lookup"><span data-stu-id="47eab-152">HTTP transport security (or SSL) is provided externally to WCF.</span></span> <span data-ttu-id="47eab-153">SSL は、次のいずれかの方法で実装できますが、その方法は、アプリケーションがどのようにホストされるかによって決まります。</span><span class="sxs-lookup"><span data-stu-id="47eab-153">You can implement SSL in one of two ways; the deciding factor is how your application is hosted:</span></span>  
  
- <span data-ttu-id="47eab-154">WCF ホストとしてインターネットインフォメーションサービス (IIS) を使用している場合は、IIS インフラストラクチャを使用して SSL サービスを設定します。</span><span class="sxs-lookup"><span data-stu-id="47eab-154">If you are using Internet Information Services (IIS) as your WCF host, use the IIS infrastructure to set up an SSL service.</span></span>  
  
- <span data-ttu-id="47eab-155">自己ホスト型 WCF アプリケーションを作成する場合は、Httpcfg.exe ツールを使用して、SSL 証明書をアドレスにバインドできます。</span><span class="sxs-lookup"><span data-stu-id="47eab-155">If you are creating a self-hosted WCF application, you can bind an SSL certificate to the address using the HttpCfg.exe tool.</span></span>  
  
### <a name="using-iis-for-transport-security"></a><span data-ttu-id="47eab-156">トランスポート セキュリティのための IIS の使用</span><span class="sxs-lookup"><span data-stu-id="47eab-156">Using IIS for Transport Security</span></span>  
  
#### <a name="iis-70"></a><span data-ttu-id="47eab-157">IIS 7.0</span><span class="sxs-lookup"><span data-stu-id="47eab-157">IIS 7.0</span></span>  
 <span data-ttu-id="47eab-158">IIS 7.0 をセキュリティで保護されたホスト (SSL を使用) として設定するには、「 [iis 7.0 での Secure Sockets Layer の構成](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="47eab-158">To set up IIS 7.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer in IIS 7.0](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc771438(v=ws.10)).</span></span>  
  
<span data-ttu-id="47eab-159">IIS 7.0 で使用する証明書を構成する方法については、「 [iis 7.0 でのサーバー証明書の構成](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="47eab-159">To configure certificates for use with IIS 7.0, see [Configuring Server Certificates in IIS 7.0](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732230(v=ws.10)).</span></span>  
  
#### <a name="iis-60"></a><span data-ttu-id="47eab-160">IIS 6.0</span><span class="sxs-lookup"><span data-stu-id="47eab-160">IIS 6.0</span></span>  
 <span data-ttu-id="47eab-161">セキュリティで保護されたホスト (SSL を使用) として IIS 6.0 を設定するには、「 [Secure Sockets Layer の構成](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="47eab-161">To set up IIS 6.0 as a secure host (using SSL), see [Configuring Secure Sockets Layer](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc736992(v=ws.10)).</span></span>  
  
 <span data-ttu-id="47eab-162">IIS 6.0 で使用する証明書を構成する方法については、「 [Certificates_IIS_SP1_Ops](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="47eab-162">To configure certificates for use with IIS 6.0, see [Certificates_IIS_SP1_Ops](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc757474(v=ws.10)).</span></span>  
  
### <a name="using-httpcfg-for-ssl"></a><span data-ttu-id="47eab-163">SSL での HttpCfg の使用</span><span class="sxs-lookup"><span data-stu-id="47eab-163">Using HttpCfg for SSL</span></span>  

 <span data-ttu-id="47eab-164">自己ホスト型 WCF アプリケーションを作成する場合は、 [httpcfg.exe](/windows/win32/http/httpcfg-exe)ツールを使用します。</span><span class="sxs-lookup"><span data-stu-id="47eab-164">If you're creating a self-hosted WCF application, use the [HttpCfg.exe](/windows/win32/http/httpcfg-exe) tool.</span></span>
  
 <span data-ttu-id="47eab-165">Httpcfg.exe ツールを使用して x.509 証明書でポートを設定する方法の詳細については、「[方法: SSL 証明書を使用](../../../../docs/framework/wcf/feature-details/how-to-configure-a-port-with-an-ssl-certificate.md)してポートを構成する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="47eab-165">For more information about using the HttpCfg.exe tool to set up a port with an X.509 certificate, see [How to: Configure a Port with an SSL Certificate](../../../../docs/framework/wcf/feature-details/how-to-configure-a-port-with-an-ssl-certificate.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="47eab-166">関連項目</span><span class="sxs-lookup"><span data-stu-id="47eab-166">See also</span></span>

- [<span data-ttu-id="47eab-167">トランスポート セキュリティ</span><span class="sxs-lookup"><span data-stu-id="47eab-167">Transport Security</span></span>](../../../../docs/framework/wcf/feature-details/transport-security.md)
- [<span data-ttu-id="47eab-168">メッセージのセキュリティ</span><span class="sxs-lookup"><span data-stu-id="47eab-168">Message Security</span></span>](../../../../docs/framework/wcf/feature-details/message-security-in-wcf.md)
