---
title: ベスト プラクティス:データ コントラクトのバージョン管理
ms.date: 03/30/2017
helpviewer_keywords:
- data contracts
- service contracts
- best practices [WCF], data contract versioning
- Windows Communication Foundation, data contracts
ms.assetid: bf0ab338-4d36-4e12-8002-8ebfdeb346cb
ms.openlocfilehash: d6a1eef949e30a1a6d9a1c5971d33c788cc548b9
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/26/2020
ms.locfileid: "96277908"
---
# <a name="best-practices-data-contract-versioning"></a><span data-ttu-id="7ca86-102">ベスト プラクティス:データ コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="7ca86-102">Best Practices: Data Contract Versioning</span></span>

<span data-ttu-id="7ca86-103">このトピックでは、長期的に容易に拡張させることのできるデータ コントラクトを作成するためのベスト プラクティスをいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-103">This topic lists the best practices for creating data contracts that can evolve easily over time.</span></span> <span data-ttu-id="7ca86-104">データコントラクトの詳細については、「 [データコントラクトの使用](./feature-details/using-data-contracts.md)」のトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-104">For more information about data contracts, see the topics in [Using Data Contracts](./feature-details/using-data-contracts.md).</span></span>  
  
## <a name="note-on-schema-validation"></a><span data-ttu-id="7ca86-105">スキーマ検証に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="7ca86-105">Note on Schema Validation</span></span>  

 <span data-ttu-id="7ca86-106">データコントラクトのバージョン管理については、Windows Communication Foundation (WCF) によってエクスポートされるデータコントラクトスキーマにはバージョン管理サポートがないことに注意してください。既定では、要素は省略可能としてマークされています。</span><span class="sxs-lookup"><span data-stu-id="7ca86-106">In discussing data contract versioning, it is important to note that the data contract schema exported by Windows Communication Foundation (WCF) does not have any versioning support, other than the fact that elements are marked as optional by default.</span></span>  
  
 <span data-ttu-id="7ca86-107">したがって、新しいデータ メンバーを追加するなどの一般的なバージョン管理シナリオであっても、スキーマに関してはシームレスに実装することはできません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-107">This means that even the most common versioning scenario, such as adding a new data member, cannot be implemented in a way that is seamless with regard to a given schema.</span></span> <span data-ttu-id="7ca86-108">新しいバージョンのデータ コントラクト (この例ではデータ メンバーが追加されたもの) を、古いスキーマに基づいて検証することはできません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-108">The newer versions of a data contract (with a new data member, for example) do not validate using the old schema.</span></span>  
  
 <span data-ttu-id="7ca86-109">ただし、スキーマへの厳密な準拠が要求されない場合も数多くあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-109">However, there are many scenarios in which strict schema compliance is not required.</span></span> <span data-ttu-id="7ca86-110">ASP.NET を使用して作成された WCF および XML Web サービスを含む多くの Web サービスプラットフォームは、既定ではスキーマ検証を実行しないため、スキーマで記述されていない余分な要素を許容します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-110">Many Web services platforms, including WCF and XML Web services created using ASP.NET, do not perform schema validation by default and therefore tolerate extra elements that are not described by the schema.</span></span> <span data-ttu-id="7ca86-111">このようなプラットフォームであればバージョン管理は容易です。</span><span class="sxs-lookup"><span data-stu-id="7ca86-111">When working with such platforms, many versioning scenarios are easier to implement.</span></span>  
  
 <span data-ttu-id="7ca86-112">これらのことから、データ コントラクトのバージョン管理に関するガイドラインには、厳密なスキーマ検証が必要な場合とそうでない場合の 2 種類があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-112">Thus, there are two sets of data contract versioning guidelines: one set for scenarios where strict schema validity is important, and another set for scenarios when it is not.</span></span>  
  
## <a name="versioning-when-schema-validation-is-required"></a><span data-ttu-id="7ca86-113">スキーマ検証が必要な場合のバージョン管理</span><span class="sxs-lookup"><span data-stu-id="7ca86-113">Versioning When Schema Validation Is Required</span></span>  

 <span data-ttu-id="7ca86-114">新から旧、旧から新の両方向で厳密なスキーマ検証が必要な場合、データ コントラクトは変更不可であると考えなければなりません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-114">If strict schema validity is required in all directions (new-to-old and old-to-new), data contracts should be considered immutable.</span></span> <span data-ttu-id="7ca86-115">バージョン管理が必要であれば、別の名前または名前空間で新しいデータ コントラクトを作成したうえで、そのデータ型が使用されているサービス コントラクトにバージョンを付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-115">If versioning is required, a new data contract should be created, with a different name or namespace, and the service contract using the data type should be versioned accordingly.</span></span>  
  
 <span data-ttu-id="7ca86-116">たとえば、`PoProcessing` という発注書処理サービス コントラクトに対して、`PostPurchaseOrder` データ コントラクトに適合したパラメーターを受け取る `PurchaseOrder` という操作が定義されているとします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-116">For example, a purchase order processing service contract named `PoProcessing` with a `PostPurchaseOrder` operation takes a parameter that conforms to a `PurchaseOrder` data contract.</span></span> <span data-ttu-id="7ca86-117">`PurchaseOrder` コントラクトの内容を変更したい場合は、新しく `PurchaseOrder2` というデータ コントラクトを作成し、こちらに変更内容を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-117">If the `PurchaseOrder` contract has to change, you must create a new data contract, that is, `PurchaseOrder2`, which includes the changes.</span></span> <span data-ttu-id="7ca86-118">そのうえで、サービス コントラクト レベルでバージョン管理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-118">You must then handle the versioning at the service contract level.</span></span> <span data-ttu-id="7ca86-119">たとえば、`PostPurchaseOrder2` パラメーターを受け取る `PurchaseOrder2` 操作を別に作成するか、`PoProcessing2` サービス コントラクトを別途作成して `PostPurchaseOrder` 操作が `PurchaseOrder2` データ コントラクトを受け取るようにします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-119">For example, by creating a `PostPurchaseOrder2` operation that takes the `PurchaseOrder2` parameter, or by creating a `PoProcessing2` service contract where the `PostPurchaseOrder` operation takes a `PurchaseOrder2` data contract.</span></span>  
  
 <span data-ttu-id="7ca86-120">なお、他のデータ コントラクトから参照されるデータ コントラクトに変更を施すと、サービス モデル レイヤーも拡張されます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-120">Note that changes in data contracts that are referenced by other data contracts also extend to the service model layer.</span></span> <span data-ttu-id="7ca86-121">たとえば、先ほどの例で、`PurchaseOrder` データ コントラクトは変更の必要がないとします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-121">For example, in the previous scenario the `PurchaseOrder` data contract does not need to change.</span></span> <span data-ttu-id="7ca86-122">ただし、そのデータ メンバーである `Customer` データ コントラクトに、さらに `Address` データ コントラクトが含まれており、これを変更しなければならないとします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-122">However, it contains a data member of a `Customer` data contract, which in turn contained a data member of the `Address` data contract, which does need to be changed.</span></span> <span data-ttu-id="7ca86-123">この場合は、まず `Address2` というデータ コントラクトを別に作成して必要な変更を行います。次に `Customer2` というデータ コントラクトを作成し、`Address2` をそのデータ メンバーとして定義します。さらに、`PurchaseOrder2` というデータ コントラクトを作成して、`Customer2` をデータ メンバーとして定義します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-123">In that case, you would need to create an `Address2` data contract with the required changes, a `Customer2` data contract that contains the `Address2` data member, and a `PurchaseOrder2` data contract that contains a `Customer2` data member.</span></span> <span data-ttu-id="7ca86-124">先ほどの例と同様、サービス コントラクトに対してもバージョン管理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-124">As in the previous case, the service contract would have to be versioned as well.</span></span>  
  
 <span data-ttu-id="7ca86-125">ここまでの例では "2" を付けて名前を変えましたが、実際には、バージョン番号または日付を付加して、名前空間の方を変更するようお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-125">Although in these examples names are changed (by appending a "2"), the recommendation is to change namespaces instead of names by appending new namespaces with a version number or a date.</span></span> <span data-ttu-id="7ca86-126">たとえば、`http://schemas.contoso.com/2005/05/21/PurchaseOrder` というデータ コントラクトを `http://schemas.contoso.com/2005/10/14/PurchaseOrder` に変更します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-126">For example, the `http://schemas.contoso.com/2005/05/21/PurchaseOrder` data contract would change to the `http://schemas.contoso.com/2005/10/14/PurchaseOrder` data contract.</span></span>  
  
 <span data-ttu-id="7ca86-127">詳細については、「ベストプラクティス: [サービスのバージョン管理](service-versioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-127">For more information, see Best Practices: [Service Versioning](service-versioning.md).</span></span>  
  
 <span data-ttu-id="7ca86-128">アプリケーションから送信するメッセージは厳密にスキーマに適合させる必要があるが、外部から受信したメッセージがこれに適合しているとは限らない、という場合もあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-128">Occasionally, you must guarantee strict schema compliance for messages sent by your application, but cannot rely on the incoming messages to be strictly schema-compliant.</span></span> <span data-ttu-id="7ca86-129">この場合、受信したメッセージには、異質なデータが含まれているおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-129">In this case, there is a danger that an incoming message might contain extraneous data.</span></span> <span data-ttu-id="7ca86-130">余分な値は、WCF によって格納および返されるため、スキーマが無効なメッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-130">The extraneous values are stored and returned by WCF and thus results in schema-invalid messages being sent.</span></span> <span data-ttu-id="7ca86-131">これを回避するには、ラウンド トリップ機能を無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-131">To avoid this problem, the round-tripping feature should be turned off.</span></span> <span data-ttu-id="7ca86-132">これには、2 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-132">There are two ways to do this.</span></span>  
  
- <span data-ttu-id="7ca86-133">独自に定義した型に <xref:System.Runtime.Serialization.IExtensibleDataObject> インターフェイスを実装しない。</span><span class="sxs-lookup"><span data-stu-id="7ca86-133">Do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface on any of your types.</span></span>  
  
- <span data-ttu-id="7ca86-134">サービス コントラクトに <xref:System.ServiceModel.ServiceBehaviorAttribute> 属性を適用し、<xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> プロパティ値を `true` に設定する。</span><span class="sxs-lookup"><span data-stu-id="7ca86-134">Apply a <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute to your service contract with the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property set to `true`.</span></span>  
  
 <span data-ttu-id="7ca86-135">ラウンドトリップの詳細については、「 [上位互換性のあるデータコントラクト](./feature-details/forward-compatible-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-135">For more information about round-tripping, see [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md).</span></span>  
  
## <a name="versioning-when-schema-validation-is-not-required"></a><span data-ttu-id="7ca86-136">スキーマ検証が不要な場合のバージョン管理</span><span class="sxs-lookup"><span data-stu-id="7ca86-136">Versioning When Schema Validation Is Not Required</span></span>  

 <span data-ttu-id="7ca86-137">スキーマへの厳密な適合が求められるケースはそれほど多くありません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-137">Strict schema compliance is rarely required.</span></span> <span data-ttu-id="7ca86-138">多くのプラットフォームでは、スキーマに記述されていない余分な要素が許容されています。</span><span class="sxs-lookup"><span data-stu-id="7ca86-138">Many platforms tolerate extra elements not described by a schema.</span></span> <span data-ttu-id="7ca86-139">これが許容される限り、「 [データコントラクトのバージョン管理](./feature-details/data-contract-versioning.md) 」および「 [上位互換性のあるデータコントラクト](./feature-details/forward-compatible-data-contracts.md) 」で説明されている機能の完全なセットを使用できます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-139">As long as this is tolerated, the full set of features described in [Data Contract Versioning](./feature-details/data-contract-versioning.md) and [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md) can be used.</span></span> <span data-ttu-id="7ca86-140">その場合は、以下のガイドラインに従うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-140">The following guidelines are recommended.</span></span>  
  
 <span data-ttu-id="7ca86-141">旧バージョンの型が想定されている場所へ新バージョンの型を送信したり、新バージョンが想定されている場所へ旧バージョンを送信したりするには、いくつかのガイドラインに厳密に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-141">Some of the guidelines must be followed exactly in order to send new versions of a type where an older one is expected or send an old one where the new one is expected.</span></span> <span data-ttu-id="7ca86-142">それ以外の項目への準拠は、それほど厳密には要求されませんが、これらはスキーマの将来的なバージョン管理に影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-142">Other guidelines are not strictly required, but are listed here because they may be affected by the future of schema versioning.</span></span>  
  
1. <span data-ttu-id="7ca86-143">型の継承でデータ コントラクトをバージョン化してはいけません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-143">Do not attempt to version data contracts by type inheritance.</span></span> <span data-ttu-id="7ca86-144">新バージョンを作成する場合は、既存の型のデータ コントラクトを直接変更するか、新しく型を定義してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-144">To create later versions, either change the data contract on an existing type or create a new unrelated type.</span></span>  
  
2. <span data-ttu-id="7ca86-145">継承とデータ コントラクトを併用してもかまいませんが、バージョン管理の目的で継承を使用しないことなど、いくつかの規則に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-145">The use of inheritance together with data contracts is allowed, provided that inheritance is not used as a versioning mechanism and that certain rules are followed.</span></span> <span data-ttu-id="7ca86-146">ある型が基本型から派生している場合、その型は将来のバージョンで別の基本型から派生させてはいけません (データ コントラクトが同一である場合を除きます)。</span><span class="sxs-lookup"><span data-stu-id="7ca86-146">If a type derives from a certain base type, do not make it derive from a different base type in a future version (unless it has the same data contract).</span></span> <span data-ttu-id="7ca86-147">例外として、階層内で、基本型と派生したデータ コントラクト型との間に別の型を追加することは可能です。ただし追加する型に含まれるデータ メンバーの名前は、階層内の他の型のどのバージョンに含まれるメンバーとも、同じにならないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-147">There is one exception to this: you can insert a type into the hierarchy between a data contract type and its base type, but only if it does not contain data members with the same names as other members in any possible versions of the other types in the hierarchy.</span></span> <span data-ttu-id="7ca86-148">一般に、同じ継承階層の異なるレベルで同名のデータ メンバーを使用すると、バージョン管理の上で重大な問題が生じるおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-148">In general, using data members with the same names at different levels of the same inheritance hierarchy can lead to serious versioning problems and should be avoided.</span></span>  
  
3. <span data-ttu-id="7ca86-149">ラウンド トリップが有効になるように、データ コントラクトの最初のバージョンから、必ず <xref:System.Runtime.Serialization.IExtensibleDataObject> を実装します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-149">Starting with the first version of a data contract, always implement <xref:System.Runtime.Serialization.IExtensibleDataObject> to enable round-tripping.</span></span> <span data-ttu-id="7ca86-150">詳細については、「[上位互換性のあるデータ コントラクト](./feature-details/forward-compatible-data-contracts.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-150">For more information, see [Forward-Compatible Data Contracts](./feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="7ca86-151">このインターフェイスが実装されていない型の 1 つ以上のバージョンがリリース済みである場合は、この型の次のバージョンで実装します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-151">If you have released one or more versions of a type without implementing this interface, implement it in the next version of the type.</span></span>  
  
4. <span data-ttu-id="7ca86-152">新しいバージョンで、データ コントラクト名や名前空間を変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-152">In later versions, do not change the data contract name or namespace.</span></span> <span data-ttu-id="7ca86-153">データ コントラクトの基になる型の名前や名前空間を変更する場合、<xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> の <xref:System.Runtime.Serialization.DataContractAttribute> プロパティを使うなど、適切なメカニズムを使用して、データ コントラクト名と名前空間を残しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-153">If changing the name or namespace of the type underlying the data contract, be sure to preserve the data contract name and namespace by using the appropriate mechanisms, such as the <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> property of the <xref:System.Runtime.Serialization.DataContractAttribute>.</span></span> <span data-ttu-id="7ca86-154">名前付けの詳細については、「 [データコントラクト名](./feature-details/data-contract-names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-154">For more information about naming, see [Data Contract Names](./feature-details/data-contract-names.md).</span></span>  
  
5. <span data-ttu-id="7ca86-155">新しいバージョンで、データ メンバーの名前を変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-155">In later versions, do not change the names of any data members.</span></span> <span data-ttu-id="7ca86-156">データ メンバーの基になるフィールド、プロパティ、イベントの名前を変更する場合は、`Name` の <xref:System.Runtime.Serialization.DataMemberAttribute> プロパティを使用して、既存のデータ メンバー名を残しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-156">If changing the name of the field, property, or event underlying the data member, use the `Name` property of the <xref:System.Runtime.Serialization.DataMemberAttribute> to preserve the existing data member name.</span></span>  
  
6. <span data-ttu-id="7ca86-157">新しいバージョンで、データ メンバーの基になるフィールド、プロパティ、イベントの型を変更して、そのデータ メンバーに対応するデータ コントラクトが変わってしまうようなことは避けてください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-157">In later versions, do not change the type of any field, property, or event underlying a data member such that the resulting data contract for that data member changes.</span></span> <span data-ttu-id="7ca86-158">予測されるデータ コントラクトを判断するうえで、インターフェイス型は <xref:System.Object> に相当することを念頭に置きます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-158">Keep in mind that interface types are equivalent to <xref:System.Object> for the purposes of determining the expected data contract.</span></span>  
  
7. <span data-ttu-id="7ca86-159">新しいバージョンで、<xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> 属性の <xref:System.Runtime.Serialization.DataMemberAttribute> プロパティを調整して既存のデータ メンバーの順序を変えることは避けてください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-159">In later versions, do not change the order of the existing data members by adjusting the <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute.</span></span>  
  
8. <span data-ttu-id="7ca86-160">新しいバージョンで、新しいデータ メンバーを追加することは可能ですが、</span><span class="sxs-lookup"><span data-stu-id="7ca86-160">In later versions, new data members can be added.</span></span> <span data-ttu-id="7ca86-161">以下の規則に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-161">They should always follow these rules:</span></span>  
  
    1. <span data-ttu-id="7ca86-162"><xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> プロパティ値は、既定値である `false` のまま変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-162">The <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property should always be left at its default value of `false`.</span></span>  
  
    2. <span data-ttu-id="7ca86-163">メンバーの既定値として `null` または 0 を許容できない場合は、<xref:System.Runtime.Serialization.OnDeserializingAttribute> を使用してコールバック メソッドを指定する必要があります。該当するメンバーが受信ストリーム内に含まれていない場合は、このコールバック メソッドで妥当な既定値を設定します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-163">If a default value of `null` or zero for the member is unacceptable, a callback method should be provided using the <xref:System.Runtime.Serialization.OnDeserializingAttribute> to provide a reasonable default in case the member is not present in the incoming stream.</span></span> <span data-ttu-id="7ca86-164">コールバックの詳細については、「 [バージョントレラントなシリアル化コールバック](./feature-details/version-tolerant-serialization-callbacks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-164">For more information about the callback, see [Version-Tolerant Serialization Callbacks](./feature-details/version-tolerant-serialization-callbacks.md).</span></span>  
  
    3. <span data-ttu-id="7ca86-165"><xref:System.Runtime.Serialization.DataMemberAttribute.Order?displayProperty=nameWithType>新しく追加されたすべてのデータメンバーが既存のデータメンバーの後に表示されるようにするには、プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-165">The <xref:System.Runtime.Serialization.DataMemberAttribute.Order?displayProperty=nameWithType> property should be used to make sure that all of the newly added data members appear after the existing data members.</span></span> <span data-ttu-id="7ca86-166">これを実現するために、最初のバージョンのデータ コントラクトでは、どのデータ メンバーにも `Order` プロパティを設定しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-166">The recommended way of doing this is as follows: None of the data members in the first version of the data contract should have their `Order` property set.</span></span> <span data-ttu-id="7ca86-167">バージョン 2 のデータ コントラクトで追加されたすべてのデータ メンバーについては、`Order` プロパティを 2 に設定します。</span><span class="sxs-lookup"><span data-stu-id="7ca86-167">All of the data members added in version 2 of the data contract should have their `Order` property set to 2.</span></span> <span data-ttu-id="7ca86-168">バージョン 3 のデータ コントラクトで追加されたすべてのデータ メンバーについては、`Order` プロパティを 3 に設定します。以降のバージョンも同様にしていきます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-168">All of the data members added in version 3 of the data contract should have their `Order` set to 3, and so on.</span></span> <span data-ttu-id="7ca86-169">複数のデータ メンバーに同じ `Order` 番号を設定してかまいません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-169">It is permissible to have more than one data member set to the same `Order` number.</span></span>  
  
9. <span data-ttu-id="7ca86-170">新しいバージョンで、データ メンバーを削除しないでください。旧バージョンで、<xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> プロパティ値が `false` (既定値) であった場合も同様です。</span><span class="sxs-lookup"><span data-stu-id="7ca86-170">Do not remove data members in later versions, even if the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property was left at its default property of `false` in prior versions.</span></span>  
  
10. <span data-ttu-id="7ca86-171">既存のデータ メンバーの `IsRequired` プロパティ値をバージョンごとに変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-171">Do not change the `IsRequired` property on any existing data members from version to version.</span></span>  
  
11. <span data-ttu-id="7ca86-172">必須データ メンバー (`IsRequired` の値が `true`) の場合、`EmitDefaultValue` プロパティ値をバージョンごとに変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-172">For required data members (where `IsRequired` is `true`), do not change the `EmitDefaultValue` property from version to version.</span></span>  
  
12. <span data-ttu-id="7ca86-173">バージョン階層を分岐させないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-173">Do not attempt to create branched versioning hierarchies.</span></span> <span data-ttu-id="7ca86-174">つまり、あるバージョンから別のバージョンへのパスは、このガイドラインで認められている変更のみを使用して、1 方向に 1 つのみになるようにします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-174">That is, there should always be a path in at least one direction from any version to any other version using only the changes permitted by these guidelines.</span></span>  
  
     <span data-ttu-id="7ca86-175">たとえば、Person データ コントラクトのバージョン 1 に、Name というデータ メンバーだけが定義されているとします。これに対し、Age というメンバーのみを追加したバージョン 2a と、Address というメンバーのみを追加したバージョン 2b を作成してはいけません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-175">For example, if version 1 of a Person data contract contains only the Name data member, you should not create version 2a of the contract adding only the Age member and version 2b adding only the Address member.</span></span> <span data-ttu-id="7ca86-176">2a から 2b に移行しようとすると、Age を削除して Address を追加することになります。この逆方向に移行する場合は、Address を削除して Age を追加しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-176">Going from 2a to 2b would involve removing Age and adding Address; going in the other direction would entail removing Address and adding Age.</span></span> <span data-ttu-id="7ca86-177">このガイドラインでは、メンバーの削除が禁止されています。</span><span class="sxs-lookup"><span data-stu-id="7ca86-177">Removing members is not permitted by these guidelines.</span></span>  
  
13. <span data-ttu-id="7ca86-178">一般に、アプリケーションの新しいバージョンで、既存のデータ コントラクト型のサブタイプを新たに作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-178">You should generally not create new subtypes of existing data contract types in a new version of your application.</span></span> <span data-ttu-id="7ca86-179">同様に、Object 型またはインターフェイス型として宣言されたデータ メンバーの代わりに、新しいデータ コントラクトを作成して使うことはできません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-179">Likewise, you should not create new data contracts that are used in place of data members declared as Object or as interface types.</span></span> <span data-ttu-id="7ca86-180">新規にクラスを定義できるのは、旧アプリケーションのすべてのインスタンスについて、既知の型リストにその新しい型を追加できることがわかっている場合に限ります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-180">Creating these new classes is allowed only when you know that you can add the new types to the known types list of all instances of your old application.</span></span> <span data-ttu-id="7ca86-181">たとえば、アプリケーションのバージョン 1 に LibraryItem というデータ コントラクト型があり、そのサブタイプとして Book および Newspaper が定義されているとします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-181">For example, in version 1 of your application, you may have the LibraryItem data contract type with the Book and Newspaper data contract subtypes.</span></span> <span data-ttu-id="7ca86-182">LibraryItem には、Book と Newspaper を含む既知の型のリストがあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-182">LibraryItem would then have a known types list that contains Book and Newspaper.</span></span> <span data-ttu-id="7ca86-183">この状況で、LibraryItem のサブタイプである Magazine をバージョン 2 に追加するとします。</span><span class="sxs-lookup"><span data-stu-id="7ca86-183">Suppose you now add a Magazine type in version 2 which is a subtype of LibraryItem.</span></span> <span data-ttu-id="7ca86-184">バージョン 2 の Magazine のインスタンスをバージョン 1 に送信した場合、既知の型のリストに Magazine データ コントラクトが見つからないので、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-184">If you send a Magazine instance from version 2 to version 1, the Magazine data contract is not found in the list of known types and an exception is thrown.</span></span>  
  
14. <span data-ttu-id="7ca86-185">バージョン間で列挙型メンバーを追加または削除することはできません。</span><span class="sxs-lookup"><span data-stu-id="7ca86-185">You should not add or remove enumeration members between versions.</span></span> <span data-ttu-id="7ca86-186">また、列挙型メンバーの名前を変更することもできません。ただし `EnumMemberAttribute` 属性の Name プロパティを使用して、データ コントラクト モデル内の名前を同じに保つ場合は例外です。</span><span class="sxs-lookup"><span data-stu-id="7ca86-186">You should also not rename enumeration members, unless you use the Name property on the `EnumMemberAttribute` attribute to keep their names in the data contract model the same.</span></span>  
  
15. <span data-ttu-id="7ca86-187">コレクションは、「 [データコントラクトのコレクション型](./feature-details/collection-types-in-data-contracts.md)」で説明されているように、データコントラクトモデルで交換できます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-187">Collections are interchangeable in the data contract model as described in [Collection Types in Data Contracts](./feature-details/collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="7ca86-188">これにより、高い柔軟性を実現できます。</span><span class="sxs-lookup"><span data-stu-id="7ca86-188">This allows for a great degree of flexibility.</span></span> <span data-ttu-id="7ca86-189">ただし、バージョン間で交換できないような形でコレクション型を不用意に変更しないように注意してください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-189">However, make sure that you do not inadvertently change a collection type in a non-interchangeable way from version to version.</span></span> <span data-ttu-id="7ca86-190">たとえば、カスタマイズされていない (`CollectionDataContractAttribute` 属性がない) コレクションをカスタマイズされたコレクションに変更したり、カスタマイズされたコレクションをカスタマイズされていないコレクションに変更したりしないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-190">For example, do not change from a non-customized collection (that is, without the `CollectionDataContractAttribute` attribute) to a customized one or a customized collection to a non-customized one.</span></span> <span data-ttu-id="7ca86-191">また、`CollectionDataContractAttribute` のプロパティをバージョンごとに変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-191">Also, do not change the properties on the `CollectionDataContractAttribute` from version to version.</span></span> <span data-ttu-id="7ca86-192">許可されている変更は、Name プロパティまたは Namespace プロパティの追加だけです。この変更は、基になるコレクション型の名前または名前空間が変更されたとき、データ コントラクト名および名前空間を旧バージョンと同じにしておきたい場合に行います。</span><span class="sxs-lookup"><span data-stu-id="7ca86-192">The only allowed change is adding a Name or Namespace property if the underlying collection type's name or namespace has changed and you need to make its data contract name and namespace the same as in a previous version.</span></span>  
  
 <span data-ttu-id="7ca86-193">以上の中には、状況によっては従わなくてもよいガイドラインもあります。</span><span class="sxs-lookup"><span data-stu-id="7ca86-193">Some of the guidelines listed here can be safely ignored when special circumstances apply.</span></span> <span data-ttu-id="7ca86-194">その判断は、シリアル化、逆シリアル化、およびスキーマのメカニズムを完全に理解したうえで行ってください。</span><span class="sxs-lookup"><span data-stu-id="7ca86-194">Make sure you fully understand the serialization, deserialization, and schema mechanisms involved before deviating from the guidelines.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7ca86-195">関連項目</span><span class="sxs-lookup"><span data-stu-id="7ca86-195">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.ServiceModel.ServiceBehaviorAttribute>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.OnDeserializingAttribute>
- [<span data-ttu-id="7ca86-196">データ コントラクトの使用</span><span class="sxs-lookup"><span data-stu-id="7ca86-196">Using Data Contracts</span></span>](./feature-details/using-data-contracts.md)
- [<span data-ttu-id="7ca86-197">データ コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="7ca86-197">Data Contract Versioning</span></span>](./feature-details/data-contract-versioning.md)
- [<span data-ttu-id="7ca86-198">データ コントラクト名</span><span class="sxs-lookup"><span data-stu-id="7ca86-198">Data Contract Names</span></span>](./feature-details/data-contract-names.md)
- [<span data-ttu-id="7ca86-199">上位互換性のあるデータ コントラクト</span><span class="sxs-lookup"><span data-stu-id="7ca86-199">Forward-Compatible Data Contracts</span></span>](./feature-details/forward-compatible-data-contracts.md)
- [<span data-ttu-id="7ca86-200">バージョン トレラントなシリアル化コールバック</span><span class="sxs-lookup"><span data-stu-id="7ca86-200">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
