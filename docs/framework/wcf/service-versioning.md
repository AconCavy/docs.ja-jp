---
title: サービスのバージョン管理
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: ea5e80e33d1b29e01e6d1867c50bb3bb973b01c3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79183122"
---
# <a name="service-versioning"></a><span data-ttu-id="facd6-102">サービスのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-102">Service Versioning</span></span>
<span data-ttu-id="facd6-103">ビジネス ニーズの変化、情報テクノロジの要件、その他の問題への対処などのさまざまな理由により、サービスの初期導入後と、場合によっては有効期間中に数回、サービス (およびサービスが公開するエンドポイント) を変更することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="facd6-104">変更が発生するたびに、新しいバージョンのサービスが導入されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="facd6-105">ここでは、WCF (WCF) でバージョン管理を検討する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="facd6-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="facd6-106">サービス変更の 4 つのカテゴリ</span><span class="sxs-lookup"><span data-stu-id="facd6-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="facd6-107">必要となるサービスの変更は、次の 4 つのカテゴリに分類できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="facd6-108">コントラクトの変更 : 操作を追加する場合や、メッセージ内のデータ要素を追加または変更する場合など。</span><span class="sxs-lookup"><span data-stu-id="facd6-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="facd6-109">アドレスの変更 : エンドポイントが新しいアドレスを持つ別の場所にサービスを移動する場合など。</span><span class="sxs-lookup"><span data-stu-id="facd6-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="facd6-110">バインディングの変更 : セキュリティ機構の変更や、その設定の変更など。</span><span class="sxs-lookup"><span data-stu-id="facd6-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="facd6-111">実装の変更 : 内部メソッド実装を変更する場合など。</span><span class="sxs-lookup"><span data-stu-id="facd6-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="facd6-112">これらの変更の中には "互換性に影響する" ものとそうでないものとがあります。</span><span class="sxs-lookup"><span data-stu-id="facd6-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="facd6-113">以前のバージョンで正常に処理されたメッセージがすべて新しいバージョンで正常に処理された場合、変更は*改行されません*。</span><span class="sxs-lookup"><span data-stu-id="facd6-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="facd6-114">その基準を満たさない変更は *、互換性に影響を与える*変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="facd6-115">サービス指向とバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="facd6-116">サービス指向の基本思想の 1 つは、サービスとクライアントが自律 (または独立) しているということです。</span><span class="sxs-lookup"><span data-stu-id="facd6-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="facd6-117">これは、サービス開発者が、すべてのサービス クライアントを制御または把握するということを想定できないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="facd6-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="facd6-118">これにより、サービスのバージョンが変更されたときに、すべてのクライアントを再構築し、再展開するという選択肢はなくなります。</span><span class="sxs-lookup"><span data-stu-id="facd6-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="facd6-119">このトピックでは、この基本思想に従ってサービスを想定しているため、クライアントから独立して、サービスを変更または "バージョン管理" する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="facd6-120">互換性に影響する変更が想定外であり、回避できない場合、アプリケーションはこの基本思想を無視し、新しいバージョンのサービスでクライアントを再構築し、再展開することを要求できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="facd6-121">コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-121">Contract Versioning</span></span>  
 <span data-ttu-id="facd6-122">クライアントが使用するコントラクトは、サービスが使用するコントラクトと同じである必要はありません。これらのコントラクトに必要なのは互換性だけです。</span><span class="sxs-lookup"><span data-stu-id="facd6-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="facd6-123">サービス コントラクトの場合、互換性は、サービスが公開する新しい操作は追加できても、既存の操作をセマンティックに削除または変更することはできないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="facd6-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="facd6-124">データ コントラクトの場合、互換性は、新しいスキーマの種類の定義は追加できても、既存のスキーマの種類の定義を互換性に影響する方法では変更できないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="facd6-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="facd6-125">互換性に影響する変更として、データ メンバーの削除や、データ型の互換性のない変更などがあります。</span><span class="sxs-lookup"><span data-stu-id="facd6-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="facd6-126">この特徴により、クライアントの互換性に影響しなければ、サービスはコントラクトのバージョンをある程度自由に変更できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="facd6-127">次の 2 つのセクションでは、WCF データとサービス コントラクトに対して行うことができる、互換性のない変更と互換性のない変更について説明します。</span><span class="sxs-lookup"><span data-stu-id="facd6-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="facd6-128">データ コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="facd6-129">ここでは、<xref:System.Runtime.Serialization.DataContractSerializer> クラスと <xref:System.Runtime.Serialization.DataContractAttribute> クラスを使用する場合のデータのバージョン管理について説明します。</span><span class="sxs-lookup"><span data-stu-id="facd6-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="facd6-130">厳密なバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-130">Strict Versioning</span></span>  
 <span data-ttu-id="facd6-131">バージョンの変更が問題となる多くのシナリオでは、サービス開発者はクライアントを制御できないため、メッセージの XML やスキーマの変更に対処する方法を想定できません。</span><span class="sxs-lookup"><span data-stu-id="facd6-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="facd6-132">このような場合、次の 2 つの理由から、新しいメッセージが古いスキーマに対して有効であることを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="facd6-133">スキーマが変更されることはないという前提で旧クライアントが開発されている場合、</span><span class="sxs-lookup"><span data-stu-id="facd6-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="facd6-134">クライアントは、その設計で対象としていないメッセージを処理できない可能性があるため。</span><span class="sxs-lookup"><span data-stu-id="facd6-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="facd6-135">旧クライアントがメッセージの処理を試みる前に、実際のスキーマ検証を古いスキーマに対して実行する可能性があるため。</span><span class="sxs-lookup"><span data-stu-id="facd6-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="facd6-136">このようなシナリオでは、既存のデータ コントラクトを変更不可として扱い、一意の XML 修飾名を持つ新しいデータ コントラクトを作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="facd6-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="facd6-137">この場合、サービス開発者は、既存のサービス コントラクトに新しいメソッドを追加するか、新しいデータ コントラクトを使用するメソッドを含む新しいサービス コントラクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="facd6-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="facd6-138">多くの場合、サービス開発者は、データ コントラクトのすべてのバージョン内で実行するビジネス ロジックと、データ コントラクトの各バージョンに固有のビジネス コードを作成することが必要になります。</span><span class="sxs-lookup"><span data-stu-id="facd6-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="facd6-139">インターフェイスを使用してこの要件を満たす方法について、このトピックの最後にある付録で説明します。</span><span class="sxs-lookup"><span data-stu-id="facd6-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="facd6-140">厳密でないバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-140">Lax Versioning</span></span>  
 <span data-ttu-id="facd6-141">他の多くのシナリオでは、サービス開発者は、新しい任意のメンバーをデータ コントラクトに追加しても、既存のクライアントの互換性には影響しないという想定を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="facd6-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="facd6-142">この場合、サービス開発者は、既存のクライアントがスキーマ検証を実行しないかどうか、また、未知のデータ メンバーを無視するかどうかを調べる必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="facd6-143">このようなシナリオでは、互換性に影響しない方法で新しいメンバーを追加するためのデータ コントラクト機能を利用できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="facd6-144">サービスの最初のバージョンで、バージョン管理のためのデータ コントラクト機能が既に使用されている場合には、サービス開発者は確信を持ってこの想定を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="facd6-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="facd6-145">WCF、ASP.NET Web サービス、および他の多くの Web サービス スタックは *、緩やかなバージョン管理を*サポートしています。</span><span class="sxs-lookup"><span data-stu-id="facd6-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="facd6-146">新しいデータ メンバーを追加しても、既存のクライアントの互換性に影響することはないと誤解しがちです。</span><span class="sxs-lookup"><span data-stu-id="facd6-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="facd6-147">すべてのクライアントが厳密でないバージョン管理に対処できるという確信がない場合は、厳密なバージョン管理のガイドラインに従い、データ コントラクトを変更不可として扱うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="facd6-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="facd6-148">データ コントラクトの緩やかなバージョン管理と厳密なバージョン管理の両方の詳細なガイドラインについては、「[ベスト プラクティス : データ コントラクトのバージョン管理](best-practices-data-contract-versioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="facd6-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="facd6-149">データ コントラクトと .NET 型の区別</span><span class="sxs-lookup"><span data-stu-id="facd6-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="facd6-150">.NET クラスまたは構造体は、<xref:System.Runtime.Serialization.DataContractAttribute> 属性をクラスに適用することにより、データ コントラクトとして投影できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="facd6-151">.NET 型とそのデータ コントラクト投影は、2 つの異なる要素です。</span><span class="sxs-lookup"><span data-stu-id="facd6-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="facd6-152">同じデータ コントラクトが投影された複数の .NET 型を使用できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="facd6-153">この区別は、投影されたデータ コントラクトを維持することによって、厳密な意味で既存のクライアントとの互換性を保ちながら、.NET 型を変更できるという点で特に有用です。</span><span class="sxs-lookup"><span data-stu-id="facd6-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="facd6-154">.NET 型とデータ コントラクトのこの区別を維持するには、次の 2 つのことを必ず行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="facd6-155"><xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> と <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A> を指定します。</span><span class="sxs-lookup"><span data-stu-id="facd6-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="facd6-156">コントラクトに .NET 型の名前と名前空間が公開されないように、データ コントラクトの名前と名前空間を必ず指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="facd6-157">これにより、後で .NET の名前空間や型名を変更することにした場合でも、データ コントラクトの変更はありません。</span><span class="sxs-lookup"><span data-stu-id="facd6-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="facd6-158"><xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A> を指定します。</span><span class="sxs-lookup"><span data-stu-id="facd6-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="facd6-159">コントラクトに .NET メンバー名が公開されないように、データ メンバーの名前を必ず指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="facd6-160">これにより、後でメンバーの .NET 名を変更することにした場合でも、データ コントラクトの変更はありません。</span><span class="sxs-lookup"><span data-stu-id="facd6-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="facd6-161">メンバーの変更または削除</span><span class="sxs-lookup"><span data-stu-id="facd6-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="facd6-162">厳密でないバージョン管理が許可されている場合でも、メンバーの名前またはデータ型の変更や、データ メンバーの削除は、互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="facd6-163">このような変更が必要な場合は、新しいデータ コントラクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="facd6-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="facd6-164">サービスの互換性が非常に重要である場合は、コードで使用していないデータ メンバーを無視するよう考慮し、これらのメンバーをそのまま残しておきます。</span><span class="sxs-lookup"><span data-stu-id="facd6-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="facd6-165">データ メンバーを複数のメンバーに分割する場合は、必要な分割と下位レベル クライアント (最新のバージョンにアップグレードされていないクライアント) の再集約を実行できるプロパティとして、既存のメンバーをそのまま残すよう考慮します。</span><span class="sxs-lookup"><span data-stu-id="facd6-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="facd6-166">同様に、データ コントラクトの名前または名前空間の変更も互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="facd6-167">未知のデータのラウンド トリップ</span><span class="sxs-lookup"><span data-stu-id="facd6-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="facd6-168">一部のシナリオでは、新しいバージョンで追加されたメンバーによって生じる未知のデータを "ラウンド トリップ" する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="facd6-169">たとえば、新しく追加された複数のメンバーを含むデータを、"versionNew" サービスから "versionOld" クライアントに送信するとします。</span><span class="sxs-lookup"><span data-stu-id="facd6-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="facd6-170">クライアントは、メッセージを処理するときに新しく追加されたメンバーを無視しますが、新しく追加されたメンバーを含む同じデータを versionNew サービスに再送信します。</span><span class="sxs-lookup"><span data-stu-id="facd6-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="facd6-171">この一般的なシナリオとして、サービスから取得したデータを変更して返すデータ更新があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="facd6-172">特定の型のラウンド トリップを有効にするには、この型に <xref:System.Runtime.Serialization.IExtensibleDataObject> インターフェイスを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="facd6-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="facd6-173">このインターフェイスには、<xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> 型を返す <xref:System.Runtime.Serialization.ExtensionDataObject> プロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="facd6-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="facd6-174">プロパティは現在のバージョンでは未知の、今後使用されるデータ コントラクトの任意のデータを格納するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="facd6-175">このデータはクライアントに対して不透明ですが、インスタンスをシリアル化すると、<xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> プロパティの内容がデータ コントラクト メンバーのその他のデータと共に書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="facd6-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="facd6-176">今後の新しい未知のメンバーを格納するために、すべての型でこのインターフェイスを実装することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="facd6-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="facd6-177">データ コントラクト ライブラリ</span><span class="sxs-lookup"><span data-stu-id="facd6-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="facd6-178">コントラクトを中央のリポジトリに公開するデータ コントラクトのライブラリを用意できます。サービスおよび型の実装側は、このリポジトリからデータ コントラクトを実装し、公開します。</span><span class="sxs-lookup"><span data-stu-id="facd6-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="facd6-179">この場合、データ コントラクトをリポジトリに公開すると、そのコントラクトを実装する型の作成者を制御することはできません。</span><span class="sxs-lookup"><span data-stu-id="facd6-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="facd6-180">したがって、コントラクトを一度公開すると、変更することができないため、そのコントラクトは実質的に変更不可となります。</span><span class="sxs-lookup"><span data-stu-id="facd6-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="facd6-181">XmlSerializer を使用する場合</span><span class="sxs-lookup"><span data-stu-id="facd6-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="facd6-182"><xref:System.Xml.Serialization.XmlSerializer> クラスを使用する場合にも、バージョン管理の同じ原則が適用されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="facd6-183">厳密なバージョン管理が必要な場合は、データ コントラクトを変更不可として扱い、新しいバージョンの一意の修飾名を持つ新しいデータ コントラクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="facd6-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="facd6-184">厳密でないバージョン管理を使用できることが確実である場合は、新しいバージョンでシリアル化可能な新しいメンバーを追加できますが、既存のメンバーを変更または削除することはできません。</span><span class="sxs-lookup"><span data-stu-id="facd6-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="facd6-185"><xref:System.Xml.Serialization.XmlSerializer> は、<xref:System.Xml.Serialization.XmlAnyElementAttribute> 属性と <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> 属性を使用して、未知のデータのラウンド トリップをサポートします。</span><span class="sxs-lookup"><span data-stu-id="facd6-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="facd6-186">メッセージ コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="facd6-187">メッセージ コントラクトのバージョン管理に関するガイドラインは、データ コントラクトのバージョン管理とよく似ています。</span><span class="sxs-lookup"><span data-stu-id="facd6-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="facd6-188">厳密なバージョン管理が必要な場合、メッセージ本文を変更するのではなく、一意の修飾名を持つ新しいメッセージ コントラクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="facd6-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="facd6-189">厳密でないバージョン管理を使用できることがわかっている場合は、メッセージ本文の新しい部分を追加できますが、既存の部分を変更または削除することはできません。</span><span class="sxs-lookup"><span data-stu-id="facd6-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="facd6-190">このガイドラインは、ベア メッセージ コントラクトとラップ メッセージ コントラクトの両方に適用されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="facd6-191">厳密なバージョン管理を使用している場合でも、メッセージ ヘッダーはいつでも追加できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="facd6-192">MustUnderstand フラグは、バージョン管理に影響を及ぼすことがあります。</span><span class="sxs-lookup"><span data-stu-id="facd6-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="facd6-193">一般に、WCF のヘッダーのバージョン管理モデルは、SOAP 仕様で説明されているようにします。</span><span class="sxs-lookup"><span data-stu-id="facd6-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="facd6-194">サービス コントラクトのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="facd6-195">データ コントラクトのバージョン管理と同様に、サービス コントラクトのバージョン管理にも、操作の追加、変更、および削除が含まれます。</span><span class="sxs-lookup"><span data-stu-id="facd6-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="facd6-196">名前、名前空間、およびアクションの指定</span><span class="sxs-lookup"><span data-stu-id="facd6-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="facd6-197">既定では、サービス コントラクトの名前はインターフェイスの名前です。</span><span class="sxs-lookup"><span data-stu-id="facd6-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="facd6-198">既定の名前空間はhttp://tempuri.org" " で、各操作の動作http://tempuri.org/contractname/methodnameは " " です。</span><span class="sxs-lookup"><span data-stu-id="facd6-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="facd6-199">サービス コントラクトの名前と名前空間を明示的に指定し、各操作に対してアクションを指定して 、 "http://tempuri.orgを使用しないようにし、サービスコントラクトでインターフェイス名とメソッド名が公開されないようにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="facd6-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="facd6-200">パラメーターと操作の追加</span><span class="sxs-lookup"><span data-stu-id="facd6-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="facd6-201">サービスが公開するサービス操作の追加は互換性に影響しない変更です。既存のクライアントは、追加された新しい操作を考慮する必要がないからです。</span><span class="sxs-lookup"><span data-stu-id="facd6-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="facd6-202">双方向コールバック コントラクトへの操作の追加は、互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="facd6-203">操作パラメーターまたは戻り値の型の変更</span><span class="sxs-lookup"><span data-stu-id="facd6-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="facd6-204">新しい型が古い型と同じデータ コントラクトを実装している場合を除き、パラメーターまたは戻り値の型の変更は、一般に互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="facd6-205">このような変更を行う場合は、新しい操作をサービス コントラクトに追加するか、新しいサービス コントラクトを定義します。</span><span class="sxs-lookup"><span data-stu-id="facd6-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="facd6-206">操作の削除</span><span class="sxs-lookup"><span data-stu-id="facd6-206">Removing Operations</span></span>  
 <span data-ttu-id="facd6-207">操作の削除も互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="facd6-208">このような変更を行う場合は、新しいサービス コントラクトを定義し、新しいエンドポイントで公開します。</span><span class="sxs-lookup"><span data-stu-id="facd6-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="facd6-209">エラー コントラクト</span><span class="sxs-lookup"><span data-stu-id="facd6-209">Fault Contracts</span></span>  
 <span data-ttu-id="facd6-210"><xref:System.ServiceModel.FaultContractAttribute> 属性を使用すると、サービス コントラクト開発者は、コントラクトの操作から返すことのできるエラーに関する情報を指定できます。</span><span class="sxs-lookup"><span data-stu-id="facd6-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="facd6-211">サービスのコントラクトに記載されたエラーのリストは、完全なリストとは見なされません。</span><span class="sxs-lookup"><span data-stu-id="facd6-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="facd6-212">操作がコントラクトに記載されていないエラーを返す可能性は常にあります。</span><span class="sxs-lookup"><span data-stu-id="facd6-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="facd6-213">したがって、コントラクトに記載されたエラーのセットの変更は、互換性に影響しないものと見なされます。</span><span class="sxs-lookup"><span data-stu-id="facd6-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="facd6-214">たとえば、<xref:System.ServiceModel.FaultContractAttribute> を使用して新しいエラーをコントラクトに追加する場合や、コントラクトから既存のエラーを削除する場合などです。</span><span class="sxs-lookup"><span data-stu-id="facd6-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="facd6-215">サービス コントラクト ライブラリ</span><span class="sxs-lookup"><span data-stu-id="facd6-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="facd6-216">組織では、コントラクトを中央のリポジトリに公開する、コントラクトのライブラリを用意できます。サービス実装側は、このリポジトリからコントラクトを実装します。</span><span class="sxs-lookup"><span data-stu-id="facd6-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="facd6-217">この場合、サービス コントラクトをリポジトリに公開すると、そのコントラクトを実装するサービスの作成者を制御することはできません。</span><span class="sxs-lookup"><span data-stu-id="facd6-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="facd6-218">したがって、サービス コントラクトを一度公開すると、変更することができないため、実質的にそのコントラクトは変更不可になります。</span><span class="sxs-lookup"><span data-stu-id="facd6-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="facd6-219">WCF では、既存のコントラクトを拡張する新しいコントラクトを作成するために使用できるコントラクトの継承がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="facd6-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="facd6-220">この機能を使用するには、古いサービス コントラクト インターフェイスから継承した新しいサービス コントラクト インターフェイスを定義し、この新しいインターフェイスにメソッドを追加します。</span><span class="sxs-lookup"><span data-stu-id="facd6-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="facd6-221">次に、古いコントラクトを実装するサービスを変更して新しいコントラクトを実装し、新しいコントラクトを使用するように "versionOld" エンドポイントの定義を変更します。</span><span class="sxs-lookup"><span data-stu-id="facd6-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="facd6-222">"versionOld" クライアントには、エンドポイントが "versionOld" コントラクトを引き続き公開しているように見えます。"versionNew" クライアントには、エンドポイントが "versionNew" コントラクトを公開しているように見えます。</span><span class="sxs-lookup"><span data-stu-id="facd6-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="facd6-223">アドレスとバインディングのバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="facd6-224">クライアントが新しいエンドポイント アドレスまたはバインディングを動的に検出できない場合、エンドポイント アドレスとバインディングの変更は互換性に影響する変更です。</span><span class="sxs-lookup"><span data-stu-id="facd6-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="facd6-225">新しいエンドポイントまたはバインディングを動的に検出する機能を実装する 1 つの方法として、クライアントがエンドポイントとの通信を試みるときに、UDDI (Universal Discovery Description and Integration) レジストリと UDDI 呼び出しパターンを使用します。エラーが発生した場合、現在のエンドポイントのメタデータについて既知の UDDI レジストリに照会します。</span><span class="sxs-lookup"><span data-stu-id="facd6-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="facd6-226">クライアントは、このメタデータからアドレスとバインディングを使用して、エンドポイントと通信を行います。</span><span class="sxs-lookup"><span data-stu-id="facd6-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="facd6-227">この通信が成功した場合、クライアントは今後使用できるように、そのアドレスとバインディングをキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="facd6-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="facd6-228">ルーティング サービスとバージョン管理</span><span class="sxs-lookup"><span data-stu-id="facd6-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="facd6-229">サービスに対して行った変更が互換性に影響するもので、複数の異なるバージョンのサービスを同時に実行する必要がある場合、WCF ルーティング サービスを使用して、メッセージを適切なサービス インスタンスにルーティングすることができます。</span><span class="sxs-lookup"><span data-stu-id="facd6-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="facd6-230">WCF ルーティング サービスは、メッセージの内容に基づくルーティングを使用します。つまり、メッセージ内に含まれる情報に応じて、そのメッセージのルーティング先が特定されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="facd6-231">WCF ルーティング サービスの詳細については、「[ルーティング サービス](./feature-details/routing-service.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="facd6-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="facd6-232">サービスのバージョン管理に WCF ルーティング サービスを使用する方法の例については、「[方法: サービスのバージョン管理」を参照](./feature-details/how-to-service-versioning.md)してください。</span><span class="sxs-lookup"><span data-stu-id="facd6-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="facd6-233">付録</span><span class="sxs-lookup"><span data-stu-id="facd6-233">Appendix</span></span>  
 <span data-ttu-id="facd6-234">厳密なバージョン管理が必要な場合、データ コントラクトのバージョン管理の一般的なガイダンスは、データ コントラクトを変更不可として扱い、変更が必要な場合は新しいデータ コントラクトを作成することです。</span><span class="sxs-lookup"><span data-stu-id="facd6-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="facd6-235">新しいデータ コントラクトごとに新しいクラスを作成する必要があります。したがって、古いデータ コントラクト クラスの観点で作成された既存のコードを取得し、新しいデータ コントラクト クラスの観点でコードを書き換える必要がないようにするための方法が必要となります。</span><span class="sxs-lookup"><span data-stu-id="facd6-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="facd6-236">このような方法の 1 つとして、インターフェイスを使用して各データ コントラクトのメンバーを定義し、インターフェイスを実装するデータ コントラクト クラスではなく、インターフェイスの観点で内部実装コードを作成します。</span><span class="sxs-lookup"><span data-stu-id="facd6-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="facd6-237">サービスのバージョン 1 の次のコードは、`IPurchaseOrderV1` インターフェイスと `PurchaseOrderV1` を示しています。</span><span class="sxs-lookup"><span data-stu-id="facd6-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="facd6-238">サービス コントラクトの操作は、`PurchaseOrderV1` の観点で作成されますが、実際のビジネス ロジックは、`IPurchaseOrderV1` の観点です。</span><span class="sxs-lookup"><span data-stu-id="facd6-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="facd6-239">次のコードに示すように、バージョン 2 には、新しい `IPurchaseOrderV2` インターフェイスと `PurchaseOrderV2` クラスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="facd6-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="facd6-240">`PurchaseOrderV2` の観点で作成された新しい操作を含めるために、サービス コントラクトが更新されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="facd6-241">`IPurchaseOrderV1` の観点で作成された既存のビジネス ロジックは、`PurchaseOrderV2` で引き続き機能し、`OrderDate` プロパティを必要とする新しいビジネス ロジックが `IPurchaseOrderV2` の観点で作成されます。</span><span class="sxs-lookup"><span data-stu-id="facd6-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="facd6-242">関連項目</span><span class="sxs-lookup"><span data-stu-id="facd6-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="facd6-243">データ コントラクトの等価性</span><span class="sxs-lookup"><span data-stu-id="facd6-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="facd6-244">バージョントレラントなシリアル化コールバック</span><span class="sxs-lookup"><span data-stu-id="facd6-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
