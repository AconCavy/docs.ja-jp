---
title: .NET Native とコンパイル
ms.date: 03/30/2017
ms.assetid: e38ae4f3-3e3d-42c3-a4b8-db1aa9d84f85
ms.openlocfilehash: cf5c9f05b2f2cb4ca15e4add5b53bc9bdca757a3
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/06/2020
ms.locfileid: "73128242"
---
# <a name="net-native-and-compilation"></a><span data-ttu-id="5a383-102">.NET Native とコンパイル</span><span class="sxs-lookup"><span data-stu-id="5a383-102">.NET Native and Compilation</span></span>

<span data-ttu-id="5a383-103">.NET Framework を対象にした Windows 8.1 アプリケーションと Windows デスクトップ アプリケーションは特定のプログラミング言語で記述し、中間言語 (IL: Intermediate Language) にコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="5a383-103">Windows 8.1 applications and Windows Desktop applications that target the.NET Framework are written in a particular programming language and compiled into intermediate language (IL).</span></span> <span data-ttu-id="5a383-104">実行時には、メソッドが初めて実行される直前に JIT (Just-In-Time) コンパイラによって IL がローカル コンピューターのネイティブ コードにコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="5a383-104">At runtime, a just-in-time (JIT) compiler is responsible for compiling the IL into native code for the local machine just before a method is executed for the first time.</span></span> <span data-ttu-id="5a383-105">それとは対照的に、.NET ネイティブ ツール チェーンでは、コンパイル時にソース コードをネイティブ コードに変換します。</span><span class="sxs-lookup"><span data-stu-id="5a383-105">In contrast, the .NET Native tool chain converts source code to native code at compile time.</span></span> <span data-ttu-id="5a383-106">このトピックでは、.NET ネイティブを、.NET Framework アプリをコンパイルする他のテクノロジと比較します。また、.NET ネイティブがネイティブ コードをどのように生成するのかについて実践的な概要を説明しますので、.NET ネイティブでコンパイルしたコードで発生する例外が JIT でコンパイルしたコードでは発生しない理由を理解するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="5a383-106">This topic compares .NET Native with other compilation technologies available for .NET Framework apps, and also provides a practical overview of how .NET Native produces native code that can help you understand why exceptions that occur in code compiled with .NET Native do not occur in JIT-compiled code.</span></span>

## <a name="net-native-generating-native-binaries"></a><span data-ttu-id="5a383-107">.NET ネイティブ: ネイティブ バイナリを生成する</span><span class="sxs-lookup"><span data-stu-id="5a383-107">.NET Native: Generating native binaries</span></span>

<span data-ttu-id="5a383-108">.NET Framework を対象にしていても、.NET ネイティブ ツール チェーンを使用してコンパイルされないアプリケーションは、次のようなアプリケーション アセンブリで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-108">An application that targets the .NET Framework and that is not compiled by using the .NET Native tool chain consists of your application assembly, which includes the following:</span></span>

- <span data-ttu-id="5a383-109">アセンブリ、その依存関係、それに含まれる型、そのメンバーを記述した[メタデータ](../../standard/metadata-and-self-describing-components.md)。</span><span class="sxs-lookup"><span data-stu-id="5a383-109">[Metadata](../../standard/metadata-and-self-describing-components.md) that describes the assembly, its dependencies, the types it contains, and their members.</span></span> <span data-ttu-id="5a383-110">メタデータは、リフレクションと遅延バインディング アクセスのために使用され、場合によってはコンパイラとビルド ツールによって使用されることもあります。</span><span class="sxs-lookup"><span data-stu-id="5a383-110">The metadata is used for reflection and late-bound access, and in some cases by compiler and build tools as well.</span></span>

- <span data-ttu-id="5a383-111">実装コード。</span><span class="sxs-lookup"><span data-stu-id="5a383-111">Implementation code.</span></span> <span data-ttu-id="5a383-112">これは、中間言語 (IL) オペコードで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-112">This consists of intermediate language (IL) opcodes.</span></span> <span data-ttu-id="5a383-113">実行時には、JIT (Just-In-Time) コンパイラが IL コードを対象のプラットフォームのネイティブ コードに変換します。</span><span class="sxs-lookup"><span data-stu-id="5a383-113">At runtime, the just-in-time (JIT) compiler translates it into native code for the target platform.</span></span>

 <span data-ttu-id="5a383-114">これらの主要なアプリケーション アセンブリに加えて、アプリは次の項目の存在を必要とします。</span><span class="sxs-lookup"><span data-stu-id="5a383-114">In addition to your main application assembly, an app requires that the following be present:</span></span>

- <span data-ttu-id="5a383-115">アプリに必要な他のすべてクラス ライブラリまたはサード パーティ製のアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="5a383-115">Any additional class libraries or third-party assemblies that are required by your app.</span></span> <span data-ttu-id="5a383-116">これらのアセンブリには、アプリと同様に、アセンブリ、その型、およびそのメンバーを記述したメタデータが含まれるほか、すべての型のメンバーを実装する IL が含まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-116">These assemblies similarly include metadata that describes the assembly, its types, and their members, as well as the IL that implements all type members.</span></span>

- <span data-ttu-id="5a383-117">.NET Framework クラス ライブラリ。</span><span class="sxs-lookup"><span data-stu-id="5a383-117">The .NET Framework Class Library.</span></span> <span data-ttu-id="5a383-118">これは、.NET Framework のインストール時にローカル システムにインストールされるアセンブリのコレクションです。</span><span class="sxs-lookup"><span data-stu-id="5a383-118">This is a collection of assemblies that is installed on the local system with the .NET Framework installation.</span></span> <span data-ttu-id="5a383-119">.NET Framework クラス ライブラリに含まれるアセンブリには、メタデータと実装コードの完全なセットが含まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-119">The assemblies included in the .NET Framework Class Library include a complete set of metadata and implementation code.</span></span>

- <span data-ttu-id="5a383-120">共通言語ランタイム。</span><span class="sxs-lookup"><span data-stu-id="5a383-120">The common language runtime.</span></span> <span data-ttu-id="5a383-121">これは、アセンブリの読み込み、メモリ管理とガベージ コレクション、例外処理、JIT コンパイル、リモート処理、および相互運用機能などのサービスを実行するダイナミック リンク ライブラリのコレクションです。</span><span class="sxs-lookup"><span data-stu-id="5a383-121">This is a collection of dynamic link libraries that perform such services as assembly loading, memory management and garbage collection, exception handling, just-in-time compilation, remoting, and interop.</span></span> <span data-ttu-id="5a383-122">クラス ライブラリと同様に、このランタイムは .NET Framework のインストールの一部としてローカル システムにインストールされます。</span><span class="sxs-lookup"><span data-stu-id="5a383-122">Like the class library, the runtime is installed on the local system as part of the .NET Framework installation.</span></span>

<span data-ttu-id="5a383-123">アプリを正常に実行するためには、共通言語ランタイム全体だけでなく、アプリケーション固有のアセンブリ、サード パーティ製のアセンブリ、およびシステム アセンブリに含まれるすべての型のメタデータと IL が存在している必要があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5a383-123">Note that the entire common language runtime, as well as metadata and IL for all types in application-specific assemblies, third-party assemblies, and system assemblies must be present for the app to execute successfully.</span></span>

## <a name="net-native-and-just-in-time-compilation"></a><span data-ttu-id="5a383-124">.NET ネイティブと Just-In-Time コンパイル</span><span class="sxs-lookup"><span data-stu-id="5a383-124">.NET Native and just-in-time compilation</span></span>

<span data-ttu-id="5a383-125">.NET ネイティブ ツール チェーンへの入力は、C# または Visual Basic コンパイラでビルドされた Windows ストア アプリです。</span><span class="sxs-lookup"><span data-stu-id="5a383-125">The input for the .NET Native tool chain is the Windows store app built by the C# or Visual Basic compiler.</span></span> <span data-ttu-id="5a383-126">したがって、.NET ネイティブ ツール チェーンの実行が開始されるのは、言語コンパイラが Windows ストア アプリのコンパイルを終了した時点です。</span><span class="sxs-lookup"><span data-stu-id="5a383-126">In other words, the .NET Native tool chain begins execution when the language compiler has finished compilation of a Windows Store app.</span></span>

> [!TIP]
> <span data-ttu-id="5a383-127">.NET ネイティブへの入力は、マネージド アセンブリ向けに記述された IL とメタデータであるため、ビルド前またはビルド後のイベントを使用するか、または MSBuild プロジェクト ファイルを変更することにより、カスタム コードの生成やその他のカスタム操作を実行する余地があります。</span><span class="sxs-lookup"><span data-stu-id="5a383-127">Because the input to .NET Native is the IL and metadata written to managed assemblies, you can still perform custom code generation or other custom operations by using pre-build or post-build events or by modifying the MSBuild project file.</span></span>
>
> <span data-ttu-id="5a383-128">ただし、IL を変更する種類のツール、つまり .NET ツール チェーンがアプリの IL を解析することを妨げるツールはサポートされません。</span><span class="sxs-lookup"><span data-stu-id="5a383-128">However, categories of tools that modify IL and thereby prevent the .NET tool chain from analyzing an app's IL are not supported.</span></span> <span data-ttu-id="5a383-129">難読化ツールは、この種類のツールとして代表的なものです。</span><span class="sxs-lookup"><span data-stu-id="5a383-129">Obfuscators are the most notable tools of this type.</span></span>

<span data-ttu-id="5a383-130">アプリを IL からネイティブ コードに変換する過程で、.NET ネイティブ ツール チェーンは次のような操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="5a383-130">In the course of converting an app from IL to native code, the .NET Native tool chain performs operations like the following:</span></span>

- <span data-ttu-id="5a383-131">特定のコード パスについて、リフレクションやメタデータに依存するコードを、静的なネイティブ コードで置き換えます。</span><span class="sxs-lookup"><span data-stu-id="5a383-131">For certain code paths, it replaces code that relies on reflection and metadata with static native code.</span></span> <span data-ttu-id="5a383-132">たとえば、値型が <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> メソッドをオーバーライドしない場合、等しいかどうかの既定のテストは、リフレクションを使用して値型のフィールドを表す <xref:System.Reflection.FieldInfo> オブジェクトを取得することによって行われるため、2 つのインスタンスのフィールド値の比較になります。</span><span class="sxs-lookup"><span data-stu-id="5a383-132">For example, if a value type does not override the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method, the default test for equality uses reflection to retrieve <xref:System.Reflection.FieldInfo> objects that represent the value type's fields, then compares the field values of two instances.</span></span> <span data-ttu-id="5a383-133">ネイティブ コードにコンパイルするとき、.NET ネイティブ ツール チェーンは、このリフレクションのコードとメタデータをフィールド値の静的な比較に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="5a383-133">When compiling to native code, the .NET Native tool chain replaces the reflection code and metadata with a static comparison of the field values.</span></span>

- <span data-ttu-id="5a383-134">可能であれば、すべてのメタデータを削除しようとします。</span><span class="sxs-lookup"><span data-stu-id="5a383-134">Where possible, it attempts to eliminate all metadata.</span></span>

- <span data-ttu-id="5a383-135">アプリにより実際に呼び出される実装コードのみを、最終的なアプリ アセンブリに組み込みます。</span><span class="sxs-lookup"><span data-stu-id="5a383-135">It includes in the final app assemblies only the implementation code that is actually invoked by the app.</span></span> <span data-ttu-id="5a383-136">これによる効果は、特にサード パーティ製ライブラリや、.NET Framework クラス ライブラリの場合に発揮されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-136">This particularly affects code in third-party libraries and in the .NET Framework Class Library.</span></span> <span data-ttu-id="5a383-137">この操作の結果として、アプリケーションはサード パーティ製のライブラリにも完全な .NET Framework クラス ライブラリにも依存しなくなり、サード パーティ製のライブラリおよび .NET Framework クラス ライブラリに含まれるコードがアプリに対してローカルになります。</span><span class="sxs-lookup"><span data-stu-id="5a383-137">As a result, an application no longer depends on either third-party libraries or the full .NET Framework Class Library; instead, code in third-party and .NET Framework class libraries is now local to the app.</span></span>

- <span data-ttu-id="5a383-138">完全な CLR を、主としてガベージ コレクターを含む、リファクタリングされたランタイムに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="5a383-138">It replaces the full CLR with a refactored runtime that primarily contains the garbage collector.</span></span> <span data-ttu-id="5a383-139">リファクタリングされたランタイムは、アプリに対してローカルで、サイズがわずか数百キロバイトの mrt100_app.dll という名前のライブラリに含まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-139">The refactored runtime is found in a library named mrt100_app.dll that is local to the app and is only a few hundred kilobytes in size.</span></span> <span data-ttu-id="5a383-140">これが可能になるのは、静的リンクを使用することにより、共通言語ランタイムによって実行されるサービスの多くが不要になるためです。</span><span class="sxs-lookup"><span data-stu-id="5a383-140">This is possible because static linking eliminates the need for many of the services performed by the common language runtime.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5a383-141">.NET ネイティブでは、標準の共通言語ランタイムと同じガベージ コレクターが使用されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-141">.NET Native uses the same garbage collector as the standard common language runtime.</span></span> <span data-ttu-id="5a383-142">.NET ネイティブのガベージ コレクターでは、既定でバックグラウンド ガベージ コレクションが既定で有効になります。</span><span class="sxs-lookup"><span data-stu-id="5a383-142">In the .NET Native garbage collector, background garbage collection is enabled by default.</span></span> <span data-ttu-id="5a383-143">ガベージ コレクションの詳細については、「[ガベージ コレクションの基礎](../../standard/garbage-collection/fundamentals.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5a383-143">For more information about garbage collection, see [Fundamentals of Garbage Collection](../../standard/garbage-collection/fundamentals.md).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5a383-144">.NET ネイティブは、アプリケーション全体をネイティブ アプリケーションにコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="5a383-144">.NET Native compiles an entire application to a native application.</span></span> <span data-ttu-id="5a383-145">ネイティブ コードに対するクラス ライブラリを含む 1 つのアセンブリをコンパイルして、マネージド コードから独立して呼び出せるようにすることはできません。</span><span class="sxs-lookup"><span data-stu-id="5a383-145">It does not allow you to compile a single assembly that contains a class library to native code so that it can be called independently from managed code.</span></span>

<span data-ttu-id="5a383-146">.NET ネイティブ ツール チェーンによって生成される結果のアプリは、プロジェクト ディレクトリの Debug または Release ディレクトリ内の ilc.out という名前のディレクトリに出力されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-146">The resulting app that is produced by the .NET Native tool chain is written to a directory named ilc.out in the Debug or Release directory of your project directory.</span></span> <span data-ttu-id="5a383-147">これは次のようなファイルで構成されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-147">It consists of the following files:</span></span>

- <span data-ttu-id="5a383-148">*\<appName>*.exe。 `Main` .dll 内の特殊なエクスポートに制御を転送するだけのスタブ実行可能ファイルです。 *\<appName>*</span><span class="sxs-lookup"><span data-stu-id="5a383-148">*\<appName>*.exe, a stub executable that simply transfers control to a special `Main` export in *\<appName>*.dll.</span></span>

- <span data-ttu-id="5a383-149">*\<appName>*.dll は、すべてのアプリケーションコードと、依存関係があるすべてのサードパーティ製ライブラリの .NET Framework コードを含む、すべてのアプリケーションコードを含む Windows ダイナミックリンクライブラリです。</span><span class="sxs-lookup"><span data-stu-id="5a383-149">*\<appName>*.dll, a Windows dynamic link library that contains all your application code, as well as code from the .NET Framework Class Library and any third-party libraries that you have a dependency on.</span></span>  <span data-ttu-id="5a383-150">さらに、たとえば Windows と相互運用するために必要なコードや、アプリ内のオブジェクトをシリアル化するために必要なコードなどのサポート コードも格納しています。</span><span class="sxs-lookup"><span data-stu-id="5a383-150">It also contains support code, such as the code necessary to interoperate with Windows and to serialize objects in your app.</span></span>

- <span data-ttu-id="5a383-151">mrt100_app.dll。リファクタリングしたランタイムであり、ガベージ コレクションなどのランタイム サービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="5a383-151">mrt100_app.dll, a refactored runtime that provides runtime services such as garbage collection.</span></span>

 <span data-ttu-id="5a383-152">すべての依存関係は、アプリの APPX マニフェストによってキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="5a383-152">All dependencies are captured by the app's APPX manifest.</span></span>  <span data-ttu-id="5a383-153">appx パッケージに直接バンドルされるアプリケーションの exe、dll、および mrt100_app.dll に加えて、さらに次の 2 つのファイルが含まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-153">In addition to the application exe, dll, and mrt100_app.dll, which are bundled directly in the appx package, this includes two more files:</span></span>

- <span data-ttu-id="5a383-154">msvcr140_app.dll。mrt100_app.dll によって使用される C ランタイム (CRT) ライブラリです。</span><span class="sxs-lookup"><span data-stu-id="5a383-154">msvcr140_app.dll, the C run-time (CRT) library used by mrt100_app.dll.</span></span> <span data-ttu-id="5a383-155">これはパッケージ内のフレームワーク参照によって組み込まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-155">It is included by a framework reference in the package.</span></span>

- <span data-ttu-id="5a383-156">mrt100.dll。</span><span class="sxs-lookup"><span data-stu-id="5a383-156">mrt100.dll.</span></span> <span data-ttu-id="5a383-157">mrt100_app.dll のパフォーマンスを向上させる関数が含まれるライブラリですが、このファイルが存在しなくても mrt100_app.dll は機能します。</span><span class="sxs-lookup"><span data-stu-id="5a383-157">This library includes functions that can improve the performance of mrt100_app.dll, although its absence does not prevent mrt100_app.dll from functioning.</span></span> <span data-ttu-id="5a383-158">これが存在する場合は、ローカル コンピューターの system32 ディレクトリから読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-158">It is loaded from the system32 directory on the local machine, if it is present.</span></span>

<span data-ttu-id="5a383-159">.NET ネイティブ ツール チェーンはアプリが実際に呼び出すことがわかっている実装コードのみをアプリにリンクするため、次のシナリオで必要なメタデータや実装コードはアプリに組み込まれないことがあります。</span><span class="sxs-lookup"><span data-stu-id="5a383-159">Because the .NET Native tool chain links implementation code into your app only if it knows that your app actually invokes that code, either the metadata or the implementation code required in the following scenarios may not be included with your app:</span></span>

- <span data-ttu-id="5a383-160">リフレクション。</span><span class="sxs-lookup"><span data-stu-id="5a383-160">Reflection.</span></span>

- <span data-ttu-id="5a383-161">動的呼び出しまたは遅延バインディング呼び出し。</span><span class="sxs-lookup"><span data-stu-id="5a383-161">Dynamic or late-bound invocation.</span></span>

- <span data-ttu-id="5a383-162">シリアル化と逆シリアル化。</span><span class="sxs-lookup"><span data-stu-id="5a383-162">Serialization and deserialization.</span></span>

- <span data-ttu-id="5a383-163">COM 相互運用。</span><span class="sxs-lookup"><span data-stu-id="5a383-163">COM interop.</span></span>

<span data-ttu-id="5a383-164">必要なメタデータや実装コードが実行時に存在しない場合は、.NET ネイティブ ランタイムが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5a383-164">If the necessary metadata or implementation code is absent at runtime, the .NET Native runtime throws an exception.</span></span> <span data-ttu-id="5a383-165">これらの例外を回避し、必要なメタデータと実装コードが .NET ネイティブ ツール チェーンによって組み込まれたことを確認するには、[ランタイム ディレクティブ ファイル](runtime-directives-rd-xml-configuration-file-reference.md)という XML ファイルを使用します。このファイルでは、実行時に利用可能であることが必要なメタデータまたは実装コードを含むプログラム要素を指定し、それらのプログラム要素にランタイム ポリシーを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="5a383-165">You can prevent these exceptions, and ensure that the .NET Native tool chain includes the required metadata and implementation code, by using a [runtime directives file](runtime-directives-rd-xml-configuration-file-reference.md), an XML file that designates the program elements whose metadata or implementation code must be available at runtime and assigns a runtime policy to them.</span></span> <span data-ttu-id="5a383-166">.NET ネイティブ ツール チェーンでコンパイルした Windows ストア プロジェクトに追加される既定のランタイム ディレクティブ ファイルは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="5a383-166">The following is the default runtime directives file that is added to a Windows Store project that is compiled by the .NET Native tool chain:</span></span>

```xml
<Directives xmlns="http://schemas.microsoft.com/netfx/2013/01/metadata">
  <Application>
    <Assembly Name="*Application*" Dynamic="Required All" />
  </Application>
</Directives>
```

<span data-ttu-id="5a383-167">これにより、アプリ パッケージ内のすべてのアセンブリに含まれるすべての型と、それに含まれるすべてのメンバーのリフレクションと動的呼び出しが可能になります。</span><span class="sxs-lookup"><span data-stu-id="5a383-167">This enables all the types, as well as all their members, in all the assemblies in your app package for reflection and dynamic invocation.</span></span> <span data-ttu-id="5a383-168">ただし、.NET Framework クラス ライブラリ アセンブリに含まれる型のリフレクションと動的なアクティブ化は可能になりません。</span><span class="sxs-lookup"><span data-stu-id="5a383-168">However, it does not enable reflection or dynamic activation of types in .NET Framework Class Library assemblies.</span></span> <span data-ttu-id="5a383-169">多くの場合、これで十分です。</span><span class="sxs-lookup"><span data-stu-id="5a383-169">In many cases, this is adequate.</span></span>

## <a name="net-native-and-ngen"></a><span data-ttu-id="5a383-170">.NET ネイティブと NGEN</span><span class="sxs-lookup"><span data-stu-id="5a383-170">.NET Native and NGEN</span></span>

<span data-ttu-id="5a383-171">[ネイティブ イメージ ジェネレーター](../tools/ngen-exe-native-image-generator.md) (NGEN) は、アセンブリをネイティブ コードにコンパイルして、ローカル コンピューター上のネイティブ イメージ キャッシュにインストールします。</span><span class="sxs-lookup"><span data-stu-id="5a383-171">The [(Native Image Generator](../tools/ngen-exe-native-image-generator.md) (NGEN) compiles assemblies to native code and installs them in the native image cache on the local computer.</span></span> <span data-ttu-id="5a383-172">ただし、NGEN は、ネイティブ コードを生成するという点では .NET ネイティブと同じですが、いくつかの重要な点で .NET ネイティブと異なります。</span><span class="sxs-lookup"><span data-stu-id="5a383-172">However, although NGEN, like .NET Native, produces native code, it differs from .NET Native in some significant ways:</span></span>

- <span data-ttu-id="5a383-173">NGEN は、特定のメソッドのネイティブ イメージを利用できない場合に、コードの JIT 処理にフォールバックします。</span><span class="sxs-lookup"><span data-stu-id="5a383-173">If no native image is available for a particular method, NGEN falls back to JITing code.</span></span> <span data-ttu-id="5a383-174">このため、NGEN が JIT コンパイルにフォールバックする必要がある場合に備えて、メタデータと IL をネイティブ イメージに組み込んでおく必要があります。</span><span class="sxs-lookup"><span data-stu-id="5a383-174">This means that native images must continue to include metadata and IL in the event that NGEN needs to fall back to JIT compilation.</span></span> <span data-ttu-id="5a383-175">これに対して、.NET ネイティブではネイティブ イメージのみが生成され、JIT コンパイルにフォールバックすることはありません。</span><span class="sxs-lookup"><span data-stu-id="5a383-175">In contrast, .NET Native produces only native images and does not fall back to JIT compilation.</span></span> <span data-ttu-id="5a383-176">その結果、一部のリフレクション、シリアル化、および相互運用機能のシナリオに必要なメタデータのみを保持すれは十分です。</span><span class="sxs-lookup"><span data-stu-id="5a383-176">As a result, only metadata required for some reflection, serialization, and interop scenarios must be preserved.</span></span>

- <span data-ttu-id="5a383-177">NGEN は、次に挙げるサービスについて完全な共通言語ランタイムに引き続き依存します。アセンブリの読み込み、リモート処理、相互運用性、メモリ管理、ガベージ コレクションなどと、必要な場合は JIT コンパイルです。</span><span class="sxs-lookup"><span data-stu-id="5a383-177">NGEN continues to rely on the full common language runtime for services such as assembly loading, remoting, interop, memory management, garbage collection, and, if necessary, JIT compilation.</span></span> <span data-ttu-id="5a383-178">.NET ネイティブでは、これらのサービスの多くが不要か (JIT コンパイル)、ビルド時に解決されてアプリのアセンブリに組み込まれます。</span><span class="sxs-lookup"><span data-stu-id="5a383-178">In .NET Native, many of these services are either unnecessary (JIT compilation) or are resolved at build-time and incorporated in the app assembly.</span></span> <span data-ttu-id="5a383-179">これら以外のサービス (最も重要なものはガベージ コレクション) は、はるかに小さい、リファクタリングされた mrt100_app.dll という名前のランタイムに含まれています。</span><span class="sxs-lookup"><span data-stu-id="5a383-179">The remaining services, the most important of which is garbage collection, are included in a much smaller, refactored runtime named mrt100_app.dll.</span></span>

- <span data-ttu-id="5a383-180">NGEN イメージは、脆弱な傾向があります。</span><span class="sxs-lookup"><span data-stu-id="5a383-180">NGEN images tend to be fragile.</span></span> <span data-ttu-id="5a383-181">たとえば、依存関係のあるファイルにパッチや変更が適用された場合は、通常、それを使用するアセンブリも再度 NGEN で処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5a383-181">For example, a patch or change to a dependency typically requires that the assemblies that use it also be re-NGENed.</span></span> <span data-ttu-id="5a383-182">このことは、特に .NET Framework クラス ライブラリに含まれるシステム アセンブリの場合に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="5a383-182">This is particularly true of system assemblies in the .NET Framework Class Library.</span></span> <span data-ttu-id="5a383-183">これに対して、.NET ネイティブでは、アプリケーションがそれぞれ個別に実行されます。</span><span class="sxs-lookup"><span data-stu-id="5a383-183">In contrast, .NET Native allows applications to be served independently of one another.</span></span>

## <a name="see-also"></a><span data-ttu-id="5a383-184">関連項目</span><span class="sxs-lookup"><span data-stu-id="5a383-184">See also</span></span>

- [<span data-ttu-id="5a383-185">メタデータと自己言及的なコンポーネント</span><span class="sxs-lookup"><span data-stu-id="5a383-185">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
- [<span data-ttu-id="5a383-186">インサイド .NET ネイティブ (Channel 9 ビデオ)</span><span class="sxs-lookup"><span data-stu-id="5a383-186">Inside .NET Native (Channel 9 Video)</span></span>](https://channel9.msdn.com/Shows/Going+Deep/Inside-NET-Native)
- [<span data-ttu-id="5a383-187">リフレクションおよび .NET ネイティブ</span><span class="sxs-lookup"><span data-stu-id="5a383-187">Reflection and .NET Native</span></span>](reflection-and-net-native.md)
- [<span data-ttu-id="5a383-188">.NET ネイティブの一般的なトラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="5a383-188">.NET Native General Troubleshooting</span></span>](net-native-general-troubleshooting.md)
