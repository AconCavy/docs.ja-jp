---
title: 信頼性に関するベスト プラクティス
description: SQL Server など、.NET ホストベースのサーバーアプリケーションでの信頼性に関するベストプラクティスを参照してください。 リソースのリークや停止を防ぐことができます。
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474242"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="f21f5-104">信頼性に関するベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="f21f5-104">Reliability Best Practices</span></span>

<span data-ttu-id="f21f5-105">以下の信頼性ルールは SQL Server を対象としたものですが、他のホスト ベースのサーバー アプリケーションにも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="f21f5-106">SQL Server などのサーバーがリソースをリークせず、停止しないことが非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="f21f5-107">ただし、オブジェクトの状態を変更するすべてのメソッドに対してバックアウト コードを記述することでは、それを実現できません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="f21f5-108">目標は、バックアウト コードによりすべての場所ですべてのエラーから復旧する 100% 信頼できるマネージド コードを記述することではありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="f21f5-109">それは、成功する可能性がほとんどない面倒な作業です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="f21f5-110">共通言語ランタイム (CLR) では、完全なマネージド コードを作成できるという十分に強力な保証は簡単には得られません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="f21f5-111">ASP.NET とは異なり、SQL Server で使用されているプロセスは 1 つだけであり、受け入れられないほど長い時間データベースを停止させない限りリサイクルできません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="f21f5-112">このように強力な保証がなく、単一プロセスで実行されている場合の信頼性は、必要なときにスレッドを終了するか、アプリケーション ドメインをリサイクルすること、および予防策を設けてハンドルやメモリなどのオペレーティング システム リソースがリークしないようにすることに基づきます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="f21f5-113">このような単純な信頼性の制約であっても、大きな信頼性の要件があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="f21f5-114">オペレーティング システムのリソースがリークしないこと。</span><span class="sxs-lookup"><span data-stu-id="f21f5-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="f21f5-115">CLR に対するすべてのフォームにおいてすべてのマネージド ロックを識別すること。</span><span class="sxs-lookup"><span data-stu-id="f21f5-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="f21f5-116">アプリケーション間のドメイン共有状態を壊すことなく、<xref:System.AppDomain> のリサイクルが円滑に機能すること。</span><span class="sxs-lookup"><span data-stu-id="f21f5-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="f21f5-117"><xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException>、<xref:System.OutOfMemoryException> の各例外を処理するマネージド コードを記述することは理論的には可能ですが、アプリケーション全体でそのような堅牢なコードを記述することを開発者に期待するのは無謀です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="f21f5-118">そのため、帯域外の例外では実行中のスレッドが終了します。また、終了したスレッドが共有の状態を編集していた場合は (これは、スレッドがロックを保持しているかどうかで判断できます)、<xref:System.AppDomain> がアンロードされます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="f21f5-119">共有状態を編集しているメソッドが終了された場合、共有状態の更新に対する信頼性の高いバックアウト コードを記述することはできないため、状態が破損します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="f21f5-120">.NET Framework バージョン 2.0 では、信頼性が必要なホストは SQL Server だけです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="f21f5-121">アセンブリが SQL Server で実行される場合は、データベースでの実行時には無効にされる特定の機能がある場合でも、そのアセンブリのすべての部分について信頼性の作業を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="f21f5-122">これが必要になるのは、コード分析エンジンはアセンブリ レベルでコードを調べるため、無効にされるコードを区別できないためです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="f21f5-123">SQL Server のプログラミングに関するもう 1 つの考慮事項は、SQL Server はすべての処理を 1 つのプロセスで実行し、メモリやオペレーティング システム ハンドルなどのすべてのリソースをクリーンアップするには <xref:System.AppDomain> のリサイクルが使われるということです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="f21f5-124">バックアウト コードでファイナライザー、デストラクター、または `try/finally` ブロックに依存することはできません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="f21f5-125">これらは、中断されたり呼び出されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="f21f5-126"><xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException>、<xref:System.OutOfMemoryException> などの非同期例外が、予期しない場所 (すべてのマシン命令) でスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="f21f5-127">マネージド スレッドは必ずしも SQL 内の Win32 スレッドではありません。ファイバーである可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="f21f5-128">プロセス全体またはアプリケーション間のドメイン変更可能な共有状態は、安全に変更することが特に困難であり、可能な限り避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="f21f5-129">メモリ不足の状況は SQL Server では珍しくありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="f21f5-130">SQL Server でホストされているライブラリが共有状態を正しく更新しない場合、データベースを再起動しないかぎりコードを復旧できない可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="f21f5-131">さらに、極端なケースでは、これにより SQL Server プロセスが失敗し、データベースが再起動する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="f21f5-132">データベースが再起動すると、Web サイトが停止したり、会社の運用に影響して、可用性が低下します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="f21f5-133">メモリやハンドルなどのオペレーティング システムのリソースがゆっくりリークすると、最終的にサーバーでのハンドルの割り当てが失敗して復旧できなかったり、サーバーのパフォーマンスが徐々に悪化して顧客のアプリケーションの可用性が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="f21f5-134">これらのシナリオを回避する必要があるのは明らかです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="f21f5-135">ベストプラクティスルール</span><span class="sxs-lookup"><span data-stu-id="f21f5-135">Best practice rules</span></span>

<span data-ttu-id="f21f5-136">概要では、フレームワークの安定性と信頼性を向上させるために、サーバーで実行されるマネージド コードのコード レビューで把握する必要があることに注目しました。</span><span class="sxs-lookup"><span data-stu-id="f21f5-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="f21f5-137">これらのチェックはすべて、一般的によいことであり、サーバーでは絶対に必要なことです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="f21f5-138">SQL Server は、デッド ロックやリソースの制約が発生すると、スレッドを中止するか、<xref:System.AppDomain> を破棄します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f21f5-139">その場合は、制約された実行領域 (CER) 内のバックアウト コードのみが実行を保証されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="f21f5-140">SafeHandle を使用してリソースリークを回避する</span><span class="sxs-lookup"><span data-stu-id="f21f5-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="f21f5-141"><xref:System.AppDomain> がアンロードされる状況では、`finally` ブロックまたはファイナライザーが実行されることに依存できないので、<xref:System.IntPtr>、<xref:System.Runtime.InteropServices.HandleRef>、または同様のクラスではなく、<xref:System.Runtime.InteropServices.SafeHandle> クラスを使用して、オペレーティング システムのすべてのリソース アクセスを抽象化することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="f21f5-142">これにより、<xref:System.AppDomain> が破棄されても、CLR は使われたハンドルを追跡して閉じることができます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="f21f5-143"><xref:System.Runtime.InteropServices.SafeHandle> は、CLR が常に実行するクリティカル ファイナライザーを使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="f21f5-144">オペレーティング システム ハンドルは、作成されてから解放されるまで、セーフ ハンドルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="f21f5-145"><xref:System.Threading.ThreadAbortException> が発生してハンドルをリークする可能性のある時間範囲はありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="f21f5-146">さらに、プラットフォームの呼び出しはハンドルを参照カウントするので、ハンドルの有効期間を詳細に追跡でき、`Dispose` と現在、ハンドルを使っているメソッドの間での競合状態によるセキュリティの問題を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="f21f5-147">現在、ファイナライザーを使ってオペレーティング システム ハンドルを単にクリーンアップしているほとんどのクラスは、ファイナライザーを使う必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="f21f5-148">代わりに、ファイナライザーは <xref:System.Runtime.InteropServices.SafeHandle> の派生クラスで呼び出されるようになります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="f21f5-149"><xref:System.Runtime.InteropServices.SafeHandle> は <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> の代わりに使う機能ではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="f21f5-150">依然としてリソース競合の可能性はあり、オペレーティング システムのリソースを明示的に破棄するとパフォーマンス上の利点があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="f21f5-151">リソースの明示的な破棄を行っている `finally` ブロックが最後まで実行されない可能性があることだけは理解しておいてください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="f21f5-152"><xref:System.Runtime.InteropServices.SafeHandle> を使うと、ハンドルを解放する処理 (オペレーティング システム ハンドル解放ルーチンに状態を渡す、ハンドルのセットをループで解放する、など) を実行する独自の <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> メソッドを実装できます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="f21f5-153">CLR はこのメソッドが実行されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="f21f5-154"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> の実装の作成者には、あらゆる状況においてハンドルが解放されることを保証する責任があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="f21f5-155">解放できないとハンドルがリークされ、多くの場合、ハンドルに関連付けられているネイティブ リソースがリークすることになります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="f21f5-156">したがって、<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> の実装が呼び出し時に使用できない可能性があるリソースの割り当てを必要としないように、<xref:System.Runtime.InteropServices.SafeHandle> 派生クラスを構成することが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="f21f5-157"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> の実装内で失敗する可能性があるメソッドの呼び出しは、コードがそのようなエラーを処理し、コントラクトを完了してネイティブ ハンドルを解放できる場合に限り、許容されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="f21f5-158">デバッグのため、<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> には、致命的なエラーが発生してリソースを解放できない場合に `false` に設定できる戻り値 <xref:System.Boolean> があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="f21f5-159">このようにすると、[releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA がアクティブ化されて (有効になっている場合)、問題を特定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="f21f5-160">他にはどのような影響もランタイムに与えません。<xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> は同じリソースに対して再び呼び出されることはなく、結果としてハンドルはリークされます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="f21f5-161"><xref:System.Runtime.InteropServices.SafeHandle> が適さない特定の状況があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="f21f5-162"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> メソッドは <xref:System.GC> ファイナライザー スレッドで実行できるので、特定のスレッドで解放する必要があるすべてのハンドルは、<xref:System.Runtime.InteropServices.SafeHandle> にラップされていてはなりません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="f21f5-163">ランタイム呼び出し可能ラッパー (RCW) は、コードを追加せずに CLR でクリーンアップできます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="f21f5-164">プラットフォーム呼び出しを使い、COM オブジェクトを `IUnknown*` または <xref:System.IntPtr> として扱うコードの場合は、RCW を使うようにコードを書き直す必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="f21f5-165">アンマネージド リリース メソッドがマネージド コードをコールバックする可能性があるため、このシナリオには <xref:System.Runtime.InteropServices.SafeHandle> は適していない場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-166">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-166">Code analysis rule</span></span>

<span data-ttu-id="f21f5-167">オペレーティング システムのリソースをカプセル化するには、<xref:System.Runtime.InteropServices.SafeHandle> を使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="f21f5-168"><xref:System.Runtime.InteropServices.HandleRef> または <xref:System.IntPtr> 型のフィールドは使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="f21f5-169">オペレーティングシステムリソースのリークを防ぐために、ファイナライザーを実行する必要がないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="f21f5-170">ファイナライザーを慎重に検討し、ファイナライザーが実行しない場合でも重要なオペレーティング システムのリソースがリークされないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="f21f5-171">アプリケーションが安定した状態で実行しているとき、または SQL Server などのサーバーがシャットダウンするときの、通常の <xref:System.AppDomain> のアンロードとは異なり、<xref:System.AppDomain> の突然のアンロードでは、オブジェクトの終了処理は行われません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="f21f5-172">アンロードが突然行われる場合は、アプリケーションの正しさは保証できませんが、リソースをリークしないことでサーバーの整合性を保持する必要があるため、リソースがリークされないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="f21f5-173">オペレーティング システムのリソースを解放するには、<xref:System.Runtime.InteropServices.SafeHandle> を使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="f21f5-174">オペレーティングシステムリソースのリークを防ぐために、finally 句を実行する必要がないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="f21f5-175">`finally` 句が CER の外部で実行される保証はないので、ライブラリ開発者はアンマネージ リソースを解放するために `finally` ブロック内のコードに依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="f21f5-176"><xref:System.Runtime.InteropServices.SafeHandle> を使うのが推奨される解決策です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-177">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-177">Code analysis rule</span></span>

<span data-ttu-id="f21f5-178">`Finalize` の代わりに、<xref:System.Runtime.InteropServices.SafeHandle> を使ってオペレーティング システムのリソースをクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="f21f5-179"><xref:System.IntPtr> を使わないでください。リソースをカプセル化するには <xref:System.Runtime.InteropServices.SafeHandle> を使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="f21f5-180">finally 句を実行する必要がある場合は、CER 内に配置します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="f21f5-181">すべてのロックは、既存のマネージロックコードを通過する必要があります</span><span class="sxs-lookup"><span data-stu-id="f21f5-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="f21f5-182">CLR は、スレッドの単なる中止ではなく、<xref:System.AppDomain> のティアダウンが必要な場合を知るため、コードがロック状態であることを認識する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="f21f5-183">スレッドの中止は、スレッドで使われているデータが不整合な状態のままになる可能性があるため、危険な場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="f21f5-184">したがって、<xref:System.AppDomain> 全体をリサイクルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="f21f5-185">ロックを識別できないと、デッドロックまたは不適切な結果になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="f21f5-186">ロック領域を識別するには、<xref:System.Threading.Thread.BeginCriticalRegion%2A> および <xref:System.Threading.Thread.EndCriticalRegion%2A> メソッドを使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="f21f5-187">これらは <xref:System.Threading.Thread> クラスの静的メソッドであり、現在のスレッドにのみ適用され、あるスレッドのロック カウントを別のスレッドが編集するのを防ぐのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="f21f5-188">これらのメソッドを使う [lock ステートメント](../../csharp/language-reference/keywords/lock-statement.md)を使うだけでなく、この CLR 通知が組み込まれている <xref:System.Threading.Monitor.Enter%2A> および <xref:System.Threading.Monitor.Exit%2A> を使うこともお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="f21f5-189">スピン ロックや <xref:System.Threading.AutoResetEvent> などの他のロック メカニズムは、これらのメソッドを呼び出して、クリティカルなセクションに入ったことを CLR に通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="f21f5-190">これらのメソッドはロックを取得しません。コードがクリティカル セクションで実行していて、スレッドを中止すると共有状態の一貫性がなくなることを、CLR に通知します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="f21f5-191">カスタム <xref:System.Threading.ReaderWriterLock> クラスなどの独自のロックの種類を定義している場合は、これらのロック カウント メソッドを使います。</span><span class="sxs-lookup"><span data-stu-id="f21f5-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-192">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-192">Code analysis rule</span></span>

<span data-ttu-id="f21f5-193"><xref:System.Threading.Thread.BeginCriticalRegion%2A> および <xref:System.Threading.Thread.EndCriticalRegion%2A> を使ってすべてのロックをマークして識別します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="f21f5-194">ループでは <xref:System.Threading.Interlocked.CompareExchange%2A>、<xref:System.Threading.Interlocked.Increment%2A>、および <xref:System.Threading.Interlocked.Decrement%2A> を使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="f21f5-195">これらのメソッドの Win32 バリエーションのプラットフォーム呼び出しは行わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="f21f5-196">ループでは <xref:System.Threading.Thread.Sleep%2A> を使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="f21f5-197">volatile フィールドを使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="f21f5-198">クリーンアップコードは、catch の後ではなく、finally ブロックまたは catch ブロック内になければなりません</span><span class="sxs-lookup"><span data-stu-id="f21f5-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="f21f5-199">クリーンアップ コードは、`catch` ブロックの後ではなく、`finally` または `catch` ブロック自体の中に置く必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="f21f5-200">これは普通に推奨される方法です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-200">This should be a normal good practice.</span></span> <span data-ttu-id="f21f5-201">`finally` ブロックは、例外がスローされたときと、`try` ブロックが正常に終了したときの両方で同じコードが実行されるため、一般に優先される方法です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="f21f5-202"><xref:System.Threading.ThreadAbortException> などの予期しない例外がスローされた場合は、クリーンアップ コードは実行されません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="f21f5-203">`finally` でクリーンアップするアンマネージ リソースをは、リークを防ぐため、できれば <xref:System.Runtime.InteropServices.SafeHandle> にラップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="f21f5-204">C# の `using` キーワードを効果的に使って、ハンドルなどのオブジェクトを破棄できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="f21f5-205"><xref:System.AppDomain> のリサイクルによってファイナライザー スレッドでリソースをクリーンアップできますが、それでもクリーンアップ コードを適切な場所に配置することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="f21f5-206">ロックを保持していないときにスレッドが非同期例外を受け取った場合、CLR は <xref:System.AppDomain> をリサイクルしないでスレッド自体を終了しようとすることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f21f5-207">リソースが早期にクリーンアップされるようにすると、リソースの可用性が高くなり、有効期間が適切に管理されるようになる利点があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="f21f5-208">エラー コード パスでファイルへのハンドルを明示的に閉じず、<xref:System.Runtime.InteropServices.SafeHandle> ファイナライザーがクリーンアップするのを待った場合、次にコードがそれを実行したときに、ファイナライザーがまだ実行していないと、まったく同じファイルへのアクセスが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="f21f5-209">このため、確実にクリーンアップ コードが存在して正しく機能するようにすることは、絶対に必要なことではありませんが、障害からよりクリーンかつ迅速に復旧するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-210">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-210">Code analysis rule</span></span>

<span data-ttu-id="f21f5-211">`catch` の後のクリーンアップ コードは、`finally` ブロック内に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="f21f5-212">dispose の呼び出しは finally ブロック内に置きます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="f21f5-213">`catch` ブロックは、スローまたは再スローで終了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="f21f5-214">例外はありますが (多数の例外のいずれかを取得する可能性があるときにネットワーク接続を確立できるかどうかを検出するコードなど)、通常の状況で複数の例外をキャッチする必要があるコードでは、コードをテストしてそれが成功するかどうかを確認する必要があることを示すようにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="f21f5-215">アプリケーションドメイン間でプロセス全体の変更可能な共有状態を削除するか、制約された実行領域を使用する必要があります</span><span class="sxs-lookup"><span data-stu-id="f21f5-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="f21f5-216">概要で説明したように、アプリケーション ドメイン間でプロセス全体の共有状態を確実な方法で監視するマネージド コードを記述するのは非常に困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="f21f5-217">プロセス全体の共有状態は、Win32 コード、CLR 内、またはリモート処理を使うマネージド コードにおいて、アプリケーション ドメイン間で共有される何らかの種類のデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="f21f5-218">変更可能な共有状態をマネージド コードで正確に記述するのは非常に困難であり、静的な共有は細心の注意を払うことによってのみ実現できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="f21f5-219">プロセス全体またはコンピューター全体の共有状態がある場合は、それを使わないで済む方法を探すか、制約された実行領域 (CER) を使って共有状態を保護するようにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="f21f5-220">共有状態の識別と修正が行われていないライブラリでは、<xref:System.AppDomain> のクリーンなアンロードを必要とする SQL Server などのホストがクラッシュする可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="f21f5-221">コードが COM オブジェクトを使っている場合は、アプリケーション ドメイン間でその COM オブジェクトを共有しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="f21f5-222">ロックは、プロセス全体またはアプリケーションドメイン間で機能しません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="f21f5-223">以前は、<xref:System.Threading.Monitor.Enter%2A> および [lock ステートメント](../../csharp/language-reference/keywords/lock-statement.md)は、グローバルなプロセス ロックの作成に使われていました。</span><span class="sxs-lookup"><span data-stu-id="f21f5-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="f21f5-224">たとえば、これは、非共有アセンブリからの <xref:System.Type> インスタンスなどの <xref:System.AppDomain> のアジャイル クラス、<xref:System.Threading.Thread> オブジェクト、インターン処理された文字列、およびリモート処理を使ってアプリケーション ドメイン間で共有される文字列でのロック時に発生します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="f21f5-225">これらのロックはプロセス全体ではなくなりました。</span><span class="sxs-lookup"><span data-stu-id="f21f5-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="f21f5-226">プロセス全体にわたるアプリケーション間ドメイン ロックの存在を識別するには、ロック内のコードが、ディスク上のファイルやデータベースなどの、外部の永続リソースを使っているかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="f21f5-227">保護されたコードが外部リソースを使っている場合、そのコードが複数のアプリケーション ドメインで同時に実行することがあるため、<xref:System.AppDomain> 内でロックを取得すると問題が発生する可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="f21f5-228">これは、1 つのログ ファイルへの書き込み、またはプロセス全体のソケットへのバインドで、問題になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="f21f5-229">これらの変更は、名前付きの <xref:System.Threading.Mutex> または <xref:System.Threading.Semaphore> インスタンスを使う以外に、マネージド コードを使ってプロセスのグローバルなロックを取得する簡単な方法はないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="f21f5-230">2 つのアプリケーション ドメインで同時に実行しないコードを作成するか、<xref:System.Threading.Mutex> または <xref:System.Threading.Semaphore> クラスを使ってください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="f21f5-231">既存のコードを変更できない場合は、この同期を実現するために Win32 名前付きミューテックスを使わないでください。なぜなら、ファイバー モードで実行するということは、同じオペレーティング システム スレッドでミューテックスを取得して解放することが保証されないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="f21f5-232">アンマネージド コードを使ってロックを同期するのではなく、マネージド <xref:System.Threading.Mutex> クラス、または名前付きの <xref:System.Threading.ManualResetEvent>、<xref:System.Threading.AutoResetEvent>、または <xref:System.Threading.Semaphore> を使って、CLR が認識する方法でコード ロックを同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="f21f5-233">lock(typeof(MyType)) を使わない</span><span class="sxs-lookup"><span data-stu-id="f21f5-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="f21f5-234">すべてのアプリケーション ドメイン間でコードのただ 1 つのコピーが共有される共有アセンブリのプライベートおよびパブリックの <xref:System.Type> オブジェクトでも、問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="f21f5-235">共有アセンブリの場合、プロセスごとに <xref:System.Type> のインスタンスが 1 つだけ存在し、これは複数のアプリケーション ドメインがまったく同じ <xref:System.Type> インスタンスを共有することを意味します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="f21f5-236"><xref:System.Type> のインスタンスでロックを取得すると、その <xref:System.AppDomain> だけでなく、プロセス全体に影響するロックが取得されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f21f5-237">ある <xref:System.AppDomain> が <xref:System.Type> オブジェクトでロックを取得した後、そのスレッドが突然中止されると、ロックは解放されません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="f21f5-238">その後、このロックにより、他のアプリケーション ドメインでデッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="f21f5-239">静的メソッドでロックを取得するよい方法は、静的な内部同期オブジェクトをコードに追加することです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="f21f5-240">これは、クラス コンストラクターが存在する場合はそれで初期化できますが、存在しない場合は次のようにして初期化できます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="f21f5-241">その後、ロックを取得するときは、`InternalSyncObject` プロパティを使ってロックするオブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="f21f5-242">クラス コンストラクターで内部同期オブジェクトを初期化した場合は、プロパティを使う必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="f21f5-243">二重チェックを行うロック初期化コードの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="f21f5-244">Lock (this) に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f21f5-244">A note about lock(this)</span></span>

<span data-ttu-id="f21f5-245">一般に、パブリックにアクセスできる個々のオブジェクトでロックを取得することは認められます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="f21f5-246">しかし、オブジェクトがサブシステム全体のデッドロックを引き起こす可能性のあるシングルトン オブジェクトである場合は、前述のデザイン パターンの使用も検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="f21f5-247">たとえば、1 つの <xref:System.Security.SecurityManager> オブジェクトでのロックにより、<xref:System.AppDomain> 内でデッドロックが発生し、<xref:System.AppDomain> 全体が使用できなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="f21f5-248">この種のパブリックにアクセスできるオブジェクトではロックを取得しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="f21f5-249">ただし、個別のコレクションまたは配列でのロックの場合は、一般に問題になりません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-250">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-250">Code analysis rule</span></span>

<span data-ttu-id="f21f5-251">アプリケーション ドメイン間で使われる可能性がある型では、ロックを取得しないでください。または、ID を強く意識しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="f21f5-252"><xref:System.Type>、<xref:System.Reflection.MethodInfo>、<xref:System.Reflection.PropertyInfo>、<xref:System.String>、<xref:System.ValueType>、<xref:System.Threading.Thread>、または <xref:System.MarshalByRefObject> から派生するすべてのオブジェクトでは、<xref:System.Threading.Monitor.Enter%2A> を呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="f21f5-253">GC を削除します。KeepAlive 呼び出し</span><span class="sxs-lookup"><span data-stu-id="f21f5-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="f21f5-254">非常に多くの既存のコードが、使うべき時に <xref:System.GC.KeepAlive%2A> を使っていないか、または適切ではないときにそれを使っています。</span><span class="sxs-lookup"><span data-stu-id="f21f5-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="f21f5-255"><xref:System.Runtime.InteropServices.SafeHandle> に変換した後、ファイナライザーを使わずに、<xref:System.Runtime.InteropServices.SafeHandle> を使ってオペレーティング システム ハンドルの終了処理を行っている場合は、クラスで <xref:System.GC.KeepAlive%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="f21f5-256"><xref:System.GC.KeepAlive%2A> の呼び出しを残しておくことによるパフォーマンス コストはほんのわずかかもしれませんが、<xref:System.GC.KeepAlive%2A> の呼び出しが、もう存在していないかもしれない有効期間の問題を解決するために必要または十分なものであると意識することは、コードの保守を困難にします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="f21f5-257">ただし、COM 相互運用機能の CLR 呼び出し可能ラッパー (RCW) を使うコードでは、<xref:System.GC.KeepAlive%2A> がまだ必要です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-258">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-258">Code analysis rule</span></span>

<span data-ttu-id="f21f5-259"><xref:System.GC.KeepAlive%2A> を削除します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="f21f5-260">HostProtection 属性を使用する</span><span class="sxs-lookup"><span data-stu-id="f21f5-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="f21f5-261"><xref:System.Security.Permissions.HostProtectionAttribute> (HPA) を使うと、宣言型のセキュリティ アクションを使ってホストの保護要件を決定でき、ホストは完全に信頼されたコードが特定のホストに対して適切ではない特定のメソッド (SQL Server に対する <xref:System.Environment.Exit%2A> や <xref:System.Windows.Forms.MessageBox.Show%2A> など) を呼び出すのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="f21f5-262">HPA は、共通言語ランタイムをホストし、ホスト保護を実装している SQL Server などのアンマネージ アプリケーションにのみ影響します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="f21f5-263">HPA を適用すると、セキュリティ アクションはクラスまたはメソッドが公開するホスト リソースに基づいてリンク確認要求を作成します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="f21f5-264">コードがホスト保護されていないクライアント アプリケーションまたはサーバーで実行される場合、この属性は "消滅" します。つまり、検出されないため適用されません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f21f5-265">この属性の目的は、セキュリティ動作ではなく、ホスト固有のプログラミング モデルのガイドラインを強制することです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="f21f5-266">リンク確認要求はプログラミング モデルの要件への準拠を確認するために使われますが、<xref:System.Security.Permissions.HostProtectionAttribute> はセキュリティ アクセス許可ではありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="f21f5-267">ホストにプログラミング モデルの要件がない場合、リンク確認要求は発生しません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="f21f5-268">この属性は次のものを識別します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="f21f5-269">ホスト プログラミング モデルには適合しないが、それ以外の問題はないメソッドまたはクラス。</span><span class="sxs-lookup"><span data-stu-id="f21f5-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="f21f5-270">ホスト プログラミング モデルに適合せず、サーバーが管理するユーザー コードが不安定になる可能性があるメソッドまたはクラス。</span><span class="sxs-lookup"><span data-stu-id="f21f5-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="f21f5-271">ホスト プログラミング モデルに適合せず、サーバー プロセス自体が不安定になる可能性があるメソッドまたはクラス。</span><span class="sxs-lookup"><span data-stu-id="f21f5-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="f21f5-272">ホストで保護された環境で実行する可能性のあるアプリケーションによって呼び出されるクラス ライブラリを作成する場合は、<xref:System.Security.Permissions.HostProtectionResource> リソース カテゴリを公開するメンバーにこの属性を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="f21f5-273">この属性を持つ .NET Framework クラス ライブラリのメンバーについては、直前の呼び出し元だけがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="f21f5-274">カスタムのライブラリ メンバーについても、同じように直前の呼び出し元がチェックされるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="f21f5-275">HPA の詳細については、「<xref:System.Security.Permissions.HostProtectionAttribute>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-276">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-276">Code analysis rule</span></span>

<span data-ttu-id="f21f5-277">SQL Server の場合、同期またはスレッド化を導入するために使われるすべてのメソッドを、HPA で識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="f21f5-278">これには、状態を共有するメソッド、同期されるメソッド、または外部プロセスを管理するメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="f21f5-279">SQL Server に影響を与える <xref:System.Security.Permissions.HostProtectionResource> の値は、<xref:System.Security.Permissions.HostProtectionResource.SharedState>、<xref:System.Security.Permissions.HostProtectionResource.Synchronization>、および <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt> です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="f21f5-280">ただし、SQL に影響を与えるリソースを使うものだけでなく、いずれかの <xref:System.Security.Permissions.HostProtectionResource> を公開するすべてのメソッドを HPA によって識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="f21f5-281">アンマネージコードで無制限にブロックしない</span><span class="sxs-lookup"><span data-stu-id="f21f5-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="f21f5-282">マネージド コード内ではなくアンマネージド コード内でブロックすると、CLR がスレッドを中止できないため、サービス拒否攻撃を受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="f21f5-283">ブロックされたスレッドは、少なくとも一部の非常に安全でない操作を実行せずに、CLR が <xref:System.AppDomain> をアンロードするのを妨げます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="f21f5-284">Windows 同期プリミティブを使用したブロックは、許可できないことを明確に示したものです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="f21f5-285">ソケットでのの呼び出しでのブロックは、可能であれ `ReadFile` ば回避する必要があります。理想的には、WINDOWS API は、このような操作のためのメカニズムを提供することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="f21f5-286">ネイティブを呼び出すメソッドでは、合理的な有限のタイムアウトで Win32 呼び出しを使うのが理想的です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="f21f5-287">ユーザーがタイムアウトを指定できる場合は、何らかの特定のセキュリティ アクセス許可なしでは、ユーザーが無限のタイムアウトを指定できないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="f21f5-288">ガイドラインとしては、メソッドが 10 秒以上ブロックする場合は、タイムアウトをサポートするバージョンを使うか、CLR のサポートを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="f21f5-289">問題のある Api の例をいくつか次に示します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="f21f5-290">パイプ (匿名と名前付きのどちらも) はタイムアウトを指定して作成できます。ただし、コードでは、NMPWAIT_WAIT_FOREVER を指定して `CreateNamedPipe` と `WaitNamedPipe` を呼び出さないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="f21f5-291">さらに、タイムアウトを指定した場合でも、予期しないブロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="f21f5-292">匿名パイプで `WriteFile` を呼び出すと、すべてのバイトが書き込まれるまでブロックします。つまり、バッファーに読み取られていないデータがある場合、リーダーがパイプのバッファー内の領域を解放するまで、`WriteFile` の呼び出しをブロックします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="f21f5-293">ソケットでは、タイムアウト メカニズムを優先する API を常に使う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-294">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-294">Code analysis rule</span></span>

<span data-ttu-id="f21f5-295">アンマネージ コードでのタイムアウトのないブロックは、サービス拒否攻撃です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="f21f5-296">`WaitForSingleObject`、`WaitForSingleObjectEx`、`WaitForMultipleObjects`、`MsgWaitForMultipleObjects`、および `MsgWaitForMultipleObjectsEx` のプラットフォーム呼び出しは実行しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="f21f5-297">NMPWAIT_WAIT_FOREVER は使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="f21f5-298">STA に依存する機能を特定する</span><span class="sxs-lookup"><span data-stu-id="f21f5-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="f21f5-299">COM シングルスレッド アパートメント (STA) を使用するコードを明らかにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="f21f5-300">SQL Server プロセスでは STA は無効になります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="f21f5-301">パフォーマンス カウンターやクリップボードなどの `CoInitialize` に依存する機能は、SQL Server 内では無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="f21f5-302">ファイナライザーに同期の問題がないことを確認する</span><span class="sxs-lookup"><span data-stu-id="f21f5-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="f21f5-303">.NET Framework の将来のバージョンでは、複数のファイナライザー スレッドが存在する可能性があります。つまり、同じ型の異なるインスタンスのファイナライザーが同時に実行します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="f21f5-304">これらは、完全にスレッド セーフである必要はありません。ガベージ コレクターが、ただ 1 つのスレッドで特定のオブジェクト インスタンスのファイナライザーが実行されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="f21f5-305">ただし、複数の異なるオブジェクト インスタンスで同時に実行するときの競合状態やデッドロックを回避するように、ファイナライザーをコーディングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="f21f5-306">ログ ファイルへの書き込みなどの外部状態をファイナライザーで使う場合は、スレッド処理の問題に対処する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="f21f5-307">終了処理に依存してスレッド セーフを提供しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="f21f5-308">マネージドまたはネイティブのスレッド ローカル記憶域を使って、ファイナライザー スレッドに状態を保存しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-309">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-309">Code analysis rule</span></span>

<span data-ttu-id="f21f5-310">ファイナライザーには同期の問題が存在していない必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="f21f5-311">静的な変更可能状態をファイナライザーで使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="f21f5-312">可能な場合はアンマネージメモリを使用しない</span><span class="sxs-lookup"><span data-stu-id="f21f5-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="f21f5-313">オペレーティング システム ハンドルと同じように、アンマネージ メモリはリークする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="f21f5-314">可能であれば、[stackalloc](../../csharp/language-reference/operators/stackalloc.md) を使ってスタック上のメモリを使うか、[fixed ステートメント](../../csharp/language-reference/keywords/fixed-statement.md) や byte[] を使う <xref:System.Runtime.InteropServices.GCHandle> などの固定されたマネージド オブジェクトを使うようにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="f21f5-315">最終的には <xref:System.GC> がこれらをクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="f21f5-316">ただし、アンマネージ メモリを割り当てる必要がある場合は、<xref:System.Runtime.InteropServices.SafeHandle> から派生するクラスを使ってメモリの割り当てをラップすることを考えます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="f21f5-317"><xref:System.Runtime.InteropServices.SafeHandle> が適切ではないケースが少なくとも 1 つあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="f21f5-318">メモリの割り当てや解放を行う COM メソッド呼び出しでは、1 つの DLL が `CoTaskMemAlloc` を使ってメモリを割り当てた後、別の DLL が `CoTaskMemFree` でそのメモリを解放するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="f21f5-319">これらの場所で <xref:System.Runtime.InteropServices.SafeHandle> を使うのは、他の DLL がメモリの有効期間を制御できるようにする代わりに、アンマネージ メモリの有効期間を <xref:System.Runtime.InteropServices.SafeHandle> の有効期間に結び付けようとするため不適切です。</span><span class="sxs-lookup"><span data-stu-id="f21f5-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="f21f5-320">Catch (Exception) のすべての使用を確認する</span><span class="sxs-lookup"><span data-stu-id="f21f5-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="f21f5-321">1 つの特定の例外ではなくすべての例外をキャッチする catch ブロックは、非同期例外もキャッチするようになります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="f21f5-322">すべての catch(Exception) ブロックを調べて、スキップされる可能性のある重要ではないリソース解放やバックアウト コード、および <xref:System.Threading.ThreadAbortException>、<xref:System.StackOverflowException>、<xref:System.OutOfMemoryException> の処理に関する catch ブロック自体の内部での不適切な可能性のある動作を探します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="f21f5-323">このコードでは、特定の例外だけを認識できる、または例外が発生したときは常に厳密に特定の 1 つの理由で失敗するということが、ログに記録されたり、想定されたりしている可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="f21f5-324">これらの想定は、<xref:System.Threading.ThreadAbortException> を含むように更新することが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="f21f5-325">すべての例外をキャッチするようになっているすべての場所を、スローされると予想される特定の種類の例外だけをキャッチするように変更することを検討してください (文字列書式設定メソッドからの <xref:System.FormatException> など)。</span><span class="sxs-lookup"><span data-stu-id="f21f5-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="f21f5-326">このようにすると、catch ブロックが予期しない例外で実行されることがなくなり、予期しない例外をキャッチすることでコードのバグが非表示にされなくなります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="f21f5-327">一般的なルールとして、ライブラリ コードでは例外を処理しないでください (例外をキャッチする必要があるコードが、呼び出しているコード内の設計上の欠陥を示す可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="f21f5-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="f21f5-328">場合によっては、例外をキャッチし、異なる例外の種類をスローすることで、より多くのデータを提供できることがあります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="f21f5-329">このような場合は入れ子になった例外を使い、エラーの実際の原因を新しい例外の <xref:System.Exception.InnerException%2A> プロパティに格納します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-330">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-330">Code analysis rule</span></span>

<span data-ttu-id="f21f5-331">すべてのオブジェクトまたはすべての例外をキャッチしているマネージド コード内のすべての catch ブロックを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="f21f5-332">C# では、これはとの両方にフラグを行うことを意味し `catch` {} `catch(Exception)` {} ます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="f21f5-333">例外の種類を非常に限定的にすることを考えます。または、コードを調べて、予期しない例外の種類をキャッチした場合に不適切に動作しないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="f21f5-334">マネージスレッドが Win32 スレッドであることを想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="f21f5-335">マネージド スレッド ローカル記憶域は動作しますが、アンマネージド スレッド ローカル記憶域を使うこと、またはコードが現在のオペレーティング システム スレッドで再び実行されると想定することはできません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="f21f5-336">スレッドのロケールなどの設定を変更しないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="f21f5-337">プラットフォーム呼び出しでは `InitializeCriticalSection` または `CreateMutex` を呼び出さないでください。これらでは、ロックを開始したオペレーティング システム スレッドがロックを終了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="f21f5-338">ファイバーを使うとこれは該当しないので、Win32 のクリティカル セクションおよびミューテックスを SQL で直接使うことはできません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="f21f5-339">マネージド <xref:System.Threading.Mutex> クラスはこれらのスレッドのアフィニティに関する注意事項を処理しないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="f21f5-340">マネージド スレッド ローカル記憶域やスレッドの現在の UI カルチャなど、マネージド <xref:System.Threading.Thread> オブジェクトのほとんどの状態は安全に使うことができます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="f21f5-341">また、<xref:System.ThreadStaticAttribute> を使うこともできます。これは、既存の静的変数の値を、現在のマネージド スレッドによってのみアクセスできるようにします (これは、CLR でファイバー ローカル記憶域を行うもう 1 つの方法です)。</span><span class="sxs-lookup"><span data-stu-id="f21f5-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="f21f5-342">プログラミング モデルの理由から、SQL で実行しているときは、スレッドの現在のカルチャを変更できません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-343">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-343">Code analysis rule</span></span>

<span data-ttu-id="f21f5-344">SQL Server はファイバー モードで実行します。スレッド ローカル記憶域は使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="f21f5-345">`TlsAlloc`、`TlsFree`、`TlsGetValue`、および `TlsSetValue.` のプラットフォーム呼び出しを行わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="f21f5-346">偽装 SQL Server 処理する</span><span class="sxs-lookup"><span data-stu-id="f21f5-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="f21f5-347">偽装はスレッド レベルで動作し、SQL が実行できるのはファイバー モードなので、マネージド コードはユーザーを偽装してはならず、`RevertToSelf` を呼び出してはなりません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-348">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-348">Code analysis rule</span></span>

<span data-ttu-id="f21f5-349">SQL Server に偽装を処理させるようにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="f21f5-350">`RevertToSelf`、`ImpersonateAnonymousToken`、`DdeImpersonateClient`、`ImpersonateDdeClientWindow`、`ImpersonateLoggedOnUser`、`ImpersonateNamedPipeClient`、`ImpersonateSelf`、`RpcImpersonateClient`、`RpcRevertToSelf`、`RpcRevertToSelfEx`、`SetThreadToken` は使わないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="f21f5-351">Thread:: Suspend を呼び出さないでください</span><span class="sxs-lookup"><span data-stu-id="f21f5-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="f21f5-352">スレッドを一時停止させる機能は単純な操作のように見えますが、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="f21f5-353">ロックを保持しているスレッドが第 2 のスレッドによって一時停止された後、第 2 のスレッドが同じロックを取得しようとすると、デッドロックが発生します。</span><span class="sxs-lookup"><span data-stu-id="f21f5-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="f21f5-354">現在、<xref:System.Threading.Thread.Suspend%2A> はセキュリティ、クラスの読み込み、リモート処理、およびリフレクションを妨げる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f21f5-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f21f5-355">コード分析規則</span><span class="sxs-lookup"><span data-stu-id="f21f5-355">Code analysis rule</span></span>

<span data-ttu-id="f21f5-356"><xref:System.Threading.Thread.Suspend%2A> を呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="f21f5-357">代わりに <xref:System.Threading.Semaphore> や <xref:System.Threading.ManualResetEvent> などの実際の同期プリミティブの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="f21f5-358">制約された実行領域と信頼性のコントラクトで重要な操作を保護する</span><span class="sxs-lookup"><span data-stu-id="f21f5-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="f21f5-359">共有状態を更新する複雑な操作、または完全に成功するか完全に失敗することが確定的に必要な複雑な操作を実行するときは、制約された実行領域 (CER) によって保護されるようにします。</span><span class="sxs-lookup"><span data-stu-id="f21f5-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="f21f5-360">これにより、スレッドの突然の中止や突然の <xref:System.AppDomain> のアンロードなど、すべてのケースでコードが実行されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="f21f5-361">CER は、<xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> の呼び出しが直前にある特定の `try/finally` ブロックです。</span><span class="sxs-lookup"><span data-stu-id="f21f5-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="f21f5-362">このようにすると、`try` ブロックを実行する前に finally ブロック内のすべてのコードを準備するよう、Just-In-Time コンパイラに指示されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="f21f5-363">これにより、finally ブロック内のコードがすべてのケースでビルドされて実行されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="f21f5-364">CER では空の `try` ブロックを使うことが珍しくありません。</span><span class="sxs-lookup"><span data-stu-id="f21f5-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="f21f5-365">CER を使うと、非同期スレッドの中止およびメモリ不足例外に対して保護されます。</span><span class="sxs-lookup"><span data-stu-id="f21f5-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="f21f5-366">非常に深いコードに対するスタック オーバーフローを追加で処理する CER の形式については、「<xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f21f5-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="f21f5-367">関連項目</span><span class="sxs-lookup"><span data-stu-id="f21f5-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="f21f5-368">SQL Server プログラミングとホスト保護属性</span><span class="sxs-lookup"><span data-stu-id="f21f5-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
