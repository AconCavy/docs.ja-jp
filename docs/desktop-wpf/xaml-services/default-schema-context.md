---
title: 既定の XAML スキーマ コンテキストと WPF XAML スキーマ コンテキスト
ms.date: 03/30/2017
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
ms.openlocfilehash: 2e92372de61230a98a02282cc28fc3f479cd94eb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433080"
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="88793-102">既定の XAML スキーマ コンテキストと WPF XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="88793-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="88793-103">XAML スキーマ コンテキストは、特定の XAML ボキャブラリを使用する XAML の運用環境がオブジェクトの書き込み動作とどのように相互作用するかを修飾する概念エンティティです。</span><span class="sxs-lookup"><span data-stu-id="88793-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="88793-104">このトピックでは、.NET XAML サービスの機能と、CLR 型システムに基づく関連する既定の XAML スキーマ コンテキストについて説明します。</span><span class="sxs-lookup"><span data-stu-id="88793-104">This topic describes the features of .NET XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="88793-105">このトピックでは、WPF で使用される XAML スキーマ コンテキストについても説明します。</span><span class="sxs-lookup"><span data-stu-id="88793-105">This topic also describes the XAML schema context that is used for WPF.</span></span>

## <a name="default-xaml-schema-context"></a><span data-ttu-id="88793-106">既定の XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="88793-106">Default XAML Schema Context</span></span>

<span data-ttu-id="88793-107">.NET XAML サービスは、既定の XAML スキーマ コンテキストを実装し、使用します。</span><span class="sxs-lookup"><span data-stu-id="88793-107">.NET XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="88793-108">既定の XAML スキーマ コンテキストの動作は、クラスの API<xref:System.Xaml.XamlSchemaContext>で常に完全に表示されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="88793-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="88793-109">ただし、多くの場合、既定の XAML スキーマ コンテキストが影響する動作は、XAML 型システムの共通 API (メンバー<xref:System.Xaml.XamlMember>や<xref:System.Xaml.XamlType>など) を通じて、または既定の XAML スキーマ コンテキストを使用する XAML リーダーや XAML ライターに公開された API を通じて観察できます。</span><span class="sxs-lookup"><span data-stu-id="88793-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>

<span data-ttu-id="88793-110">コンストラクターを呼び<xref:System.Xaml.XamlSchemaContext>出すことによって、既定の動作をカプセル化<xref:System.Xaml.XamlSchemaContext>する を作成できます。</span><span class="sxs-lookup"><span data-stu-id="88793-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="88793-111">これにより、既定の XAML スキーマ コンテキストが明示的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="88793-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="88793-112">入力パラメーターを明示的に受け取らない API を使用して XAML リーダーまたは XAML ライターを初期化した場合、同<xref:System.Xaml.XamlSchemaContext>じ既定の XAML スキーマ コンテキストが暗黙的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="88793-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>

<span data-ttu-id="88793-113">既定の XAML スキーマ コンテキストは、型マッピングの動作に CLR リフレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="88793-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="88793-114">これには、定義する CLR<xref:System.Type>と関連<xref:System.Reflection.PropertyInfo>する<xref:System.Reflection.MethodInfo>の検証が含まれます。</span><span class="sxs-lookup"><span data-stu-id="88793-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="88793-115">また、型またはメンバーに対する CLR 属性は、CLR バッキング型を使用する XAML 型または XAML メンバー情報の詳細を入力するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="88793-116">既定の XAML スキーマ コンテキストでは、`Invoker`必要な情報が CLR 型システムから取得できるため、パターンなどの型システム拡張手法は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="88793-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>

<span data-ttu-id="88793-117">アセンブリ読み込みロジックの場合、既定の XAML スキーマ コンテキストは、主に XAML 名前空間マッピングで提供されるアセンブリ値に依存します。</span><span class="sxs-lookup"><span data-stu-id="88793-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="88793-118">また、<xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A>内部型の読み込みなどのシナリオで、読み込むアセンブリをヒントにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="88793-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>

## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="88793-119">WPF XAML スキーマ コンテキスト</span><span class="sxs-lookup"><span data-stu-id="88793-119">WPF XAML Schema Context</span></span>

<span data-ttu-id="88793-120">WPF XAML スキーマ コンテキストは、WPF 実装が既定以外の XAML スキーマ コンテキストを実装することによって導入できる機能の種類の興味深い図を提供するため、このトピックで説明します。</span><span class="sxs-lookup"><span data-stu-id="88793-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="88793-121">また、XAML スキーマ コンテキストの概念は、WPF XAML に対応する WPF ドキュメントではあまり説明されていません。XAML スキーマ コンテキストで有効になる動作は、既定の XAML スキーマ コンテキストの動作に関する説明と統合されている場合にのみ、完全に理解できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="88793-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="88793-122">WPF XAML スキーマ コンテキストは、次の動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="88793-122">The WPF XAML schema context implements the following behavior.</span></span>

<span data-ttu-id="88793-123">**ルックアップのオーバーライド:** WPF には、属性を持たずに機能する XAML コンテンツ プロパティがある<xref:System.Windows.Markup.ContentPropertyAttribute>XAML 用のコンテンツ モデルがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="88793-123">**Lookup overrides:** WPF has a few content models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="88793-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>WPF のオーバーライドは、この動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="88793-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>

<span data-ttu-id="88793-125">**WPF 式の遅延:** WPF には、ランタイム コンテキストが使用可能になるまで値を遅延する式クラスがいくつか用意されています。</span><span class="sxs-lookup"><span data-stu-id="88793-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="88793-126">また、テンプレートの展開は、遅延テクニックに依存する実行時の動作です。</span><span class="sxs-lookup"><span data-stu-id="88793-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>

<span data-ttu-id="88793-127">**システムルックアップの最適化を入力します。** WPF には、数百の WPF 定義クラスを継承する基本クラス メンバー定義など、広範な XAML ボキャブラリとオブジェクト モデルがあります。</span><span class="sxs-lookup"><span data-stu-id="88793-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="88793-128">また、WPF 自体は複数のアセンブリに分散されます。</span><span class="sxs-lookup"><span data-stu-id="88793-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="88793-129">WPF では、参照テーブルやその他の手法を使用して、型の参照を最適化します。</span><span class="sxs-lookup"><span data-stu-id="88793-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="88793-130">これにより、既定の XAML スキーマ コンテキストと CLR ベースの型検索に対するパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="88793-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="88793-131">ルックアップ テーブルに型が存在しない場合、動作では既定の XAML スキーマ コンテキストに似た XAML スキーマ コンテキスト手法が使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>

<span data-ttu-id="88793-132">**拡張機能と Xaml メンバー拡張機能:** WPF では、プロパティの概念を依存関係プロパティと、ルーティング イベントを使用したイベントの概念を拡張します。</span><span class="sxs-lookup"><span data-stu-id="88793-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="88793-133">これらの概念を XAML 処理操作に対してより<xref:System.Xaml.XamlType>詳細<xref:System.Xaml.XamlMember>に表示できるように、WPF は、依存関係プロパティとルーティング イベントの特性を報告する内部プロパティを拡張および追加します。</span><span class="sxs-lookup"><span data-stu-id="88793-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>

### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="88793-134">WPF XAML スキーマ コンテキストへのアクセス</span><span class="sxs-lookup"><span data-stu-id="88793-134">Accessing the WPF XAML Schema Context</span></span>

<span data-ttu-id="88793-135">WPF<xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType>または<xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>に基づく XAML 手法を使用している場合、WPF XAML スキーマ コンテキストは、これらの XAML リーダーおよび XAML ライターの実装で既に使用されています。</span><span class="sxs-lookup"><span data-stu-id="88793-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>

<span data-ttu-id="88793-136">WPF XAML スキーマ コンテキストで初期化されない他の XAML リーダーまたは XAML ライターの実装を使用している場合は、 から作業 WPF XAML<xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>スキーマ コンテキストを取得できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="88793-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="88793-137">この値は、<xref:System.Xaml.XamlSchemaContext>を使用する他の API の初期化として使用できます。</span><span class="sxs-lookup"><span data-stu-id="88793-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="88793-138">たとえば、初期化を呼び<xref:System.Xaml.XamlXmlReader.%23ctor%2A>出して、WPF XAML スキーマ コンテキストを渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="88793-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="88793-139">または、XAML 型のシステム操作に WPF XAML スキーマ コンテキストを使用できます。</span><span class="sxs-lookup"><span data-stu-id="88793-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="88793-140">これには、<xref:System.Xaml.XamlType>または<xref:System.Xaml.XamlMember>の構築の初期化、または<xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>呼び出しが含まれます。</span><span class="sxs-lookup"><span data-stu-id="88793-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="88793-141">純粋な XAML ノード ストリームの観点から WPF XAML の特定の側面にアクセスする場合、WPF フレームワーク機能の一部がまだ機能していない可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="88793-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="88793-142">たとえば、コントロールの WPF テンプレートはまだ適用されていません。</span><span class="sxs-lookup"><span data-stu-id="88793-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="88793-143">したがって、実行時に完全なビジュアル ツリーが設定されるプロパティにアクセスすると、テンプレートを参照するプロパティ値のみが表示されることがあります。</span><span class="sxs-lookup"><span data-stu-id="88793-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="88793-144">WPF マークアップ拡張機能に提供されるサービス コンテキストは、ランタイム以外の状況から提供された場合は正確でない可能性があり、オブジェクト グラフを書き込もうとすると例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="88793-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>

## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="88793-145">XAML とアセンブリの読み込み</span><span class="sxs-lookup"><span data-stu-id="88793-145">XAML and Assembly Loading</span></span>

<span data-ttu-id="88793-146">XAML および .NET XAML サービスのアセンブリ読み込みは、 <xref:System.AppDomain>CLR で定義された概念の と統合されます。</span><span class="sxs-lookup"><span data-stu-id="88793-146">Assembly loading for XAML and .NET XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="88793-147">XAML スキーマ コンテキストでは、アセンブリを読み込む方法、または実行時またはデザイン時に型を検索する方法を<xref:System.AppDomain>、その他の要因の使用に基づいて解釈します。</span><span class="sxs-lookup"><span data-stu-id="88793-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="88793-148">ロジックは、XAML が XAML リーダーの緩い XAML であるか、XAML が DLL`XamlBuildTask`にコンパイルされているか、WPF によって生成された BAML`PresentationBuildTask`であるかによって少し異なります。</span><span class="sxs-lookup"><span data-stu-id="88793-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>

<span data-ttu-id="88793-149">WPF の XAML スキーマ コンテキストは、WPF アプリケーション モデルと統合<xref:System.AppDomain>され、WPF 実装の詳細である他の要素も使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>

#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="88793-150">XAML リーダー入力 (緩い XAML)</span><span class="sxs-lookup"><span data-stu-id="88793-150">XAML reader input (loose XAML)</span></span>

01. <span data-ttu-id="88793-151">XAML スキーマ コンテキストは、アプリケーション<xref:System.AppDomain>を反復処理し、最後に読み込まれたアセンブリから始まる名前のすべての側面に一致する既に読み込まれたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="88793-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="88793-152">一致が見つかった場合、そのアセンブリは解決に使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-152">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="88793-153">それ以外の場合は、CLR <xref:System.Reflection.Assembly> API に基づく次のいずれかの手法を使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="88793-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>

    - <span data-ttu-id="88793-154">名前がマッピングで修飾されている場合は、修飾<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>名を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

    - <span data-ttu-id="88793-155">前の手順が失敗した場合は、短い名前 (および存在する場合は公開<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>キー トークン) を使用して を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

    - <span data-ttu-id="88793-156">マッピングで名前が修飾されていない場合は、 を<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>

#### <a name="xamlbuildtask"></a><span data-ttu-id="88793-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="88793-157">XamlBuildTask</span></span>

<span data-ttu-id="88793-158">`XamlBuildTask`は、WCF (WCF) および Windows ワークフローファウンデーションで使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-158">`XamlBuildTask` is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</span></span>

<span data-ttu-id="88793-159">アセンブリ参照が常に`XamlBuildTask`完全に修飾されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="88793-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>

1. <span data-ttu-id="88793-160">修飾<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>名を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

2. <span data-ttu-id="88793-161">前の手順が失敗した場合は、短い名前 (および存在する場合は公開<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>キー トークン) を使用して を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="88793-162">バムラ (ビルドタスク)</span><span class="sxs-lookup"><span data-stu-id="88793-162">BAML (PresentationBuildTask)</span></span>

<span data-ttu-id="88793-163">BAML のアセンブリ読み込みには、BAML を含む初期アセンブリをコンポーネントとして読み込み、BAML プロダクションで参照される型の型バッキング アセンブリを読み込むという 2 つの側面があります。</span><span class="sxs-lookup"><span data-stu-id="88793-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>

##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="88793-164">初期マークアップのアセンブリ読み込み:</span><span class="sxs-lookup"><span data-stu-id="88793-164">Assembly load for initial markup:</span></span>

<span data-ttu-id="88793-165">マークアップを読み込むアセンブリへの参照は、常に修飾されない。</span><span class="sxs-lookup"><span data-stu-id="88793-165">The reference to the assembly to load the markup from is always unqualified.</span></span>

1. <span data-ttu-id="88793-166">WPF XAML スキーマ コンテキストは、WPF アプリケーション<xref:System.AppDomain>を反復処理し、最後に読み込まれたアセンブリから始めて、名前のすべての側面に一致する既に読み込まれたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="88793-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="88793-167">一致が見つかった場合、そのアセンブリは解決に使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-167">If a match is found, that assembly is used for resolution.</span></span>

2. <span data-ttu-id="88793-168">前の手順が失敗した場合は、短い名前 (および存在する場合は公開<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>キー トークン) を使用して を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="88793-169">BAML タイプによるアセンブリ参照:</span><span class="sxs-lookup"><span data-stu-id="88793-169">Assembly references by BAML types:</span></span>

<span data-ttu-id="88793-170">BAML の生産で使用される型のアセンブリ参照は、ビルド タスクの出力として常に完全修飾されます。</span><span class="sxs-lookup"><span data-stu-id="88793-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>

01. <span data-ttu-id="88793-171">WPF XAML スキーマ コンテキストは、WPF アプリケーション<xref:System.AppDomain>を反復処理し、最後に読み込まれたアセンブリから始めて、名前のすべての側面に一致する既に読み込まれたアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="88793-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="88793-172">一致が見つかった場合、そのアセンブリは解決に使用されます。</span><span class="sxs-lookup"><span data-stu-id="88793-172">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="88793-173">それ以外の場合は、次のいずれかの方法を使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="88793-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>

    - <span data-ttu-id="88793-174">修飾<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>名を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="88793-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>
  
    - <span data-ttu-id="88793-175">短い名前と公開キー トークンの組み合わせが BAML の読み込み元のアセンブリと一致する場合は、そのアセンブリを使用します。</span><span class="sxs-lookup"><span data-stu-id="88793-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>

    - <span data-ttu-id="88793-176">短縮名 + 公開鍵トークンを<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>使用して を呼び出す。</span><span class="sxs-lookup"><span data-stu-id="88793-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="88793-177">関連項目</span><span class="sxs-lookup"><span data-stu-id="88793-177">See also</span></span>

- [<span data-ttu-id="88793-178">XAML ノード ストリームの構造と概念について</span><span class="sxs-lookup"><span data-stu-id="88793-178">Understanding XAML Node Stream Structures and Concepts</span></span>](understanding-xaml-node-stream-structures-and-concepts.md)
