---
title: .NET XAML サービスで使用するカスタム型の定義
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433074"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="a64e0-102">.NET XAML サービスで使用するカスタム型を定義する</span><span class="sxs-lookup"><span data-stu-id="a64e0-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="a64e0-103">ビジネス オブジェクトであるカスタム型、または特定のフレームワークに依存しない型を定義する場合は、XAML に従うことができる特定のベスト プラクティスがあります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="a64e0-104">これらの方法に従うと、.NET XAML サービスとその XAML リーダーおよび XAML ライターは、型の XAML 特性を検出し、XAML 型システムを使用して XAML ノード ストリームで適切な表現を提供できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="a64e0-105">このトピックでは、型定義、メンバー定義、および型またはメンバーの CLR 属性に関するベスト プラクティスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="a64e0-106">XAML のコンストラクター パターンと型定義</span><span class="sxs-lookup"><span data-stu-id="a64e0-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="a64e0-107">XAML でオブジェクト要素としてインスタンス化するには、カスタム クラスが次の要件を満たしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="a64e0-108">カスタム クラスはパブリックである必要があり、パラメーターなしのパブリック コンストラクターを公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="a64e0-109">(構造に関する注意事項については、次のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="a64e0-110">カスタム クラスは、入れ子になったクラスであってはなりません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="a64e0-111">フルネーム パスに追加の "ドット" を指定すると、クラス名前空間の除算があいまいになり、添付プロパティなどの他の XAML 機能と干渉します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="a64e0-112">オブジェクトをオブジェクト要素としてインスタンス化できる場合、作成されたオブジェクトは、オブジェクトを基になる型として受け取るプロパティのプロパティ要素フォームに入力できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="a64e0-113">値コンバーターを有効にした場合、これらの基準を満たさない型にオブジェクト値を指定できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="a64e0-114">詳細については、「 [XAML の型コンバーターとマークアップ拡張機能](type-converters-and-markup-extensions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="a64e0-115">構造体</span><span class="sxs-lookup"><span data-stu-id="a64e0-115">Structures</span></span>

<span data-ttu-id="a64e0-116">構造体は、CLR 定義によって常に XAML で構築できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="a64e0-117">これは、CLR コンパイラが構造体のパラメーターなしのコンストラクターを暗黙的に作成するためです。</span><span class="sxs-lookup"><span data-stu-id="a64e0-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="a64e0-118">このコンストラクターは、すべてのプロパティ値を既定値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="a64e0-119">場合によっては、構造の既定の構築動作が望ましくないことがあります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="a64e0-120">これは、構造体が値を埋め、概念的に和集合として機能することを意図している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="a64e0-121">和集合として、含まれている値は相互に排他的な解釈を持つ可能性があるため、そのプロパティはいずれも設定可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="a64e0-122">WPF ボキャブラリのこのような構造の例<xref:System.Windows.GridLength>は です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="a64e0-123">このような構造体は、構造体値の異なる解釈またはモードを作成する文字列規則を使用して、値を属性形式で表現できるように型コンバーターを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="a64e0-124">構造体は、パラメーターなしのコンストラクターを使用してコード構築の同様の動作を公開する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="a64e0-125">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="a64e0-125">Interfaces</span></span>

<span data-ttu-id="a64e0-126">インターフェイスは、基になるメンバーの型として使用できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="a64e0-127">XAML 型システムは、割り当て可能なリストをチェックし、値として提供されるオブジェクトがインターフェイスに割り当てられることを期待します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="a64e0-128">関連する割り当て可能な型が XAML 構築要件をサポートしている限り、インターフェイスを XAML 型として表示する方法の概念はありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="a64e0-129">工場のメソッド</span><span class="sxs-lookup"><span data-stu-id="a64e0-129">Factory Methods</span></span>

<span data-ttu-id="a64e0-130">ファクトリ メソッドは、XAML 2009 の機能です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="a64e0-131">オブジェクトにはパラメーターなしのコンストラクターが必要であるという XAML 原則が変更されます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="a64e0-132">ファクトリ メソッドについては、この資料では説明しません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="a64e0-133">[「x:ファクトリメソッドディレクティブ](xfactorymethod-directive.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="a64e0-134">列挙</span><span class="sxs-lookup"><span data-stu-id="a64e0-134">Enumerations</span></span>

<span data-ttu-id="a64e0-135">列挙型には、XAML ネイティブ型の変換動作があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="a64e0-136">XAML で指定された列挙定数名は、基になる列挙型に対して解決され、列挙値を XAML オブジェクト ライターに返します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="a64e0-137">XAML では、適用された列挙体に対して<xref:System.FlagsAttribute>フラグ スタイルの使用法がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="a64e0-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="a64e0-138">詳細については[、「XAML 構文の詳細](../../framework/wpf/advanced/xaml-syntax-in-detail.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="a64e0-139">([詳細な XAML 構文](../../framework/wpf/advanced/xaml-syntax-in-detail.md)は WPF の対象に記述されていますが、そのトピックの情報のほとんどは、特定の実装フレームワークに固有ではない XAML に関連しています)。</span><span class="sxs-lookup"><span data-stu-id="a64e0-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="a64e0-140">メンバー定義</span><span class="sxs-lookup"><span data-stu-id="a64e0-140">Member Definitions</span></span>

<span data-ttu-id="a64e0-141">型は、XAML の使用に使用するメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="a64e0-142">型では、特定の型が XAML で使用できない場合でも、XAML で使用できるメンバーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="a64e0-143">これは、CLR 継承が原因で可能です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="a64e0-144">メンバーを継承する型が XAML の使用法を型としてサポートし、そのメンバーがその基になる型の XAML の使用法をサポートしているか、ネイティブ XAML 構文を使用できる場合、そのメンバーは XAML で使用可能です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="a64e0-145">Properties</span><span class="sxs-lookup"><span data-stu-id="a64e0-145">Properties</span></span>

<span data-ttu-id="a64e0-146">プロパティを、一般的な CLR`get`とアクセサー パターン`set`、および言語に適したキーワードを使用してパブリック CLR プロパティとして定義する場合、XAML 型システムは<xref:System.Xaml.XamlMember>、 および<xref:System.Xaml.XamlMember.IsReadPublic%2A>などの<xref:System.Xaml.XamlMember.IsWritePublic%2A>プロパティに対して提供される適切な情報をメンバとしてプロパティを報告できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="a64e0-147">特定のプロパティを適用することにより、テキスト構文を<xref:System.ComponentModel.TypeConverterAttribute>有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="a64e0-148">詳細については、「 [XAML の型コンバーターとマークアップ拡張機能](type-converters-and-markup-extensions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="a64e0-149">テキスト構文またはネイティブ XAML 変換が存在しない場合、マークアップ拡張機能の使用など、さらに間接参照がない場合は、(XAML 型システム<xref:System.Xaml.XamlMember.TargetType%2A>内の) プロパティの型は、ターゲット型を CLR 型として扱うことによって、XAML オブジェクト ライターにインスタンスを返すことができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="a64e0-150">XAML 2009 を使用する場合[、x:参照マークアップ拡張機能](xreference-markup-extension.md)は、前の考慮事項が満たされていない場合に値を提供するために使用できます。ただし、これは型定義の問題よりも使用上の問題です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="a64e0-151">events</span><span class="sxs-lookup"><span data-stu-id="a64e0-151">Events</span></span>

<span data-ttu-id="a64e0-152">イベントをパブリック CLR イベントとして定義すると、XAML 型システムは イベントを メンバー<xref:System.Xaml.XamlMember.IsEvent%2A>として`true`レポートできます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="a64e0-153">イベント ハンドラーの配線は、.NET XAML サービス機能の範囲内にありません。配線は、特定のフレームワークと実装に委なされます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="a64e0-154">メソッド</span><span class="sxs-lookup"><span data-stu-id="a64e0-154">Methods</span></span>

<span data-ttu-id="a64e0-155">メソッドのインライン コードは、既定の XAML 機能ではありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="a64e0-156">ほとんどの場合、XAML からメソッド メンバーを直接参照することはなく、XAML のメソッドの役割は、特定の XAML パターンをサポートする目的でのみ行われます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="a64e0-157">[x:ファクトリメソッドディレクティブ](xfactorymethod-directive.md)は例外です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="a64e0-158">フィールド</span><span class="sxs-lookup"><span data-stu-id="a64e0-158">Fields</span></span>

<span data-ttu-id="a64e0-159">CLR 設計ガイドラインでは、非静的フィールドを使用しません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="a64e0-160">静的フィールドの場合は、 x: Static[マークアップ拡張機能](xstatic-markup-extension.md)を使用して静的フィールド値にアクセスできます。この場合[、x:Static](xstatic-markup-extension.md)の使用用フィールドを公開するために、CLR 定義で特別な操作を行う必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="a64e0-161">アタッチ可能なメンバー</span><span class="sxs-lookup"><span data-stu-id="a64e0-161">Attachable Members</span></span>

<span data-ttu-id="a64e0-162">アタッチ可能なメンバーは、定義する型のアクセサー メソッド パターンを通じて XAML に公開されます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="a64e0-163">定義する型自体は、オブジェクトとして XAML で使用できる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="a64e0-164">実際には、アタッチ可能なメンバーを所有し、関連する動作を実装する役割を持つサービス クラスを宣言するが、UI 表現などの他の関数を提供しない一般的なパターンです。</span><span class="sxs-lookup"><span data-stu-id="a64e0-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="a64e0-165">次のセクションでは、プレースホルダー *PropertyName*はアタッチ可能なメンバーの名前を表します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="a64e0-166">この名前は[XamlName 文法](xamlname-grammar.md)で有効である必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="a64e0-167">これらのパターンと型の他のメソッドとの間の名前の衝突には注意してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="a64e0-168">パターンのいずれかに一致するメンバーが存在する場合、意図しなかった場合でも、XAML プロセッサによってアタッチ可能なメンバー使用経路として解釈できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="a64e0-169">アクセサー</span><span class="sxs-lookup"><span data-stu-id="a64e0-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="a64e0-170">アクセサーのシグネチャ`GetPropertyName`は次の指定が必要です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="a64e0-171">`target` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="a64e0-172">これを使用して、アタッチ可能なメンバーの使用をスコープに設定できます。目的のスコープ外での使用は、無効なキャスト例外をスローし、その後 XAML 解析エラーによって表示されます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="a64e0-173">パラメーター名`target`は必須ではありませんが、ほとんどの実装では慣例`target`で名前が付けられています。</span><span class="sxs-lookup"><span data-stu-id="a64e0-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="a64e0-174">戻り値は、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="a64e0-175">アタッチ可能な<xref:System.ComponentModel.TypeConverter>メンバーの属性の使用に対して有効なテキスト構文を<xref:System.ComponentModel.TypeConverterAttribute>サポートするには`GetPropertyName`、アクセサーに適用します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="a64e0-176">の`get`代わりに`set`適用することは直感的ではないようです。ただし、この規則では、シリアル化できる読み取り専用のアタッチ可能なメンバーの概念をサポートできます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="a64e0-177">アクセサー</span><span class="sxs-lookup"><span data-stu-id="a64e0-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="a64e0-178">アクセサーのシグネチャ`SetPropertyName`は次の指定が必要です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="a64e0-179">オブジェクト`target`は、前のセクションで説明したように、ロジックと結果を使用して、実装でより具体的な型として指定できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="a64e0-180">`value` オブジェクトは、実装のより具体的な型として指定することができます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="a64e0-181">このメソッドの値は、XAML の使用法からの入力であり、通常は属性形式であることを覚えておいてください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="a64e0-182">属性フォームから、テキスト構文の値コンバーターのサポートが必要です`GetPropertyName`。</span><span class="sxs-lookup"><span data-stu-id="a64e0-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="a64e0-183">アタッチ可能なメンバ ストア</span><span class="sxs-lookup"><span data-stu-id="a64e0-183">Attachable Member Stores</span></span>

<span data-ttu-id="a64e0-184">通常、アクセサー メソッドでは、アタッチ可能なメンバー値をオブジェクト グラフに配置したり、オブジェクト グラフから値を取得して適切にシリアル化したりする手段を提供するには十分ではありません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="a64e0-185">この機能を提供するには、`target`前のアクセサー シグネチャのオブジェクトが値を格納できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="a64e0-186">ストレージ・メカニズムは、アタッチ可能メンバーがメンバー・リストにないターゲットにメンバーをアタッチできる、というアタッチ可能メンバーの原則と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="a64e0-187">.NET XAML サービスは、API<xref:System.Xaml.IAttachedPropertyStore>と を介してアタッチ可能な<xref:System.Xaml.AttachablePropertyServices>メンバ ストアの実装手法を提供します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="a64e0-188"><xref:System.Xaml.IAttachedPropertyStore>は、XAML ライターがストアの実装を検出するために使用し、アクセサー`target`の型に実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="a64e0-189">静的<xref:System.Xaml.AttachablePropertyServices>API はアクセサーの本体内で使用され、そのアクセサーによってアタッチ可能なメンバーを<xref:System.Xaml.AttachableMemberIdentifier>参照します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="a64e0-190">XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="a64e0-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="a64e0-191">型、メンバー、およびアセンブリに正しく関連付けられているのは、XAML 型システム情報を .NET XAML サービスに報告するために重要です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="a64e0-192">次のいずれかの状況に該当する場合は、XAML 型システム情報のレポートが関連します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="a64e0-193">型は、.NET XAML サービス XAML リーダーと XAML ライターに直接基づく XAML システムで使用する予定です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="a64e0-194">これらの XAML リーダーと XAML ライターに基づく XAML を使用するフレームワークを定義または使用します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="a64e0-195">カスタム型の XAML サポートに関連する各 XAML 関連の属性の一覧については、「[カスタム型とライブラリの XAML 関連](clr-attributes-with-custom-types-and-libraries.md)CLR 属性」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a64e0-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="a64e0-196">使用法</span><span class="sxs-lookup"><span data-stu-id="a64e0-196">Usage</span></span>

<span data-ttu-id="a64e0-197">カスタム型を使用するには、マークアップ作成者が、カスタム型を含むアセンブリと CLR 名前空間のプレフィックスをマップする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="a64e0-198">この手順については、このトピックでは説明しません。</span><span class="sxs-lookup"><span data-stu-id="a64e0-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="a64e0-199">アクセス レベル</span><span class="sxs-lookup"><span data-stu-id="a64e0-199">Access Level</span></span>

<span data-ttu-id="a64e0-200">XAML は、アクセス レベルを持つ型を`internal`読み込んでインスタンス化する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="a64e0-201">この機能は、ユーザー コードが独自の型を定義し、同じユーザー コード スコープの一部でもあるマークアップからそれらのクラスをインスタンス化できるように提供されています。</span><span class="sxs-lookup"><span data-stu-id="a64e0-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="a64e0-202">WPF の例は、ユーザー コードが<xref:System.Windows.Controls.UserControl>UI 動作をリファクタリングする方法として定義されているが、アクセス レベルで`public`サポート クラスを宣言することによって暗黙の拡張メカニズムの一部としては定義されない場合です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="a64e0-203">このような<xref:System.Windows.Controls.UserControl>a は、XAML 型として`internal`参照されるアセンブリと同じアセンブリにバッキング コードがコンパイルされている場合に、access を使用して宣言できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="a64e0-204">完全信頼の下で XAML を読み<xref:System.Xaml.XamlObjectWriter>込み、`internal`を使用するアプリケーションでは、アクセス レベルを持つクラスの読み込みは常に有効になります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="a64e0-205">部分信頼の下で XAML を読み込むアプリケーションの場合は、API<xref:System.Xaml.Permissions.XamlAccessLevel>を使用してアクセス レベルの特性を制御できます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="a64e0-206">また、遅延メカニズム (WPF テンプレート システムなど) は、アクセス レベルのアクセス許可を伝達し、最終的な実行時評価のためにそれらを保持できる必要があります。これは、情報を渡すことによって内部的に<xref:System.Xaml.Permissions.XamlAccessLevel>処理されます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="a64e0-207">WPF の実装</span><span class="sxs-lookup"><span data-stu-id="a64e0-207">WPF Implementation</span></span>

<span data-ttu-id="a64e0-208">WPF XAML は、部分的な信頼の下で BAML が読み込まれる場合、BAML ソースであるアセンブリに対する<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>アクセスが制限される部分信頼アクセス モデルを使用します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="a64e0-209">遅延の場合、WPF<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>はアクセス レベル情報を渡すためのメカニズムとして使用します。</span><span class="sxs-lookup"><span data-stu-id="a64e0-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="a64e0-210">WPF XAML 用語では、*内部型*は、参照元の XAML も含む同じアセンブリによって定義される型です。</span><span class="sxs-lookup"><span data-stu-id="a64e0-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="a64e0-211">このような型は、マップの assembly= 部分を意図的に省略する XAML 名前空間を通じてマップできます`xmlns:local="clr-namespace:WPFApplication1"`。</span><span class="sxs-lookup"><span data-stu-id="a64e0-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="a64e0-212">BAML が内部型を参照し、その`internal`型にアクセス レベルがある場合`GeneratedInternalTypeHelper`、アセンブリのクラスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="a64e0-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="a64e0-213">を避`GeneratedInternalTypeHelper`ける場合は、アクセス レベルを`public`使用するか、関連するクラスを別のアセンブリに分類してそのアセンブリを依存させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a64e0-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="a64e0-214">関連項目</span><span class="sxs-lookup"><span data-stu-id="a64e0-214">See also</span></span>

- [<span data-ttu-id="a64e0-215">カスタム型およびライブラリの XAML 関連の CLR 属性</span><span class="sxs-lookup"><span data-stu-id="a64e0-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="a64e0-216">XAML サービス</span><span class="sxs-lookup"><span data-stu-id="a64e0-216">XAML Services</span></span>](../../../api/index.md)
