---
title: F# スタイル ガイド
description: 優れた F# コードの 5 つの原則について説明します。
ms.date: 12/10/2018
ms.openlocfilehash: 9f47257626e04b09b546de2ae315d48d791678be
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401113"
---
# <a name="f-style-guide"></a><span data-ttu-id="a707d-103">F# スタイル ガイド</span><span class="sxs-lookup"><span data-stu-id="a707d-103">F# style guide</span></span>

<span data-ttu-id="a707d-104">次の記事では、F# コードの書式設定のガイドラインと、言語の機能に関するトピック ガイダンス、および使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="a707d-104">The following articles describe guidelines for formatting F# code and topical guidance for features of the language and how they should be used.</span></span>

<span data-ttu-id="a707d-105">このガイダンスは、さまざまなプログラマグループを持つ大規模なコードベースでの F# の使用に基づいて策定されています。</span><span class="sxs-lookup"><span data-stu-id="a707d-105">This guidance has been formulated based on the use of F# in large codebases with a diverse group of programmers.</span></span> <span data-ttu-id="a707d-106">このガイドは一般的に F# の使用を成功させ、プログラムの要件が時間の経過とともに変化する場合の不満を最小限に抑えます。</span><span class="sxs-lookup"><span data-stu-id="a707d-106">This guidance generally leads to successful use of F# and minimizes frustrations when requirements for programs change over time.</span></span>

## <a name="five-principles-of-good-f-code"></a><span data-ttu-id="a707d-107">良い F# コードの 5 つの原則</span><span class="sxs-lookup"><span data-stu-id="a707d-107">Five principles of good F# code</span></span>

<span data-ttu-id="a707d-108">F# コードを記述する場合は常に、特に時間の経過とと同じ変化するシステムでは、次の原則に留意してください。</span><span class="sxs-lookup"><span data-stu-id="a707d-108">Keep the following principles in mind any time you write F# code, especially in systems that will change over time.</span></span> <span data-ttu-id="a707d-109">さらなる記事のガイダンスのすべての部分は、これらの5つのポイントに由来します。</span><span class="sxs-lookup"><span data-stu-id="a707d-109">Every piece of guidance in further articles stems from these five points.</span></span>

1. <span data-ttu-id="a707d-110">**良い F# コードは簡潔で、表現力があり、構成可能です**</span><span class="sxs-lookup"><span data-stu-id="a707d-110">**Good F# code is succinct, expressive, and composable**</span></span>

    <span data-ttu-id="a707d-111">F# には、少ないコード行でアクションを表現し、汎用機能を再利用できる多くの機能があります。</span><span class="sxs-lookup"><span data-stu-id="a707d-111">F# has many features that allow you to express actions in fewer lines of code and reuse generic functionality.</span></span> <span data-ttu-id="a707d-112">F# コア ライブラリには、データの一般的なコレクションを操作するための便利な型と関数も多数含まれています。</span><span class="sxs-lookup"><span data-stu-id="a707d-112">The F# core library also contains many useful types and functions for working with common collections of data.</span></span> <span data-ttu-id="a707d-113">独自の関数と F# コア ライブラリ (または他のライブラリ) の関数の構成は、ルーチンの慣用 F# プログラミングの一部です。</span><span class="sxs-lookup"><span data-stu-id="a707d-113">Composition of your own functions and those in the F# core library (or other libraries) is a part of routine idiomatic F# programming.</span></span> <span data-ttu-id="a707d-114">一般的なルールとして、問題の解決策を少ないコード行で表現できれば、他の開発者 (または将来の開発者) は高く評価されます。</span><span class="sxs-lookup"><span data-stu-id="a707d-114">As a general rule, if you can express a solution to a problem in fewer lines of code, other developers (or your future self) will be appreciative.</span></span> <span data-ttu-id="a707d-115">また、簡単な作業を行う必要がある場合は、FSharp.Core などのライブラリ、F# が実行される[広大な .NET ライブラリ](../../../api/index.md)[、NuGet](https://www.nuget.org/)のサードパーティ パッケージを使用することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a707d-115">It's also highly recommended that you use a library such as FSharp.Core, the [vast .NET libraries](../../../api/index.md) that F# runs on, or a third-party package on [NuGet](https://www.nuget.org/) when you need to do a nontrivial task.</span></span>

2. <span data-ttu-id="a707d-116">**良い F# コードは相互運用可能です**</span><span class="sxs-lookup"><span data-stu-id="a707d-116">**Good F# code is interoperable**</span></span>

    <span data-ttu-id="a707d-117">相互運用は、異なる言語でコードを使用する場合を含め、複数の形式をとることができます。</span><span class="sxs-lookup"><span data-stu-id="a707d-117">Interoperation can take multiple forms, including consuming code in different languages.</span></span> <span data-ttu-id="a707d-118">他の呼び出し元が相互運用するコードの境界は、呼び出し元が F# でも存在する場合でも、正しく取得するための重要な部分です。</span><span class="sxs-lookup"><span data-stu-id="a707d-118">The boundaries of your code that other callers interoperate with are critical pieces to get right, even if the callers are also in F#.</span></span> <span data-ttu-id="a707d-119">F# を記述する場合は、他のコードが C# のような別の言語から呼び出す場合など、記述するコードを呼び出す方法を常に考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="a707d-119">When writing F#, you should always be thinking about how other code will call into the code you're writing, including if they do so from another language like C#.</span></span> <span data-ttu-id="a707d-120">[F# コンポーネント設計ガイドライン](component-design-guidelines.md)では、相互運用性について詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="a707d-120">The [F# Component Design Guidelines](component-design-guidelines.md) describe interoperability in detail.</span></span>

3. <span data-ttu-id="a707d-121">**良い F# コードはオブジェクト指向ではなく、オブジェクト プログラミングを利用します。**</span><span class="sxs-lookup"><span data-stu-id="a707d-121">**Good F# code makes use of object programming, not object orientation**</span></span>

    <span data-ttu-id="a707d-122">F# は、[クラス](../language-reference/classes.md)、[インターフェイス](../language-reference/interfaces.md)、[アクセス修飾子](../language-reference/access-control.md)、[抽象クラス](../language-reference/abstract-classes.md)など、.NET のオブジェクトを使用したプログラミングを完全にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="a707d-122">F# has full support for programming with objects in .NET, including [classes](../language-reference/classes.md), [interfaces](../language-reference/interfaces.md), [access modifiers](../language-reference/access-control.md), [abstract classes](../language-reference/abstract-classes.md), and so on.</span></span> <span data-ttu-id="a707d-123">コンテキストに対応する必要がある関数など、より複雑な関数コードの場合、オブジェクトは、コンテキスト情報を関数ではカプセル化できません。</span><span class="sxs-lookup"><span data-stu-id="a707d-123">For more complicated functional code, such as functions that must be context-aware, objects can easily encapsulate contextual information in ways that functions cannot.</span></span> <span data-ttu-id="a707d-124">[オプションのパラメーター](../language-reference/members/methods.md#optional-arguments)や[オーバーロード](../language-reference/members/methods.md#overloaded-methods)の注意深い使用などの機能により、呼び出し元は、この機能を簡単に使用できます。</span><span class="sxs-lookup"><span data-stu-id="a707d-124">Features such as [optional parameters](../language-reference/members/methods.md#optional-arguments) and careful use of [overloading](../language-reference/members/methods.md#overloaded-methods) can make consumption of this functionality easier for callers.</span></span>

4. <span data-ttu-id="a707d-125">**良い F# コードは、変異を公開せずに適切に実行します。**</span><span class="sxs-lookup"><span data-stu-id="a707d-125">**Good F# code performs well without exposing mutation**</span></span>

    <span data-ttu-id="a707d-126">高性能なコードを記述するには、変異を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="a707d-126">It's no secret that to write high-performance code, you must use mutation.</span></span> <span data-ttu-id="a707d-127">結局のところ、それはコンピュータの仕組みです。</span><span class="sxs-lookup"><span data-stu-id="a707d-127">It's how computers work, after all.</span></span> <span data-ttu-id="a707d-128">このようなコードは、エラーが発生しやすく、正しく取得するのが困難な場合が多いです。</span><span class="sxs-lookup"><span data-stu-id="a707d-128">Such code is often error-prone and difficult to get right.</span></span> <span data-ttu-id="a707d-129">呼び出し元に変異を公開しないようにします。</span><span class="sxs-lookup"><span data-stu-id="a707d-129">Avoid exposing mutation to callers.</span></span> <span data-ttu-id="a707d-130">代わりに、パフォーマンスが重要な場合[に、変更ベースの実装を隠す機能インターフェイスを構築](conventions.md#performance)します。</span><span class="sxs-lookup"><span data-stu-id="a707d-130">Instead, [build a functional interface that hides a mutation-based implementation](conventions.md#performance) when performance is critical.</span></span>

5. <span data-ttu-id="a707d-131">**良い F# コードはツール可能です**</span><span class="sxs-lookup"><span data-stu-id="a707d-131">**Good F# code is toolable**</span></span>

    <span data-ttu-id="a707d-132">ツールは、大規模なコードベースでの作業に非常に貴重なツールであり、F# 言語ツールでより効果的に使用できるように F# コードを記述できます。</span><span class="sxs-lookup"><span data-stu-id="a707d-132">Tools are invaluable for working in large codebases, and you can write F# code such that it can be used more effectively with F# language tooling.</span></span> <span data-ttu-id="a707d-133">1 つの例として、ポイントフリーのプログラミングスタイルで過剰に処理しないようにして、中間値をデバッガーで調べられるようにします。</span><span class="sxs-lookup"><span data-stu-id="a707d-133">One example is making sure you don't overdo it with a point-free style of programming, so that intermediate values can be inspected with a debugger.</span></span> <span data-ttu-id="a707d-134">別の例としては、エディタのツールヒントが呼び出しサイトでそれらのコメントを表示できるように、構成を記述する[XML ドキュメント](../language-reference/xml-documentation.md)コメントを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="a707d-134">Another example is using [XML documentation comments](../language-reference/xml-documentation.md) describing constructs such that tooltips in editors can display those comments at the call site.</span></span> <span data-ttu-id="a707d-135">自分のツールを使って、他のプログラマがコードをどのように読み取り、ナビゲートし、デバッグし、操作するかを常に考えてください。</span><span class="sxs-lookup"><span data-stu-id="a707d-135">Always think about how your code will be read, navigated, debugged, and manipulated by other programmers with their tools.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a707d-136">次のステップ</span><span class="sxs-lookup"><span data-stu-id="a707d-136">Next steps</span></span>

<span data-ttu-id="a707d-137">[F# のコードの書式設定のガイドライン](formatting.md)では、コードを読みやすくするために、コードの書式を設定する方法についてのガイダンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="a707d-137">The [F# code formatting guidelines](formatting.md) provide guidance on how to format code so that it is easy to read.</span></span>

<span data-ttu-id="a707d-138">[F# のコーディング規則は、](conventions.md)大規模な F# コードベースの長期的な保守に役立つ F# プログラミングイディオムのガイダンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="a707d-138">The [F# coding conventions](conventions.md) provide guidance for F# programming idioms that will help the long-term maintenance of larger F# codebases.</span></span>

<span data-ttu-id="a707d-139">[F# コンポーネントの設計ガイドライン](component-design-guidelines.md)では、ライブラリなどの F# コンポーネントを作成するためのガイダンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="a707d-139">The [F# component design guidelines](component-design-guidelines.md) provide guidance for authoring F# components, such as libraries.</span></span>
