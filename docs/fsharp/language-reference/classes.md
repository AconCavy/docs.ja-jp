---
title: クラス
description: 'F # クラスが、プロパティ、メソッド、およびイベントを持つことができるオブジェクトを表す型であることについて説明します。'
ms.date: 05/16/2016
ms.openlocfilehash: fd6638e0f1c08cf667a73582e19b2bb5bba46e20
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970168"
---
# <a name="classes"></a>クラス

*クラス* は、プロパティ、メソッド、およびイベントを持つことができるオブジェクトを表す型です。

## <a name="syntax"></a>構文

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>解説

クラスは、.NET オブジェクト型の基本的な説明を表します。クラスは、F # でのオブジェクト指向プログラミングをサポートする主要な型の概念です。

上記の構文では、 `type-name` は任意の有効な識別子です。 では、 `type-params` 省略可能なジェネリック型パラメーターについて説明します。 型パラメーター名と、山かっこ (と) で囲まれた制約で構成さ `<` `>` れます。 詳細については、「 [ジェネリック](./generics/index.md) と [制約](./generics/constraints.md)」を参照してください。 は、 `parameter-list` コンストラクターのパラメーターについて説明します。 最初のアクセス修飾子は、型に関連します。2つ目は、プライマリコンストラクターに関連します。 どちらの場合も、既定値は `public` です。

クラスの基底クラスは、キーワードを使用して指定し `inherit` ます。 基底クラスのコンストラクターには、かっこで囲んだ引数を指定する必要があります。

バインディングを使用して、クラスに対してローカルなフィールドまたは関数の値を宣言 `let` し、バインディングの一般的な規則に従う必要があり `let` ます。 このセクションには、 `do-bindings` オブジェクトの構築時に実行されるコードが含まれています。

は、 `member-list` 追加のコンストラクター、インスタンスと静的メソッドの宣言、インターフェイス宣言、抽象バインディング、およびプロパティとイベント宣言で構成されています。 これらについては、「 [メンバー](./members/index.md)」を参照してください。

`identifier`省略可能なキーワードと共に使用されるでは、 `as` インスタンス変数または自己識別子に名前が付けられます。これは、型のインスタンスを参照するために型定義で使用できます。 詳細については、このトピックで後述する「自己識別子」を参照してください。

`class` `end` 定義の開始と終了をマークするキーワードとは省略可能です。

相互に再帰的に参照される型である相互再帰型は、 `and` 相互に再帰的な関数と同様に、キーワードと共に結合されます。 例については、「相互再帰型」を参照してください。

## <a name="constructors"></a>コンストラクター

コンストラクターは、クラス型のインスタンスを作成するコードです。 クラスのコンストラクターは、F # では、他の .NET 言語とは少し異なる方法で動作します。 F # クラスでは、常に、型名の後のに記述される引数を持つプライマリコンストラクターが存在 `parameter-list` します。また、本体は、 `let` `let rec` クラス宣言の先頭にある (と) バインディングと、その後に続くバインディングで構成され `do` ます。 プライマリコンストラクターの引数は、クラス宣言全体でスコープ内にあります。

次のように、キーワードを使用してメンバーを追加することにより、追加のコンストラクターを追加でき `new` ます。

`new`(`argument-list`) = `constructor-body`

新しいコンストラクターの本体は、クラス宣言の先頭に指定されているプライマリコンストラクターを呼び出す必要があります。

次の例は、この概念を示しています。 次のコードでは、に2つの `MyClass` コンストラクターがあります。これは、2つの引数を受け取るプライマリコンストラクターと、引数を受け取らない別のコンストラクターです。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>let バインドと do バインド

`let`クラス定義内のとのバインドは、 `do` プライマリクラスのコンストラクターの本体を形成するため、クラスのインスタンスが作成されるたびに実行されます。 `let`バインディングが関数の場合は、メンバーにコンパイルされます。 `let`バインディングが、どの関数またはメンバーでも使用されていない値である場合は、コンストラクターに対してローカルな変数にコンパイルされます。 それ以外の場合は、クラスのフィールドにコンパイルされます。 `do`次の式は、プライマリコンストラクターにコンパイルされ、すべてのインスタンスに対して初期化コードを実行します。 追加のコンストラクターは常にプライマリコンストラクターを呼び出すため、 `let` バインドとバインドは、 `do` 呼び出されるコンストラクターに関係なく、常に実行されます。

バインドによって作成されたフィールドには、 `let` クラスのメソッドとプロパティを通じてアクセスできます。ただし、静的メソッドがパラメーターとしてインスタンス変数を受け取る場合でも、静的メソッドからアクセスすることはできません。 自己識別子 (存在する場合) を使用してアクセスすることはできません。

## <a name="self-identifiers"></a>自己識別子

*Self 識別子* は、現在のインスタンスを表す名前です。 自己識別子は、 `this` C#、C++、または Visual Basic でキーワードに似て `Me` います。 自己識別子は、クラス定義全体のスコープ内にあるか、または個別のメソッドのスコープ内にあるかに応じて、2つの異なる方法で定義できます。

クラス全体の自己識別子を定義するには、 `as` コンストラクターのパラメーターリストの終わりかっこの後にキーワードを使用し、識別子の名前を指定します。

1つのメソッドに対してのみ自己識別子を定義するには、メンバー宣言内の自己識別子を、メソッド名の直前とピリオド (.) の区切り記号として指定します。

次のコード例は、自己識別子を作成する2つの方法を示しています。 最初の行では、 `as` キーワードを使用して自己識別子を定義します。 5行目では、識別子を使用して、 `this` スコープがメソッドに限定された自己識別子を定義し `PrintMessage` ます。

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

他の .NET 言語とは異なり、自己識別子には名前を付けることができます。、、などの名前に制限されていません `self` `Me` `this` 。

キーワードを使用して宣言された自己識別子 `as` は、基本コンストラクターの後まで初期化されません。 したがって、基本コンストラクターの前または内部で使用すると、 `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` 実行時にが発生します。 自己識別子は、バインディングやバインドなど、基本コンストラクターの後で自由に使用でき `let` `do` ます。

## <a name="generic-type-parameters"></a>ジェネリック型の型パラメーター

ジェネリック型パラメーターは、山かっこ (と) で指定され `<` `>` 、単一引用符の後に識別子が続きます。 複数のジェネリック型パラメーターは、コンマで区切られます。 ジェネリック型パラメーターは、宣言全体でスコープ内にあります。 ジェネリック型パラメーターを指定する方法を次のコード例に示します。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

型引数は、型が使用されるときに推論されます。 次のコードでは、推論される型は組のシーケンスです。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>継承の指定

句は、 `inherit` 直接基底クラス (存在する場合) を識別します。 F # では、直接基底クラスを1つだけ使用できます。 クラスが実装するインターフェイスは、基本クラスとは見なされません。 インターフェイスについては、「 [インターフェイス](Interfaces.md) 」を参照してください。

識別子として言語キーワードを使用し、 `base` その後にピリオド (.) とメンバーの名前を指定することで、派生クラスから基底クラスのメソッドとプロパティにアクセスできます。

詳細については、「[継承](inheritance.md)」を参照してください。

## <a name="members-section"></a>Members セクション

このセクションでは、静的メソッド、インスタンスメソッド、プロパティ、インターフェイスの実装、抽象メンバー、イベント宣言、および追加のコンストラクターを定義できます。 Let と do のバインドは、このセクションには記述できません。 メンバーは、クラスに加えてさまざまな F # 型に追加でき [ます。そのため、メンバーに](./members/index.md)ついては、個別のトピックで説明します。

## <a name="mutually-recursive-types"></a>相互再帰型

相互参照する型を循環する方法で定義する場合は、キーワードを使用して型定義を文字列で連結し `and` ます。 キーワードは、 `and` `type` 最初の定義以外のすべてのキーワードを次のように置き換えます。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

出力は、現在のディレクトリにあるすべてのファイルの一覧です。

## <a name="when-to-use-classes-unions-records-and-structures"></a>クラス、共用体、レコード、および構造体を使用する場合

さまざまな種類から選択できるように、それぞれの型が特定の状況に適した型を選択できるように設計されていることを十分に理解しておく必要があります。 クラスは、オブジェクト指向プログラミングコンテキストで使用するように設計されています。 オブジェクト指向プログラミングは、.NET Framework 用に記述されたアプリケーションで使用される最も重要なパラダイムです。 F # コードを .NET Framework または別のオブジェクト指向ライブラリと密接に連携させる必要がある場合、特に UI ライブラリなどのオブジェクト指向型システムから拡張する必要がある場合は、クラスが適切であると想定されます。

オブジェクト指向のコードと密接に相互運用していない場合、または自己完結型のコードを記述していて、オブジェクト指向のコードと頻繁にやり取りする場合は、レコードと判別共用体の使用を検討する必要があります。 適切なパターン一致コードと共に1つのよく見られる判別共用体が、オブジェクト階層の代替手段として使用されることがよくあります。 判別共用体の詳細については、「 [判別共用体](discriminated-unions.md)」を参照してください。

レコードにはクラスよりも単純な利点がありますが、型の要求が単純さで実現できることを超える場合、レコードは適切ではありません。 レコードは、基本的には値の単純な集計であり、カスタムアクションを実行できる個別のコンストラクターと、非表示フィールドを除いて、継承やインターフェイスの実装は不要です。 プロパティやメソッドなどのメンバーをレコードに追加して、動作をより複雑にすることができますが、レコードに格納されているフィールドは、引き続き単純な値の集計になります。 レコードの詳細については、「 [レコード](records.md)」を参照してください。

構造体は、データの小さな集計にも役立ちますが、クラスとレコードは .NET 値型であるとは異なります。 クラスとレコードは .NET 参照型です。 値型と参照型のセマンティクスは、値型が値で渡されるという意味で異なります。 これは、パラメーターとして渡された場合、または関数から返された場合にビットのビットがコピーされることを意味します。 また、これらはスタックに格納されます。また、フィールドとして使用されている場合は、ヒープ上の別の場所に格納されるのではなく、親オブジェクト内に埋め込まれます。 したがって、ヒープにアクセスするオーバーヘッドが問題になる場合は、構造体が頻繁にアクセスされるデータに適しています。 構造体の詳細については、「 [構造体](structures.md)」を参照してください。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [メンバー](./members/index.md)
- [継承](inheritance.md)
- [インターフェイス](interfaces.md)
