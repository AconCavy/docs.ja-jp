---
title: キャストと変換
description: について説明しますが、どのようにF#さまざまなプリミティブ型間の算術変換の変換演算子を提供するプログラミング言語。
ms.date: 05/16/2016
ms.openlocfilehash: 2a12d48106a267edfc67c9e7b3d3a7bd41d8261c
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "61966617"
---
# <a name="casting-and-conversions-f"></a>キャストと変換 (F#)

このトピックでは、F# の型変換のサポートについて説明します。

## <a name="arithmetic-types"></a>数値型

F#整数と浮動小数点型の間のように、さまざまなプリミティブ型の間の算術変換の変換演算子を提供します。 整数と文字の変換演算子がチェックと unchecked フォームです。浮動小数点の演算子と`enum`変換演算子がありません。 チェックを行わないフォームが定義されている`Microsoft.FSharp.Core.Operators`でチェックされているフォームが定義されていると`Microsoft.FSharp.Core.Operators.Checked`します。 チェックされているフォームでは、オーバーフローをチェックし、結果の値が対象の型の制限を超えた場合、ランタイム例外を生成します。

これらの各演算子は、変換先の型の名前と同じ名前があります。 これで、型が明示的に注釈付け、次のコードなどで`byte`で 2 つの異なる意味が表示されます。 最初に見つかったは型であり、2 つ目は変換演算子。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

次の表では、F# で定義された変換演算子を示します。

|演算子|説明|
|--------|-----------|
|`byte`|バイトを 8 ビット符号なしの型に変換します。|
|`sbyte`|符号付きバイトに変換します。|
|`int16`|16 ビット符号付き整数に変換します。|
|`uint16`|16 ビット符号なし整数に変換します。|
|`int32, int`|32 ビット符号付き整数に変換します。|
|`uint32`|32 ビット符号なし整数に変換します。|
|`int64`|64 ビット符号付き整数に変換します。|
|`uint64`|64 ビット符号なし整数に変換します。|
|`nativeint`|ネイティブ整数に変換します。|
|`unativeint`|符号なしネイティブ整数に変換します。|
|`float, double`|64 ビット IEEE 倍精度浮動小数点数に変換します。|
|`float32, single`|32 ビット IEEE 単精度浮動小数点数に変換します。|
|`decimal`|変換`System.Decimal`します。|
|`char`|変換`System.Char`、Unicode 文字。|
|`enum`|列挙型に変換します。|

実装する型をこれらの演算子を使用する組み込みのプリミティブ型に加えて`op_Explicit`または`op_Implicit`適切なシグネチャを持つメソッド。 たとえば、`int`変換演算子は、静的メソッドを提供する任意の型と連携`op_Explicit`を型をパラメーターとして受け取り、返します`int`します。 戻り値の型でメソッドをオーバー ロードできません、一般的な規則に特殊な例外としてこれを行う`op_Explicit`と`op_Implicit`します。

## <a name="enumerated-types"></a>列挙型

`enum`演算子は、汎用の演算子の型を表す 1 つの型パラメーターを受け取る、`enum`に変換します。 列挙型に変換するときの入力の種類を決定しようと推論、`enum`に変換します。 次の例では、変数`col1`明示的に注釈がありませんが、それ以降の等値テストから型を推論します。 そのため、コンパイラに変換することを推測することができます、`Color`列挙体。 型の注釈を指定する代わりと同様`col2`次の例です。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

次のコードのように、型パラメーターとして明示的にターゲットの列挙型を指定できます。

```fsharp
let col3 = enum<Color> 3
```

列挙体の基になる型が変換される型と互換性のある場合にのみ、列挙体で作業をキャストすることに注意してください。 次のコードで、変換は失敗の間で不一致が原因でコンパイルする`int32`と`uint32`します。

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

詳細については、次を参照してください。[列挙](enumerations.md)します。

## <a name="casting-object-types"></a>オブジェクト型のキャスト

オブジェクト階層内の型の間の変換は、オブジェクト指向プログラミングの基盤です。 変換の 2 つの基本的な種類があります。 (キャスト) をキャストすると、(ダウン キャスト)。 階層へのキャストは、ベース オブジェクトの参照への参照を派生オブジェクトからのキャストを意味します。 そのようなキャスト基底クラスが派生クラスの継承階層である限りを操作することが保証されます。 派生オブジェクトの参照への参照を基本オブジェクトの階層の下位へのキャストが成功すると、オブジェクトが実際には (派生)、適切な変換先の型または変換先の型から派生した型のインスタンスが場合にのみです。

F#これらの種類の変換の演算子を提供します。 `:>`演算子は、階層のキャスト、`:?>`演算子が、階層の下位にキャストします。

### <a name="upcasting"></a>キャスト

多くのオブジェクト指向言語でキャストは暗黙の型です。F# では、規則が若干異なります。 オブジェクトの種類のメソッドに引数を渡すときに、キャストが自動的に適用されます。 ただし、モジュール内の let バインドされた関数、キャスト自動ではありません、パラメーターの型は柔軟な型として宣言されていない場合。 詳細については、次を参照してください。[フレキシブル型](flexible-Types.md)します。

`:>`演算子はキャスト、つまり、コンパイル時のキャストの成功が決定される静的なを実行します。 キャストを使用する場合、 `:>` 、正常にコンパイルし、有効なキャストは、実行時にエラーが発生する可能性がないです。

使用することも、`upcast`オペレーターがこのような変換を実行します。 次の式は、階層の上位変換を指定します。

```fsharp
upcast expression
```

Upcast 演算子を使用すると、コンパイラは、コンテキストから変換する型を推論しようとします。 コンパイラでターゲットの種類を決定することがない場合、コンパイラはエラーを報告します。

### <a name="downcasting"></a>ダウン キャスト

`:?>`演算子はキャスト、つまり、実行時のキャストの成功が決定される動的なを実行します。 使用するキャスト、`:?>`演算子は、コンパイル時にチェックされませんが、実行時にしようとしましたが、指定した型にキャストします。 オブジェクトは、対象の型と互換性が、キャストが成功します。 オブジェクトが対象の型と互換性がない場合、ランタイムが発生します、`InvalidCastException`します。

使用することも、`downcast`動的な型変換を実行する演算子。 次の式は、階層内の下位プログラム コンテキストから推論される型への変換を指定します。

```fsharp
downcast expression
```

場合と同様、`upcast`演算子、コンパイラは、コンテキストから特定のターゲット型を推論されない場合、エラーを報告します。

次のコードの使用を示しています、`:>`と`:?>`演算子。 コードを示していますが、`:?>`わかっている場合、変換が成功することをスローするため、演算子が使用される最適`InvalidCastException`変換が失敗した場合。 変換が成功するを使用する型テストを把握していない場合、`match`例外を生成するオーバーヘッドを回避するので、式が向上します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

ため、ジェネリック演算子`downcast`と`upcast`上記のコードで、引数と戻り値の型を決定する型の推定に依存して、置き換えることができます

```fsharp
let base1 = d1 :> Base1
```

代入

```fsharp
let base1 = upcast d1
```

引数の型と戻り値の型が、上記のコードで`Derived1`と`Base1`、それぞれします。

型のテストの詳細については、次を参照してください。[一致式](match-Expressions.md)します。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
