---
title: フレキシブル型
description: 'F # の柔軟な型の注釈を使用する方法について説明します。これは、パラメーター、変数、または値に、指定した型と互換性のある型があることを示します。'
ms.date: 08/15/2020
ms.openlocfilehash: 44241ad082cd7f3de9e0cc6a48b8a8946e7b33d3
ms.sourcegitcommit: 8bfeb5930ca48b2ee6053f16082dcaf24d46d221
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/18/2020
ms.locfileid: "88557751"
---
# <a name="flexible-types"></a>フレキシブル型

*柔軟な型の注釈*は、パラメーター、変数、または値に、指定された型と互換性のある型があることを示します。互換性は、クラスまたはインターフェイスのオブジェクト指向階層内の位置によって決まります。 柔軟な型は、型階層の上位にある型への自動変換が行われず、階層内の任意の型、またはインターフェイスを実装する任意の型で機能できるようにする場合に特に便利です。

## <a name="syntax"></a>構文

```fsharp
#type
```

## <a name="remarks"></a>解説

前の構文では、 *型* は基本型またはインターフェイスを表します。

柔軟な型は、基本型またはインターフェイス型と互換性のある型に対して許可される型を制限する制約を持つジェネリック型に相当します。 つまり、次の2行のコードは同等です。

```fsharp
#SomeType

'T when 'T :> SomeType
```

柔軟性のある型は、さまざまな状況で役立ちます。 たとえば、高階関数 (関数を引数として受け取る関数) がある場合、多くの場合、関数が柔軟な型を返すようにすると便利です。 次の例では、でシーケンス引数を持つ柔軟な型を使用することにより、高階関数を使用して、 `iterate2` シーケンス、配列、リスト、およびその他の列挙可能な型を生成する関数を操作できます。

次の2つの関数について考えてみます。1つはシーケンスを返し、もう一方は柔軟な型を返します。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

もう1つの例として、 [Seq. concat](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-seqmodule.html#concat) ライブラリ関数を考えてみます。

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

この関数には、次のいずれかの列挙可能なシーケンスを渡すことができます。

- リストの一覧
- 配列の一覧
- リストの配列
- シーケンスの配列
- 列挙可能なシーケンスのその他の組み合わせ

次のコードでは、を使用して `Seq.concat` 、柔軟な型を使用してサポートできるシナリオを示します。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

出力は次のとおりです。

```console
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

F # では、他のオブジェクト指向言語と同様に、インターフェイスを実装する派生型または型が基本型またはインターフェイス型に自動的に変換されるコンテキストがあります。 これらの自動変換は直接引数で行われますが、型が下位の位置にある場合や、型が関数型の戻り値の型などのより複雑な型の一部として、または型引数として存在する場合には発生しません。 したがって、柔軟な型表記は、それを適用している型がより複雑な型の一部である場合に、主に役立ちます。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [ジェネリック](./generics/index.md)
