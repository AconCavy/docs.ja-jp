---
title: フレキシブル型
description: 使用する方法について説明しますF#柔軟な型の注釈は、パラメーター、変数、または値に指定した型と互換性がある型があることを示します。
ms.date: 05/16/2016
ms.openlocfilehash: e8edae671c54971862a35f03da8663c8567e2261
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/15/2019
ms.locfileid: "65641929"
---
# <a name="flexible-types"></a>フレキシブル型

A*柔軟な型の注釈*パラメーター、変数、または値に互換性がクラスまたはインターフェイスのオブジェクト指向の階層内の位置によって決まりますが、種類を指定して互換性のある型があることを示します。 フレキシブル型は、型の階層で上位の型への自動変換は発生しませんが、階層内の任意の型またはインターフェイスを実装する任意の型を使用する、機能を有効にするときに特に便利です。

## <a name="syntax"></a>構文

```fsharp
#type
```

## <a name="remarks"></a>Remarks

前の構文で*型*基本データ型またはインターフェイスを表します。

柔軟な型では、基本またはインターフェイス型と互換性がある型に使用できる型を制限する制約を持つジェネリック型に相当します。 つまり、次の 2 行のコードは同等です。

```fsharp
#SomeType

'T when 'T :> SomeType
```

フレキシブル型は、いくつかの種類の状況で便利です。 たとえば、高階関数 (引数として関数を受け取る関数) を使用するは、柔軟な型を返す関数を用意すると便利は多くの場合。 次の例では、シーケンスに引数を持つ柔軟な型を使用して`iterate2`シーケンス、配列、リスト、およびその他の列挙可能な型を生成する関数を使用する、高階関数を使用します。

次の 2 つ関数のシーケンスを返しますが、柔軟な型を返しますが、その他のいずれかを検討してください。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

別の例として、 [Seq.concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712)ライブラリ関数。

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

次の列挙可能なシーケンスのいずれかは、この関数に渡すことができます。

- リストの一覧
- 配列の一覧
- リストの配列
- シーケンスの配列
- 列挙可能なシーケンスの他の任意の組み合わせ

次のコードでは`Seq.concat`に柔軟な型を使用してサポートできるシナリオについて説明します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

出力は次のとおりです。

```
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

F#、その他のオブジェクト指向の言語があるコンテキストを派生型またはインターフェイスを実装する型が基本型またはインターフェイス型に自動的に変換します。 直接の引数が関数の型の戻り値の型などのより複雑な型の一部として、または型引数として、下位の位置での型がの場合は、これらの自動変換が発生します。 したがってに適用する型がより複雑な型の一部である場合は、柔軟な表記は主に役立ちます。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [ジェネリック](generics/index.md)
