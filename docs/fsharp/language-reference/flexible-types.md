---
title: フレキシブル型
description: 柔軟な型のF#注釈を使用する方法について説明します。これは、パラメーター、変数、または値に、指定した型と互換性のある型があることを示します。
ms.date: 05/16/2016
ms.openlocfilehash: bf05f78f163d1f9c73c667df60925b66a5315627
ms.sourcegitcommit: a2d0e1f66367367065bc8dc0dde488ab536da73f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/18/2019
ms.locfileid: "71083064"
---
# <a name="flexible-types"></a>フレキシブル型

*柔軟な型の注釈*は、パラメーター、変数、または値に、指定された型と互換性のある型があることを示します。互換性は、クラスまたはインターフェイスのオブジェクト指向階層内の位置によって決まります。 柔軟な型は、型階層の上位にある型への自動変換が行われず、階層内の任意の型、またはインターフェイスを実装する任意の型で機能できるようにする場合に特に便利です。

## <a name="syntax"></a>構文

```fsharp
#type
```

## <a name="remarks"></a>Remarks

前の構文では、*型*は基本型またはインターフェイスを表します。

柔軟な型は、基本型またはインターフェイス型と互換性のある型に対して許可される型を制限する制約を持つジェネリック型に相当します。 つまり、次の2行のコードは同等です。

```fsharp
#SomeType

'T when 'T :> SomeType
```

柔軟性のある型は、さまざまな状況で役立ちます。 たとえば、高階関数 (関数を引数として受け取る関数) がある場合、多くの場合、関数が柔軟な型を返すようにすると便利です。 次の例では、で`iterate2`シーケンス引数を持つ柔軟な型を使用することにより、高階関数を使用して、シーケンス、配列、リスト、およびその他の列挙可能な型を生成する関数を操作できます。

次の2つの関数について考えてみます。1つはシーケンスを返し、もう一方は柔軟な型を返します。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

もう1つの例として、 [Seq. concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712)ライブラリ関数を考えてみます。

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

この関数には、次のいずれかの列挙可能なシーケンスを渡すことができます。

- リストの一覧
- 配列の一覧
- リストの配列
- シーケンスの配列
- 列挙可能なシーケンスのその他の組み合わせ

次のコードで`Seq.concat`は、を使用して、柔軟な型を使用してサポートできるシナリオを示します。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

出力は次のとおりです。

```console
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

でF#は、他のオブジェクト指向言語と同様に、インターフェイスを実装する派生型または型が基本型またはインターフェイス型に自動的に変換されるコンテキストがあります。 これらの自動変換は直接引数で行われますが、型が下位の位置にある場合や、型が関数型の戻り値の型などのより複雑な型の一部として、または型引数として存在する場合には発生しません。 したがって、柔軟な型表記は、それを適用している型がより複雑な型の一部である場合に、主に役立ちます。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [ジェネリック](./generics/index.md)
