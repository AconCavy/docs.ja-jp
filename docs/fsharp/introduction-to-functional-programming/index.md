---
title: 'F# の関数型プログラミングの概要'
description: 'F#で関数型プログラミングの基礎を学習します。'
ms.date: 10/29/2018
---

# <a name="introduction-to-functional-programming-in-f"></a>F# での関数型プログラミングの概要

関数型プログラミングは、関数と不変データを重視するプログラミングスタイルです。 型付き関数型プログラミング言語は、F#のように関数型プログラミングと静的型を組み合わせたものです。一般に、次の概念が関数型プログラミングで強調されます。

* 第一級の構成要素の関数
* ステートメントではなく式
* 変数よりも不変の値
* 命令型プログラミングよりも宣言型プログラミング

この連載では、F# を用いて関数型プログラミングの基本概念とパターンについて学びます。その過程でF#についてもいくつか説明します。

## <a name="terminology"></a>用語

多くのプログラミングパラダイムと同様、関数型プログラミングを学習するのにもボキャブラリを学ぶ事が必要です。 ここでは、いくつかの一般的な用語を示します。

* **関数** - 関数とは指定した入力から出力を生成する構成要素です。正式には、ある集合を別の集合へ _マッピング_ するものです。この定式化は様々な方法に適用されます。特にデータのコレクションを操作する関数を扱うような場合に有効です。これは、関数型プログラミングで最も基本的な (かつ重要な) 概念です。 
* **式** - 式は、値を生成する後世要素です。 F#では、この値はバインドされるかまたは明示的に無視されます。 式は、関数呼び出しで簡単に置き換える事ができます。
* **純粋性** - 純粋性とは同じ引数に対して戻り値は常に同じであり、その評価には副作用がないという関数の性質です。純粋関数はその引数に完全に依存します。
* **参照透過性** - 参照透過性とはプログラムの動作に影響を与えずにその出力を交換できるような式の性質です。
* **不変性** - 不変性とは、値をその場で変更できないことを意味します。これは、その場で変化する可能性のある変数とは対照的です。

## <a name="examples"></a>使用例

次の例では、これらの主要な概念を示します。

### <a name="functions"></a>関数

関数型プログラミングの最も一般的なと基本的な構造は、関数です。 整数値に 1 を追加する単純な関数を次に示します。

```fsharp
let addOne x = x + 1
```

その型シグネチャは次の通りです。

```fsharp
val addOne: x:int -> int
```

このシグニチャは、「`addOne` は `x` という名前の `int` を受け入れ、`int` を生成する」と読み取る事ができます。 より正式には、`addOne` は整数集合の値を整数集合に_マッピング_します。 `->` トークンは、このマッピングを示します。 F# では、通常、関数のシグニチャを見てその関数の意味を把握する事ができます。

ではなぜシグニチャが重要なのでしょうか? 型付き関数型プログラミングでは、しばしば関数の実装は実際の型シグニチャほど重要ではないのです! `addOne` が整数に対して値 1 を加算する事は実行時には興味深いですが、プログラムを作成する際は、この関数が`int`を受け入れて返すという事実が実際に関数を使用する上で重要なのです。 さらに、この関数を (型シグニチャにおいて) 正しく使用すると、問題を `addOne` 関数の本文内のみで診断する事ができます。 これが型付き関数型プログラミングの背景にある推進力なのです。

### <a name="expressions"></a>式

式は、値に評価する構成要素です。 ステートメントで、アクションを実行するとは対照的の値を提供するアクションを実行する式を考えることができます。 式は、関数型プログラミングでステートメントを優先してほとんどの場合に使用されます。

前の `addOne` 関数について考えます。 `addOne` の本文は式です。

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

`addOne`関数の結果の型を定義するのはこの式の結果です。たとえば、この関数を構成する式は`string`など別の型に変更する事ができます。

```fsharp
let addOne x = x.ToString() + "1"
```

関数のシグネチャは、ようになりました。

```fsharp
val addOne: x:'a -> string
```

F#の全ての型は`ToString()`を呼び出す事ができるので、`x`の型はジェネリック([自動ジェネリック化](../language-reference/generics/automatic-generalization.md)と呼ばれる)であり結果の型は`string`となります。

式は関数本体だけにあるものではありません。式は値を用いられるあらゆる場所に使う事ができます。よくある例の 1 つは`if`です:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if`式は結果を`result`に代入します。 `result`を完全に省略することもできることに注意してください。これによって`if`式を`addOneIfOdd`関数本体とする事ができます。 式について覚えておくべき重要な点は、値を生成することです。

`unit`という特殊な型があります。これは値を返しません。たとえば、次の単純な関数があるとします。

```fsharp
let printString (str: string) =
    printfn "String is: %s" str
```

型シグニチャは次のようになります。

```fsharp
val printString: str:string -> unit
```

`unit`型は、実際には値を返さないことを示しています。「作業をする」がその結果として値を返さないような場合に用いられます。

これは命令型プログラミングとは対照的です。同じ`if`が文の場合、結果の値を生成するには通常、変数値の変更を伴います。例えば、C#ではこのように書くでしょう:

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

なおC#やCスタイルの言語は[三項式](../../csharp/language-reference/operators/conditional-operator.md)をサポートするので、式ベースの条件付きプログラミングが可能です。

関数型プログラミングでは、ステートメントで値を変更する事は稀です。関数が多言語の中には文や値の変更をサポートするものもありますが、そういったものは関数型プログラミングでは一般的ではありません。

### <a name="pure-functions"></a>純粋関数

前に説明したように、純粋関数はとは以下のような関数です:

* 常に同じ入力に対して同じ値を返します
* 副作用がありません

ここで数学の関数を考えるとわかりやすいでしょう。数学では、関数は引数のみに依存し副作用がありません。数学の`f(x) = x + 1`という関数は、`f(x)`の値は`x`の値のみに依存します。関数型プログラミングの純粋関数も同様です。

純粋関数を書くときは、関数は引数のみに依存し、副作用を生じるようなアクションを実行する事がないようにする必要があります。

ここで純粋関数でない関数の例を示します。この関数はグローバルで変更可能な状態に依存します。

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

`value`はいつでも変更する事が可能で 1以外の値をとる事があり得るので、`addOneToValue`関数は明らかに純粋ではありません。このようなグローバル変数に依存する事は関数型プログラミングでは避けるべきです。

次の純粋関数でない関数の例は、副作用を生じます。

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

この関数はグローバル変数に依存する訳ではありませんが、`x`の値をプログラムの出力に書き出します。この処理自体は本質的には悪い事ではありませんが、この処理によってこの関数は純粋ではなくなります。もしこのプログラムの中に例えば出力バッファのようなプログラムの外部に依存する部分があれば、この関数を呼ぶ事で他の部分に影響を及ぼす事になります。

`printfn`ステートメントを削除する事によって、この関数は純粋関数になります。

```fsharp
let addOneToValue x = x + 1
```

この関数は前の`printfn`ステートメントのあるバージョンに対して本質的に_優れている_訳ではありませんが、この関数は値を返すだけであることを保証しています。この関数を何度呼び出しても同じ結果を返します。ただ値を生成するだけです。この純粋性による予見可能性こそが多くの関数型プログラマが追求するものなのです。

### <a name="immutability"></a>不変性

最後に、型付き関数型プログラミング言語の最も本質的な概念の一つが不変性です。F#では、デフォルトで全ての変数の値が不変です。これは、明示的に変更可能と記述しないかぎり変数の値を変更する事ができないことを意味します。

実際、不変な値を用いる事で「値を変更する」プログラミングから「新しい値を生成する」プログラミングへアプローチを変える事になります。

例えば、変数の値に1を加えるのは既にある値を変更するのではなく、新たな値を生成することを意味します。

```fsharp
let value = 1
let secondValue = value + 1
```

F#では、次のコードは`value`の値を変更するのでは**なく**、等価判定を行います。

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

関数型プログラミング言語の中には値の変更を全くサポートしないものもあります。F#の場合はサポートされていますが、デフォルトの動作ではありません。

この概念は、さらにデータ構造に拡張されます。関数型プログラミング言語では、集合(およびその他のデータ)といった不変データ構造の実装は、最初の予想とは異なります。ある集合に要素を一つ加える場合、集合そのものを変えるのではなく要素が一つ加わった集合を**新たに**つくるようなイメージです。実際には、多くの場合、データの適切な表現を結果として提供できるような値を効率的に追跡できる別のデータ構造によって実現されます。

値とデータ構造を操作するこのスタイルは、何かを変更する操作を、あたかもその新しいバージョンを作成するかのように扱うことを強制するためとても重要です。 これにより、プログラムで等価性や比較可能性などを一貫して扱う事ができます。。

## <a name="next-steps"></a>次のステップ

次のセクションでは、関数を徹底的に取り上げ、関数型プログラミングにおける様々な扱い方を探ります。

[ファーストクラス関数](first-class-functions.md)は関数を深く様々なコンテキストで使用する方法を示します。

## <a name="further-reading"></a>関連項目

[Thinking Functionally](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/)シリーズは、F#をしようした関数型プログラミングについて学ぶためのもう一つの優れたリソースです。F#の機能をしようして概念を説明し、実用的でよう見やすい方法で関数型プログラミングの基礎を説明します。


