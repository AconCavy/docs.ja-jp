---
title: セキュリティの基本概念
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- unauthorized access
- permissions [.NET Framework]
- security [.NET Framework], about security
ms.assetid: 3cfced4f-ea02-4e66-ae98-d69286363e98
ms.openlocfilehash: b7bcb7e56ca14d129eadcaeac19452d4a443713d
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/07/2020
ms.locfileid: "75705973"
---
# <a name="key-security-concepts"></a><span data-ttu-id="657fe-102">セキュリティの基本概念</span><span class="sxs-lookup"><span data-stu-id="657fe-102">Key Security Concepts</span></span>
<span data-ttu-id="657fe-103">Microsoft .NET Framework では、モバイル コードに関するセキュリティへの対応を支援し、各ユーザーにどのような権限を与えるかをコンポーネントで決定できるようにするためのサポートを提供するロールベースのセキュリティがあります。</span><span class="sxs-lookup"><span data-stu-id="657fe-103">The Microsoft .NET Framework offers role-based security to help address security concerns about mobile code and to provide support that enables components to determine what users are authorized to do.</span></span>  
  
## <a name="type-safety-and-security"></a><span data-ttu-id="657fe-104">タイプ セーフとセキュリティ</span><span class="sxs-lookup"><span data-stu-id="657fe-104">Type safety and security</span></span>  
 <span data-ttu-id="657fe-105">タイプ セーフなコードは、アクセス権限を与えられているメモリ位置にだけアクセスします。</span><span class="sxs-lookup"><span data-stu-id="657fe-105">Type-safe code accesses only the memory locations it is authorized to access.</span></span> <span data-ttu-id="657fe-106">(この説明では、タイプセーフはメモリタイプの安全性を意味するので、より広い観点でタイプセーフと混同しないようにする必要があります)。たとえば、タイプセーフなコードでは、別のオブジェクトのプライベートフィールドから値を読み取ることはできません。</span><span class="sxs-lookup"><span data-stu-id="657fe-106">(For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields.</span></span> <span data-ttu-id="657fe-107">適切に定義された許容される方法でだけ、タイプにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="657fe-107">It accesses types only in well-defined, allowable ways.</span></span>  
  
 <span data-ttu-id="657fe-108">ジャスト イン タイム (JIT: Just-In-Time) コンパイル時に、オプションの検査プロセスは、ネイティブなマシン コードに JIT コンパイルされるメソッドのメタデータと Microsoft Intermediate Language (MSIL) を調べて、タイプ セーフかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="657fe-108">During just-in-time (JIT) compilation, an optional verification process examines the metadata and Microsoft intermediate language (MSIL) of a method to be JIT-compiled into native machine code to verify that they are type safe.</span></span> <span data-ttu-id="657fe-109">コードに検査を省略するためのアクセス許可がある場合、このプロセスは省略されます。</span><span class="sxs-lookup"><span data-stu-id="657fe-109">This process is skipped if the code has permission to bypass verification.</span></span> <span data-ttu-id="657fe-110">検査の詳細については、「[マネージド実行プロセス](../../../docs/standard/managed-execution-process.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="657fe-110">For more information about verification, see [Managed Execution Process](../../../docs/standard/managed-execution-process.md).</span></span>  
  
 <span data-ttu-id="657fe-111">タイプ セーフの検査はマネージド コードの実行に必須ではありませんが、アセンブリの分離とセキュリティの適用において、タイプ セーフであることが重要な意味を持ちます。</span><span class="sxs-lookup"><span data-stu-id="657fe-111">Although verification of type safety is not mandatory to run managed code, type safety plays a crucial role in assembly isolation and security enforcement.</span></span> <span data-ttu-id="657fe-112">コードがタイプ セーフであると、共通言語ランタイムはアセンブリを互いに完全に分離できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-112">When code is type safe, the common language runtime can completely isolate assemblies from each other.</span></span> <span data-ttu-id="657fe-113">アセンブリが互いに分離していると、アセンブリどうしが悪い影響を及ぼしあうことがなく、アプリケーションの信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="657fe-113">This isolation helps ensure that assemblies cannot adversely affect each other and it increases application reliability.</span></span> <span data-ttu-id="657fe-114">タイプ セーフなコンポーネントは、信頼されるレベルが異なっていても、同じプロセスで安全に実行できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-114">Type-safe components can execute safely in the same process even if they are trusted at different levels.</span></span> <span data-ttu-id="657fe-115">コードがタイプ セーフでないと、望ましくない副作用が生じることがあります。</span><span class="sxs-lookup"><span data-stu-id="657fe-115">When code is not type safe, unwanted side effects can occur.</span></span> <span data-ttu-id="657fe-116">たとえば、ランタイムは、マネージド コードがネイティブ (アンマネージ) コードにアクセスしたり、不正な操作を実行することを防止できません。</span><span class="sxs-lookup"><span data-stu-id="657fe-116">For example, the runtime cannot prevent managed code from calling into native (unmanaged) code and performing malicious operations.</span></span> <span data-ttu-id="657fe-117">コードがタイプ セーフであると、ランタイムのセキュリティ適用機構によって、必要なアクセス許可を持たないコードがネイティブ コードにアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="657fe-117">When code is type safe, the runtime's security enforcement mechanism ensures that it does not access native code unless it has permission to do so.</span></span> <span data-ttu-id="657fe-118">タイプ セーフでないすべてのコードは、列挙子メンバー <xref:System.Security.Permissions.SecurityPermission> が渡された <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> を与えられていないと実行できません。</span><span class="sxs-lookup"><span data-stu-id="657fe-118">All code that is not type safe must have been granted <xref:System.Security.Permissions.SecurityPermission> with the passed enum member <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> to run.</span></span>  
  
 <span data-ttu-id="657fe-119">詳しくは、「[コード アクセス セキュリティの基礎](../../../docs/framework/misc/code-access-security-basics.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="657fe-119">For more information, see [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md).</span></span>  
  
## <a name="principal"></a><span data-ttu-id="657fe-120">プリンシパル</span><span class="sxs-lookup"><span data-stu-id="657fe-120">Principal</span></span>  
 <span data-ttu-id="657fe-121">プリンシパルは、ユーザーの ID とロールを表し、ユーザーの代わりを務めます。</span><span class="sxs-lookup"><span data-stu-id="657fe-121">A principal represents the identity and role of a user and acts on the user's behalf.</span></span> <span data-ttu-id="657fe-122">.NET Framework のロール ベース セキュリティでは、次の 3 種類のプリンシパルがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="657fe-122">Role-based security in the .NET Framework supports three kinds of principals:</span></span>  
  
- <span data-ttu-id="657fe-123">汎用プリンシパルは、Windows のユーザーとロールとは無関係に存在するユーザーとロールを表します。</span><span class="sxs-lookup"><span data-stu-id="657fe-123">Generic principals represent users and roles that exist independent of Windows users and roles.</span></span>  
  
- <span data-ttu-id="657fe-124">Windows プリンシパルは、Windows のユーザーとそのロール (または Windows グループ) を表します。</span><span class="sxs-lookup"><span data-stu-id="657fe-124">Windows principals represent Windows users and their roles (or their Windows groups).</span></span> <span data-ttu-id="657fe-125">Windows プリンシパルは、他のユーザーを偽装できます。つまり、Windows プリンシパルは、あるユーザーに属する ID を提示し、そのユーザーの代わりにリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="657fe-125">A Windows principal can impersonate another user, which means that the principal can access a resource on a user's behalf while presenting the identity that belongs to that user.</span></span>  
  
- <span data-ttu-id="657fe-126">カスタム プリンシパルは、アプリケーションが必要に応じて自由に定義できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-126">Custom principals can be defined by an application in any way that is needed for that particular application.</span></span> <span data-ttu-id="657fe-127">カスタム プリンシパルによって、プリンシパルの ID とロールの基本概念を拡張できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-127">They can extend the basic notion of the principal's identity and roles.</span></span>  
  
 <span data-ttu-id="657fe-128">詳しくは、「[プリンシパル オブジェクトと ID オブジェクト](../../../docs/standard/security/principal-and-identity-objects.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="657fe-128">For more information, see [Principal and Identity Objects](../../../docs/standard/security/principal-and-identity-objects.md).</span></span>  
  
## <a name="authentication"></a><span data-ttu-id="657fe-129">認証</span><span class="sxs-lookup"><span data-stu-id="657fe-129">Authentication</span></span>  
 <span data-ttu-id="657fe-130">認証とは、ユーザーの資格情報を調べ、資格情報をなんらかの権限に対して検証することによって、プリンシパルの身元 を発見および確認するプロセスです。</span><span class="sxs-lookup"><span data-stu-id="657fe-130">Authentication is the process of discovering and verifying the identity of a principal by examining the user's credentials and validating those credentials against some authority.</span></span> <span data-ttu-id="657fe-131">認証時に得られる情報は、コードで直接使用できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-131">The information obtained during authentication is directly usable by your code.</span></span> <span data-ttu-id="657fe-132">また、.NET Framework のロール ベース セキュリティを使用して、現在のユーザーを認証したり、そのプリンシパルにコードへのアクセスを許可するかどうかを判断したりできます。</span><span class="sxs-lookup"><span data-stu-id="657fe-132">You can also use .NET Framework role-based security to authenticate the current user and to determine whether to allow that principal to access your code.</span></span> <span data-ttu-id="657fe-133">特定のロールに関してプリンシパルを認証する方法の例については、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> メソッドのオーバーロードを参照してください。</span><span class="sxs-lookup"><span data-stu-id="657fe-133">See the overloads of the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> method for examples of how to authenticate the principal for specific roles.</span></span> <span data-ttu-id="657fe-134">たとえば、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> オーバーロードを使用すると、現在のユーザーが Administrators グループのメンバーであるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-134">For example, you can use the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> overload to determine if the current user is a member of the Administrators group.</span></span>  
  
 <span data-ttu-id="657fe-135">さまざまな認証メカニズムが現在使用されていて、その多くを .NET Framework のロール ベース セキュリティと一緒に使用できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-135">A variety of authentication mechanisms are used today, many of which can be used with .NET Framework role-based security.</span></span> <span data-ttu-id="657fe-136">最も一般に使用されている認証機構としては、基本認証、ダイジェスト認証、パスポート認証、オペレーティング システム認証 (NTLM 認証や Kerberos 認証など)、およびアプリケーション定義の認証機構などがあります。</span><span class="sxs-lookup"><span data-stu-id="657fe-136">Some of the most commonly used mechanisms are basic, digest, Passport, operating system (such as NTLM or Kerberos), or application-defined mechanisms.</span></span>  
  
### <a name="example"></a><span data-ttu-id="657fe-137">使用例</span><span class="sxs-lookup"><span data-stu-id="657fe-137">Example</span></span>  
 <span data-ttu-id="657fe-138">以下の例では、アクティブ プリンシパルが管理者である必要があります。</span><span class="sxs-lookup"><span data-stu-id="657fe-138">The following example requires that the active principal be an administrator.</span></span> <span data-ttu-id="657fe-139">`name` パラメーターは `null` で、これにより、管理者ユーザーがこの確認要求を渡すことを許可されます。</span><span class="sxs-lookup"><span data-stu-id="657fe-139">The `name` parameter is `null`, which allows any user who is an administrator to pass the demand.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="657fe-140">Windows Vista では、ユーザー アカウント制御 (UAC: User Account Control) でユーザーの権限が決定されます。</span><span class="sxs-lookup"><span data-stu-id="657fe-140">In Windows Vista, User Account Control (UAC) determines the privileges of a user.</span></span> <span data-ttu-id="657fe-141">ユーザーが組み込みの Administrators グループのメンバーである場合、そのユーザーには標準ユーザー アクセス トークンおよび管理者アクセス トークンの 2 つのランタイム アクセス トークンが割り当てられています。</span><span class="sxs-lookup"><span data-stu-id="657fe-141">If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token.</span></span> <span data-ttu-id="657fe-142">既定では、ユーザーは標準ユーザー ロールに所属します。</span><span class="sxs-lookup"><span data-stu-id="657fe-142">By default, you are in the standard user role.</span></span> <span data-ttu-id="657fe-143">管理者であることを要求するコードを実行するには、最初に、ユーザーの権限を標準ユーザーから管理者に昇格させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="657fe-143">To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator.</span></span> <span data-ttu-id="657fe-144">この操作は、アプリケーションの起動時にアプリケーション アイコンを右クリックし、管理者として実行することを指定して行うことができます。</span><span class="sxs-lookup"><span data-stu-id="657fe-144">You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.</span></span>  
  
 [!code-cpp[Classic PrincipalPermission Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PrincipalPermission Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CS/source.cs#1)]
 [!code-vb[Classic PrincipalPermission Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/VB/source.vb#1)]  
  
 <span data-ttu-id="657fe-145">次の例は、プリンシパルの ID と、プリンシパルで使用できるロールを判別する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="657fe-145">The following example demonstrates how to determine the identity of the principal and the roles available to the principal.</span></span> <span data-ttu-id="657fe-146">この例のアプリケーションは、現在のユーザーがアプリケーションの使用を許可するロールに含まれていることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-146">An application of this example might be to confirm that the current user is in a role you allow for using your application.</span></span>  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
## <a name="authorization"></a><span data-ttu-id="657fe-147">認証</span><span class="sxs-lookup"><span data-stu-id="657fe-147">Authorization</span></span>  
 <span data-ttu-id="657fe-148">承認とは、要求されたアクションの実行をプリンシパルに許可するかどうかを判断するプロセスです。</span><span class="sxs-lookup"><span data-stu-id="657fe-148">Authorization is the process of determining whether a principal is allowed to perform a requested action.</span></span> <span data-ttu-id="657fe-149">承認は認証の後に行われ、プリンシパルの ID とロールについての情報を使用して、そのプリンシパルがアクセスできるリソースを判断します。</span><span class="sxs-lookup"><span data-stu-id="657fe-149">Authorization occurs after authentication and uses information about the principal's identity and roles to determine what resources the principal can access.</span></span> <span data-ttu-id="657fe-150">承認は、.NET Framework のロール ベース セキュリティを使用して実装できます。</span><span class="sxs-lookup"><span data-stu-id="657fe-150">You can use .NET Framework role-based security to implement authorization.</span></span>
