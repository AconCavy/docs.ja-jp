---
title: 暗号化サービス
description: .NET でサポートされる暗号化の方法と手法の概要です。
ms.date: 07/14/2020
helpviewer_keywords:
- cryptography [.NET]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET]
- security [.NET], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: 5558c60768b992984c3800b482961128d3bf5d0b
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2020
ms.locfileid: "94829909"
---
# <a name="cryptographic-services"></a><span data-ttu-id="e9aa1-103">暗号化サービス</span><span class="sxs-lookup"><span data-stu-id="e9aa1-103">Cryptographic Services</span></span>

<span data-ttu-id="e9aa1-104">インターネットなどの公衆ネットワークには、エンティティ間の通信を保護する手段が用意されていません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-104">Public networks such as the Internet do not provide a means of secure communication between entities.</span></span> <span data-ttu-id="e9aa1-105">公衆ネットワークを経由した通信は、不当な第三者によって読み取られたり、さらには変更されたりするおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-105">Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</span></span> <span data-ttu-id="e9aa1-106">暗号化を使用すると、データが表示されないように保護し、データが変更されたかどうかを検出する方法を提供し、通常は安全でないチャネル上に安全な通信手段を確立できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-106">Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</span></span> <span data-ttu-id="e9aa1-107">たとえば、暗号化アルゴリズムを使用してデータを暗号化し、暗号化された状態で送信できます。送信先の相手は、後でこのデータを復号化できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-107">For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</span></span> <span data-ttu-id="e9aa1-108">暗号化されたデータを第三者が傍受したとしても、復号化するのは困難です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-108">If a third party intercepts the encrypted data, it will be difficult to decipher.</span></span>

<span data-ttu-id="e9aa1-109">.NET では、名前空間のクラスによって、 <xref:System.Security.Cryptography> 暗号化の多くの詳細が管理されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-109">In .NET, the classes in the <xref:System.Security.Cryptography> namespace manage many details of cryptography for you.</span></span> <span data-ttu-id="e9aa1-110">オペレーティングシステム実装用のラッパーもあれば、純粋なマネージ実装もあります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-110">Some are wrappers for operating system implementations, while others are purely managed implementations.</span></span> <span data-ttu-id="e9aa1-111">これらのクラスを使用するにあたって、暗号の専門家になる必要はありません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-111">You do not need to be an expert in cryptography to use these classes.</span></span> <span data-ttu-id="e9aa1-112">いずれかの暗号化アルゴリズム クラスのインスタンスを新しく作成すると、使いやすいようにキーが自動生成されます。また、既定のプロパティは可能な限り安全に保たれます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-112">When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</span></span>

<span data-ttu-id="e9aa1-113">この概要では、ClickOnce マニフェストなど、.NET でサポートされる暗号化の方法と手法の概要を示します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-113">This overview provides a synopsis of the encryption methods and practices supported by .NET, including the ClickOnce manifests.</span></span>

## <a name="cryptographic-primitives"></a><span data-ttu-id="e9aa1-114">暗号プリミティブ</span><span class="sxs-lookup"><span data-stu-id="e9aa1-114">Cryptographic Primitives</span></span>

<span data-ttu-id="e9aa1-115">暗号化が使用される一般的な状況では、二者 (ここでは Alice と Bob) が安全でないチャネルを経由して通信します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-115">In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</span></span> <span data-ttu-id="e9aa1-116">Alice と Bob は、通信が第三者に傍受されたとしても、内容は理解されないという保証を必要としています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-116">Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</span></span> <span data-ttu-id="e9aa1-117">また、Alice と Bob は離れた場所にいるため、Alice には、Bob から受け取る情報が送信中に変更されていないという保証が必要です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-117">Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</span></span> <span data-ttu-id="e9aa1-118">さらに Alice には、Bob のふりをしただれかからではなく、本当に Bob からの情報を受け取ることができるという保証が必要です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-118">In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</span></span>

<span data-ttu-id="e9aa1-119">暗号化は、次の目標を達成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-119">Cryptography is used to achieve the following goals:</span></span>

- <span data-ttu-id="e9aa1-120">機密性。ユーザーの ID またはデータが読み取られないように保護するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-120">Confidentiality: To help protect a user's identity or data from being read.</span></span>

- <span data-ttu-id="e9aa1-121">データの整合性。データが変更されないように保護するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-121">Data integrity: To help protect data from being changed.</span></span>

- <span data-ttu-id="e9aa1-122">信憑性。データが特定の人から送信されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-122">Authentication: To ensure that data originates from a particular party.</span></span>

- <span data-ttu-id="e9aa1-123">否認不可。特定の人がメッセージを送信したことを拒否することを防止します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-123">Non-repudiation: To prevent a particular party from denying that they sent a message.</span></span>

<span data-ttu-id="e9aa1-124">これらの目標を達成するために、暗号プリミティブと呼ばれるアルゴリズムと手法の組み合わせを使用して暗号スキームを作成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-124">To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</span></span> <span data-ttu-id="e9aa1-125">暗号プリミティブとその用途の一覧を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-125">The following table lists the cryptographic primitives and their uses.</span></span>

|<span data-ttu-id="e9aa1-126">暗号プリミティブ</span><span class="sxs-lookup"><span data-stu-id="e9aa1-126">Cryptographic primitive</span></span>|<span data-ttu-id="e9aa1-127">用途</span><span class="sxs-lookup"><span data-stu-id="e9aa1-127">Use</span></span>|
|-----------------------------|---------|
|<span data-ttu-id="e9aa1-128">共有キー暗号方式 (対称暗号化方式)</span><span class="sxs-lookup"><span data-stu-id="e9aa1-128">Secret-key encryption (symmetric cryptography)</span></span>|<span data-ttu-id="e9aa1-129">データに対して変換処理を実行し、データが第三者に読み取られるのを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-129">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="e9aa1-130">このタイプの暗号方式では、単一の共有キーを使用してデータの暗号化と復号化が行われます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-130">This type of encryption uses a single shared, secret key to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="e9aa1-131">公開キー暗号方式 (非対称暗号化方式)</span><span class="sxs-lookup"><span data-stu-id="e9aa1-131">Public-key encryption (asymmetric cryptography)</span></span>|<span data-ttu-id="e9aa1-132">データに対して変換処理を実行し、データが第三者に読み取られるのを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-132">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="e9aa1-133">このタイプの暗号方式では、公開キーと秘密キーのペアを使用してデータの暗号化と復号化が行われます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-133">This type of encryption uses a public/private key pair to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="e9aa1-134">署名の暗号化</span><span class="sxs-lookup"><span data-stu-id="e9aa1-134">Cryptographic signing</span></span>|<span data-ttu-id="e9aa1-135">送信元に固有のデジタル署名を作成することで、データが特定の人から送信されたことを確認することに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-135">Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</span></span> <span data-ttu-id="e9aa1-136">この処理でもハッシュ関数が使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-136">This process also uses hash functions.</span></span>|
|<span data-ttu-id="e9aa1-137">暗号ハッシュ</span><span class="sxs-lookup"><span data-stu-id="e9aa1-137">Cryptographic hashes</span></span>|<span data-ttu-id="e9aa1-138">任意の長さのデータを固定長のバイト シーケンスに変換します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-138">Maps data from any length to a fixed-length byte sequence.</span></span> <span data-ttu-id="e9aa1-139">ハッシュは統計的に一意となります。つまり、異なる 2 バイトのシーケンスが同一の値にハッシュされることはありません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-139">Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</span></span>|

## <a name="secret-key-encryption"></a><span data-ttu-id="e9aa1-140">共有キー暗号方式</span><span class="sxs-lookup"><span data-stu-id="e9aa1-140">Secret-Key Encryption</span></span>

<span data-ttu-id="e9aa1-141">共有キー暗号方式のアルゴリズムでは、単一の共有キーを使用したデータの暗号化と復号化が行われます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-141">Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</span></span> <span data-ttu-id="e9aa1-142">キーを取得した人はだれでもデータを復号化したり、独自のデータを暗号化したりできるため、承認されていないエージェントがアクセスしてデータの作成者になりすますことができないように、キーを保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-142">You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</span></span>

<span data-ttu-id="e9aa1-143">共有キー暗号方式は対称暗号化方式とも呼ばれます。これは、暗号化と復号化で同じキーが使用されるためです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-143">Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</span></span> <span data-ttu-id="e9aa1-144">共有キー暗号化アルゴリズムは (公開キー アルゴリズムと比較して) 非常に高速であり、大量のデータ ストリームに対して暗号変換を実行する場合に適しています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-144">Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</span></span> <span data-ttu-id="e9aa1-145">RSA などの非対称暗号化アルゴリズムは、暗号化できるデータ量に数学的に制限があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-145">Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</span></span> <span data-ttu-id="e9aa1-146">通常、対称暗号化アルゴリズムではこれらの問題は発生しません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-146">Symmetric encryption algorithms do not generally have those problems.</span></span>

<span data-ttu-id="e9aa1-147">データをブロック単位で暗号化するときには、ブロック暗号と呼ばれる共有キー アルゴリズムの種類が使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-147">A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</span></span> <span data-ttu-id="e9aa1-148">DES (Data Encryption Standard)、TripleDES、AES (Advanced Encryption Standard) などのブロック暗号では、 *n* バイトの入力ブロックが、暗号化されたバイト数の出力ブロックに変換されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-148">Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes.</span></span> <span data-ttu-id="e9aa1-149">バイト シーケンスを暗号化または復号化する場合は、ブロック単位で行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-149">If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</span></span> <span data-ttu-id="e9aa1-150">*8* は小さいため (DES および TripleDES では 8 バイト、AES では 16 バイト (既定)、24 バイト、または 32 バイト)、 *8* よりも大きいデータ値は 1 ブロックずつ暗号化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-150">Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time.</span></span> <span data-ttu-id="e9aa1-151">*8* よりも小さいデータ値を処理するためには、 *8* に拡張する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-151">Data values that are smaller than *n* have to be expanded to *n* in order to be processed.</span></span>

<span data-ttu-id="e9aa1-152">ブロック暗号の 1 つに、ECB (Electronic Codebook) モードと呼ばれる単純な形式があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-152">One simple form of block cipher is called the electronic codebook (ECB) mode.</span></span> <span data-ttu-id="e9aa1-153">ECB モードは、初期化ベクターを使用して最初の平文ブロックを初期化しないため、安全とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-153">ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</span></span> <span data-ttu-id="e9aa1-154">秘密キーを *k* とする場合、初期化ベクターを使用しない単純なブロック暗号では、同じ平文の入力ブロックは同じ暗号文の出力ブロックに暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-154">For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</span></span> <span data-ttu-id="e9aa1-155">したがって、入力平文ストリーム内に重複するブロックがある場合、暗号文ストリームにも重複するブロックが生成されることになります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-155">Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</span></span> <span data-ttu-id="e9aa1-156">このような重複する出力ブロックが存在すると、アルゴリズムで弱い暗号化が使用されていて、攻撃が可能なモードであることが、承認されていないユーザーにわかります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-156">These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</span></span> <span data-ttu-id="e9aa1-157">このため、ECB 暗号モードは分析に対してきわめて脆弱で、最終的にキーが検出されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-157">The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</span></span>

<span data-ttu-id="e9aa1-158">基底クラス ライブラリに用意されているブロック暗号クラスでは、暗号ブロック チェイン (CBC: Cipher Block Chaining) と呼ばれる既定のチェイン モードが使用されます。ただし、この既定のモードは必要に応じて変更できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-158">The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</span></span>

<span data-ttu-id="e9aa1-159">CBC 暗号は、初期化ベクター (IV: Initialization Vector) を使用して平文の最初のブロックを暗号化することにより、ECB 暗号に関連する問題を回避します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-159">CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</span></span> <span data-ttu-id="e9aa1-160">平文の後続の各ブロックは、前の暗号文ブロックを使用してビットごとの排他的 OR (`XOR`) 演算を実行してから、暗号化されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-160">Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted.</span></span> <span data-ttu-id="e9aa1-161">このため、各平文ブロックは、前のすべてのブロックに依存します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-161">Each ciphertext block is therefore dependent on all previous blocks.</span></span> <span data-ttu-id="e9aa1-162">このシステムを使用した場合は、承認されていないユーザーが共通メッセージ ヘッダーを知っていたとしても、その情報からキーをリバース エンジニアリングすることはできません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-162">When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</span></span>

<span data-ttu-id="e9aa1-163">CBC 暗号によって暗号化されたデータを解読する 1 つの方法は、考えられるすべてのキーを徹底的に探索することです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-163">One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</span></span> <span data-ttu-id="e9aa1-164">ただし、暗号化の実行時に使用したキーのサイズによっては、どれほど高速なコンピューターを使用してもかなりの時間がかかるため、この探索方法は現実的ではありません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-164">Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</span></span> <span data-ttu-id="e9aa1-165">キーのサイズを大きくするほど、復号化は困難になります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-165">Larger key sizes are more difficult to decipher.</span></span> <span data-ttu-id="e9aa1-166">暗号化することにより、暗号データの復号化が理論的に不可能になるわけではありませんが、復号化にかかるコストを大きくできます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-166">Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</span></span> <span data-ttu-id="e9aa1-167">3 か月をかけて徹底的な探索を行っても、取得されたデータが数日間しか意味を持たないとすると、その探索方法は実用的とはいえません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-167">If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</span></span>

<span data-ttu-id="e9aa1-168">共有キー暗号方式の弱点は、両者のキーと IV を一致させ、それぞれの値を転送しておく必要がある点です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-168">The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</span></span> <span data-ttu-id="e9aa1-169">IV は秘密情報とは見なされないため、平文のメッセージで転送できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-169">The IV is not considered a secret and can be transmitted in plaintext with the message.</span></span> <span data-ttu-id="e9aa1-170">しかし、キーは承認されていないユーザーから保護する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-170">However, the key must be kept secret from unauthorized users.</span></span> <span data-ttu-id="e9aa1-171">このような問題のため、共有キー暗号方式は公開キー暗号方式と併用されることがよくあります。公開キー暗号方式は、キーと IV の値を秘密に通信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-171">Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</span></span>

<span data-ttu-id="e9aa1-172">安全でないチャネルを経由して Alice と Bob が通信しようとしている場合は、次のように共有キー暗号方式を使用することが考えられます。Alice と Bob は、特定の 1 つのアルゴリズム (たとえば AES) と、特定のキーおよび IV を使用することに合意します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-172">Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</span></span> <span data-ttu-id="e9aa1-173">Alice はメッセージを作成し、メッセージの送信先となるネットワークストリーム (名前付きパイプやネットワーク電子メールなど) を作成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-173">Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.</span></span> <span data-ttu-id="e9aa1-174">次に、キーと IV を使用してテキストを暗号化し、暗号化されたメッセージと IV をインターネット経由で Bob に送信します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-174">Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</span></span> <span data-ttu-id="e9aa1-175">暗号化されたテキストを受信した Bob は、IV とあらかじめ決めてあるキーを使用して復号化を行います。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-175">Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</span></span> <span data-ttu-id="e9aa1-176">送信が傍受された場合、インターセプターはキーを認識しないため、元のメッセージを回復できません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-176">If the transmission is intercepted, the interceptor cannot recover the original message, because they do not know the key.</span></span> <span data-ttu-id="e9aa1-177">このシナリオでは、秘密にしておく必要があるのはキーだけです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-177">In this scenario, only the key must remain secret.</span></span> <span data-ttu-id="e9aa1-178">実際のシナリオでは、Alice または Bob のどちらかが共有キーを生成し、公開キー (非対称) 暗号方式を使用して相手に共有 (対称) キーを転送することになります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-178">In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</span></span> <span data-ttu-id="e9aa1-179">公開キー暗号方式の詳細については、次のセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-179">For more information about public-key encryption, see the next section.</span></span>

<span data-ttu-id="e9aa1-180">.NET には、共有キー暗号化アルゴリズムを実装する次のクラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-180">.NET provides the following classes that implement secret-key encryption algorithms:</span></span>

- <xref:System.Security.Cryptography.Aes>

- <span data-ttu-id="e9aa1-181"><xref:System.Security.Cryptography.HMACSHA256>、<xref:System.Security.Cryptography.HMACSHA384> および <xref:System.Security.Cryptography.HMACSHA512>。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-181"><xref:System.Security.Cryptography.HMACSHA256>, <xref:System.Security.Cryptography.HMACSHA384> and <xref:System.Security.Cryptography.HMACSHA512>.</span></span> <span data-ttu-id="e9aa1-182">(これらは、秘密キーと組み合わせた暗号ハッシュ関数を使用して計算されるメッセージ認証コードを表すため、技術的には共有キーアルゴリズムです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-182">(These are technically secret-key algorithms because they represent message authentication codes that are calculated by using a cryptographic hash function combined with a secret key.</span></span> <span data-ttu-id="e9aa1-183">この記事で後述する「 [ハッシュ値](#hash-values)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-183">See [Hash Values](#hash-values), later in this article.)</span></span>

## <a name="public-key-encryption"></a><span data-ttu-id="e9aa1-184">公開キー暗号方式</span><span class="sxs-lookup"><span data-stu-id="e9aa1-184">Public-Key Encryption</span></span>

<span data-ttu-id="e9aa1-185">公開キー暗号方式では、承認されていないユーザーから保護する必要のある秘密キーと、だれに公開してもかまわない公開キーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-185">Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</span></span> <span data-ttu-id="e9aa1-186">公開キーと秘密キーは正確にリンクされ、公開キーで暗号化されたデータは、対応する秘密キーでしか復号化できません。また、秘密キーで署名されたデータは、対応する公開キーでしか検査できません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-186">The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</span></span> <span data-ttu-id="e9aa1-187">公開キーはだれに公開してもかまいません。公開キーは、秘密キーの所有者に送信するデータを暗号化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-187">The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</span></span> <span data-ttu-id="e9aa1-188">公開キー暗号化アルゴリズムは、非対称アルゴリズムとしても知られています。これは、データの暗号化に 1 つのキーが使用され、データの復号化に別のキーが使用されるためです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-188">Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</span></span> <span data-ttu-id="e9aa1-189">基本的な暗号化規則でキーの再使用を禁止し、いずれのキーも通信セッションごとに一意にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-189">A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</span></span> <span data-ttu-id="e9aa1-190">ただし、実際には、非対称キーの寿命は長いことが一般的です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-190">However, in practice, asymmetric keys are generally long-lived.</span></span>

<span data-ttu-id="e9aa1-191">二者 (ここでは Alice と Bob) は、次のように公開キーの暗号化を使用できます。まず、Alice が公開キー/秘密キーのペアを生成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-191">Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</span></span> <span data-ttu-id="e9aa1-192">暗号メッセージを Alice に送信するとき、Bob は Alice に公開キーを送信するように依頼します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-192">If Bob wants to send Alice an encrypted message, he asks her for her public key.</span></span> <span data-ttu-id="e9aa1-193">Alice は安全でないネットワークを通して Bob に公開キーを送信し、Bob はこのキーを使用してメッセージを暗号化します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-193">Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</span></span> <span data-ttu-id="e9aa1-194">Bob は暗号メッセージを Alice に送信し、Alice は自分の秘密キーを使用してメッセージを復号化します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-194">Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</span></span> <span data-ttu-id="e9aa1-195">公衆ネットワークなどの安全でないチャネル経由で Alice のキーを受信した場合、Bob は man-in-the-middle 攻撃に対して無防備になります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-195">If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</span></span> <span data-ttu-id="e9aa1-196">したがって、Bob は所有している Alice の公開キーの正しいコピーを使用して、Alice であることを検証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-196">Therefore, Bob must verify with Alice that he has a correct copy of her public key.</span></span>

<span data-ttu-id="e9aa1-197">Alice の公開キーの転送中に、承認されていないエージェントによってキーが傍受される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-197">During the transmission of Alice's public key, an unauthorized agent might intercept the key.</span></span> <span data-ttu-id="e9aa1-198">さらに、同じエージェントが Bob からの暗号メッセージを傍受する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-198">Furthermore, the same agent might intercept the encrypted message from Bob.</span></span> <span data-ttu-id="e9aa1-199">しかし、公開キーを使用してもメッセージを復号化することはできません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-199">However, the agent cannot decrypt the message with the public key.</span></span> <span data-ttu-id="e9aa1-200">メッセージを復号化できるのは Alice の秘密キーだけですが、これは送信されていません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-200">The message can be decrypted only with Alice's private key, which has not been transmitted.</span></span> <span data-ttu-id="e9aa1-201">Alice は Bob への返信メッセージを暗号化するときに自分の秘密キーを使用しません。公開キーを持つ人は、だれでもそのメッセージを復号化できるためです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-201">Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</span></span> <span data-ttu-id="e9aa1-202">Alice から Bob にメッセージを返信するときには、Alice が Bob の公開キーをたずね、その公開キーを使用してメッセージを暗号化します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-202">If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</span></span> <span data-ttu-id="e9aa1-203">その後、Bob は自分の秘密キーを使用してメッセージを復号化します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-203">Bob then decrypts the message using his associated private key.</span></span>

<span data-ttu-id="e9aa1-204">このシナリオでは、Alice と Bob は公開キー (非対称) 暗号方式を使用して共有 (対称) キーを転送し、その他のセッションでは共有キー暗号方式を使用することになります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-204">In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</span></span>

<span data-ttu-id="e9aa1-205">次の一覧を使用して、公開キーと共有キーの暗号化アルゴリズムを比較します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-205">The following list offers comparisons between public-key and secret-key cryptographic algorithms:</span></span>

- <span data-ttu-id="e9aa1-206">公開キー暗号化アルゴリズムでは固定バッファー サイズが使用されますが、共有キー暗号化アルゴリズムでは可変長バッファーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-206">Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</span></span>

- <span data-ttu-id="e9aa1-207">公開キー アルゴリズムでは少量のデータしか暗号化できないため、共有キー アルゴリズムのようにデータをチェインしてストリームを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-207">Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</span></span> <span data-ttu-id="e9aa1-208">したがって、非対称操作では対称操作と同じストリーミング モデルは使用されません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-208">Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</span></span>

- <span data-ttu-id="e9aa1-209">公開キーの暗号化方式では、秘密キーの暗号化と比較してキーのキースペース (使用できる値の範囲) が大幅に広がります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-209">Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</span></span> <span data-ttu-id="e9aa1-210">そのため、公開キーの暗号化では、あらゆるキーを試すような徹底的な攻撃の影響を受けにくくなります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-210">Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</span></span>

- <span data-ttu-id="e9aa1-211">送信元の身元を検証する方法が存在する場合、公開キーは保護する必要なく簡単に配布できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-211">Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</span></span>

- <span data-ttu-id="e9aa1-212">いくつかの公開キー アルゴリズム (Diffie-Hellman 以外の RSA や DSA など) では、データの送信元の身元を検査するデジタル署名を作成できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-212">Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</span></span>

- <span data-ttu-id="e9aa1-213">公開キー アルゴリズムは秘密キー アルゴリズムと比較してきわめて低速であり、大量のデータを暗号化するようには設計されていません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-213">Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</span></span> <span data-ttu-id="e9aa1-214">公開キー アルゴリズムが便利なのは、少量のデータを転送する場合に限られます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-214">Public-key algorithms are useful only for transferring very small amounts of data.</span></span> <span data-ttu-id="e9aa1-215">一般に、公開キー暗号方式は、共有キー アルゴリズムで使われるキーと IV を暗号化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-215">Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</span></span> <span data-ttu-id="e9aa1-216">キーと IV を転送した後の残りのセッションでは、共有キー暗号方式が使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-216">After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</span></span>

<span data-ttu-id="e9aa1-217">.NET には、公開キーアルゴリズムを実装する次のクラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-217">.NET provides the following classes that implement public-key algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.ECDiffieHellman>

- <xref:System.Security.Cryptography.DSA>

<span data-ttu-id="e9aa1-218">RSA では暗号化と署名の両方が許可されますが、DSA は署名にのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-218">RSA allows both encryption and signing, but DSA can be used only for signing.</span></span> <span data-ttu-id="e9aa1-219">DSA は RSA ほど安全ではないため、RSA をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-219">DSA is not as secure as RSA, and we recommend RSA.</span></span> <span data-ttu-id="e9aa1-220">Diffie-Hellman は、キーの生成にのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-220">Diffie-Hellman can be used only for key generation.</span></span> <span data-ttu-id="e9aa1-221">一般に、秘密キー アルゴリズムに比べて、公開キー アルゴリズムの使用には多くの制限があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-221">In general, public-key algorithms are more limited in their uses than private-key algorithms.</span></span>

## <a name="digital-signatures"></a><span data-ttu-id="e9aa1-222">デジタル署名</span><span class="sxs-lookup"><span data-stu-id="e9aa1-222">Digital Signatures</span></span>

<span data-ttu-id="e9aa1-223">公開キー アルゴリズムは、デジタル署名を形成するためにも使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-223">Public-key algorithms can also be used to form digital signatures.</span></span> <span data-ttu-id="e9aa1-224">デジタル署名は、(送信元の公開キーを信頼している場合に) 送信元の ID を認証したり、データの整合性を保護することを支援したりします。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-224">Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</span></span> <span data-ttu-id="e9aa1-225">Alice によって生成された公開キーを使用すると、Alice のデータの受信者は、Alice のデータに添付されたデジタル署名と Alice の公開キーを比較することによって、データの送信元が Alice かどうかを検査できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-225">Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</span></span>

<span data-ttu-id="e9aa1-226">Alice は、公開キー暗号方式を使用してメッセージにデジタル署名を添付するために、まずメッセージに対してハッシュ アルゴリズムを適用してメッセージ ダイジェストを作成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-226">To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</span></span> <span data-ttu-id="e9aa1-227">このメッセージ ダイジェストは、一意でコンパクトなデータ表現です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-227">The message digest is a compact and unique representation of data.</span></span> <span data-ttu-id="e9aa1-228">次に Alice は、自分の秘密キーを使用してメッセージ ダイジェストを暗号化し、個人用の署名を作成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-228">Alice then encrypts the message digest with her private key to create her personal signature.</span></span> <span data-ttu-id="e9aa1-229">Bob は、メッセージと署名を受信したときに Alice の公開キーを使用して署名を復号化し、メッセージ ダイジェストを復元します。そして、Alice が使用したのと同じハッシュ アルゴリズムを使用してメッセージをハッシュします。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-229">Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</span></span> <span data-ttu-id="e9aa1-230">Bob が計算したメッセージ ダイジェストが Alice から受け取ったメッセージ ダイジェストと正確に一致する場合、そのメッセージは秘密キーの所有者から送信されたことになり、データも変更されていないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-230">If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</span></span> <span data-ttu-id="e9aa1-231">Alice が秘密キーの所有者であることが確かならば、Bob にはメッセージが Alice から送信されたことがわかります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-231">If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</span></span>

> [!NOTE]
> <span data-ttu-id="e9aa1-232">送信者の公開キーは公開された情報であり、通常はデジタル署名の書式に含まれるため、だれでも署名を検査できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-232">A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</span></span> <span data-ttu-id="e9aa1-233">この方法では、メッセージの秘密性は保持されません。メッセージを秘密にしておくためには、メッセージ自体も暗号化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-233">This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</span></span>

<span data-ttu-id="e9aa1-234">.NET には、デジタル署名アルゴリズムを実装する次のクラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-234">.NET provides the following classes that implement digital signature algorithms:</span></span>

- <xref:System.Security.Cryptography.RSA>

- <xref:System.Security.Cryptography.ECDsa>

- <xref:System.Security.Cryptography.DSA>

## <a name="hash-values"></a><span data-ttu-id="e9aa1-235">ハッシュ値</span><span class="sxs-lookup"><span data-stu-id="e9aa1-235">Hash Values</span></span>

<span data-ttu-id="e9aa1-236">ハッシュ アルゴリズムは、任意の長さのバイナリ値を、ハッシュ値と呼ばれるより小さい固定長のバイナリ値に変換します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-236">Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</span></span> <span data-ttu-id="e9aa1-237">ハッシュ値は、ひとまとまりのデータを数値で表現したものです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-237">A hash value is a numerical representation of a piece of data.</span></span> <span data-ttu-id="e9aa1-238">平文の段落のハッシュを計算してから、段落の 1 文字だけでも変更すると、その後のハッシュでは別の値が生成されることになります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-238">If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</span></span> <span data-ttu-id="e9aa1-239">強力な暗号化におけるハッシュは、値が大幅に変わります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-239">If the hash is cryptographically strong, its value will change significantly.</span></span> <span data-ttu-id="e9aa1-240">たとえば、メッセージの 1 ビットを変更すると、強力なハッシュ関数では 50% 異なる出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-240">For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</span></span> <span data-ttu-id="e9aa1-241">多くの入力値が同じ出力値にハッシュされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-241">Many input values may hash to the same output value.</span></span> <span data-ttu-id="e9aa1-242">ただし、同一の値にハッシュされる 2 つの異なる入力を見つけることは、計算上不可能です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-242">However, it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span>

<span data-ttu-id="e9aa1-243">二者 (ここでは Alice と Bob) は、ハッシュ関数を使用してメッセージの整合性を確保できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-243">Two parties (Alice and Bob) could use a hash function to ensure message integrity.</span></span> <span data-ttu-id="e9aa1-244">Alice と Bob はハッシュ アルゴリズムを選択してメッセージに署名します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-244">They would select a hash algorithm to sign their messages.</span></span> <span data-ttu-id="e9aa1-245">Alice はメッセージを書き込み、選択したアルゴリズムを使用してそのメッセージのハッシュを作成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-245">Alice would write a message, and then create a hash of that message by using the selected algorithm.</span></span> <span data-ttu-id="e9aa1-246">そして、次のいずれかの方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-246">They would then follow one of the following methods:</span></span>

- <span data-ttu-id="e9aa1-247">Alice はプレーンテキスト メッセージとハッシュしたメッセージ (デジタル署名) を Bob に送信します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-247">Alice sends the plaintext message and the hashed message (digital signature) to Bob.</span></span> <span data-ttu-id="e9aa1-248">Bob はメッセージを受信してハッシュ値を計算し、算出したハッシュ値を Alice から受け取ったハッシュ値と比較します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-248">Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</span></span> <span data-ttu-id="e9aa1-249">ハッシュ値が同一の場合、メッセージは変更されていません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-249">If the hash values are identical, the message was not altered.</span></span> <span data-ttu-id="e9aa1-250">ハッシュ値が同一でない場合は、Alice がメッセージを作成した後でその内容が変更されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-250">If the values are not identical, the message was altered after Alice wrote it.</span></span>

  <span data-ttu-id="e9aa1-251">残念ながら、この方法では送信元の信頼性を保証できません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-251">Unfortunately, this method does not establish the authenticity of the sender.</span></span> <span data-ttu-id="e9aa1-252">どのユーザーでも Alice を偽装して Bob にメッセージを送信できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-252">Anyone can impersonate Alice and send a message to Bob.</span></span> <span data-ttu-id="e9aa1-253">だれもが同じハッシュ アルゴリズムを使用してメッセージに署名できます。Bob が判断できるのは、メッセージがその署名と一致するかどうかだけです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-253">They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</span></span> <span data-ttu-id="e9aa1-254">これは、一種の man-in-the-middle 攻撃です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-254">This is one form of a man-in-the-middle attack.</span></span> <span data-ttu-id="e9aa1-255">詳細については、「 [Cryptography Next Generation (CNG) セキュリティで保護された通信の例](/previous-versions/cc488018(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-255">For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](/previous-versions/cc488018(v=vs.100)).</span></span>

- <span data-ttu-id="e9aa1-256">Alice はセキュリティで保護されていないパブリック チャネルを使用して、Bob にプレーンテキスト メッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-256">Alice sends the plaintext message to Bob over a nonsecure public channel.</span></span> <span data-ttu-id="e9aa1-257">そして、セキュリティで保護されたプライベート チャネルを使用して、Bob にハッシュしたメッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-257">She sends the hashed message to Bob over a secure private channel.</span></span> <span data-ttu-id="e9aa1-258">Bob はプレーンテキスト メッセージを受信し、ハッシュを計算して、プライベートに交換したハッシュと比較します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-258">Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</span></span> <span data-ttu-id="e9aa1-259">ハッシュが一致すると、Bob は次の 2 つのことを判断できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-259">If the hashes match, Bob knows two things:</span></span>

  - <span data-ttu-id="e9aa1-260">メッセージが変更されていないこと。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-260">The message was not altered.</span></span>

  - <span data-ttu-id="e9aa1-261">メッセージの送信元 (Alice) は認証されていること。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-261">The sender of the message (Alice) is authentic.</span></span>

  <span data-ttu-id="e9aa1-262">このしくみを機能させるために、Alice は元のハッシュ値を Bob 以外の人から隠す必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-262">For this system to work, Alice must hide her original hash value from all parties except Bob.</span></span>

- <span data-ttu-id="e9aa1-263">Alice はセキュリティで保護されていないパブリック チャネルを使用して Bob にプレーンテキスト メッセージを送信し、パブリックに参照できる Web サイトにハッシュしたメッセージを配置します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-263">Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</span></span>

  <span data-ttu-id="e9aa1-264">この方法は、だれかがハッシュ値を変更することを防ぐことで、メッセージの改ざんを防止します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-264">This method prevents message tampering by preventing anyone from modifying the hash value.</span></span> <span data-ttu-id="e9aa1-265">メッセージとそのハッシュ値はどのユーザーでも読み取ることができますが、ハッシュ値を変更できるのは Alice だけです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-265">Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</span></span> <span data-ttu-id="e9aa1-266">Alice を偽装しようとする攻撃者は、Alice の Web サイトにアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-266">An attacker who wants to impersonate Alice would require access to Alice's Web site.</span></span>

<span data-ttu-id="e9aa1-267">Alice のメッセージはプレーンテキストで送信されるため、前に説明した方法では、Alice のメッセージがだれかから読み取られないように防ぐことはできません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-267">None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</span></span> <span data-ttu-id="e9aa1-268">セキュリティを完全にするには、一般に、デジタル署名 (メッセージ署名) と暗号化が必要です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-268">Full security typically requires digital signatures (message signing) and encryption.</span></span>

<span data-ttu-id="e9aa1-269">.NET には、ハッシュアルゴリズムを実装する次のクラスが用意されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-269">.NET provides the following classes that implement hashing algorithms:</span></span>

- <span data-ttu-id="e9aa1-270"><xref:System.Security.Cryptography.SHA256>.</span><span class="sxs-lookup"><span data-stu-id="e9aa1-270"><xref:System.Security.Cryptography.SHA256>.</span></span>

- <span data-ttu-id="e9aa1-271"><xref:System.Security.Cryptography.SHA384>.</span><span class="sxs-lookup"><span data-stu-id="e9aa1-271"><xref:System.Security.Cryptography.SHA384>.</span></span>

- <span data-ttu-id="e9aa1-272"><xref:System.Security.Cryptography.SHA512>.</span><span class="sxs-lookup"><span data-stu-id="e9aa1-272"><xref:System.Security.Cryptography.SHA512>.</span></span>

<span data-ttu-id="e9aa1-273">.NET には、およびも用意され <xref:System.Security.Cryptography.MD5> て <xref:System.Security.Cryptography.SHA1> います。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-273">.NET also provides <xref:System.Security.Cryptography.MD5> and <xref:System.Security.Cryptography.SHA1>.</span></span> <span data-ttu-id="e9aa1-274">しかし、MD5 アルゴリズムと SHA-1 アルゴリズムは安全ではないことがわかり、代わりに SHA-1 が推奨されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-274">But the MD5 and SHA-1 algorithms have been found to be insecure, and SHA-2 is now recommended instead.</span></span> <span data-ttu-id="e9aa1-275">SHA-1 には SHA256、SHA384、および SHA512 が含まれます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-275">SHA-2 includes SHA256, SHA384, and SHA512.</span></span>

## <a name="random-number-generation"></a><span data-ttu-id="e9aa1-276">乱数生成</span><span class="sxs-lookup"><span data-stu-id="e9aa1-276">Random Number Generation</span></span>

<span data-ttu-id="e9aa1-277">乱数生成は、多くの暗号化操作に欠かせない部分です。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-277">Random number generation is integral to many cryptographic operations.</span></span> <span data-ttu-id="e9aa1-278">たとえば、暗号キーはできるだけランダムにして、再現できないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-278">For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</span></span> <span data-ttu-id="e9aa1-279">暗号乱数ジェネレーターは、予測される確率が 50% よりも低い、計算上は不可能な出力を生成しなければなりません。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-279">Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</span></span> <span data-ttu-id="e9aa1-280">したがって、当て推量をされた場合でも予測できないような手段を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-280">Therefore, any method of predicting the next output bit must not perform better than random guessing.</span></span> <span data-ttu-id="e9aa1-281">.NET のクラスは、乱数ジェネレーターを使用して暗号化キーを生成します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-281">The classes in .NET use random number generators to generate cryptographic keys.</span></span>

<span data-ttu-id="e9aa1-282">乱数ジェネレーター アルゴリズムは、 <xref:System.Security.Cryptography.RandomNumberGenerator> クラスに実装されています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-282">The <xref:System.Security.Cryptography.RandomNumberGenerator> class is an implementation of a random number generator algorithm.</span></span>

## <a name="clickonce-manifests"></a><span data-ttu-id="e9aa1-283">ClickOnce マニフェスト</span><span class="sxs-lookup"><span data-stu-id="e9aa1-283">ClickOnce Manifests</span></span>

<span data-ttu-id="e9aa1-284">次の暗号化クラスを使用すると、 [ClickOnce テクノロジ](/visualstudio/deployment/clickonce-security-and-deployment)を使用して配置されたアプリケーションのマニフェスト署名に関する情報を取得および検証できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-284">The following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):</span></span>

- <span data-ttu-id="e9aa1-285"><xref:System.Security.Cryptography.ManifestSignatureInformation> クラスは、 <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> メソッド オーバーロードの使用時に、マニフェストの署名に関する情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-285">The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.</span></span>

- <span data-ttu-id="e9aa1-286">検証するマニフェストを指定するには、 <xref:System.Security.ManifestKinds> 列挙体を使用します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-286">You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify.</span></span> <span data-ttu-id="e9aa1-287">検証の結果は、 <xref:System.Security.Cryptography.SignatureVerificationResult> のいずれかの列挙値になります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-287">The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.</span></span>

- <span data-ttu-id="e9aa1-288"><xref:System.Security.Cryptography.ManifestSignatureInformationCollection> クラスは、検証された署名の <xref:System.Security.Cryptography.ManifestSignatureInformation> オブジェクトの読み取り専用コレクションを提供します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-288">The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.</span></span>

<span data-ttu-id="e9aa1-289">特定の署名情報を提供するクラスとしては、他にも次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-289">In addition, the following classes provide specific signature information:</span></span>

- <span data-ttu-id="e9aa1-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> は、マニフェストの厳密な名前の署名情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-290"><xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.</span></span>

- <span data-ttu-id="e9aa1-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> は、マニフェストの Authenticode 署名情報を表します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-291"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.</span></span>

- <span data-ttu-id="e9aa1-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> は、Authenticode 署名のタイム スタンプ情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-292"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.</span></span>

- <span data-ttu-id="e9aa1-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> は、Authenticode 署名が信頼済みかどうかを簡単な方法でチェックできます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-293"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.</span></span>

## <a name="cryptography-next-generation-cng-classes"></a><span data-ttu-id="e9aa1-294">CNG (Cryptography Next Generation) クラス</span><span class="sxs-lookup"><span data-stu-id="e9aa1-294">Cryptography Next Generation (CNG) Classes</span></span>

<span data-ttu-id="e9aa1-295">CNG のクラスには、ネイティブ CNG 関数を扱うマネージド ラッパーが用意されています</span><span class="sxs-lookup"><span data-stu-id="e9aa1-295">The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</span></span> <span data-ttu-id="e9aa1-296">(CNG は CryptoAPI に代わるものです)。これらのクラスは、名前の一部として "Cng" を持ちます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-296">(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</span></span> <span data-ttu-id="e9aa1-297">CNG ラッパー クラスの中心は、CNG キーのストレージと使用を抽象化する <xref:System.Security.Cryptography.CngKey> キー コンテナー クラスです。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-297">Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys.</span></span> <span data-ttu-id="e9aa1-298">このクラスにより、キー ペアまたは公開キーを安全に格納したり、単純な文字列名を使って参照したりすることが可能になります。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-298">This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</span></span> <span data-ttu-id="e9aa1-299">楕円曲線ベースの <xref:System.Security.Cryptography.ECDsaCng> 署名クラスおよび <xref:System.Security.Cryptography.ECDiffieHellmanCng> 暗号化クラスは、 <xref:System.Security.Cryptography.CngKey> オブジェクトを使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-299">The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.</span></span>

<span data-ttu-id="e9aa1-300"><xref:System.Security.Cryptography.CngKey> クラスは、キーを開く、作成する、削除する、エクスポートするなど、さまざまな補足的な操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-300">The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</span></span> <span data-ttu-id="e9aa1-301">また、ネイティブ関数を直接呼び出すときに使用する、基になるキー ハンドルへのアクセスも提供します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-301">It also provides access to the underlying key handle to use when calling native functions directly.</span></span>

<span data-ttu-id="e9aa1-302">.NET には、次のようなさまざまなサポート CNG クラスも含まれています。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-302">.NET also includes a variety of supporting CNG classes, such as the following:</span></span>

- <span data-ttu-id="e9aa1-303"><xref:System.Security.Cryptography.CngProvider> は、キー ストレージ プロバイダーを管理します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-303"><xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.</span></span>

- <span data-ttu-id="e9aa1-304"><xref:System.Security.Cryptography.CngAlgorithm> は、CNG アルゴリズムを管理します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-304"><xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.</span></span>

- <span data-ttu-id="e9aa1-305"><xref:System.Security.Cryptography.CngProperty> は、よく使用される主要なプロパティを管理します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-305"><xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.</span></span>

## <a name="see-also"></a><span data-ttu-id="e9aa1-306">関連項目</span><span class="sxs-lookup"><span data-stu-id="e9aa1-306">See also</span></span>

- <span data-ttu-id="e9aa1-307">[暗号化モデル](cryptography-model.md) -基本クラスライブラリにおける暗号化の実装方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="e9aa1-307">[Cryptography Model](cryptography-model.md) - Describes how cryptography is implemented in the base class library.</span></span>
- [<span data-ttu-id="e9aa1-308">クロスプラットフォーム暗号化</span><span class="sxs-lookup"><span data-stu-id="e9aa1-308">Cross-Platform Cryptography</span></span>](cross-platform-cryptography.md)
- [<span data-ttu-id="e9aa1-309">パディングを使用した CBC モードの対称復号化に関するタイミングの脆弱性</span><span class="sxs-lookup"><span data-stu-id="e9aa1-309">Timing vulnerabilities with CBC-mode symmetric decryption using padding</span></span>](vulnerabilities-cbc-mode.md)
- [<span data-ttu-id="e9aa1-310">データ保護の ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="e9aa1-310">ASP.NET Core Data Protection</span></span>](/aspnet/core/security/data-protection/introduction)
