---
title: タスク ベースの非同期パターン (TAP)
description: タスク ベースの非同期パターン (TAP) について学習します。 TAP は、.NET での開発に推奨される非同期デザイン パターンです。
ms.date: 02/26/2019
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: f194a0bafa0ab7b9606d72f091dbb12e94f31099
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2020
ms.locfileid: "94824019"
---
# <a name="task-based-asynchronous-pattern"></a><span data-ttu-id="bc83c-104">タスク ベースの非同期パターン</span><span class="sxs-lookup"><span data-stu-id="bc83c-104">Task-based asynchronous pattern</span></span>

<span data-ttu-id="bc83c-105">タスク ベースの非同期パターン (TAP) は、任意の非同期操作を表すために使用される、<xref:System.Threading.Tasks?displayProperty=nameWithType> 名前空間の <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> および <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 型に基づいています。</span><span class="sxs-lookup"><span data-stu-id="bc83c-105">The task-based asynchronous pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="bc83c-106">TAP は、新規開発に推奨の非同期デザイン パターンです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-106">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="bc83c-107">名前付け、パラメーター、および戻り値の型</span><span class="sxs-lookup"><span data-stu-id="bc83c-107">Naming, parameters, and return types</span></span>

<span data-ttu-id="bc83c-108">TAP では、非同期操作の開始と終了を表すために単一のメソッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-108">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="bc83c-109">これは、非同期プログラミング モデル (APM または `IAsyncResult`) パターンとイベントベースの非同期パターン (EAP) の両方とは対照的です。</span><span class="sxs-lookup"><span data-stu-id="bc83c-109">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="bc83c-110">APM では、`Begin` と `End` メソッドが必要です。</span><span class="sxs-lookup"><span data-stu-id="bc83c-110">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="bc83c-111">EAP では、`Async` サフィックスを持つメソッドが必要であり、1 つ以上のイベント、イベント ハンドラー デリゲート型、および `EventArg` 派生型も必要です。</span><span class="sxs-lookup"><span data-stu-id="bc83c-111">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="bc83c-112">TAP の非同期メソッドには、待機可能な型を返すメソッドの操作名の後ろに `Async` サフィックスが含まれます (<xref:System.Threading.Tasks.Task>、<xref:System.Threading.Tasks.Task%601>、<xref:System.Threading.Tasks.ValueTask>、<xref:System.Threading.Tasks.ValueTask%601> など)。</span><span class="sxs-lookup"><span data-stu-id="bc83c-112">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="bc83c-113">たとえば、`Task<String>` を返す非同期の `Get` 操作を `GetAsync` と名付けることができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-113">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="bc83c-114">既に `Async` サフィックスの付いた EAP メソッド名を含むクラスに TAP メソッドを追加する場合は、代わりに `TaskAsync` サフィックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-114">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="bc83c-115">たとえば、既にクラスに `GetAsync` メソッドが含まれている場合は、`GetTaskAsync` という名前を使用します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-115">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="bc83c-116">メソッドによって非同期操作が開始されるが、待機可能な型が返らない場合は、その名前を `Begin`、`Start`、またはこのメソッドが操作の結果を返したりスローしたりしないことを示すその他の動詞で始める必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-116">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="bc83c-117">対応する同期メソッドにより void または `TResult` 型が返されるかどうかに応じて、TAP メソッドは <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> または <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> を返します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-117">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="bc83c-118">TAP メソッドのパラメーターには、対応する同期メソッドと同じパラメーターを、同じ順序で指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-118">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="bc83c-119">ただし、`out` パラメーターと `ref` パラメーターはこの規則に該当せず、すべて回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-119">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="bc83c-120">`out` パラメーターまたは `ref` パラメーターで返されるデータは、代わりに複数の値を格納するために、タプルまたはカスタム データ構造を使用して、`TResult` により返される <xref:System.Threading.Tasks.Task%601> の一部として返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-120">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="bc83c-121">また、TAP メソッドに対応する同期メソッドでは提供されていない場合でも、<xref:System.Threading.CancellationToken> パラメーターの追加を検討してください。</span><span class="sxs-lookup"><span data-stu-id="bc83c-121">Also, consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="bc83c-122">タスクの作成、操作、または組み合わせのためだけに使用されるメソッド (メソッド名またはメソッドが属する型の名前でメソッドの非同期の意図が明確な場合) は、この名前付けパターンに従う必要はありません。このようなメソッドは、*連結子* と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-122">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="bc83c-123">連結子の例には、<xref:System.Threading.Tasks.Task.WhenAll%2A> および <xref:System.Threading.Tasks.Task.WhenAny%2A> があります。詳細については、記事「[タスク ベースの非同期パターンの利用](consuming-the-task-based-asynchronous-pattern.md)」の「[タスク ベースの組み込み連結子の使用](consuming-the-task-based-asynchronous-pattern.md#combinators)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bc83c-123">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="bc83c-124">非同期プログラミング モデル (APM) やイベント ベースの非同期パターン (EAP) など、従来の非同期プログラミング パターンで使用される構文とは異なる TAP 構文の例については、「[非同期プログラミングのパターン](index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bc83c-124">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="bc83c-125">非同期操作の開始</span><span class="sxs-lookup"><span data-stu-id="bc83c-125">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="bc83c-126">TAP に基づく非同期メソッドは、引数の検証や非同期操作の開始などの少量の作業を同期をとって実行してから結果のタスクを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-126">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="bc83c-127">このような同期作業は必要最低限にし、非同期メソッドからすぐに制御を戻すようにします。</span><span class="sxs-lookup"><span data-stu-id="bc83c-127">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="bc83c-128">制御をすぐに戻す理由は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-128">Reasons for a quick return include:</span></span>  
  
- <span data-ttu-id="bc83c-129">非同期メソッドはユーザー インターフェイス (UI) スレッドから呼び出される可能性があるため、同期作業の実行に時間がかかると、アプリケーションの応答性が低下します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-129">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="bc83c-130">複数の非同期メソッドが同時に起動される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-130">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="bc83c-131">そのため、非同期メソッドの同期部分の作業に時間がかかると、他の非同期操作の開始が遅れ、コンカレンシーの利点が低減します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-131">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="bc83c-132">場合によっては、操作の完了に必要な作業の量は、操作を非同期に起動するのに必要な作業量よりも少なくなります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-132">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="bc83c-133">このようなシナリオの例にはストリームからの読み取りがあり、既にメモリ バッファーにあるデータを読み取ることで読み取り操作が完了する場合です。</span><span class="sxs-lookup"><span data-stu-id="bc83c-133">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="bc83c-134">このような場合は、操作を同期をとって実行し、既に完了しているタスクを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-134">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="bc83c-135">例外</span><span class="sxs-lookup"><span data-stu-id="bc83c-135">Exceptions</span></span>  
 <span data-ttu-id="bc83c-136">非同期メソッドは、使用エラーに応答して非同期メソッド呼び出しからスローされる例外のみを発生する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-136">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="bc83c-137">運用コードでは使用エラーを発生させないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-137">Usage errors should never occur in production code.</span></span> <span data-ttu-id="bc83c-138">たとえば、null 参照 (Visual Basic では `Nothing`) がメソッドの引数の 1 つとして渡されたときにエラー状態 (通常、<xref:System.ArgumentNullException> 例外によって表される) が発生する場合、呼び出し元のコードを変更し、確実に null 参照が渡されないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-138">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method's arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="bc83c-139">他のエラーの場合はすべて、非同期メソッドの実行中に発生する例外を、返されるタスクに割り当てます。これは、タスクが返される前に非同期メソッドが同期をとって行われる場合でも同じです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-139">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="bc83c-140">通常、タスクに含まれる例外は最大でも 1 つです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-140">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="bc83c-141">ただし、タスクが複数の操作 (<xref:System.Threading.Tasks.Task.WhenAll%2A> など) を表す場合は、複数の例外を単一タスクに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-141">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="bc83c-142">ターゲット環境</span><span class="sxs-lookup"><span data-stu-id="bc83c-142">Target environment</span></span>  
 <span data-ttu-id="bc83c-143">TAP メソッドを実装するときに、非同期実行をどこで行うかを決定できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-143">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="bc83c-144">スレッド プールでワークロードを実行したり、(操作の実行のほとんどでスレッドにバインドされないように) 非同期 I/O を使用して実装したり、特定のスレッド (UI スレッドなど) で実行したり、任意の数の可能なコンテキストを使用したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-144">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation's execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="bc83c-145">TAP メソッドは何も実行せず、システムの他の場所で発生した何らかの条件を表す <xref:System.Threading.Tasks.Task> を返すのみの場合もあります (待ち行列データ構造に届いたデータを表すタスクなど)。</span><span class="sxs-lookup"><span data-stu-id="bc83c-145">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="bc83c-146">TAP メソッドの呼び出し元は、結果的に生成されるタスクに同期的に応答することで、TAP メソッドの完了を待つことをブロックできます。あるいは、非同期操作の完了時に追加 (継続) コードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-146">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="bc83c-147">継続コードの作成者は、そのコードが実行される場所を制御できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-147">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="bc83c-148">継続コードは、<xref:System.Threading.Tasks.Task> クラス (<xref:System.Threading.Tasks.Task.ContinueWith%2A> など) のメソッドによって明示的に作成するか、継続の上位にビルドされる言語サポート (C# の `await`、Visual Basic の `Await`、F# の `AwaitValue` など) を使用して暗黙のうちに作成できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-148">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="bc83c-149">タスクの状態</span><span class="sxs-lookup"><span data-stu-id="bc83c-149">Task status</span></span>  
 <span data-ttu-id="bc83c-150"><xref:System.Threading.Tasks.Task> クラスは、非同期操作の有効期間を提供し、そのサイクルは、<xref:System.Threading.Tasks.TaskStatus> 列挙型によって表されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-150">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="bc83c-151"><xref:System.Threading.Tasks.Task> および <xref:System.Threading.Tasks.Task%601> から派生する型のコーナー ケースに加え、スケジューリングからの構造の分離をサポートするために、<xref:System.Threading.Tasks.Task> クラスは <xref:System.Threading.Tasks.Task.Start%2A> メソッドを公開します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-151">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="bc83c-152"><xref:System.Threading.Tasks.Task> パブリック コンストラクターにより作成されるタスクは、ライフ サイクルがスケジュールされていない <xref:System.Threading.Tasks.TaskStatus.Created> 状態から始まり、これらのインスタンスで <xref:System.Threading.Tasks.Task.Start%2A> が呼び出されるときにのみスケジュールされることから、*コールド タスク* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-152">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="bc83c-153">他のすべてのタスクは、ホットな状態からライフ サイクルが始まります。つまり、タスクが表す非同期操作が既に開始され、それらのタスクの状態は <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType> 以外の列挙値であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-153">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bc83c-154">TAP メソッドから返されるすべてのタスクをアクティブにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-154">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="bc83c-155">**TAP メソッドで、返すタスクをインスタンス化するためにタスクのコンストラクターを内部使用する場合、その TAP メソッドでは、タスクを返す前に <xref:System.Threading.Tasks.Task> オブジェクトで <xref:System.Threading.Tasks.Task.Start%2A> を呼び出す必要があります。**</span><span class="sxs-lookup"><span data-stu-id="bc83c-155">**If a TAP method internally uses a task's constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="bc83c-156">TAP メソッドのコンシューマーは、返されたタスクがアクティブであるものと推定しても問題はなく、TAP メソッドから返された <xref:System.Threading.Tasks.Task.Start%2A> 上で <xref:System.Threading.Tasks.Task> 呼び出しを試行しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-156">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="bc83c-157">アクティブなタスク上で <xref:System.Threading.Tasks.Task.Start%2A> を呼び出すと、<xref:System.InvalidOperationException> 例外になります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-157">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="bc83c-158">取り消し (省略可能)</span><span class="sxs-lookup"><span data-stu-id="bc83c-158">Cancellation (optional)</span></span>  
 <span data-ttu-id="bc83c-159">TAP では、取り消しは非同期メソッドの実装側とコンシューマーのどちらでも省略可能です。</span><span class="sxs-lookup"><span data-stu-id="bc83c-159">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="bc83c-160">操作の取り消しを許可する場合、キャンセル トークン (<xref:System.Threading.CancellationToken> インスタンス) を受け取る非同期メソッドのオーバーロードを公開します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-160">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="bc83c-161">規則により、パラメーターには `cancellationToken` という名前が付けられます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-161">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="bc83c-162">非同期操作は取り消し要求に対してこのトークンを監視します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-162">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="bc83c-163">取り消し要求を受け取ると、その要求を受け入れて操作を取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-163">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="bc83c-164">取り消し要求によって作業が途中で終了する場合、TAP メソッドは <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了するタスクを返します。使用できる結果はなく、例外もスローされません。</span><span class="sxs-lookup"><span data-stu-id="bc83c-164">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="bc83c-165"><xref:System.Threading.Tasks.TaskStatus.Canceled> 状態は、<xref:System.Threading.Tasks.TaskStatus.Faulted> 状態や <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態と共に、タスクの最終状態 (完了状態) と見なされます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-165">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="bc83c-166">したがって、タスクが <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態の場合、<xref:System.Threading.Tasks.Task.IsCompleted%2A> プロパティは `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-166">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="bc83c-167">タスクが <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で完了した場合、<xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> など、継続のオプションを継続から除外するよう指定されていない限り、タスクに登録された継続がスケジュールまたは実行されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-167">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="bc83c-168">言語機能を使用して取り消されたタスクを非同期に待機するコードは実行を継続しますが、<xref:System.OperationCanceledException> またはその派生例外を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-168">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="bc83c-169"><xref:System.Threading.Tasks.Task.Wait%2A> や <xref:System.Threading.Tasks.Task.WaitAll%2A> などのメソッドによってタスクでの同期をとって待機している状態をブロックされたコードも、例外を伴って実行を継続します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-169">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="bc83c-170">キャンセル トークンが、トークンを受け取る TAP メソッドが呼び出される前に取り消しを要求していた場合、TAP メソッドは <xref:System.Threading.Tasks.TaskStatus.Canceled> タスクを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-170">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="bc83c-171">ただし、非同期操作の実行中に取り消し要求が出される場合、その非同期操作は取り消し要求を受け取る必要はありません。</span><span class="sxs-lookup"><span data-stu-id="bc83c-171">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="bc83c-172">取り消し要求の結果として操作が完了した場合にのみ、返されたタスクが <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-172">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="bc83c-173">取り消しが要求されても、結果 (例外) が依然として生成される場合、タスクは <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状態または <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で終了します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-173">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="bc83c-174">何よりもまず、取り消す機能を公開することが望まれる非同期メソッドの場合、キャンセル トークンを受け入れないオーバーロードを用意する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="bc83c-174">For asynchronous methods that want to expose the ability to be canceled first and foremost, you don't have to provide an overload that doesn't accept a cancellation token.</span></span> <span data-ttu-id="bc83c-175">取り消せないメソッドの場合、キャンセル トークンを受け取るオーバーロードを用意しません。これにより、ターゲット メソッドが実際に取り消し可能かどうかを呼び出し元に示すことができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-175">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="bc83c-176">取り消しを望まないコンシューマー コードは、<xref:System.Threading.CancellationToken> を受け取るメソッドを呼び出し、引数値として <xref:System.Threading.CancellationToken.None%2A> を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-176">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="bc83c-177"><xref:System.Threading.CancellationToken.None%2A> は、既定の <xref:System.Threading.CancellationToken> と機能的には同じです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-177"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="bc83c-178">進行状況のレポート (省略可能)</span><span class="sxs-lookup"><span data-stu-id="bc83c-178">Progress reporting (optional)</span></span>  
 <span data-ttu-id="bc83c-179">一部の非同期操作では、進行状況の通知を行うことで利点が得られます。進行状況の通知は、通常、非同期操作の進行状況に関する情報でユーザー インターフェイスを更新するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-179">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="bc83c-180">TAP では、進行状況が、通常 <xref:System.IProgress%601> という名前のパラメーターとして非同期メソッドに渡される `progress` インターフェイスによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-180">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="bc83c-181">非同期メソッドの呼び出し時に進行状況インターフェイスを指定することで、不適切な使用方法により発生する競合状態 (操作の開始後に不適切に登録されたイベント ハンドラーで更新を検出できない場合) を排除できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-181">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="bc83c-182">さらに重要なのは、コンシューマー コードの判断に応じて、進行状況インターフェイスがさまざまな実装方法の進行状況をサポートできるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-182">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="bc83c-183">たとえば、コンシューマー コードが最新の進行状況の更新のみに留意する場合、すべての更新をバッファーに格納することを望む場合、各更新の操作を呼び出すことを望む場合、呼び出しを特定のスレッドにマーシャリングするかどうかの制御を望む場合が考えられます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-183">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="bc83c-184">これらのオプションはすべて、特定のコンシューマーのニーズに合わせてカスタマイズされた、インターフェイスの異なる実装を使用して実現できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-184">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer's needs.</span></span>  <span data-ttu-id="bc83c-185">取り消しと同様、TAP の実装では、API が進行状況通知をサポートする場合にのみ、<xref:System.IProgress%601> パラメーターを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-185">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="bc83c-186">たとえば、前に説明した `ReadAsync` メソッドが読み取り済みのバイト数の形式で中間進行状況を報告できる場合、進行状況のコールバックは <xref:System.IProgress%601> インターフェイスとなることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-186">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="bc83c-187">`FindFilesAsync` メソッドから、特定の検索パターンに合ったすべてのファイルの一覧が返された場合、進行状況のコールバックで、完了した作業の割合の見積りと、現在の部分的な結果セットが示されることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-187">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed and the current set of partial results.</span></span> <span data-ttu-id="bc83c-188">この情報は、次のようにタプルを使用して提供されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-188">It could provide this information with either a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="bc83c-189">または、次のように API 固有のデータ型を使用して提供されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-189">or with a data type that's specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="bc83c-190">後者の場合、特別なデータ型には通常 `ProgressInfo` サフィックスを付けます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-190">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="bc83c-191">TAP の実装で、`progress` パラメーターを受け入れるオーバーロードが提供される場合、`null` の引数を許可する必要があります。この場合、進行状況は報告されません。</span><span class="sxs-lookup"><span data-stu-id="bc83c-191">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress is reported.</span></span> <span data-ttu-id="bc83c-192">TAP の実装では、進行状況を <xref:System.Progress%601> オブジェクトに同期的に報告する必要があります。これにより、非同期メソッドで迅速に進行状況を提供できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-192">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress.</span></span> <span data-ttu-id="bc83c-193">また、進行状況のコンシューマーが、情報の処理に最適な方法と場所を決定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="bc83c-193">It also allows the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="bc83c-194">たとえば、進行状況のインスタンスはコールバックをマーシャリングし、キャプチャされた同期コンテキストでイベントを発生するように選択することができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-194">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="bc83c-195">IProgress\<T> の実装</span><span class="sxs-lookup"><span data-stu-id="bc83c-195">IProgress\<T> implementations</span></span>  
<span data-ttu-id="bc83c-196">.NET には、<xref:System.Progress%601> を実装する <xref:System.IProgress%601> クラスがあります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-196">.NET provides the <xref:System.Progress%601> class, which implements <xref:System.IProgress%601>.</span></span> <span data-ttu-id="bc83c-197"><xref:System.Progress%601> クラスは次のように宣言されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-197">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T>? ProgressChanged;  
}  
```
  
 <span data-ttu-id="bc83c-198"><xref:System.Progress%601> のインスタンスは、非同期操作が進行状況の更新を報告するたびに発生する <xref:System.Progress%601.ProgressChanged> イベントを公開します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-198">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="bc83c-199"><xref:System.Progress%601.ProgressChanged> イベントは、<xref:System.Threading.SynchronizationContext> インスタンスがインスタンス化されたときにキャプチャされた <xref:System.Progress%601> オブジェクトで発生します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-199">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="bc83c-200">同期コンテキストを利用できない場合は、スレッド プールをターゲットとして、既定のコンテキストが使用されます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-200">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="bc83c-201">ハンドラーは、このイベントに登録することができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-201">Handlers may be registered with this event.</span></span> <span data-ttu-id="bc83c-202">1 つのハンドラーは、利便性のために <xref:System.Progress%601> コンストラクターにも提供でき、<xref:System.Progress%601.ProgressChanged> イベントのイベント ハンドラーと同様に作動します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-202">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="bc83c-203">進行状況の更新は、イベント ハンドラーの実行中、非同期操作を遅延しないように、非同期に発生します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-203">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="bc83c-204">別のセマンティクスを適用するため、別の <xref:System.IProgress%601> の実装を選択できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-204">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="bc83c-205">提供するオーバーロードの選択</span><span class="sxs-lookup"><span data-stu-id="bc83c-205">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="bc83c-206">ともに省略可能な <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> パラメーターと <xref:System.IProgress%601> パラメーターの両方を TAP の実装に使用すると、4 つまでオーバーロードを要求することができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-206">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="bc83c-207">しかし、多くの TAP の実装では、取り消しや進行状況の機能が提供されないため、必要なメソッドは 1 つです。</span><span class="sxs-lookup"><span data-stu-id="bc83c-207">However, many TAP implementations don't provide cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="bc83c-208">TAP の実装で取り消しまたは進行状況の両方ではなく、いずれかを一方をサポートする場合は、実装に 2 つのオーバーロードを提供することができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-208">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="bc83c-209">TAP の実装で取り消しおよび進行状況の両方をサポートする場合は、4 種類のオーバーロードをすべて公開できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-209">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="bc83c-210">ただし、次の 2 種類のみ提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-210">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="bc83c-211">不足する 2 種類の中間の組み合わせを補足するために、開発者は <xref:System.Threading.CancellationToken.None%2A> パラメーターに <xref:System.Threading.CancellationToken> または既定の `cancellationToken` を渡したり、`null` パラメーターに `progress` を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-211">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="bc83c-212">TAP メソッドを使用するたびに取り消しや進行状況をサポートすることを想定する場合、必要なパラメーターを受け入れないオーバーロードは省略できます。</span><span class="sxs-lookup"><span data-stu-id="bc83c-212">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don't accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="bc83c-213">複数のオーバーロードを公開して取り消しや進行状況を省略可能にする場合、取り消しや進行状況をサポートしないオーバーロードは、これらをサポートするオーバーロードに、取り消しの場合は <xref:System.Threading.CancellationToken.None%2A>、進行状況の場合は `null` が渡された場合と同じように動作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bc83c-213">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don't support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-articles"></a><span data-ttu-id="bc83c-214">関連記事</span><span class="sxs-lookup"><span data-stu-id="bc83c-214">Related articles</span></span>
  
|<span data-ttu-id="bc83c-215">Title</span><span class="sxs-lookup"><span data-stu-id="bc83c-215">Title</span></span>|<span data-ttu-id="bc83c-216">説明</span><span class="sxs-lookup"><span data-stu-id="bc83c-216">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="bc83c-217">非同期プログラミングのパターン</span><span class="sxs-lookup"><span data-stu-id="bc83c-217">Asynchronous Programming Patterns</span></span>](index.md)|<span data-ttu-id="bc83c-218">非同期操作を実行するための 3 種類のパターンとして、タスク ベースの非同期パターン (TAP)、非同期プログラミング モデル (APM)、およびイベント ベースの非同期パターン (EAP) を紹介します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-218">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="bc83c-219">タスク ベースの非同期パターンの実装</span><span class="sxs-lookup"><span data-stu-id="bc83c-219">Implementing the Task-based Asynchronous Pattern</span></span>](implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="bc83c-220">タスク ベースの非同期パターン (TAP) の実装の 3 つの方法として、Visual Studio の C# および Visual Basic コンパイラを使用する方法、手動で行う方法、またはコンパイラと手動による方法を組み合わせた方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-220">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="bc83c-221">T:System.Threading.Tasks.Task</span><span class="sxs-lookup"><span data-stu-id="bc83c-221">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="bc83c-222">タスクとコールバックを使用して、ブロックすることなく待機できる方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-222">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="bc83c-223">他の非同期パターンと型との相互運用</span><span class="sxs-lookup"><span data-stu-id="bc83c-223">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="bc83c-224">タスク ベースの非同期パターン (TAP) を使用して、非同期プログラミング モデル (APM) とイベント ベースの非同期パターン (EAP) を実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="bc83c-224">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
