---
title: タスク ベースの非同期パターンの実装
description: この記事では、タスク ベースの非同期パターンを実装する方法について説明します。 これを使用し、計算主体の非同期操作と I/O バインドの非同期操作を実装できます。
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- asynchronous design patterns, .NET
- TAP, .NET support for
- Task-based Asynchronous Pattern, .NET support for
- .NET, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 8bac9d265211d2f266db634d4bcebb87c2debd9a
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888777"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="5f1e5-104">タスク ベースの非同期パターンの実装</span><span class="sxs-lookup"><span data-stu-id="5f1e5-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="5f1e5-105">タスク ベースの非同期パターン (TAP) は、3 つの方法 (Visual Studio の C# および Visual Basic コンパイラを使用する方法、手動で行う方法、またはコンパイラと手動による方法を組み合わせた方法) で実装できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="5f1e5-106">以下のセクションでは、それぞれの方法について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="5f1e5-107">TAP パターンを使用し、計算主体の非同期操作と I/O バインドの非同期操作の両方を実装できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="5f1e5-108">[[ワークロード]](#workloads) セクションでは、操作の各種類を確認します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="5f1e5-109">TAP メソッドを生成する</span><span class="sxs-lookup"><span data-stu-id="5f1e5-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="5f1e5-110">コンパイラを使用する</span><span class="sxs-lookup"><span data-stu-id="5f1e5-110">Using the compilers</span></span>
<span data-ttu-id="5f1e5-111">.NET Framework 4.5 以降、`async` キーワード (Visual Basic では `Async`) を使用して属性設定されているメソッドは、非同期メソッドと見なされ、TAP を使用して非同期にメソッドを実装するために必要となる変換が C# コンパイラおよび Visual Basic コンパイラによって行われます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="5f1e5-112">非同期メソッドは、<xref:System.Threading.Tasks.Task?displayProperty=nameWithType> オブジェクトまたは <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> オブジェクトを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="5f1e5-113">後者の場合、関数の本体は `TResult` を返す必要があり、コンパイラによって、結果として得られるタスク オブジェクトでこの結果が利用可能になっていることが確認されます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="5f1e5-114">同様に、メソッド本体で処理されない例外は、出力タスクにマーシャリングされ、結果として得られるタスクが <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 状態で終了する原因となります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="5f1e5-115">この規則に対する例外は、<xref:System.OperationCanceledException> (または派生型) がハンドルされない場合で、結果として得られるタスクは <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 状態で終了します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="5f1e5-116">手動で TAP メソッドを生成する</span><span class="sxs-lookup"><span data-stu-id="5f1e5-116">Generating TAP methods manually</span></span>
<span data-ttu-id="5f1e5-117">TAP パターンは、実装の制御を強化するために手動で実装することができます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="5f1e5-118">コンパイラは、<xref:System.Threading.Tasks?displayProperty=nameWithType> 名前空間から公開されるパブリック アクセス機能および <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> 名前空間でサポートされている型に依存します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="5f1e5-119">TAP を実装するには、<xref:System.Threading.Tasks.TaskCompletionSource%601> オブジェクトを作成して非同期操作を実行し、それが完了したら、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>、または <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> メソッド、またはそのいずれかのメソッドの `Try` バージョンを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="5f1e5-120">TAP メソッドを手動で実装する場合には、表現されている非同期操作の完了時に、結果として得られるタスクを完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="5f1e5-121">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="5f1e5-122">ハイブリッド手法</span><span class="sxs-lookup"><span data-stu-id="5f1e5-122">Hybrid approach</span></span>
 <span data-ttu-id="5f1e5-123">TAP パターンは手動で実装しても、コア ロジックはコンパイラの実装に委譲すると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="5f1e5-124">たとえば、例外を <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> オブジェクトを使用して公開するのではなく、メソッドの直接の呼び出し元にエスケープするように、コンパイラが生成した非同期メソッドの外部で引数を検証する場合は、ハイブリッド手法を使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method's direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="5f1e5-125">また、このような委譲が便利なもう 1 つのケースとして、高速パスの最適化を実装し、キャッシュされたタスクを返す場合を挙げられます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="5f1e5-126">作業負荷</span><span class="sxs-lookup"><span data-stu-id="5f1e5-126">Workloads</span></span>
<span data-ttu-id="5f1e5-127">計算主体および I/O バインドの非同期操作は、いずれも、TAP のメソッドとして実装することができます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="5f1e5-128">ただし、TAP メソッドがライブラリから公開される場合には、TAP メソッドは、I/O バインド操作 (計算が含まれていても、純粋な計算ではない) を含む作業負荷にのみ指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="5f1e5-129">メソッドが純粋に計算主体の場合、同期実装としてのみ公開してください。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="5f1e5-130">そのメソッドを使用するコードによって、別のスレッドに作業をオフロードするため、または並列化を実現するためにその同期メソッドの呼び出しをタスク内にラップするかどうかが選択されます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="5f1e5-131">メソッドが I/O バインドの場合、非同期実装としてのみ公開してください。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="5f1e5-132">計算主体のタスク</span><span class="sxs-lookup"><span data-stu-id="5f1e5-132">Compute-bound tasks</span></span>
<span data-ttu-id="5f1e5-133"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> クラスは、計算を集中的に行う操作の表現に適しています。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="5f1e5-134">既定では、このクラスは、<xref:System.Threading.ThreadPool> クラス内の特別なサポートを利用します。また、いつ、どこで、どのように非同期計算を実行するかを細かく制御することもできます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="5f1e5-135">計算主体のタスクは、次の方法で生成できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="5f1e5-136">.NET Framework 4.5 以降のバージョンでは (.NET Core と .NET 5 以降を含む)、<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> へのショートカットとして静的 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-136">In .NET Framework 4.5 and later versions (including .NET Core and .NET 5+), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5f1e5-137">スレッド プールをターゲットとする計算主体のタスクを簡単に起動するには、<xref:System.Threading.Tasks.Task.Run%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-137">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="5f1e5-138">これが計算主体のタスクで推奨される開始方法です。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-138">This is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="5f1e5-139">タスクによりきめの細かい制御を行う場合のみ `StartNew` を直接使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-139">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="5f1e5-140">.NET Framework 4 では、デリゲート (通常は <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> または <xref:System.Action%601>) の非同期実行を許容する <xref:System.Func%601> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-140">In .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="5f1e5-141"><xref:System.Action%601> のデリゲートを指定する場合、メソッドはデリゲートの非同期実行を表す <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-141">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="5f1e5-142"><xref:System.Func%601> のデリゲートを指定する場合、メソッドは <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-142">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="5f1e5-143"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドのオーバーロードは、キャンセル トークン (<xref:System.Threading.CancellationToken>)、タスクの作成オプション (<xref:System.Threading.Tasks.TaskCreationOptions>)、およびタスク スケジューラ (<xref:System.Threading.Tasks.TaskScheduler>) を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-143">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="5f1e5-144">たとえば、<xref:System.Threading.Tasks.Task.Factory%2A> など、現在のタスク スケジューラをターゲットとするファクトリ インスタンスを、<xref:System.Threading.Tasks.Task> クラスの静的プロパティ (`Task.Factory.StartNew(…)`) として使用できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-144">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="5f1e5-145">タスクを個別に生成およびスケジュールする場合は、`Task` 型のコンストラクターまたは `Start` メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="5f1e5-146">パブリック メソッドは、既に開始されているタスクのみを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="5f1e5-147"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5f1e5-148">このメソッドは、別のタスクが完了したときにスケジュールされる新しいタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="5f1e5-149">一部の <xref:System.Threading.Tasks.Task.ContinueWith%2A> オーバーロードは、キャンセル トークン、継続オプション、およびタスク スケジューラを受け取るため、継続タスクのスケジュール設定と実行を細かく制御することができます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="5f1e5-150"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> メソッドと <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="5f1e5-151">これらのメソッドは、指定された一連のタスクのすべてまたは一部の完了時にスケジュールされる新しいタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="5f1e5-152">これらのメソッドには、こうしたタスクのスケジュール設定と実行を制御するためのオーバーロードも用意されています。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="5f1e5-153">計算主体のタスクでは、実行開始前に取り消し要求を受信した場合に、スケジュール済みのタスクがシステムによって実行されないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="5f1e5-154">したがって、キャンセル トークン (<xref:System.Threading.CancellationToken> オブジェクト) を指定すると、そのトークンを監視する非同期コードにそのトークンを渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="5f1e5-155">また、`StartNew` や `Run` など、前述のメソッドのいずれかにそのトークンを指定し、`Task` ランタイムによって、そのトークンが監視されるようにもできます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="5f1e5-156">たとえば、イメージをレンダリングする非同期メソッドを考えます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="5f1e5-157">タスクの本体によってキャンセル トークンをポーリングすることで、レンダリングの実行中に取り消し要求を受信した場合にコードを早期に終了できるようにします。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="5f1e5-158">また、取り消し要求がレンダリングの開始前に発生した場合、レンダリング処理が行われないようにします。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="5f1e5-159">計算主体のタスクは、次の条件のうち最低でも 1 つが true の場合に <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態で終了します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="5f1e5-160">取り消し要求は、タスクが <xref:System.Threading.CancellationToken> 状態に遷移する前に、引数として作成メソッド (`StartNew` や `Run` など) に渡される <xref:System.Threading.Tasks.TaskStatus.Running> オブジェクトを使用して受け取ります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="5f1e5-161">このようなタスクの本体では、<xref:System.OperationCanceledException> 例外がハンドルされなくなります。この例外にはタスクに渡されたのと同じ <xref:System.Threading.CancellationToken> が含まれていて、このトークンは取り消しが要求されていることを示します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="5f1e5-162">別の例外がそのタスク本体でハンドルされないと、タスクは <xref:System.Threading.Tasks.TaskStatus.Faulted> 状態で終了し、タスクでの待機または結果へのアクセスが試みられると例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="5f1e5-163">I/O バインドのタスク</span><span class="sxs-lookup"><span data-stu-id="5f1e5-163">I/O-bound tasks</span></span>
<span data-ttu-id="5f1e5-164">スレッドの実行全体に対してスレッドによって直接サポートされないタスクを作成するには、<xref:System.Threading.Tasks.TaskCompletionSource%601> 型を使用します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="5f1e5-165">この型は、関連する <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> インスタンスを返す <xref:System.Threading.Tasks.Task%601> プロパティを公開します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="5f1e5-166">このタスクの有効期間は、<xref:System.Threading.Tasks.TaskCompletionSource%601>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>、<xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> バリアントなどの `TrySet` メソッドによって制御されます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="5f1e5-167">指定時間が経過すると完了するタスクを作成する場合を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="5f1e5-168">たとえば、ユーザー インターフェイスでアクティビティを遅延させる場合などです。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="5f1e5-169"><xref:System.Threading.Timer?displayProperty=nameWithType> クラスには、一定時間経過後にデリゲートを非同期に呼び出す機能、また、<xref:System.Threading.Tasks.TaskCompletionSource%601> を使用して、タイマーの前に <xref:System.Threading.Tasks.Task%601> を配置する機能が用意されています。次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="5f1e5-170">この用途には、別の非同期メソッドで使用できる <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> メソッドが用意されています。たとえば、これは次のような非同期でのポーリング ループの実装に使用できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-170">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="5f1e5-171"><xref:System.Threading.Tasks.TaskCompletionSource%601> クラスには、非ジェネリック クラスがありません。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="5f1e5-172">ただし、<xref:System.Threading.Tasks.Task%601> から <xref:System.Threading.Tasks.Task> が派生されるため、単純にタスクを返す I/O バインド メソッドに対してジェネリックな <xref:System.Threading.Tasks.TaskCompletionSource%601> オブジェクトを使用できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="5f1e5-173">これを行うには、ソースをダミー `TResult` と共に使用します (<xref:System.Boolean> は適切な既定の選択肢ですが、<xref:System.Threading.Tasks.Task> のユーザーがそれを <xref:System.Threading.Tasks.Task%601> にダウンキャストすることが懸念される場合は、代わりにプライベートな `TResult` を使用することもできます)。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="5f1e5-174">たとえば、前の例の `Delay` メソッドは、結果として得られるオフセット (`Task<DateTimeOffset>`) と共に現在時間を返します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="5f1e5-175">このような結果値が不要である場合、メソッドのコードは次のように記述できます (戻り値の型と <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A> の引数が変化することに注意してください)。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="5f1e5-176">計算主体のタスクと I/O バインドのタスクの混在</span><span class="sxs-lookup"><span data-stu-id="5f1e5-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="5f1e5-177">非同期メソッドは、計算主体の操作や I/O バインド操作に限らず、この 2 つを混在させた操作を表現できます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="5f1e5-178">実際、複数の非同期操作は、しばしばより規模の大きな混合操作に合成されます。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="5f1e5-179">たとえば、前の例の `RenderAsync` メソッドでは、いくつかの入力 `imageData` に基づいて、計算を集中的に行う操作を実行してイメージをレンダリングしました。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="5f1e5-180">この `imageData` は、非同期にアクセスする Web サービスから次のように取得される場合があります。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="5f1e5-181">また、この例では、単一のキャンセル トークンが複数の非同期操作でどのようにスレッド化されるかも示します。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="5f1e5-182">詳細については、「[タスク ベースの非同期パターンの利用](consuming-the-task-based-asynchronous-pattern.md)」のキャンセルの使用セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="5f1e5-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="5f1e5-183">関連項目</span><span class="sxs-lookup"><span data-stu-id="5f1e5-183">See also</span></span>

- [<span data-ttu-id="5f1e5-184">タスク ベースの非同期パターン (TAP)</span><span class="sxs-lookup"><span data-stu-id="5f1e5-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="5f1e5-185">T:System.Threading.Tasks.Task</span><span class="sxs-lookup"><span data-stu-id="5f1e5-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="5f1e5-186">他の非同期パターンと型との相互運用</span><span class="sxs-lookup"><span data-stu-id="5f1e5-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
