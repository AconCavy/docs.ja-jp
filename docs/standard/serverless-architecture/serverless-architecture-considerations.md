---
title: サーバーレス アーキテクチャの考慮事項 - サーバーレス アプリ
description: ログ、トレースと診断の状態の管理とスケールには、永続的なストレージからのサーバーレス アプリケーションの設計の課題を理解します。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: d1654375be1c815d1f46bd8983c38baf063eee04
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/15/2019
ms.locfileid: "65643581"
---
# <a name="serverless-architecture-considerations"></a>サーバーレス アーキテクチャの考慮事項

サーバーレスのアーキテクチャーを採用するには、いくつかの課題があります。 このセクションでは、注意すべき一般的な考慮事項について説明します。 これらのすべての課題には、ソリューションがあります。 すべてのアーキテクチャを選択するときと同様に、サーバーレス化をするという決定は、長所と短所を慎重に検討してから行わなければなりません。 アプリケーションのニーズに応じて、サーバーレスの実装が特定のコンポーネントに適したソリューションではないと判断できる場合があります。

## <a name="managing-state"></a>状態を管理

一般的には、マイクロサービスと同様に、デフォルトでサーバーレスの関数はステートレスです。 状態を管理しないことで、サーバーレスが一時的で、スケールアウトすることができ、単一障害点がなく回復性を提供することができます。 状況によっては、ビジネスプロセスで状態が必要な場合があります。 プロセスに状態が必要な場合、2 つのオプションがあります。 サーバーレス以外のモデルを採用する、または、状態を提供する別のサービスと対話することです。 状態を保持すると、ソリューションが複雑になり、スケールすることが難しくなり、単一障害点が発生する可能性があります。 その関数に、絶対に状態が必要かを慎重に検討してください。 答えが「はい」の場合は、サーバーレスで実装することに筋が通っているかを見極めてください。

サーバーレスのメリットを損なうことなく状態を管理するソリューションはいくつかあります。 一般的なソリューションには、次のようなものがあります。

* Redis のような、一時的なデータストアまたは分散キャッシュを使用する
* SQL や CosmosDB のようなデータベースに状態を保存する
* Durable Functions のようなワークフローエンジンで状態を管理する

要するに、サーバーレスで実装しようとしているプロセスの状態管理の必要性には注意する必要があるということです。

## <a name="long-running-processes"></a>実行時間の長いプロセス

サーバーレスの多くのメリットは、一時的なプロセスに依存します。 実行時間の短いやすく、サーバーレスのプロバイダーのホスト間で関数の関数が終了し、共有リソースを解放します。 ほとんどのクラウド プロバイダーでは、約 10 分間に、関数を実行できる合計時間を制限します。 プロセスがかかる場合があります、代替実装を検討する可能性があります。

いくつかの例外とソリューションがあります。 1 つのソリューションは、個別にかかる実行時間がより小さなコンポーネントに、プロセスを中断する可能性があります。 依存関係の時間の長いため、プロセスを実行する場合は、durable functions のようなソリューションを使用して非同期ワークフローも検討できます。 Durable functions では、一時停止あり、外部の処理が完了するには、待機中に、プロセスの状態を維持します。 非同期処理には、実際のプロセスの実行時間が短縮されます。

## <a name="startup-time"></a>起動時間

サーバーレスの実装の 1 つの潜在的な問題は、スタートアップ時間です。 リソースを節約するために多くのサーバーレス プロバイダーが"、オンデマンドで"インフラストラクチャを作成します。 指定した時間の経過後サーバーレスの関数がトリガーされると、関数をホストするためのリソースが作成または再起動する必要があります。 場合によっては、いくつかの秒の遅延がコールド スタート可能性があります。 起動時間は、プロバイダーとサービス レベルによって異なります。 アドレス起動時間にいくつかの方法がある場合は、アプリの成功を最小化することが重要です。

* 一部のプロバイダーでは、インフラストラクチャは、"常に on"を保証するサービス レベルの料金を支払うようにします。
* Keep alive メカニズム (ping"起動状態"に保つためにエンドポイント) を実装します。
* (ホストが既に実行中の新しいインスタンスをスピンアップは非常に高速) 関数のコンテナー化されたアプローチでは、Kubernetes などのオーケストレーションを使用します。

## <a name="database-updates-and-migrations"></a>データベースの更新と移行

サーバーレス コードの利点は、アプリケーション全体を再デプロイしなくても新しい関数を解放することができます。 この利点は、リレーショナル データベースが関係する場合、欠点になります。 データベース スキーマへの変更はサーバーレスの更新プログラムと同期する困難です。 新たな課題は、問題が生じたときに、変更をロールバックする必要がありますに挙げられています。 データの整合性は、マイクロ サービスやサーバーレス機能のためのベスト プラクティスは、独自のデータを所有している理由の 1 つです。 コンピューティングとデータの 1 つの単位として変更をデプロイできるようになります。 実際には、サーバーレス アーキテクチャと一致する必要がある大規模なバック エンド データベースの機能を多くのレガシ システムです。

スキーマのバージョン管理を解決するために一般的なアプローチでは、既存のプロパティと列を変更できませんが、代わりに新しい情報を追加します。 たとえば、ブール値から移動する変更を「完了日」に todo リストのフラグを「完了」 古いフィールドを削除するには、代わりに、データベースの変更を行います。

1. 新しい「完了日」フィールドを追加します。
1. 完了した日付が現在の日付後かどうかを評価する計算された関数を「完了」のブール値フィールドを変換します。
1. 完了したブール値が設定されている場合、現在の日付に完了した日付を設定するトリガーの追加を true にします。

一連の変更により、レガシ コードが引き続き新しいサーバーレス関数を利用して、新しいフィールドの中に、「現状有姿を実行します。

サーバーレス アーキテクチャでデータの詳細については、次を参照してください。[に関する課題とソリューションの分散データ管理](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md)します。

## <a name="scaling"></a>スケーリング

サーバーレスは「サーバーはありません」よくある誤解ですが 実際には"server 以下です" あるという事実は、バッキング インフラストラクチャがスケーリングに関しては重要です。 最もサーバーレス プラットフォームでは、一連のイベントの密度が増えた場合で、インフラストラクチャをスケーリングする方法を処理するためにコントロールを提供します。 さまざまなオプションから選択できますが、戦略は、関数によって異なる場合があります。 さらに、関数は、同じホスト上の関数がある、同じスケール オプションように通常、関連するホストで実行されます。 そのためを整理し、顧客のどの機能がホストされているスケール要件に基づいて必要なは。

規則は多くの場合、スケール アップする方法を指定 (ホスト リソースを増やす) およびスケール アウト (ホスト インスタンスの数を増やす) さまざまなパラメーターに基づきます。 スケールのトリガーには、スケジュール、要求レート、CPU 使用率およびメモリ使用量を含めることができます。 高いパフォーマンスで多くの場合よりコストが発生します。 すばやくと要求レートが突然の増加に応じて、低コスト、使用量ベースのアプローチは拡張できません可能性があります。 前もって「保険コスト」料金を支払うと支払いの間のトレードオフが厳密に"としてする go"およびリスクの需要の急激な増加のため応答が遅くなります。

## <a name="monitoring-tracing-and-logging"></a>監視、トレース、およびログ記録

DevOps の見落とされがちな側面には、1 回配置されたアプリケーションは監視です。 サーバーレス関数を監視するための戦略に重要です。 最大の課題は、相関関係、またはユーザーが同一の相互作用の一部として複数の関数を呼び出すときに認識する多くの場合は。 最もサーバーレス プラットフォームを使用すると、コンソール ログをサード パーティのツールにインポートできます。 テレメトリの収集を自動化、生成および追跡の相関関係 Id、および詳細な情報を提供する特定のアクションを監視するためのオプションもあります。 Azure には、高度な[Application Insights プラットフォーム](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)で監視および分析します。

## <a name="inter-service-dependencies"></a>サービス間の依存関係

サーバーレス アーキテクチャでは、その他の関数に依存する関数を含めることができます。 実際には、にない一般的でない複数サービスの相互作用または分散トランザクションの一部として相互に呼び出すサーバーレス アーキテクチャ。 強力な結合を避けるためには、サービスはありませんを参照する他の直接をお勧めします。 サービスのエンドポイントを変更する場合の直接参照が主なリファクタリングになる可能性があります。 要求の種類の適切な終了点を提供する、レジストリなどのサービス検出メカニズムを提供することをお勧めします。 別のソリューションでは、サービス間の通信のキューやトピックなどのメッセージング サービスを活用します。

## <a name="managing-failure-and-providing-resiliency"></a>障害の管理と回復性を提供します。

考慮すべき重要なも、*サーキット ブレーカー パターン*:何らかの理由で、サービスのエラーが続く場合は、そのサービスを繰り返し呼び出すことをお勧めはありません。 代わりに、別のサービスが呼び出されるか、依存サービスの正常性が再確立されるまで、メッセージが返されます。 サーバーレス アーキテクチャでは、解決、およびサービス間の依存関係の管理の戦略を考慮する必要があります。

サーキット ブレーカー パターンを続行するには、サービスはフォールト トレラントであり、回復力のあるを使用する必要があります。 フォールト トレランスは予期しない例外発生後も実行を継続するアプリケーションの機能、または無効な状態が発生しました。 フォールト トレランスは、通常、コード自体の関数と、例外を処理するために記述する方法。 回復性の障害から回復できる能力のアプリが指しています。 回復性は、多くの場合、サーバーレス プラットフォームによって管理されます。 プラットフォームは、既存のものが失敗したときに、新しいサーバーレスの関数インスタンスを起動できる必要があります。 プラットフォームは、インテリジェントなすべての新しいインスタンスが失敗したときに、新しいインスタンスをスピンアップを停止する必要があります。

詳細については、次を参照してください。[サーキット ブレーカー パターンを実装する](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md)します。

## <a name="versioning-and-greenblue-deployments"></a>バージョン管理、および緑/青の展開

サーバーなしの大きな利点は、アプリケーション全体を再デプロイしなくても、特定の関数をアップグレードする機能です。 正常に行うアップグレードでは、関数がありますバージョン管理されたサービスを呼び出すことがコードの正しいバージョンにルーティングされるようにします。 新しいバージョンをデプロイするための戦略も重要です。 一般的なアプローチは、「緑/青展開します」を使用するには グリーン配置には、現在の関数です。 新しい「青」バージョンが運用環境にデプロイし、テストします。 パスをテストするときに、緑、青のバージョン、新しいバージョンがライブになるようにスワップされます。 問題が発生した場合戻るスワップすることができます。 バージョン管理と緑/青の展開をサポートしているバージョンの変化に対応する関数を作成および展開を処理するサーバーレス プラットフォームの操作の組み合わせが必要です。 これについては、プロキシを使用する方法の 1 つは、 [Azure サーバーレス プラットフォーム](azure-functions.md#proxies)」の章。

>[!div class="step-by-step"]
>[前へ](serverless-architecture.md)
>[次へ](serverless-design-examples.md)
