---
title: マネージド スレッドの例外
description: .NET でハンドルされない例外をハンドルする方法について参照します。 ほとんどのハンドルされないスレッド例外がそのまま続行して、アプリケーションが終了します。
ms.date: 03/30/2017
helpviewer_keywords:
- unhandled exceptions,in managed threads
- threading [.NET],unhandled exceptions
- threading [.NET],exceptions in managed threads
- managed threading
ms.assetid: 11294769-2e89-43cb-890e-ad4ad79cfbee
ms.openlocfilehash: 740cd1b78b96c2fcaecf39a725973d738037f403
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723754"
---
# <a name="exceptions-in-managed-threads"></a>マネージド スレッドの例外

共通言語ランタイムはスレッド内のほとんどのハンドルされない例外をそのまま続行させます。 ほとんどの場合、これはハンドルされない例外によってアプリケーションが終了することを意味します。
  
共通言語ランタイムには、プログラム フローの制御に使用する特定のハンドルされない例外について、次のような安全策が用意されています。  
  
- <xref:System.Threading.Thread.Abort%2A> が呼び出されたため、スレッドで <xref:System.Threading.ThreadAbortException> がスローされる。  
  
- スレッドが実行中のアプリケーション ドメインがアンロードされると、スレッドで <xref:System.AppDomainUnloadedException> がスローされる。  
  
- 共通言語ランタイムまたはホスト プロセスは、内部例外をスローすることによってスレッドを終了します。  
  
 共通言語ランタイムによって作成されたスレッドでこれらの例外がハンドルされない場合、その例外によってスレッドは終了しますが、共通言語ランタイムは例外を続行させません。  
  
 メイン スレッドまたはアンマネージ コードからランタイムに入ったスレッドでこれらの例外がハンドルされない場合、例外は通常どおり続行するため、アプリケーションが終了します。  
  
> [!NOTE]
> マネージド コードが例外ハンドラーをインストールする機会を得る前に、ランタイムはハンドルされない例外をスローできます。 マネージド コードにこのような例外をハンドルする機会がない場合でも、例外を続行させることができます。  
  
## <a name="exposing-threading-problems-during-development"></a>開発時におけるスレッド処理の問題の露呈  

 アプリケーションを終了せずに、スレッドが暗黙に失敗したまま放置されていると、プログラミングの深刻な問題が検出されない状態になる可能性があります。 長期間実行されるサービスや他のアプリケーションでは、これは特に問題となります。 スレッドが失敗すると、プログラムの状態が徐々に破損します。 アプリケーションのパフォーマンスが低下、またはアプリケーションが応答しなくなる場合があります。  
  
 スレッド内でハンドルされない例外を続行させておき、結果としてオペレーティング システムにそのプログラムを終了させることで、開発およびテスト中にこのような問題が明らかになります。 プログラムの終了に関するエラー報告はデバッグをサポートします。  
  
## <a name="change-from-previous-versions"></a>以前のバージョンからの変更

.NET Framework バージョン 1.0 および 1.1 では、共通言語ランタイムには、次の状況でのハンドルされない例外に関する安全策が用意されています。  
  
- スレッド プールのスレッドのハンドルされない例外は存在しません。 タスクが例外をスローし、その例外がハンドルされない場合、ランタイムは例外のスタック トレースをコンソールに出力し、スレッドをスレッド プールに戻します。  
  
- <xref:System.Threading.Thread> クラスの <xref:System.Threading.Thread.Start%2A> メソッドを使用して作成されたスレッドのハンドルされない例外は存在しません。 このようなスレッド上で実行中のコードが例外をスローし、その例外がハンドルされない場合、ランタイムは例外のスタック トレースをコンソールに出力し、スレッドを適切に終了します。  
  
- ファイナライザー スレッドのハンドルされない例外は存在しません。 ファイナライザーが例外をスローし、その例外がハンドルされない場合、ランタイムは例外のスタック トレースをコンソールに出力し、ファイナライザー スレッドがファイナライザーの実行を再開できるようにします。  
  
 マネージド スレッドのフォアグラウンドまたはバックグラウンドのステータスは、この動作に影響しません。  
  
 アンマネージ コードで作成されたスレッドのハンドルされない例外の場合、微妙な相違点があります。 ランタイムの JIT アタッチ ダイアログは、ネイティブ コードを通ってきたスレッド内でのマネージド例外またはネイティブ例外に関する、オペレーティング システム ダイアログより優先されます。 プロセスは常に終了します。

### <a name="migration"></a>移行

.NET Framework 1.0 または 1.1 から移行するとき、スレッドを強制終了するなどのためにランタイムの安全策を活用した場合、次の移行戦略のいずれかを検討してください。  
  
- シグナルを受信したときに、スレッドが適切に終了するようにコードを再構築します。  
  
- スレッドを中止するには、<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> メソッドを使用します。  
  
- プロセスを終了できるように、スレッドを中止する必要がある場合は、スレッドをバックグラウンド スレッドにして、プロセス終了時にスレッドが自動的に終了するようにします。  
  
どのような場合でも、方法は例外に関するデザイン ガイドラインに従う必要があります。 「[例外のデザイン ガイドライン](../design-guidelines/exceptions.md)」を参照してください。  
  
一時的な互換性対策として、管理者はアプリケーション構成ファイルの `<runtime>` セクションに互換性フラグを配置できます。 これにより、共通言語ランタイムをバージョン 1.0 および 1.1 の動作に戻すことができます。  
  
```xml  
<legacyUnhandledExceptionPolicy enabled="1"/>  
```  
  
## <a name="host-override"></a>ホストのオーバーライド

アンマネージ ホストはホスト API の [ICLRPolicyManager](../../framework/unmanaged-api/hosting/iclrpolicymanager-interface.md) インターフェイスを使用して、共通言語ランタイムの既定のハンドルされない例外ポリシーをオーバーライドできます。 [ICLRPolicyManager::SetUnhandledExceptionPolicy](../../framework/unmanaged-api/hosting/iclrpolicymanager-setunhandledexceptionpolicy-method.md) 関数を使用して、ハンドルされない例外のポリシーを設定します。  
  
## <a name="see-also"></a>関連項目

- [マネージド スレッド処理の基本](managed-threading-basics.md)
