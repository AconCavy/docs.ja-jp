---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723785"
---
# <a name="eventwaithandle"></a><span data-ttu-id="6fcc2-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="6fcc2-102">EventWaitHandle</span></span>

<span data-ttu-id="6fcc2-103"><xref:System.Threading.EventWaitHandle> クラスを使用すると、スレッドは通知および通知の待機により、互いに通信できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="6fcc2-104">イベント待機ハンドル (単にイベントとも呼ばれます) は、通知を受けて、1 つ以上の待機中のイベントを解放できる待機ハンドルです。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="6fcc2-105">通知を受けると、イベント待機ハンドルは手動または自動でリセットされます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="6fcc2-106"><xref:System.Threading.EventWaitHandle> クラスは、ローカルのイベント待機ハンドル (ローカル イベント) または名前付きのシステム イベント待機ハンドル (名前付きのイベントまたはシステム イベント。すべてのプロセスから参照できます) を表すことができます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6fcc2-107">イベント待機ハンドルは、.NET の[イベント](../events/index.md)ではありません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="6fcc2-108">デリゲートやイベント ハンドラーは関連していません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="6fcc2-109">"イベント" という言葉で説明されているのは、それらがこれまでオペレーティング システム イベントと呼ばれており、待機ハンドルの通知はイベントが発生した待機中のスレッドを示すためです。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="6fcc2-110">ローカル イベント待機ハンドルと名前付きイベント待機ハンドルはどちらも、システム同期オブジェクトを使用します。これは <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ラッパーによって保護されており、リソースが確実に解放されるようにします。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="6fcc2-111"><xref:System.Threading.WaitHandle.Dispose%2A> メソッドを使用すると、オブジェクトを使い終わったらすぐにリソースを解放できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="6fcc2-112">自動的にリセットされるイベント待機ハンドル</span><span class="sxs-lookup"><span data-stu-id="6fcc2-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="6fcc2-113">自動リセット イベントを作成するには、<xref:System.Threading.EventWaitHandle> オブジェクトを作成するときに <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="6fcc2-114">その名前が示すとおり、この同期イベントは通知を受けたときに、単一の待機中のスレッドを解放した後、自動的にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="6fcc2-115">イベントを通知するには、その <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="6fcc2-116">通常、自動リセット イベントは、単一のスレッドのリソースに一度に排他アクセスを提供するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="6fcc2-117">スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出してリソースを要求します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="6fcc2-118">他のスレッドに待機ハンドルがない場合、メソッドは `true` を返し、呼び出し元スレッドはリソースの制御権を持ちます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="6fcc2-119">あらゆる同期機構と同様に、すべてのコード パスが適切な待機ハンドルを待ってから、保護されているリソースにアクセスする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="6fcc2-120">スレッドの同期は連携しています。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="6fcc2-121">自動リセット イベントが通知を受けたとき、待機中のスレッドがない場合は、スレッドが待機中になるまでシグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="6fcc2-122">イベントはスレッドを解放してすぐにリセットされ、以降のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="6fcc2-123">手動でリセットされるイベント待機ハンドル</span><span class="sxs-lookup"><span data-stu-id="6fcc2-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="6fcc2-124">手動リセット イベントを作成するには、<xref:System.Threading.EventWaitHandle> オブジェクトを作成するときに <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="6fcc2-125">その名前が示すとおり、この同期イベントは、通知を受けた後に手動でリセットする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="6fcc2-126"><xref:System.Threading.EventWaitHandle.Reset%2A> メソッドを呼び出してリセットするまで、イベント ハンドルを待っているスレッドはすぐに続行され、ブロックされません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="6fcc2-127">手動リセット イベントは、家畜を飼う囲いのゲートのように動作します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="6fcc2-128">イベントが通知を受けないと、待機中のスレッドは囲いの中の馬のようにブロックされます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="6fcc2-129">イベントが通知を受けると、その <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出して、すべての待機中のスレッドは自由に続行できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="6fcc2-130">イベントは、その <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、シグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="6fcc2-131">これにより、手動リセット イベントは、1 つのスレッドがタスクを終えるまで待機させる必要のあるスレッドを保持する理想的な方法となっています。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="6fcc2-132">馬が囲いから出るように、解放されたスレッドがオペレーティング システムによってスケジュールされ、実行が再開されるには時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="6fcc2-133">すべてのスレッドの実行が再開される前に <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出された場合、残りのスレッドは再びブロックされます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="6fcc2-134">再開されるスレッドとブロックされるスレッドは、システム上の負荷や、スケジューラを待っているスレッドの数など、ランダムな要素によって異なります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="6fcc2-135">イベントを通知したスレッドが通知後に終了した場合 (これは最も一般的な使用パターンです)、これは問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="6fcc2-136">すべての待機中のスレッドが再開された後で、イベントを通知したスレッドに新しいタスクを開始させる場合は、すべての待機中のスレッドが再開されるまで、そのスレッドをブロックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="6fcc2-137">それ以外の場合は競合状態で、コードの動作は予測できません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="6fcc2-138">自動イベントと手動イベントの共通の機能</span><span class="sxs-lookup"><span data-stu-id="6fcc2-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="6fcc2-139">通常、ブロックされていないスレッドが <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出して、いずれかの待機中のスレッド (自動リセット イベントの場合) またはそれらすべて (手動リセット イベントの場合) を解放するまで、1 つ以上のスレッドが <xref:System.Threading.EventWaitHandle> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="6fcc2-140">スレッドは、静的な <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> メソッドを呼び出すことにより、<xref:System.Threading.EventWaitHandle> の通知とブロックを分割できない操作として行うことができます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6fcc2-141"><xref:System.Threading.EventWaitHandle> オブジェクトは、静的な <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> および <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> メソッドと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="6fcc2-142"><xref:System.Threading.EventWaitHandle> および <xref:System.Threading.Mutex> クラスはいずれも <xref:System.Threading.WaitHandle> から派生するため、両方のクラスをこれらのメソッドで使用できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="6fcc2-143">名前付きのイベント</span><span class="sxs-lookup"><span data-stu-id="6fcc2-143">Named Events</span></span>  

 <span data-ttu-id="6fcc2-144">Windows オペレーティング システムでは、イベント待機ハンドルに名前を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="6fcc2-145">名前付きのイベントはシステム全体で使用されます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-145">A named event is system wide.</span></span> <span data-ttu-id="6fcc2-146">つまり、いったん名前付きのイベントを作成すると、すべてのプロセスのすべてのスレッドがそれを参照できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="6fcc2-147">したがって、名前付きのイベントを使用して、スレッドだけでなくプロセスのアクティビティも同期できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="6fcc2-148">名前付きのシステム イベントを表す <xref:System.Threading.EventWaitHandle> オブジェクトを作成するには、イベントの名前を指定するいずれかのコンストラクターを使用します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6fcc2-149">名前付きのイベントはシステム全体で使用されるため、複数の <xref:System.Threading.EventWaitHandle> オブジェクトで同じ名前付きイベントを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="6fcc2-150">コンストラクターまたは <xref:System.Threading.EventWaitHandle.OpenExisting%2A> メソッドを呼び出すたびに、新しい <xref:System.Threading.EventWaitHandle> オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="6fcc2-151">同じ名前を繰り返し指定すると、同じ名前付きイベントを表す複数のオブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="6fcc2-152">名前付きのイベントを使用する際には注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-152">Caution is advised in using named events.</span></span> <span data-ttu-id="6fcc2-153">それらはシステム全体で使用されるので、別のプロセスが同じ名前を使用すると、スレッドが予期せずにブロックされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="6fcc2-154">同じコンピューター上で実行される悪意のあるコードが、これをサービス拒否攻撃の土台として使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="6fcc2-155">アクセス制御セキュリティを使用して、名前付きのイベントを表す <xref:System.Threading.EventWaitHandle> オブジェクトを保護します。可能であれば <xref:System.Security.AccessControl.EventWaitHandleSecurity> オブジェクトを指定するコンストラクターを使用します。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="6fcc2-156">また、<xref:System.Threading.EventWaitHandle.SetAccessControl%2A> メソッドを使用してアクセス制御セキュリティを適用できますが、この場合、イベント待機ハンドルが作成されてから保護されるまでの間に無防備な時間帯が生じてしまいます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="6fcc2-157">アクセス制御セキュリティでイベントを保護すると、悪意のある攻撃を防ぐのに役立ちますが、予期しない名前の衝突の問題解決にはなりません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6fcc2-158"><xref:System.Threading.EventWaitHandle> クラスとは異なり、派生したクラスである <xref:System.Threading.AutoResetEvent> および <xref:System.Threading.ManualResetEvent> は、ローカルの待機ハンドルのみを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="6fcc2-159">名前付きのシステム イベントを表すことはできません。</span><span class="sxs-lookup"><span data-stu-id="6fcc2-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6fcc2-160">参照</span><span class="sxs-lookup"><span data-stu-id="6fcc2-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
