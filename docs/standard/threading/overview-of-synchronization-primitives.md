---
title: 同期プリミティブの概要
description: 共有リソースへのアクセスを同期する場合や、スレッド相互作用を制御する場合に使用される .NET スレッド同期プリミティブについて説明します
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 43f78c914b7cb01f9b0de4c258d5882548e52790
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/15/2020
ms.locfileid: "73106593"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="b3706-103">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="b3706-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="b3706-104">.NET では、共有リソースへのアクセスを同期する場合や、スレッド相互作用を調整する場合に使用できるさまざまな型が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b3706-105">共有リソースでのアクセスを保護するには、同じ同期プリミティブ インスタンスを使用します。</span><span class="sxs-lookup"><span data-stu-id="b3706-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="b3706-106">異なる同期プリミティブ インスタンスを使用して同じリソースを保護する場合は、同期プリミティブによって提供される保護を回避します。</span><span class="sxs-lookup"><span data-stu-id="b3706-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="b3706-107">WaitHandle クラスと軽量の同期型</span><span class="sxs-lookup"><span data-stu-id="b3706-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="b3706-108">複数の .NET 同期プリミティブは <xref:System.Threading.WaitHandle?displayProperty=nameWithType> クラスから派生します。このクラスでは、ネイティブ オペレーティング システムの同期ハンドルをカプセル化し、スレッド相互作用のシグナリング メカニズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="b3706-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="b3706-109">次のようなクラスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b3706-109">Those classes include:</span></span>

- <span data-ttu-id="b3706-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>。共有リソースへの排他アクセスが許可されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="b3706-111">所有しているスレッドがない場合、ミューテックスはシグナル状態になります。</span><span class="sxs-lookup"><span data-stu-id="b3706-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="b3706-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>。共有リソースまたはリソースのプールに同時にアクセスできるスレッドの数を制限します。</span><span class="sxs-lookup"><span data-stu-id="b3706-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="b3706-113">セマフォの状態は、そのカウントが 0 より大きい場合はシグナル状態に、0 の場合は非シグナル状態に設定されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="b3706-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>。スレッド同期イベントを表し、シグナル状態または非シグナル状態のいずれかになります。</span><span class="sxs-lookup"><span data-stu-id="b3706-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="b3706-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>。<xref:System.Threading.EventWaitHandle> から派生し、シグナル状態の場合、単一の待ちスレッドを解放した後、自動的に非シグナル状態にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="b3706-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>。<xref:System.Threading.EventWaitHandle> から派生し、シグナル状態の場合、<xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまでシグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="b3706-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="b3706-117">.NET Framework では、<xref:System.Threading.WaitHandle> は <xref:System.MarshalByRefObject?displayProperty=nameWithType> から派生するため、これらの型を使用して、アプリケーション ドメインの境界を越えてスレッドのアクティビティを同期させることができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="b3706-118">.NET Framework と .NET Core では、これらの型のいくつかで名前付きのシステム同期ハンドルを表すことができます。ハンドルはオペレーティング システム全体で表示され、プロセス間同期で使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="b3706-119"><xref:System.Threading.Mutex> (.NET Framework と .NET Core)、</span><span class="sxs-lookup"><span data-stu-id="b3706-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="b3706-120"><xref:System.Threading.Semaphore> (Windows 上の .NET Framework と .NET Core)、</span><span class="sxs-lookup"><span data-stu-id="b3706-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="b3706-121"><xref:System.Threading.EventWaitHandle> (Windows 上の .NET Framework と .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="b3706-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="b3706-122">詳細については、<xref:System.Threading.WaitHandle> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="b3706-123">軽量の同期型は、基になるオペレーティング システム ハンドルに依存しておらず、通常はパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="b3706-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="b3706-124">しかし、プロセス間同期には使用できません。</span><span class="sxs-lookup"><span data-stu-id="b3706-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="b3706-125">これらの型は、1 つのアプリケーション内のスレッド同期で使用します。</span><span class="sxs-lookup"><span data-stu-id="b3706-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="b3706-126">これらの型のいくつかは、<xref:System.Threading.WaitHandle> から派生した型の代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="b3706-127">たとえば、<xref:System.Threading.SemaphoreSlim> は軽量であり、<xref:System.Threading.Semaphore> の代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="b3706-128">共有リソースへのアクセスの同期</span><span class="sxs-lookup"><span data-stu-id="b3706-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="b3706-129">.NET では、複数のスレッドによる共有リソースへのアクセスを制御するためのさまざまな同期プリミティブが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="b3706-130">Monitor クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-130">Monitor class</span></span>

<span data-ttu-id="b3706-131"><xref:System.Threading.Monitor?displayProperty=nameWithType> クラスでは、リソースを識別するオブジェクトに対するロックを取得または解放することで、共有リソースへの排他アクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="b3706-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="b3706-132">ロックが保持されている間、ロックを保持するスレッドではロックを再度取得し、解放することができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="b3706-133">他のスレッドはブロックされてロックを取得できず、<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> メソッドではロックが解放されるまで待機します。</span><span class="sxs-lookup"><span data-stu-id="b3706-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="b3706-134"><xref:System.Threading.Monitor.Enter%2A> メソッドでは解放されたロックを取得します。</span><span class="sxs-lookup"><span data-stu-id="b3706-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="b3706-135">また、<xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> メソッドを使用して、スレッドでのロック取得の試行時間を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="b3706-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="b3706-136"><xref:System.Threading.Monitor> クラスにはスレッド アフィニティがあるため、ロックを取得したスレッドでは、<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> メソッドを呼び出してロックを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3706-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b3706-137"><xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>、および <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> メソッドを使用して、同じオブジェクトに対するロックを取得するスレッドの相互作用を調整することができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="b3706-138">詳細については、<xref:System.Threading.Monitor> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="b3706-139">C# では [lock](../../csharp/language-reference/keywords/lock-statement.md) ステートメントを、Visual Basic では [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) ステートメントを使って、<xref:System.Threading.Monitor> クラスを直接使用せずに、共有リソースへのアクセスを同期します。</span><span class="sxs-lookup"><span data-stu-id="b3706-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="b3706-140">これらのステートメントは、<xref:System.Threading.Monitor.Enter%2A> および <xref:System.Threading.Monitor.Exit%2A> メソッドを使用して実装されます。また、このステートメントでは、取得されたロックが常に確実に解除されるように、`try…finally` ブロックが使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="b3706-141">Mutex クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-141">Mutex class</span></span>

<span data-ttu-id="b3706-142"><xref:System.Threading.Mutex?displayProperty=nameWithType> クラスでは、<xref:System.Threading.Monitor> と同様に、共有リソースへの排他アクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="b3706-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="b3706-143">[Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) メソッドのオーバーロードのいずれかを使用して、ミューテックスの所有権を要求します。</span><span class="sxs-lookup"><span data-stu-id="b3706-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="b3706-144"><xref:System.Threading.Monitor> と同様に、<xref:System.Threading.Mutex> にはスレッド アフィニティがあり、ミューテックスを取得したスレッドで、<xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> メソッドを呼び出してそれを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3706-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b3706-145"><xref:System.Threading.Monitor> とは異なり、<xref:System.Threading.Mutex> クラスをプロセス間同期に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="b3706-146">そのためには、オペレーティング システム全体で表示される、名前付きミューテックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="b3706-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="b3706-147">名前付きミュー テックスのインスタンスを作成するには、名前を指定する [Mutex コンストラクター](<xref:System.Threading.Mutex.%23ctor%2A>)を使用します。</span><span class="sxs-lookup"><span data-stu-id="b3706-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="b3706-148">また、<xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> メソッドを呼び出して、既存の名前付きシステム ミューテックスを開くこともできます。</span><span class="sxs-lookup"><span data-stu-id="b3706-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="b3706-149">詳細については、「[ミューテックス](mutexes.md)」の記事と、<xref:System.Threading.Mutex> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="b3706-150">SpinLock 構造体</span><span class="sxs-lookup"><span data-stu-id="b3706-150">SpinLock structure</span></span>

<span data-ttu-id="b3706-151"><xref:System.Threading.SpinLock?displayProperty=nameWithType> 構造体では、<xref:System.Threading.Monitor> と同様に、ロックの可用性に基づいて、共有リソースへの排他アクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="b3706-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="b3706-152"><xref:System.Threading.SpinLock> で使用できないロックの取得が試行された場合、ループ内で待機し、ロックが使用できるようになるまで繰り返し確認されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="b3706-153">スピン ロックを使用する利点と欠点の詳細については、「[SpinLock](spinlock.md)」の記事と、<xref:System.Threading.SpinLock> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="b3706-154">ReaderWriterLockSlim クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="b3706-155"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> クラスでは、書き込み用の共有リソースへの排他アクセスを許可し、複数のスレッドでの読み取り用のリソースへの同時アクセスを許可します。</span><span class="sxs-lookup"><span data-stu-id="b3706-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="b3706-156">スレッドセーフ読み取り操作をサポートするが、書き込み操作を行うために排他アクセスを必要とする共有データ構造体へのアクセスを同期する場合は、<xref:System.Threading.ReaderWriterLockSlim> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="b3706-157">スレッドで (たとえば、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> メソッドを呼び出して) 排他アクセスを要求すると、後続のリーダーとライターの要求は、既存のすべてのリーダーがロックを終了し、ライターがロックに参加して終了するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="b3706-158">詳細については、<xref:System.Threading.ReaderWriterLockSlim> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="b3706-159">Semaphore および SemaphoreSlim クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="b3706-160"><xref:System.Threading.Semaphore?displayProperty=nameWithType> および <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> クラスでは、共有リソースまたはリソースのプールに同時にアクセスできるスレッドの数を制限します。</span><span class="sxs-lookup"><span data-stu-id="b3706-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="b3706-161">リソースを要求する追加のスレッドは、任意のスレッドでセマフォが解放されるまで待機します。</span><span class="sxs-lookup"><span data-stu-id="b3706-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="b3706-162">セマフォにはスレッド アフィニティがないため、あるスレッドでセマフォを取得し、別のスレッドで解放することができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="b3706-163"><xref:System.Threading.SemaphoreSlim> は軽量であり、<xref:System.Threading.Semaphore> の代わりに使用され、単一のプロセス境界内の同期化でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="b3706-164">Windows では、プロセス間同期で <xref:System.Threading.Semaphore> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="b3706-165">そのためには、名前または <xref:System.Threading.Semaphore> メソッドを指定する [Semaphore コンストラクター](<xref:System.Threading.Semaphore.%23ctor%2A>)のいずれかを使用して、名前付きシステム セマフォを表す <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="b3706-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="b3706-166"><xref:System.Threading.SemaphoreSlim> では、名前付きシステム セマフォはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="b3706-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="b3706-167">詳細については、「[Semaphore と SemaphoreSlim](semaphore-and-semaphoreslim.md)」の記事と、<xref:System.Threading.Semaphore> または <xref:System.Threading.SemaphoreSlim> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="b3706-168">スレッドの相互作用、またはシグナリング</span><span class="sxs-lookup"><span data-stu-id="b3706-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="b3706-169">スレッドの相互作用 (またはスレッドのシグナリング) は、あるスレッドで、先に進むために 1 つ以上のスレッドからの通知 (または、シグナル) を待機する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="b3706-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="b3706-170">たとえば、スレッド A でスレッド B の<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> メソッドを呼び出す場合、スレッド A は、スレッド B が完了するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="b3706-171">前のセクションで説明されている同期プリミティブでは、シグナリングに関する別のメカニズムが提供されます。その場合、あるスレッドによって、ロックを獲得することで先に進むことができる別のスレッドに通知されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="b3706-172">このセクションでは、.NET によって提供される追加のシグナリング構造について説明します。</span><span class="sxs-lookup"><span data-stu-id="b3706-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="b3706-173">EventWaitHandle、AutoResetEvent、ManualResetEvent、および ManualResetEventSlim クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="b3706-174"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> クラスはスレッドの同期イベントを表します。</span><span class="sxs-lookup"><span data-stu-id="b3706-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="b3706-175">同期イベントには、非シグナル状態またはシグナル状態のいずれかを指定できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="b3706-176">イベントの状態が非シグナルの場合、イベントの <xref:System.Threading.WaitHandle.WaitOne%2A?> オーバーロードを呼び出すスレッドは、イベントがシグナル状態になるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="b3706-177"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> メソッドでは、イベントの状態をシグナル状態に設定します。</span><span class="sxs-lookup"><span data-stu-id="b3706-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="b3706-178">シグナル状態になった <xref:System.Threading.EventWaitHandle> の動作は、そのリセット モードによって異なります。</span><span class="sxs-lookup"><span data-stu-id="b3706-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="b3706-179"><xref:System.Threading.EventWaitHandle> フラグで作成された <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> では、単一の待ちスレッドが解放された後、自動的にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="b3706-180">これは、シグナル状態になるたびに 1 つのスレッドのみが通れる回転ドアのようなものです。</span><span class="sxs-lookup"><span data-stu-id="b3706-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="b3706-181"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> から派生する、<xref:System.Threading.EventWaitHandle> クラスはその動作を表します。</span><span class="sxs-lookup"><span data-stu-id="b3706-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="b3706-182"><xref:System.Threading.EventWaitHandle> フラグで作成された <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> は、その <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、シグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="b3706-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="b3706-183">これは、シグナル状態になるまで閉じられ、誰かが閉めるまで開いたままになっている門のようなものです。</span><span class="sxs-lookup"><span data-stu-id="b3706-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="b3706-184"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> から派生する、<xref:System.Threading.EventWaitHandle> クラスはその動作を表します。</span><span class="sxs-lookup"><span data-stu-id="b3706-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="b3706-185"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> クラスは軽量であり、<xref:System.Threading.ManualResetEvent> の代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="b3706-186">Windows では、プロセス間同期で <xref:System.Threading.EventWaitHandle> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="b3706-187">そのためには、名前または <xref:System.Threading.EventWaitHandle> メソッドを指定する [EventWaitHandle コンストラクター](<xref:System.Threading.EventWaitHandle.%23ctor%2A>)のいずれかを使用して、名前付きシステム同期イベントを表す <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="b3706-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b3706-188">詳細については、「[EventWaitHandle](eventwaithandle.md)」の記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="b3706-189">API リファレンスについては、<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>、<xref:System.Threading.ManualResetEvent>、および <xref:System.Threading.ManualResetEventSlim> に関する記述を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="b3706-190">CountdownEvent クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-190">CountdownEvent class</span></span>

<span data-ttu-id="b3706-191"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> クラスは、そのカウントが 0 になると設定されるようになるイベントを表します。</span><span class="sxs-lookup"><span data-stu-id="b3706-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="b3706-192"><xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> が 0 より大きい間は、<xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> を呼び出すスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b3706-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="b3706-193">イベントのカウントをデクリメントするには、<xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b3706-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="b3706-194">1 つのスレッドからのシグナルで複数のスレッドのブロックを解除するために使用できる、<xref:System.Threading.ManualResetEvent> や <xref:System.Threading.ManualResetEventSlim> とは対照的に、<xref:System.Threading.CountdownEvent> を使用すると、複数のスレッドからのシグナルで 1 つ以上のスレッドのブロックを解除できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="b3706-195">詳細については、「[CountdownEvent](countdownevent.md)」の記事と、<xref:System.Threading.CountdownEvent> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="b3706-196">Barrier クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-196">Barrier class</span></span>

<span data-ttu-id="b3706-197"><xref:System.Threading.Barrier?displayProperty=nameWithType> クラスはスレッド実行のバリアを表します。</span><span class="sxs-lookup"><span data-stu-id="b3706-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="b3706-198"><xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> メソッドを呼び出すスレッドでは、バリアに到達したことを知らせ、他の参加スレッドがバリアに到達するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="b3706-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="b3706-199">すべての参加スレッドは、バリアに到達したときに先に進み、バリアはリセットされて再度使用することができます。</span><span class="sxs-lookup"><span data-stu-id="b3706-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="b3706-200">1 つ以上のスレッドが次の計算フェーズに進む前に、他のスレッドの結果を必要とする場合は、<xref:System.Threading.Barrier> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="b3706-201">詳細については、「[バリア](barrier.md)」の記事と、<xref:System.Threading.Barrier> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="b3706-202">Interlocked クラス</span><span class="sxs-lookup"><span data-stu-id="b3706-202">Interlocked class</span></span>

<span data-ttu-id="b3706-203"><xref:System.Threading.Interlocked?displayProperty=nameWithType> クラスでは、変数に対してシンプルなアトミック操作を実行する静的メソッドが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="b3706-204">それらのアトミック操作としては、64 ビット整数値を対象とした追加、インクリメントとデクリメント、交換、比較による条件付き交換、読み取りの各操作があります。</span><span class="sxs-lookup"><span data-stu-id="b3706-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="b3706-205">詳細については、<xref:System.Threading.Interlocked> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="b3706-206">SpinWait 構造体</span><span class="sxs-lookup"><span data-stu-id="b3706-206">SpinWait structure</span></span>

<span data-ttu-id="b3706-207"><xref:System.Threading.SpinWait?displayProperty=nameWithType> 構造体では、スピンベースの待機のサポートが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b3706-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="b3706-208">これは、イベントが通知されるか条件が満たされるのをスレッドが待機する必要があるが、待機ハンドルを使用するかあるいはスレッドをブロックする際に必要な待機時間よりも実際の待機時間が短いと思われる場合に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="b3706-209"><xref:System.Threading.SpinWait> を使用することにより、待機中はスピンし、指定した時間内に条件が満たされなかった場合のみ (たとえば待機またはスリープして) 譲渡するための短い時間を指定できます。</span><span class="sxs-lookup"><span data-stu-id="b3706-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="b3706-210">詳細については、「[SpinWait](spinwait.md)」の記事と、<xref:System.Threading.SpinWait> API リファレンスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b3706-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="b3706-211">参照</span><span class="sxs-lookup"><span data-stu-id="b3706-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="b3706-212">スレッド セーフなコレクション</span><span class="sxs-lookup"><span data-stu-id="b3706-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="b3706-213">スレッド処理オブジェクトと機能</span><span class="sxs-lookup"><span data-stu-id="b3706-213">Threading objects and features</span></span>](threading-objects-and-features.md)
