---
title: Semaphore と SemaphoreSlim
description: Semaphore と SemaphoreSlim について学習します。 クラス Semaphore は、Win32 セマフォ オブジェクトの Thin ラッパーです。 クラス SemaphoreSlim は、軽量で高速のセマフォです。
ms.date: 03/30/2017
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
ms.openlocfilehash: 34ffe11f7211d2d8b282bfd27f8c48328a5cb6d1
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/24/2020
ms.locfileid: "95681900"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="f912b-105">Semaphore と SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="f912b-105">Semaphore and SemaphoreSlim</span></span>

<span data-ttu-id="f912b-106"><xref:System.Threading.Semaphore?displayProperty=nameWithType> クラスは、名前付きセマフォ (システム全体) またはローカル セマフォを表します。</span><span class="sxs-lookup"><span data-stu-id="f912b-106">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="f912b-107">これは、Win32 セマフォ オブジェクトの Thin ラッパーです。</span><span class="sxs-lookup"><span data-stu-id="f912b-107">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="f912b-108">Win32 セマフォは、リソースのプールへのアクセスの制御に使用できるカウント セマフォです。</span><span class="sxs-lookup"><span data-stu-id="f912b-108">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="f912b-109"><xref:System.Threading.SemaphoreSlim> クラスは軽量で高速のセマフォを表しており、非常に短い待機時間が期待されている場合に単一プロセス内で待機のために使用できます。</span><span class="sxs-lookup"><span data-stu-id="f912b-109">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="f912b-110"><xref:System.Threading.SemaphoreSlim> は、共通言語ランタイム (CLR) により提供される同期プリミティブに可能な限り依存します。</span><span class="sxs-lookup"><span data-stu-id="f912b-110"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="f912b-111">ただし、複数のセマフォでの待機をサポートする必要がある場合は、遅れて初期化されるカーネル ベースの待機ハンドルも提供します。</span><span class="sxs-lookup"><span data-stu-id="f912b-111">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="f912b-112"><xref:System.Threading.SemaphoreSlim> はキャンセル トークンの使用もサポートしていますが、名前付きセマフォや、同期での待機ハンドルの使用はサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="f912b-112"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="f912b-113">制限されているリソースの管理</span><span class="sxs-lookup"><span data-stu-id="f912b-113">Managing a Limited Resource</span></span>  

 <span data-ttu-id="f912b-114">スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出してセマフォに入ります。このメソッドは <xref:System.Threading.WaitHandle> クラスから継承されるか (<xref:System.Threading.Semaphore?displayProperty=nameWithType> オブジェクトの場合)、<xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> メソッドまたは <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> メソッドから継承されます (<xref:System.Threading.SemaphoreSlim> オブジェクトの場合)。</span><span class="sxs-lookup"><span data-stu-id="f912b-114">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="f912b-115">呼び出しが戻されると、セマフォのカウントがデクリメントします。</span><span class="sxs-lookup"><span data-stu-id="f912b-115">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="f912b-116">スレッドがエントリを要求し、カウントがゼロの場合、そのスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="f912b-116">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="f912b-117">スレッドが <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> メソッドまたは <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> メソッドを呼び出してセマフォを解放すると、ブロックされたスレッドがセマフォに入ることができるようになります。</span><span class="sxs-lookup"><span data-stu-id="f912b-117">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="f912b-118">ブロックされたスレッドがセマフォに入る順序には、先入れ先出し (FIFO) や後入れ先出し (LIFO) などの決まった順序がありません。</span><span class="sxs-lookup"><span data-stu-id="f912b-118">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="f912b-119">スレッドは、<xref:System.Threading.Semaphore?displayProperty=nameWithType> オブジェクトの <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドまたは <xref:System.Threading.SemaphoreSlim> オブジェクトの <xref:System.Threading.SemaphoreSlim.Wait%2A> メソッドを繰り返し呼び出すことで、セマフォに複数回入ることができます。</span><span class="sxs-lookup"><span data-stu-id="f912b-119">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="f912b-120">セマフォを解放するために、スレッドは、<xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> メソッド オーバーロードまたは <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> メソッド オーバーロードを同じ回数呼び出すか、<xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> メソッド オーバーロードまたは <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> メソッド オーバーロードを呼び出して、解放するエントリ数を指定します。</span><span class="sxs-lookup"><span data-stu-id="f912b-120">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="f912b-121">セマフォとスレッド ID</span><span class="sxs-lookup"><span data-stu-id="f912b-121">Semaphores and Thread Identity</span></span>  

 <span data-ttu-id="f912b-122">この 2 つの種類のセマフォは、<xref:System.Threading.WaitHandle.WaitOne%2A>、<xref:System.Threading.SemaphoreSlim.Wait%2A>、<xref:System.Threading.Semaphore.Release%2A>、および <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> の各メソッドの呼び出しでスレッド ID を適用しません。</span><span class="sxs-lookup"><span data-stu-id="f912b-122">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f912b-123">たとえば、セマフォの一般的な使用シナリオでは、producer スレッドと consumer スレッドが使用され、一方のスレッドが常にセマフォ カウントをインクリメントし、もう一方のスレッドが常にセマフォ カウントをデクリメントします。</span><span class="sxs-lookup"><span data-stu-id="f912b-123">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="f912b-124">プログラマは、スレッドによるセマフォの解放回数が多くなりすぎないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f912b-124">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="f912b-125">たとえば、セマフォの最大カウントが 2 で、スレッド A とスレッド B が両方ともセマフォに入るとします。</span><span class="sxs-lookup"><span data-stu-id="f912b-125">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="f912b-126">スレッド B がプログラミング エラーのために `Release` を 2 回呼び出した場合、この呼び出しは両方とも成功します。</span><span class="sxs-lookup"><span data-stu-id="f912b-126">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="f912b-127">セマフォのカウントがいっぱいになっているときに、スレッド A も `Release` を呼び出すと、<xref:System.Threading.SemaphoreFullException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f912b-127">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="f912b-128">名前付きセマフォ</span><span class="sxs-lookup"><span data-stu-id="f912b-128">Named Semaphores</span></span>  

 <span data-ttu-id="f912b-129">Windows オペレーティング システムでは、セマフォに名前を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="f912b-129">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="f912b-130">名前付きセマフォはシステム全体でのセマフォです。</span><span class="sxs-lookup"><span data-stu-id="f912b-130">A named semaphore is system wide.</span></span> <span data-ttu-id="f912b-131">つまり、名前付きセマフォは、作成されると、すべてのプロセスのすべてのスレッドで認識されるようになります。</span><span class="sxs-lookup"><span data-stu-id="f912b-131">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="f912b-132">そのため、名前付きセマフォは、プロセスおよびスレッドのアクティビティを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="f912b-132">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="f912b-133">名前を指定するコンストラクターのいずれかを使用して、名前付きシステム セマフォを表す <xref:System.Threading.Semaphore> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="f912b-133">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f912b-134">名前付きセマフォはシステム全体でのセマフォであるため、同じ名前付きセマフォを表す複数の <xref:System.Threading.Semaphore> オブジェクトが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f912b-134">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="f912b-135">コンストラクターまたは <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> メソッドを呼び出すたびに、新しい <xref:System.Threading.Semaphore> オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="f912b-135">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="f912b-136">同じ名前を繰り返し指定すると、同じ名前付きセマフォを表す複数のオブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="f912b-136">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="f912b-137">名前付きセマフォを使用する際には注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f912b-137">Be careful when you use named semaphores.</span></span> <span data-ttu-id="f912b-138">システム全体でのセマフォであるため、同じ名前を使用する別のプロセスが予期せずセマフォに入る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f912b-138">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="f912b-139">同じコンピューター上で実行される悪意のあるコードが、これをサービス拒否攻撃の土台として使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f912b-139">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="f912b-140">アクセス制御セキュリティを使用して、名前付きセマフォを表す <xref:System.Threading.Semaphore> オブジェクトを保護します。可能であれば <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> オブジェクトを指定するコンストラクターを使用して保護します。</span><span class="sxs-lookup"><span data-stu-id="f912b-140">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="f912b-141"><xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> メソッドを使用してアクセス制御セキュリティを適用することもできますが、この場合、セマフォが作成されてから保護されるまでの間に無防備な時間帯が生じてしまいます。</span><span class="sxs-lookup"><span data-stu-id="f912b-141">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="f912b-142">アクセス制御セキュリティによりセマフォを保護すると、悪意のある攻撃を防ぐことができますが、意図しない名前の競合の問題の解決にはなりません。</span><span class="sxs-lookup"><span data-stu-id="f912b-142">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f912b-143">関連項目</span><span class="sxs-lookup"><span data-stu-id="f912b-143">See also</span></span>

- <xref:System.Threading.Semaphore>
- <xref:System.Threading.SemaphoreSlim>
- [<span data-ttu-id="f912b-144">スレッド処理オブジェクトと機能</span><span class="sxs-lookup"><span data-stu-id="f912b-144">Threading Objects and Features</span></span>](threading-objects-and-features.md)
