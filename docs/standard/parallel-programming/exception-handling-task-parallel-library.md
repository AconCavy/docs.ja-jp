---
title: 例外処理 (タスク並列ライブラリ)
description: .NET のタスク並列ライブラリ (TPL) を使用した例外処理について確認します。 入れ子にされた例外集計、内部例外、監視されていないタスクの例外などを参照します。
ms.date: 04/20/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
ms.openlocfilehash: f1c1a994f4b3a8df0556a0190bc4eacb63f2921e
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662538"
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="610b0-104">例外処理 (タスク並列ライブラリ)</span><span class="sxs-lookup"><span data-stu-id="610b0-104">Exception handling (Task Parallel Library)</span></span>

<span data-ttu-id="610b0-105">タスク内で実行中のユーザー コードによってスローされた、ハンドルされない例外は、呼び出し元のスレッドに反映されます。ただし、このトピックの後半で説明している特定の状況を除きます。</span><span class="sxs-lookup"><span data-stu-id="610b0-105">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="610b0-106">静的な、またはインスタンスの <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドの 1 つを使用し、その呼び出しを `try`/`catch` ステートメント内に入れて例外を処理すると、例外が反映されます。</span><span class="sxs-lookup"><span data-stu-id="610b0-106">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="610b0-107">タスクが、アタッチされた子タスクの親である場合、または複数のタスクを待機している場合、複数の例外がスローされることがあります。</span><span class="sxs-lookup"><span data-stu-id="610b0-107">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>

<span data-ttu-id="610b0-108">呼び出し元のスレッドにすべての例外を反映するために、Task インフラストラクチャが例外を <xref:System.AggregateException> インスタンスにラップします。</span><span class="sxs-lookup"><span data-stu-id="610b0-108">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="610b0-109"><xref:System.AggregateException> 例外には、スローされた元のすべての例外を調べるために列挙できる <xref:System.AggregateException.InnerExceptions%2A> プロパティがあり、個々に処理したり未処理にしたりできます。</span><span class="sxs-lookup"><span data-stu-id="610b0-109">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="610b0-110">また、 <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> メソッドを使用して元の例外を処理することもできます。</span><span class="sxs-lookup"><span data-stu-id="610b0-110">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="610b0-111">例外が 1 つだけスローされた場合でも、次の例のように <xref:System.AggregateException> 例外にラップされます。</span><span class="sxs-lookup"><span data-stu-id="610b0-111">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
[!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]

<span data-ttu-id="610b0-112">ハンドルされない例外は、 <xref:System.AggregateException> をキャッチして、内部例外を確認しないことで回避できます。</span><span class="sxs-lookup"><span data-stu-id="610b0-112">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="610b0-113">ただし、並列でない状況で基本的な <xref:System.Exception> の種類をキャッチする場合と類似しているため、この操作はお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="610b0-113">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="610b0-114">特定の操作を取得することなく例外をキャッチして回復しようとすると、プログラムが中間状態のままになるおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="610b0-114">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>

<span data-ttu-id="610b0-115"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出してタスクの完了を待機する処理を行わない場合は、次の例のようにタスクの <xref:System.Threading.Tasks.Task.Exception%2A> プロパティから <xref:System.AggregateException> 例外を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="610b0-115">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="610b0-116">詳細については、このトピックの「[Task.Exception プロパティによる例外の確認](#observing-exceptions-by-using-the-taskexception-property)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="610b0-116">For more information, see the [Observing exceptions by using the Task.Exception property](#observing-exceptions-by-using-the-taskexception-property) section in this topic.</span></span>

[!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
[!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]

<span data-ttu-id="610b0-117">例外を反映するタスクを待機しない場合、またはタスクの <xref:System.Threading.Tasks.Task.Exception%2A> プロパティにアクセスする場合、例外はタスクがガベージ コレクトされるときに .NET の例外ポリシーに従ってエスカレートされます。</span><span class="sxs-lookup"><span data-stu-id="610b0-117">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>

<span data-ttu-id="610b0-118">連結しているスレッドへ例外が上方向に通知されると、例外が発生した後も、タスクによって一部の項目の処理が続行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="610b0-118">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>

> [!NOTE]
> <span data-ttu-id="610b0-119">[マイ コードのみ] が有効になっている場合、Visual Studio では、例外をスローする行で処理が中断され、"ユーザー コードで処理されない例外" に関するエラー メッセージが表示されることがあります。</span><span class="sxs-lookup"><span data-stu-id="610b0-119">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="610b0-120">このエラーは問題にはなりません。</span><span class="sxs-lookup"><span data-stu-id="610b0-120">This error is benign.</span></span> <span data-ttu-id="610b0-121">F5 キーを押して続行し、以下の例に示す例外処理動作を確認できます。</span><span class="sxs-lookup"><span data-stu-id="610b0-121">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="610b0-122">Visual Studio による処理が最初のエラーで中断しないようにするには、 **[ツール]** メニューの [オプション]、[デバッグ] の順にクリックし、[全般] で **[マイ コードのみを有効にする]** チェック ボックスをオフにします。</span><span class="sxs-lookup"><span data-stu-id="610b0-122">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>

## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="610b0-123">アタッチされた子タスクと入れ子の AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="610b0-123">Attached child tasks and nested AggregateExceptions</span></span>

<span data-ttu-id="610b0-124">タスクに、例外をスローする子タスクがアタッチされている場合、その例外は親タスクに反映される前に <xref:System.AggregateException> でラップされます。つまり、呼び出し元のスレッドに反映される前に、その例外が固有の <xref:System.AggregateException> でラップされるということです。</span><span class="sxs-lookup"><span data-stu-id="610b0-124">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="610b0-125">このような場合、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task.WaitAny%2A>、<xref:System.Threading.Tasks.Task.WaitAll%2A> の各メソッドでキャッチされた <xref:System.AggregateException> 例外の <xref:System.AggregateException.InnerExceptions%2A> プロパティには、違反の原因となった元の例外ではなく、1 つ以上の <xref:System.AggregateException> インスタンスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="610b0-125">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task.WaitAny%2A>, or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="610b0-126">入れ子の <xref:System.AggregateException> 例外を反復処理しなくて済むようにするには、<xref:System.AggregateException.Flatten%2A> メソッドを使用して入れ子の <xref:System.AggregateException> をすべて削除します。これにより、<xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> プロパティに元の例外が含まれるようになります。</span><span class="sxs-lookup"><span data-stu-id="610b0-126">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="610b0-127">次の例では、入れ子の <xref:System.AggregateException> インスタンスが 1 つのループで平坦化され、処理されています。</span><span class="sxs-lookup"><span data-stu-id="610b0-127">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>

[!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
[!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]

<span data-ttu-id="610b0-128">また、次の例のように、<xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> メソッドを使用して、単一の <xref:System.AggregateException> インスタンス内の複数のタスクによってスローされた複数の <xref:System.AggregateException> インスタンスから内部例外を再スローすることもできます。</span><span class="sxs-lookup"><span data-stu-id="610b0-128">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>

[!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
[!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]

## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="610b0-129">デタッチされた子タスクの例外</span><span class="sxs-lookup"><span data-stu-id="610b0-129">Exceptions from detached child tasks</span></span>

<span data-ttu-id="610b0-130">既定では、子タスクはデタッチされた状態で作成されます。</span><span class="sxs-lookup"><span data-stu-id="610b0-130">By default, child tasks are created as detached.</span></span> <span data-ttu-id="610b0-131">デタッチされたタスクからスローされた例外は、処理されるか、直接の親に再スローされる必要があります。これらの例外は、アタッチされた子タスクが反映されるのとは異なる方法で、呼び出し元のスレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="610b0-131">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="610b0-132">最上位の親では、デタッチされた子からの例外を手動で再スローすることで、 <xref:System.AggregateException> にラップして、呼び出し元のスレッドに反映させることができます。</span><span class="sxs-lookup"><span data-stu-id="610b0-132">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>

[!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
[!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]

<span data-ttu-id="610b0-133">子タスク内の例外を確認するために継続を使用する場合でも、親タスクによって例外を確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="610b0-133">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>

## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="610b0-134">他の処理との連携によるキャンセル処理を示す例外</span><span class="sxs-lookup"><span data-stu-id="610b0-134">Exceptions that indicate cooperative cancellation</span></span>

<span data-ttu-id="610b0-135">タスク内のユーザー コードがキャンセル要求に応答する場合の正しいプロシージャは、その要求が伝えられたキャセル トークンに渡すために <xref:System.OperationCanceledException> をスローすることです。</span><span class="sxs-lookup"><span data-stu-id="610b0-135">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="610b0-136">例外が反映される前に、タスク インスタンスによって、例外内のトークンがそのタスクが作成されたときに渡されたトークンと比較されます。</span><span class="sxs-lookup"><span data-stu-id="610b0-136">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="610b0-137">それらが同じである場合、タスクは <xref:System.Threading.Tasks.TaskCanceledException> でラップされた <xref:System.AggregateException>を反映します。これは、内部例外を調べると確認できます。</span><span class="sxs-lookup"><span data-stu-id="610b0-137">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="610b0-138">ただし、呼び出し元のスレッドがタスクを待機していない場合、このような特定の例外は反映されません。</span><span class="sxs-lookup"><span data-stu-id="610b0-138">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="610b0-139">詳細については、「[タスクのキャンセル](task-cancellation.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="610b0-139">For more information, see [Task Cancellation](task-cancellation.md).</span></span>

[!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
[!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]

## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="610b0-140">内部例外をフィルター処理する Handle メソッドの使用</span><span class="sxs-lookup"><span data-stu-id="610b0-140">Using the handle method to filter inner exceptions</span></span>

<span data-ttu-id="610b0-141"><xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> メソッドを使用すると、"処理済み" として扱うことのできる例外をフィルターで除外できます。追加のロジックを使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="610b0-141">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="610b0-142"><xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> メソッドに用意されているユーザー デリゲートでは、例外の種類、その <xref:System.Exception.Message%2A> プロパティ、またはその例外に問題がないかどうかを判別できるその他の情報を調べることができます。</span><span class="sxs-lookup"><span data-stu-id="610b0-142">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="610b0-143">デリゲートが `false` を返す例外は、<xref:System.AggregateException> メソッドが返された直後に新しい <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> インスタンスで再スローされます。</span><span class="sxs-lookup"><span data-stu-id="610b0-143">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>

<span data-ttu-id="610b0-144">次の例は、機能的には、<xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> コレクション内の各例外を調べるこのトピックの最初の例と同じです。</span><span class="sxs-lookup"><span data-stu-id="610b0-144">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="610b0-145">代わりに、この例外ハンドラーでは、例外ごとに <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> メソッドのオブジェクトを呼び出し、`CustomException` インスタンスでない例外のみを再スローしています。</span><span class="sxs-lookup"><span data-stu-id="610b0-145">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>

[!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
[!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]

<span data-ttu-id="610b0-146">次の例はさらに複雑です。<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> メソッドを使用して、ファイルの列挙時に <xref:System.UnauthorizedAccessException> 例外の特別な処理を行っています。</span><span class="sxs-lookup"><span data-stu-id="610b0-146">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>

[!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
[!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]

## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="610b0-147">Task.Exception プロパティによる例外の確認</span><span class="sxs-lookup"><span data-stu-id="610b0-147">Observing exceptions by using the Task.Exception property</span></span>

<span data-ttu-id="610b0-148">タスクが <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 状態で完了した場合、その <xref:System.Threading.Tasks.Task.Exception%2A> プロパティを調べることで違反の原因となった例外を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="610b0-148">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="610b0-149"><xref:System.Threading.Tasks.Task.Exception%2A> プロパティを確認する場合は、次の例に示すように、継続元タスクが違反した場合にのみ実行される継続を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="610b0-149">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>

[!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
[!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]

<span data-ttu-id="610b0-150">重要なアプリケーションでは、継続のデリゲートで例外に関する詳細情報を記録して、新しいタスクを作成して例外から回復することが考えられます。</span><span class="sxs-lookup"><span data-stu-id="610b0-150">In a meaningful application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span> <span data-ttu-id="610b0-151">タスクで障害が発生した場合は、次の式によって例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="610b0-151">If a task faults, the following expressions throw the exception:</span></span>

- `await task`
- `task.Wait()`
- `task.Result`
- `task.GetAwaiter().GetResult()`

<span data-ttu-id="610b0-152">スローされた例外を処理したり観察したりするには、[`try-catch`](../../csharp/language-reference/keywords/try-catch.md) ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="610b0-152">Use a [`try-catch`](../../csharp/language-reference/keywords/try-catch.md) statement to handle and observe thrown exceptions.</span></span> <span data-ttu-id="610b0-153"><xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> プロパティにアクセスして例外を観察する方法もあります。</span><span class="sxs-lookup"><span data-stu-id="610b0-153">Alternatively, observe the exception by accessing the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> property.</span></span>

## <a name="unobservedtaskexception-event"></a><span data-ttu-id="610b0-154">UnobservedTaskException イベント</span><span class="sxs-lookup"><span data-stu-id="610b0-154">UnobservedTaskException event</span></span>

<span data-ttu-id="610b0-155">信頼関係のないプラグインをホストするときなど、シナリオによっては、問題のない例外がよく発生する場合や、難しすぎてすべてを手動で観察できなくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="610b0-155">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="610b0-156">このような場合、 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> イベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="610b0-156">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="610b0-157">ハンドラーに渡される <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> インスタンスを使用して、観察されない例外が連結しているスレッドに反映されないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="610b0-157">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>

## <a name="see-also"></a><span data-ttu-id="610b0-158">関連項目</span><span class="sxs-lookup"><span data-stu-id="610b0-158">See also</span></span>

- [<span data-ttu-id="610b0-159">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="610b0-159">Task Parallel Library (TPL)</span></span>](task-parallel-library-tpl.md)
