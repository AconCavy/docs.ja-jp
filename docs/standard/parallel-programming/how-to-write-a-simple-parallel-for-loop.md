---
title: '方法: 単純な Parallel.For ループを記述する'
description: ループをキャンセルしたり、ループのイテレーションを中断したり、スレッドローカルの状態を維持したりする必要のない、.NET の Parallel.For ループの記述を学びます。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Parallel.For, How to Write
- for loop, parallel construction in .NET
- parallel for loops, how to use
ms.assetid: 9029ba7f-a9d1-4526-8c84-c88716dba5d4
ms.openlocfilehash: 8307f2205653fbd213d824acffc405ee97580166
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/10/2020
ms.locfileid: "84662694"
---
# <a name="how-to-write-a-simple-parallelfor-loop"></a><span data-ttu-id="5801d-103">方法: 単純な Parallel.For ループを記述する</span><span class="sxs-lookup"><span data-stu-id="5801d-103">How to: Write a Simple Parallel.For Loop</span></span>

<span data-ttu-id="5801d-104">このトピックでは、<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドを示す 2 つの例を示しています。</span><span class="sxs-lookup"><span data-stu-id="5801d-104">This topic contains two examples that illustrate the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5801d-105">最初の例では <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> メソッドのオーバー ロードを使用し、2 番目の例では <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> のオーバー ロードを使用しています。これらは <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドの 2 つの最も単純なオーバーロードです。</span><span class="sxs-lookup"><span data-stu-id="5801d-105">The first uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int64%2CSystem.Int64%2CSystem.Action%7BSystem.Int64%7D%29?displayProperty=nameWithType> method overload, and the second uses the <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Action%7BSystem.Int32%7D%29?displayProperty=nameWithType> overload, the two simplest overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5801d-106"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドのこれらの 2 つのオーバー ロードは、ループをキャンセルする必要がない場合、ループのイテレーションから抜ける場合、またはいずれかのスレッドローカル状態を維持する場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="5801d-106">You can use these two overloads of the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method when you do not need to cancel the loop, break out of the loop iterations, or maintain any thread-local state.</span></span>

> [!NOTE]
> <span data-ttu-id="5801d-107">ここでは、ラムダ式を使用して TPL でデリゲートを定義します。</span><span class="sxs-lookup"><span data-stu-id="5801d-107">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="5801d-108">C# または Visual Basic のラムダ式についての情報が必要な場合は、「[Lambda Expressions in PLINQ and TPL (PLINQ および TPL のラムダ式)](lambda-expressions-in-plinq-and-tpl.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5801d-108">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="5801d-109">最初の例では、1 つのディレクトリ内のファイルのサイズを計算します。</span><span class="sxs-lookup"><span data-stu-id="5801d-109">The first example calculates the size of files in a single directory.</span></span> <span data-ttu-id="5801d-110">2 つ目の例では、2 つの行列の積を計算します。</span><span class="sxs-lookup"><span data-stu-id="5801d-110">The second computes the product of two matrices.</span></span>

## <a name="directory-size-example"></a><span data-ttu-id="5801d-111">ディレクトリ サイズの例</span><span class="sxs-lookup"><span data-stu-id="5801d-111">Directory size example</span></span>

<span data-ttu-id="5801d-112">この例は、ディレクトリ内のファイルの合計サイズを計算する単純なコマンド ライン ユーティリティです。</span><span class="sxs-lookup"><span data-stu-id="5801d-112">This example is a simple command-line utility that calculates the total size of files in a directory.</span></span> <span data-ttu-id="5801d-113">引数として 1 つのディレクトリ パスを必要とし、対象のディレクトリ内のファイルの数と合計サイズを報告します。</span><span class="sxs-lookup"><span data-stu-id="5801d-113">It expects a single directory path as an argument, and reports the number and total size of the files in that directory.</span></span> <span data-ttu-id="5801d-114">ディレクトリが存在することを確認したら、<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドを使用してディレクトリ内のファイルを列挙し、そのファイルのサイズを決定します。</span><span class="sxs-lookup"><span data-stu-id="5801d-114">After verifying that the directory exists, it uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to enumerate the files in the directory and determine their file sizes.</span></span> <span data-ttu-id="5801d-115">そして、各ファイル サイズが `totalSize` 変数に追加されます。</span><span class="sxs-lookup"><span data-stu-id="5801d-115">Each file size is then added to the `totalSize` variable.</span></span> <span data-ttu-id="5801d-116">加算処理は、アトミックな操作として実行できるように、<xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> を呼び出して実行されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5801d-116">Note that the addition is performed by calling the <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> so that the addition is performed as an atomic operation.</span></span> <span data-ttu-id="5801d-117">そうしない場合、複数のタスクが同時に `totalSize` 変数を更新しようとすることがあります。</span><span class="sxs-lookup"><span data-stu-id="5801d-117">Otherwise, multiple tasks could try to update the `totalSize` variable simultaneously.</span></span>

[!code-csharp[Conceptual.Parallel.For#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.parallel.for/cs/for1.cs#1)]
[!code-vb[Conceptual.Parallel.For#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.parallel.for/vb/for1.vb#1)]

## <a name="matrix-and-stopwatch-example"></a><span data-ttu-id="5801d-118">行列とストップウォッチの例</span><span class="sxs-lookup"><span data-stu-id="5801d-118">Matrix and stopwatch example</span></span>

<span data-ttu-id="5801d-119">この例では、<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドを使用して 2 つの行列の積を計算します。</span><span class="sxs-lookup"><span data-stu-id="5801d-119">This example uses the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method to compute the product of two matrices.</span></span> <span data-ttu-id="5801d-120">また、<xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> クラスを使用して並列ループと並列ではないループのパフォーマンスを比較する方法も示しています。</span><span class="sxs-lookup"><span data-stu-id="5801d-120">It also shows how to use the <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class to compare the performance of a parallel loop with a non-parallel loop.</span></span> <span data-ttu-id="5801d-121">大量の出力が生成されるため、この例では出力をファイルにリダイレクトできることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="5801d-121">Note that, because it can generate a large volume of output, the example allows output to be redirected to a file.</span></span>

[!code-csharp[TPL_Parallel#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_parallel/cs/simpleparallelfor.cs#01)]
[!code-vb[TPL_Parallel#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_parallel/vb/simpleparallelfor.vb#01)]

<span data-ttu-id="5801d-122">ループを含む任意のコードを並列処理する場合、1 つの重要な目標は、並列処理のオーバーヘッドがパフォーマンス上の利点を無にするところまで並列化しすぎることなく、できるだけプロセッサを活用することです。</span><span class="sxs-lookup"><span data-stu-id="5801d-122">When parallelizing any code, including loops, one important goal is to utilize the processors as much as possible without over parallelizing to the point where the overhead for parallel processing negates any performance benefits.</span></span> <span data-ttu-id="5801d-123">この特殊な例では、内側のループで実行される作業があまり多くないため、外側のループのみが並列化されています。</span><span class="sxs-lookup"><span data-stu-id="5801d-123">In this particular example, only the outer loop is parallelized because there is not very much work performed in the inner loop.</span></span> <span data-ttu-id="5801d-124">少量の作業と不適切なキャッシュの影響が組み合わさって、結果として入れ子になった並列ループのパフォーマンスが低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="5801d-124">The combination of a small amount of work and undesirable cache effects can result in performance degradation in nested parallel loops.</span></span> <span data-ttu-id="5801d-125">このため、大部分のシステムでは、外側のループだけをコンカレンシーすることで、最大限の効果を得ることができると言えます。</span><span class="sxs-lookup"><span data-stu-id="5801d-125">Therefore, parallelizing the outer loop only is the best way to maximize the benefits of concurrency on most systems.</span></span>

## <a name="the-delegate"></a><span data-ttu-id="5801d-126">デリゲート</span><span class="sxs-lookup"><span data-stu-id="5801d-126">The Delegate</span></span>

<span data-ttu-id="5801d-127">この <xref:System.Threading.Tasks.Parallel.For%2A> のオーバーロードの 3 番目のパラメーターは、`Action<int>` 型 (C#) または`Action(Of Integer)` 型 (Visual Basic) のデリゲートです。</span><span class="sxs-lookup"><span data-stu-id="5801d-127">The third parameter of this overload of <xref:System.Threading.Tasks.Parallel.For%2A> is a delegate of type `Action<int>` in C# or `Action(Of Integer)` in Visual Basic.</span></span> <span data-ttu-id="5801d-128">`Action` デリゲートは、0、1、または 16 の型パラメーターのいずれがあっても常に void を返します。</span><span class="sxs-lookup"><span data-stu-id="5801d-128">An `Action` delegate, whether it has zero, one or sixteen type parameters, always returns void.</span></span> <span data-ttu-id="5801d-129">Visual Basic では、`Action` の動作は `Sub` で定義されます。</span><span class="sxs-lookup"><span data-stu-id="5801d-129">In Visual Basic, the behavior of an `Action` is defined with a `Sub`.</span></span> <span data-ttu-id="5801d-130">例では、ラムダ式を使用してデリゲートを作成していますが、他の方法でも同様にデリゲートを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="5801d-130">The example uses a lambda expression to create the delegate, but you can create the delegate in other ways as well.</span></span> <span data-ttu-id="5801d-131">詳細については、「[PLINQ および TPL のラムダ式](lambda-expressions-in-plinq-and-tpl.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5801d-131">For more information, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

## <a name="the-iteration-value"></a><span data-ttu-id="5801d-132">イテレーション値</span><span class="sxs-lookup"><span data-stu-id="5801d-132">The Iteration Value</span></span>

<span data-ttu-id="5801d-133">デリゲートは、値が現在のイテレーションである 1 つの入力パラメーターを受け取ります。</span><span class="sxs-lookup"><span data-stu-id="5801d-133">The delegate takes a single input parameter whose value is the current iteration.</span></span> <span data-ttu-id="5801d-134">このイテレーション値はランタイムによって提供され、その開始値は、現在のスレッドで処理されているソースのセグメント (パーティション) の最初の要素のインデックスです。</span><span class="sxs-lookup"><span data-stu-id="5801d-134">This iteration value is supplied by the runtime and its starting value is the index of the first element on the segment (partition) of the source that is being processed on the current thread.</span></span>

<span data-ttu-id="5801d-135">コンカレンシー レベルをより細かく制御する必要がある場合は、<xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType> などの <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> 入力パラメーターを受け取るいずれかのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="5801d-135">If you require more control over the concurrency level, use one of the overloads that takes a <xref:System.Threading.Tasks.ParallelOptions?displayProperty=nameWithType> input parameter, such as: <xref:System.Threading.Tasks.Parallel.For%28System.Int32%2CSystem.Int32%2CSystem.Threading.Tasks.ParallelOptions%2CSystem.Action%7BSystem.Int32%2CSystem.Threading.Tasks.ParallelLoopState%7D%29?displayProperty=nameWithType>.</span></span>

## <a name="return-value-and-exception-handling"></a><span data-ttu-id="5801d-136">戻り値と例外処理</span><span class="sxs-lookup"><span data-stu-id="5801d-136">Return Value and Exception Handling</span></span>

<span data-ttu-id="5801d-137">すべてのスレッドが完了すると、<xref:System.Threading.Tasks.Parallel.For%2A> は <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="5801d-137"><xref:System.Threading.Tasks.Parallel.For%2A> returns a <xref:System.Threading.Tasks.ParallelLoopResult?displayProperty=nameWithType> object when all threads have completed.</span></span> <span data-ttu-id="5801d-138">この戻り値は、手動でループのイテレーションを停止したり抜けたりする場合に役立ちます。完了まで実行した最後のイテレーションなどの情報を <xref:System.Threading.Tasks.ParallelLoopResult> が格納しているためです。</span><span class="sxs-lookup"><span data-stu-id="5801d-138">This return value is useful when you are stopping or breaking loop iteration manually, because the <xref:System.Threading.Tasks.ParallelLoopResult> stores information such as the last iteration that ran to completion.</span></span> <span data-ttu-id="5801d-139">いずれかのスレッドで 1 つ以上の例外が発生した場合、<xref:System.AggregateException?displayProperty=nameWithType> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="5801d-139">If one or more exceptions occur on one of the threads, a <xref:System.AggregateException?displayProperty=nameWithType> will be thrown.</span></span>

<span data-ttu-id="5801d-140">この例のコードでは、戻り値に <xref:System.Threading.Tasks.Parallel.For%2A> は使用されません。</span><span class="sxs-lookup"><span data-stu-id="5801d-140">In the code in this example, the return value of <xref:System.Threading.Tasks.Parallel.For%2A> is not used.</span></span>

## <a name="analysis-and-performance"></a><span data-ttu-id="5801d-141">分析とパフォーマンス</span><span class="sxs-lookup"><span data-stu-id="5801d-141">Analysis and Performance</span></span>

<span data-ttu-id="5801d-142">パフォーマンス ウィザードを使用すると、コンピューター上の CPU 使用率を表示できます。</span><span class="sxs-lookup"><span data-stu-id="5801d-142">You can use the Performance Wizard to view CPU usage on your computer.</span></span> <span data-ttu-id="5801d-143">試しに、マトリックスの列と行の数を増やします。</span><span class="sxs-lookup"><span data-stu-id="5801d-143">As an experiment, increase the number of columns and rows in the matrices.</span></span> <span data-ttu-id="5801d-144">マトリックスが大きいほど、並列バージョンとシーケンシャル バージョンの計算の間でパフォーマンスの違いが大きくなります。</span><span class="sxs-lookup"><span data-stu-id="5801d-144">The larger the matrices, the greater the performance difference between the parallel and sequential versions of the computation.</span></span> <span data-ttu-id="5801d-145">マトリックスが小さい場合、並列ループを設定する際のオーバーヘッドがあるため、シーケンシャル バージョンのほうが高速に実行します。</span><span class="sxs-lookup"><span data-stu-id="5801d-145">When the matrix is small, the sequential version will run faster because of the overhead in setting up the parallel loop.</span></span>

<span data-ttu-id="5801d-146">コンソールやファイル システムなどの共有リソースへの同期呼び出しを行うと、並列ループのパフォーマンスが大幅に低下します。</span><span class="sxs-lookup"><span data-stu-id="5801d-146">Synchronous calls to shared resources, like the Console or the File System, will significantly degrade the performance of a parallel loop.</span></span> <span data-ttu-id="5801d-147">パフォーマンスを測定する際は、ループ内の <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> などの呼び出しを避けるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="5801d-147">When measuring performance, try to avoid calls such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> within the loop.</span></span>

## <a name="compile-the-code"></a><span data-ttu-id="5801d-148">コードのコンパイル</span><span class="sxs-lookup"><span data-stu-id="5801d-148">Compile the Code</span></span>

<span data-ttu-id="5801d-149">このコードをコピーして、Visual Studio プロジェクトに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="5801d-149">Copy and paste this code into a Visual Studio project.</span></span>

## <a name="see-also"></a><span data-ttu-id="5801d-150">関連項目</span><span class="sxs-lookup"><span data-stu-id="5801d-150">See also</span></span>

- <xref:System.Threading.Tasks.Parallel.For%2A>
- <xref:System.Threading.Tasks.Parallel.ForEach%2A>
- [<span data-ttu-id="5801d-151">データの並列化</span><span class="sxs-lookup"><span data-stu-id="5801d-151">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)
- [<span data-ttu-id="5801d-152">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="5801d-152">Parallel Programming</span></span>](index.md)
