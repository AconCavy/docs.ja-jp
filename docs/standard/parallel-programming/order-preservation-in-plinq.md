---
title: PLINQ における順序維持
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, order preservation
ms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca
ms.openlocfilehash: 997bb80b6e30d4769613c4a1df647e6cd475a8ed
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/24/2020
ms.locfileid: "95730605"
---
# <a name="order-preservation-in-plinq"></a><span data-ttu-id="7909a-102">PLINQ における順序維持</span><span class="sxs-lookup"><span data-stu-id="7909a-102">Order Preservation in PLINQ</span></span>

<span data-ttu-id="7909a-103">PLINQ では、正確性を維持しながらパフォーマンスを最大にすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="7909a-103">In PLINQ, the goal is to maximize performance while maintaining correctness.</span></span> <span data-ttu-id="7909a-104">クエリをできるだけ速く実行する一方で、正確な結果を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7909a-104">A query should run as fast as possible but still produce the correct results.</span></span> <span data-ttu-id="7909a-105">正確性のために、ソース シーケンスの順序の維持が必要な場合がありますが、順序付けには負荷がかかります。</span><span class="sxs-lookup"><span data-stu-id="7909a-105">In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.</span></span> <span data-ttu-id="7909a-106">したがって、既定では、PLINQ はソース シーケンスの順序を維持しません。</span><span class="sxs-lookup"><span data-stu-id="7909a-106">Therefore, by default, PLINQ does not preserve the order of the source sequence.</span></span> <span data-ttu-id="7909a-107">この点で、PLINQ は [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)] と似ていますが、順序を維持する LINQ to Objects とは異なります。</span><span class="sxs-lookup"><span data-stu-id="7909a-107">In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.</span></span>  
  
 <span data-ttu-id="7909a-108">既定の動作をオーバーライドするには、ソース シーケンス上で <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 演算子を使用して、順序の維持を有効にします。</span><span class="sxs-lookup"><span data-stu-id="7909a-108">To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="7909a-109">その後、<xref:System.Linq.ParallelEnumerable.AsUnordered%2A> メソッドを使用して、クエリでの順序の維持を無効にできます。</span><span class="sxs-lookup"><span data-stu-id="7909a-109">You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method.</span></span> <span data-ttu-id="7909a-110">どちらの方法でも、クエリを並列実行するか順次実行するかを決定するヒューリスティックに基づいてクエリが処理されます。</span><span class="sxs-lookup"><span data-stu-id="7909a-110">With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.</span></span> <span data-ttu-id="7909a-111">詳細については、「[Understanding Speedup in PLINQ (PLINQ での高速化について)](understanding-speedup-in-plinq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7909a-111">For more information, see [Understanding Speedup in PLINQ](understanding-speedup-in-plinq.md).</span></span>  
  
 <span data-ttu-id="7909a-112">次の例では、結果を順序付けず、条件に一致するすべての要素をフィルター処理する、順序なしの並列クエリを示しています。</span><span class="sxs-lookup"><span data-stu-id="7909a-112">The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.</span></span>  
  
 [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]
 [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  
  
 <span data-ttu-id="7909a-113">このクエリでは、ソース シーケンスで条件を満たす最初の 1000 都市が生成されるとは限らず、条件を満たす一連の 1000 都市が生成されます。</span><span class="sxs-lookup"><span data-stu-id="7909a-113">This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.</span></span> <span data-ttu-id="7909a-114">PLINQ クエリ演算子は、同時実行タスクとして処理される複数のサブシーケンスにソース シーケンスをパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="7909a-114">PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.</span></span> <span data-ttu-id="7909a-115">順序の維持が指定されていない場合、パーティションごとの結果はクエリの次のステージに任意の順序で渡されます。</span><span class="sxs-lookup"><span data-stu-id="7909a-115">If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.</span></span> <span data-ttu-id="7909a-116">また、パーティションでは、残りの要素の処理が続行される前に、結果のサブセットが生成される場合があります。</span><span class="sxs-lookup"><span data-stu-id="7909a-116">Also, a partition may yield a subset of its results before it continues to process the remaining elements.</span></span> <span data-ttu-id="7909a-117">結果の順序は毎回異なることがあります。</span><span class="sxs-lookup"><span data-stu-id="7909a-117">The resulting order may be different every time.</span></span> <span data-ttu-id="7909a-118">この動作は、オペレーティング システムによるスレッドのスケジュール方法に依存するため、アプリケーションでは制御できません。</span><span class="sxs-lookup"><span data-stu-id="7909a-118">Your application cannot control this because it depends on how the operating system schedules the threads.</span></span>  
  
 <span data-ttu-id="7909a-119">次の例では、ソース シーケンス上で <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 演算子を使用して、既定の動作をオーバーライドしています。</span><span class="sxs-lookup"><span data-stu-id="7909a-119">The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="7909a-120">この例では <xref:System.Linq.ParallelEnumerable.Take%2A> メソッドにより、ソース シーケンスで条件を満たす最初の 1000 都市が返されます。</span><span class="sxs-lookup"><span data-stu-id="7909a-120">This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.</span></span>  
  
 [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]
 [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  
  
 <span data-ttu-id="7909a-121">ただし、このクエリは順序なしのクエリと同じ速度では実行されません。パーティション全体とマージ時刻で元の順序を追跡し、順序が一貫していることを確認する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="7909a-121">However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.</span></span> <span data-ttu-id="7909a-122">したがって、<xref:System.Linq.ParallelEnumerable.AsOrdered%2A> は、必要な場合にのみ、クエリの該当部分に限って使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7909a-122">Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it.</span></span> <span data-ttu-id="7909a-123">順序を維持する必要がなくなったら、<xref:System.Linq.ParallelEnumerable.AsUnordered%2A> を使用して無効にします。</span><span class="sxs-lookup"><span data-stu-id="7909a-123">When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off.</span></span> <span data-ttu-id="7909a-124">2 つのクエリを組み合わせてこの処理を行う例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="7909a-124">The following example achieves this by composing two queries.</span></span>  
  
 [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]
 [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  
  
 <span data-ttu-id="7909a-125">PLINQ は、残りのクエリに対し、順序を強制する演算子によって生成されるシーケンスの順序を維持することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7909a-125">Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.</span></span> <span data-ttu-id="7909a-126">つまり、<xref:System.Linq.ParallelEnumerable.OrderBy%2A> や <xref:System.Linq.ParallelEnumerable.ThenBy%2A> の演算子に続いて <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> が呼び出されるのと同じように処理されます。</span><span class="sxs-lookup"><span data-stu-id="7909a-126">In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span></span>  
  
## <a name="query-operators-and-ordering"></a><span data-ttu-id="7909a-127">クエリ演算子と順序付け</span><span class="sxs-lookup"><span data-stu-id="7909a-127">Query Operators and Ordering</span></span>  

 <span data-ttu-id="7909a-128">次のクエリ演算子は、クエリ内のすべての後続演算子で順序を維持するか、または <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> が呼び出されるまで順序を維持します。</span><span class="sxs-lookup"><span data-stu-id="7909a-128">The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  
  
- <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  
  
 <span data-ttu-id="7909a-129">次の PLINQ クエリ演算子では、正確な結果を生成するために順序ありのソース シーケンスが必要となる場合があります。</span><span class="sxs-lookup"><span data-stu-id="7909a-129">The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:</span></span>  
  
- <xref:System.Linq.ParallelEnumerable.Reverse%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  
  
- <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  
  
- <xref:System.Linq.ParallelEnumerable.Zip%2A>  
  
 <span data-ttu-id="7909a-130">PLINQ クエリ演算子の中には、ソース シーケンスが順序ありか順序なしかによって動作が異なるものがあります。</span><span class="sxs-lookup"><span data-stu-id="7909a-130">Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.</span></span> <span data-ttu-id="7909a-131">次の表に、これらの演算子の一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="7909a-131">The following table lists these operators.</span></span>  
  
|<span data-ttu-id="7909a-132">演算子</span><span class="sxs-lookup"><span data-stu-id="7909a-132">Operator</span></span>|<span data-ttu-id="7909a-133">ソース シーケンスが順序ありの場合の結果</span><span class="sxs-lookup"><span data-stu-id="7909a-133">Result when the source sequence is ordered</span></span>|<span data-ttu-id="7909a-134">ソース シーケンスが順序なしの場合の結果</span><span class="sxs-lookup"><span data-stu-id="7909a-134">Result when the source sequence is unordered</span></span>|  
|--------------|------------------------------------------------|--------------------------------------------------|  
|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|<span data-ttu-id="7909a-135">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-135">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="7909a-136">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-136">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.All%2A>|<span data-ttu-id="7909a-137">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-137">Not applicable</span></span>|<span data-ttu-id="7909a-138">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-138">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Any%2A>|<span data-ttu-id="7909a-139">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-139">Not applicable</span></span>|<span data-ttu-id="7909a-140">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-140">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="7909a-141">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-141">Not applicable</span></span>|<span data-ttu-id="7909a-142">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-142">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Average%2A>|<span data-ttu-id="7909a-143">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-143">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="7909a-144">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-144">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="7909a-145">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-145">Ordered results</span></span>|<span data-ttu-id="7909a-146">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-146">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="7909a-147">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-147">Ordered results</span></span>|<span data-ttu-id="7909a-148">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-148">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Count%2A>|<span data-ttu-id="7909a-149">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-149">Not applicable</span></span>|<span data-ttu-id="7909a-150">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-150">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="7909a-151">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-151">Not applicable</span></span>|<span data-ttu-id="7909a-152">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-152">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|<span data-ttu-id="7909a-153">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-153">Ordered results</span></span>|<span data-ttu-id="7909a-154">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-154">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|<span data-ttu-id="7909a-155">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-155">Return specified element</span></span>|<span data-ttu-id="7909a-156">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-156">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|<span data-ttu-id="7909a-157">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-157">Return specified element</span></span>|<span data-ttu-id="7909a-158">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-158">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Except%2A>|<span data-ttu-id="7909a-159">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-159">Unordered results</span></span>|<span data-ttu-id="7909a-160">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-160">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.First%2A>|<span data-ttu-id="7909a-161">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-161">Return specified element</span></span>|<span data-ttu-id="7909a-162">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-162">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|<span data-ttu-id="7909a-163">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-163">Return specified element</span></span>|<span data-ttu-id="7909a-164">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-164">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="7909a-165">非確定的に並列実行</span><span class="sxs-lookup"><span data-stu-id="7909a-165">Executes nondeterministically in parallel</span></span>|<span data-ttu-id="7909a-166">非確定的に並列実行</span><span class="sxs-lookup"><span data-stu-id="7909a-166">Executes nondeterministically in parallel</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|<span data-ttu-id="7909a-167">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-167">Ordered results</span></span>|<span data-ttu-id="7909a-168">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-168">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|<span data-ttu-id="7909a-169">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-169">Ordered results</span></span>|<span data-ttu-id="7909a-170">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-170">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|<span data-ttu-id="7909a-171">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-171">Ordered results</span></span>|<span data-ttu-id="7909a-172">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-172">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Join%2A>|<span data-ttu-id="7909a-173">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-173">Ordered results</span></span>|<span data-ttu-id="7909a-174">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-174">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Last%2A>|<span data-ttu-id="7909a-175">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-175">Return specified element</span></span>|<span data-ttu-id="7909a-176">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-176">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|<span data-ttu-id="7909a-177">指定された要素を返す</span><span class="sxs-lookup"><span data-stu-id="7909a-177">Return specified element</span></span>|<span data-ttu-id="7909a-178">任意の要素</span><span class="sxs-lookup"><span data-stu-id="7909a-178">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|<span data-ttu-id="7909a-179">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-179">Not applicable</span></span>|<span data-ttu-id="7909a-180">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-180">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Min%2A>|<span data-ttu-id="7909a-181">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-181">Not applicable</span></span>|<span data-ttu-id="7909a-182">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-182">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|<span data-ttu-id="7909a-183">シーケンスを並べ替え</span><span class="sxs-lookup"><span data-stu-id="7909a-183">Reorders the sequence</span></span>|<span data-ttu-id="7909a-184">新規に順序付けられたセクションを開始</span><span class="sxs-lookup"><span data-stu-id="7909a-184">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|<span data-ttu-id="7909a-185">シーケンスを並べ替え</span><span class="sxs-lookup"><span data-stu-id="7909a-185">Reorders the sequence</span></span>|<span data-ttu-id="7909a-186">新規に順序付けられたセクションを開始</span><span class="sxs-lookup"><span data-stu-id="7909a-186">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Range%2A>|<span data-ttu-id="7909a-187">該当なし (<xref:System.Linq.ParallelEnumerable.AsParallel%2A> の既定と同じ)</span><span class="sxs-lookup"><span data-stu-id="7909a-187">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span></span>|<span data-ttu-id="7909a-188">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-188">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|<span data-ttu-id="7909a-189">該当なし (<xref:System.Linq.ParallelEnumerable.AsParallel%2A> の既定と同じ)</span><span class="sxs-lookup"><span data-stu-id="7909a-189">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span></span>|<span data-ttu-id="7909a-190">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-190">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="7909a-191">逆方向</span><span class="sxs-lookup"><span data-stu-id="7909a-191">Reverses</span></span>|<span data-ttu-id="7909a-192">処理を行わない</span><span class="sxs-lookup"><span data-stu-id="7909a-192">Does nothing</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="7909a-193">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-193">Ordered results</span></span>|<span data-ttu-id="7909a-194">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-194">Unordered results</span></span>|  
|<span data-ttu-id="7909a-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (インデックス付き)</span><span class="sxs-lookup"><span data-stu-id="7909a-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)</span></span>|<span data-ttu-id="7909a-196">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-196">Ordered results</span></span>|<span data-ttu-id="7909a-197">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-197">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="7909a-198">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-198">Ordered results.</span></span>|<span data-ttu-id="7909a-199">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-199">Unordered results</span></span>|  
|<span data-ttu-id="7909a-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (インデックス付き)</span><span class="sxs-lookup"><span data-stu-id="7909a-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)</span></span>|<span data-ttu-id="7909a-201">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-201">Ordered results.</span></span>|<span data-ttu-id="7909a-202">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-202">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|<span data-ttu-id="7909a-203">順序ありの比較</span><span class="sxs-lookup"><span data-stu-id="7909a-203">Ordered comparison</span></span>|<span data-ttu-id="7909a-204">順序なしの比較</span><span class="sxs-lookup"><span data-stu-id="7909a-204">Unordered comparison</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Single%2A>|<span data-ttu-id="7909a-205">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-205">Not applicable</span></span>|<span data-ttu-id="7909a-206">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-206">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|<span data-ttu-id="7909a-207">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-207">Not applicable</span></span>|<span data-ttu-id="7909a-208">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-208">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="7909a-209">最初の *n* 要素をスキップ</span><span class="sxs-lookup"><span data-stu-id="7909a-209">Skips first *n* elements</span></span>|<span data-ttu-id="7909a-210">任意の *n* 要素をスキップ</span><span class="sxs-lookup"><span data-stu-id="7909a-210">Skips any *n* elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|<span data-ttu-id="7909a-211">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-211">Ordered results.</span></span>|<span data-ttu-id="7909a-212">非確定。</span><span class="sxs-lookup"><span data-stu-id="7909a-212">Nondeterministic.</span></span> <span data-ttu-id="7909a-213">現在の任意の順序で SkipWhile を実行</span><span class="sxs-lookup"><span data-stu-id="7909a-213">Performs SkipWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Sum%2A>|<span data-ttu-id="7909a-214">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-214">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="7909a-215">非結合演算子または非可換演算子の場合は非確定の出力</span><span class="sxs-lookup"><span data-stu-id="7909a-215">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="7909a-216">最初の `n` 要素を取得</span><span class="sxs-lookup"><span data-stu-id="7909a-216">Takes first `n` elements</span></span>|<span data-ttu-id="7909a-217">`n` 要素を取得</span><span class="sxs-lookup"><span data-stu-id="7909a-217">Takes any `n` elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|<span data-ttu-id="7909a-218">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-218">Ordered results</span></span>|<span data-ttu-id="7909a-219">非確定。</span><span class="sxs-lookup"><span data-stu-id="7909a-219">Nondeterministic.</span></span> <span data-ttu-id="7909a-220">現在の任意の順序で TakeWhile を実行</span><span class="sxs-lookup"><span data-stu-id="7909a-220">Performs TakeWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|<span data-ttu-id="7909a-221">`OrderBy` を補足</span><span class="sxs-lookup"><span data-stu-id="7909a-221">Supplements `OrderBy`</span></span>|<span data-ttu-id="7909a-222">`OrderBy` を補足</span><span class="sxs-lookup"><span data-stu-id="7909a-222">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|<span data-ttu-id="7909a-223">`OrderBy` を補足</span><span class="sxs-lookup"><span data-stu-id="7909a-223">Supplements `OrderBy`</span></span>|<span data-ttu-id="7909a-224">`OrderBy` を補足</span><span class="sxs-lookup"><span data-stu-id="7909a-224">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|<span data-ttu-id="7909a-225">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-225">Ordered results</span></span>|<span data-ttu-id="7909a-226">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-226">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|<span data-ttu-id="7909a-227">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-227">Not applicable</span></span>|<span data-ttu-id="7909a-228">適用なし</span><span class="sxs-lookup"><span data-stu-id="7909a-228">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToList%2A>|<span data-ttu-id="7909a-229">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-229">Ordered results</span></span>|<span data-ttu-id="7909a-230">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-230">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|<span data-ttu-id="7909a-231">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-231">Ordered results</span></span>|<span data-ttu-id="7909a-232">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-232">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Union%2A>|<span data-ttu-id="7909a-233">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-233">Ordered results</span></span>|<span data-ttu-id="7909a-234">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-234">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="7909a-235">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-235">Ordered results</span></span>|<span data-ttu-id="7909a-236">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-236">Unordered results</span></span>|  
|<span data-ttu-id="7909a-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (インデックス付き)</span><span class="sxs-lookup"><span data-stu-id="7909a-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)</span></span>|<span data-ttu-id="7909a-238">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-238">Ordered results</span></span>|<span data-ttu-id="7909a-239">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-239">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Zip%2A>|<span data-ttu-id="7909a-240">順序ありの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-240">Ordered results</span></span>|<span data-ttu-id="7909a-241">順序なしの結果</span><span class="sxs-lookup"><span data-stu-id="7909a-241">Unordered results</span></span>|  
  
 <span data-ttu-id="7909a-242">順序なしの結果はアクティブにシャッフルされるわけではありません。適用される特別な順序ロジックがないだけです。</span><span class="sxs-lookup"><span data-stu-id="7909a-242">Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.</span></span> <span data-ttu-id="7909a-243">順序なしのクエリでソース シーケンスの順序が保持される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="7909a-243">In some cases, an unordered query may retain the ordering of the source sequence.</span></span> <span data-ttu-id="7909a-244">インデックス付きの Select 演算子を使用するクエリの場合、PLINQ ではインデックスが増加する順に出力要素が出力されることは保証しますが、どのインデックスがどの要素に割り当てられるかについては一切保証しません。</span><span class="sxs-lookup"><span data-stu-id="7909a-244">For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7909a-245">参照</span><span class="sxs-lookup"><span data-stu-id="7909a-245">See also</span></span>

- [<span data-ttu-id="7909a-246">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="7909a-246">Parallel LINQ (PLINQ)</span></span>](introduction-to-plinq.md)
- [<span data-ttu-id="7909a-247">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="7909a-247">Parallel Programming</span></span>](index.md)
