---
title: PLINQ および TPL 用のカスタム パーティショナー
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 8caea6d8a97b8c0daf7c59718479ea2e12a52d78
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/15/2020
ms.locfileid: "73141569"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="fdb00-102">PLINQ および TPL 用のカスタム パーティショナー</span><span class="sxs-lookup"><span data-stu-id="fdb00-102">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="fdb00-103">データ ソース上で操作を並列化する場合の必須の手順の 1 つは、ソースを複数のスレッドによって同時にアクセスできる複数のセクションに*パーティション分割*することです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="fdb00-104">PLINQ およびタスク並列ライブラリ (TPL: Task Parallel Library) には、並列クエリまたは <xref:System.Threading.Tasks.Parallel.ForEach%2A> ループを記述するときに透過的に機能する既定のパーティショナーが用意されています。</span><span class="sxs-lookup"><span data-stu-id="fdb00-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="fdb00-105">より高度なシナリオでは、独自のパーティショナーをプラグインできます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="fdb00-106">パーティション分割の種類</span><span class="sxs-lookup"><span data-stu-id="fdb00-106">Kinds of Partitioning</span></span>

<span data-ttu-id="fdb00-107">データ ソースは、さまざまな方法でパーティション分割できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="fdb00-108">最も効率的な方法は、ソースを複数のサブシーケンスに物理的に分離するのではなく、複数のスレッドが協調して元のソース シーケンスを処理するというものです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="fdb00-109">配列や、長さが事前にわかっている <xref:System.Collections.IList> コレクションなどの他のインデックス付きソースの場合は、"*範囲パーティション分割*" が最も簡単なパーティション分割です。</span><span class="sxs-lookup"><span data-stu-id="fdb00-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="fdb00-110">各スレッドは、一意の開始インデックスおよび終了インデックスを受け取ります。そのため、他のスレッドで上書きしたり、上書きされたりすることなく、ソースの範囲を処理できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="fdb00-111">範囲パーティション分割に必要なオーバーヘッドは、最初に行われる範囲を作成する作業のみです。その後は、追加の同期は不要です。</span><span class="sxs-lookup"><span data-stu-id="fdb00-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="fdb00-112">したがって、ワークロードが均等に分割されている限り、優れたパフォーマンスを実現できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="fdb00-113">範囲パーティション分割の欠点は、あるスレッドが早く終了した場合、他のスレッドが作業を終了するのを支援できないことです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="fdb00-114">リンク リストまたは長さがわからない他のコレクションの場合は、"*チャンク パーティション分割*" を使用できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="fdb00-115">チャンク パーティション分割では、並列ループまたは並列クエリ内のすべてのスレッドまたはタスクが、1 つのチャンク内のソース要素をいくつか使用し、それらのソース要素を処理し、その後追加の要素を取得します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="fdb00-116">パーティショナーは、すべての要素が配布され、重複する要素が存在しないことを保証します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="fdb00-117">チャンクは任意のサイズにすることができます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-117">A chunk may be any size.</span></span> <span data-ttu-id="fdb00-118">たとえば、「[方法: 動的パーティションを実装する](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」で示されているパーティショナーは、1 つの要素のみを含むチャンクを作成します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="fdb00-119">チャンクが大きすぎない限り、この種類のパーティション分割は、本質的に負荷分散を実行します。これは、スレッドへの要素の割り当てが事前に決定されないからです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="fdb00-120">ただし、スレッドが別のチャンクを取得する必要があるたびに、パーティショナーが同期のオーバーヘッドを発生させます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="fdb00-121">これらのケースで発生する同期の量は、チャンクのサイズに反比例します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="fdb00-122">一般に、範囲パーティション分割の方が高速なのは、デリゲートの実行時間が短時間から中程度までの長さであり、ソースに多数の要素があり、かつ各パーティションの総作業量がほぼ等価である場合のみです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="fdb00-123">したがってチャンク パーティション分割の方が、ほとんどのケースで高速です。</span><span class="sxs-lookup"><span data-stu-id="fdb00-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="fdb00-124">要素が少ないか、またはデリゲートの実行時間が長いソースでは、チャンク パーティション分割と範囲パーティション分割のパフォーマンスがほぼ等しくなります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="fdb00-125">TPL パーティショナーは、動的な数のパーティションもサポートします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="fdb00-126">つまり、たとえば <xref:System.Threading.Tasks.Parallel.ForEach%2A> ループが新しいタスクを作成するときに、パーティションをその場で作成できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="fdb00-127">この機能により、パーティショナーをループ自体と共に拡大縮小できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="fdb00-128">動的パーティショナーも本質的に負荷分散を実行します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="fdb00-129">カスタム パーティショナーを作成するときは、<xref:System.Threading.Tasks.Parallel.ForEach%2A> ループから使用できるようにするために、動的パーティション分割をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="fdb00-130">PLINQ 用の負荷分散パーティショナーの構成</span><span class="sxs-lookup"><span data-stu-id="fdb00-130">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="fdb00-131"><xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> メソッドの一部のオーバーロードを使用すると、配列または <xref:System.Collections.IList> ソース用のパーティショナーを作成し、スレッド間でワークロードの分散を試みるかどうかを指定できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="fdb00-132">負荷分散を実行するようにパーティショナーを構成した場合、チャンク パーティション分割が使用され、要素は要求時に小さいチャンクで各パーティションに渡されます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="fdb00-133">この方法は、ループまたはクエリの全体が完了するまで、すべてのパーティションに処理する要素があることを保証するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="fdb00-134">追加のオーバーロードを使用すると、任意の <xref:System.Collections.IEnumerable> ソースを負荷分散パーティション分割できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="fdb00-135">一般に、負荷分散では、パーティションで比較的頻繁にパーティショナーに要素を要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="fdb00-136">これに対し、静的パーティション分割を実行するパーティショナーでは、範囲パーティション分割またはチャンク パーティション分割を使用して、各パーティショナーに要素を一度に割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="fdb00-137">この方法では、負荷分散よりもオーバーヘッドが少なくて済みますが、あるスレッドが他のスレッドよりもはるかに多くの作業を行う場合は、実行時間が長くなることがあります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="fdb00-138">既定では、IList または配列が渡された場合、PLINQ は常に負荷分散なしの範囲パーティション分割を使用します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="fdb00-139">PLINQ で負荷分散を有効にするには、次の例に示すように、`Partitioner.Create` メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="fdb00-140">特定のシナリオで負荷分散を使用するかどうかを判断する最適な方法は、典型的な負荷およびコンピューター構成の下で操作が完了するまでにどのくらいの時間がかかるかを実験し、計測することです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="fdb00-141">たとえば、静的パーティション分割は、少数のコアしか持たないマルチコア コンピューターでは速度が飛躍的に向上することがありますが、比較的多くのコアを持つコンピューターでは速度が低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="fdb00-142">次の表に、<xref:System.Collections.Concurrent.Partitioner.Create%2A> メソッドで使用できるオーバーロードを示します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="fdb00-143">これらのパーティショナーは、PLINQ または <xref:System.Threading.Tasks.Task> での使用に限定されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="fdb00-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="fdb00-144">これらのパーティショナーは、任意のカスタム parallel コンストラクトでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-144">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="fdb00-145">オーバーロード</span><span class="sxs-lookup"><span data-stu-id="fdb00-145">Overload</span></span>|<span data-ttu-id="fdb00-146">負荷分散を使用する</span><span class="sxs-lookup"><span data-stu-id="fdb00-146">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="fdb00-147">Always (常に)</span><span class="sxs-lookup"><span data-stu-id="fdb00-147">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="fdb00-148">ブール型の引数を true と指定した場合</span><span class="sxs-lookup"><span data-stu-id="fdb00-148">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="fdb00-149">ブール型の引数を true と指定した場合</span><span class="sxs-lookup"><span data-stu-id="fdb00-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="fdb00-150">Never</span><span class="sxs-lookup"><span data-stu-id="fdb00-150">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="fdb00-151">Never</span><span class="sxs-lookup"><span data-stu-id="fdb00-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="fdb00-152">Never</span><span class="sxs-lookup"><span data-stu-id="fdb00-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="fdb00-153">Never</span><span class="sxs-lookup"><span data-stu-id="fdb00-153">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="fdb00-154">Parallel.ForEach 用の静的範囲パーティショナーの構成</span><span class="sxs-lookup"><span data-stu-id="fdb00-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="fdb00-155"><xref:System.Threading.Tasks.Parallel.For%2A> ループでは、ループの本体がデリゲートとしてメソッドに提供されます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="fdb00-156">このデリゲートを呼び出すコストは、仮想メソッドの呼び出しとほぼ同じです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="fdb00-157">シナリオによっては、並列ループの本体が小さく、各ループ反復でデリゲートを呼び出すコストが膨大になることがあります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="fdb00-158">そのような状況では、いずれかの <xref:System.Collections.Concurrent.Partitioner.Create%2A> オーバーロードを使用して、ソース要素に対する範囲パーティション分割の <xref:System.Collections.Generic.IEnumerable%601> を作成できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="fdb00-159">その後、この範囲のコレクションを、本体が通常の `for` ループで構成される <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="fdb00-160">この方法の利点は、デリゲートを呼び出すコストが、要素ごとに 1 回ではなく、範囲ごとに 1 回しか発生しないことです。</span><span class="sxs-lookup"><span data-stu-id="fdb00-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="fdb00-161">基本的なパターンを次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-161">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="fdb00-162">ループ内のすべてのスレッドは、指定されたサブ範囲の開始インデックス値と終了インデックス値を含む独自の <xref:System.Tuple%602> を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="fdb00-163">内側の `for` ループでは、`fromInclusive` 値および `toExclusive` 値を使用して、配列または <xref:System.Collections.IList> を直接ループ処理します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="fdb00-164"><xref:System.Collections.Concurrent.Partitioner.Create%2A> オーバーロードのいずれかを使用すると、パーティションのサイズと、パーティションの数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="fdb00-165">このオーバーロードは、要素ごとの作業がきわめて少なく、要素ごとに 1 回の仮想メソッド呼び出しでもパフォーマンスに大きな影響が及ぶシナリオで使用できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="fdb00-166">カスタム パーティショナー</span><span class="sxs-lookup"><span data-stu-id="fdb00-166">Custom Partitioners</span></span>

<span data-ttu-id="fdb00-167">シナリオによっては、独自のパーティショナーを実装するのが適切か、または必須である場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="fdb00-168">たとえば、クラスの内部構造に関する知識に基づいて、カスタム コレクション クラスを既定のパーティショナーよりも効率的にパーティション分割できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="fdb00-169">または、ソース コレクションの異なる場所にある要素を処理するのにかかる時間についての知識に基づいて、可変サイズの範囲パーティションを作成する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="fdb00-170">基本的なカスタム パーティショナーを作成するには、<xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> からクラスを派生させ、次の表に示すように仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="fdb00-171">このメソッドは、メイン スレッドによって 1 回呼び出され、IList(IEnumerator(TSource)) を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="fdb00-172">ループまたはクエリ内の各ワーカー スレッドでは、リスト上で `GetEnumerator` を呼び出して、個別のパーティションに対する <xref:System.Collections.Generic.IEnumerator%601> を取得できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="fdb00-173">`true` を実装した場合は <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> を返し、それ以外の場合は `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="fdb00-174"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> が `true` の場合、このメソッドを必要に応じて <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> の代わりに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="fdb00-175">結果が並べ替え可能である必要がある場合、または要素へのインデックス付きアクセスが必要な場合、<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> から派生させて、次の表に示すように仮想メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="fdb00-176">このメソッドは、メイン スレッドによって 1 回呼び出され、`IList(IEnumerator(TSource))` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="fdb00-177">ループまたはクエリ内の各ワーカー スレッドでは、リスト上で `GetEnumerator` を呼び出して、個別のパーティションに対する <xref:System.Collections.Generic.IEnumerator%601> を取得できます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="fdb00-178"><xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A> を実装した場合は `true` を返し、それ以外の場合は false を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="fdb00-179">通常は <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> を単純に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="fdb00-180"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> が `true` の場合、このメソッドを必要に応じて <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> の代わりに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="fdb00-181">次の表に、3 種類の負荷分散パーティショナーで <xref:System.Collections.Concurrent.OrderablePartitioner%601> クラスを実装する方法の詳細を示します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="fdb00-182">メソッド/プロパティ</span><span class="sxs-lookup"><span data-stu-id="fdb00-182">Method/Property</span></span>|<span data-ttu-id="fdb00-183">負荷分散なしの IList/配列</span><span class="sxs-lookup"><span data-stu-id="fdb00-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="fdb00-184">負荷分散ありの IList/配列</span><span class="sxs-lookup"><span data-stu-id="fdb00-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="fdb00-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="fdb00-185">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="fdb00-186">範囲パーティション分割を使用</span><span class="sxs-lookup"><span data-stu-id="fdb00-186">Uses range partitioning</span></span>|<span data-ttu-id="fdb00-187">指定された partitionCount のリストに最適化されたチャンク パーティション分割を使用</span><span class="sxs-lookup"><span data-stu-id="fdb00-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="fdb00-188">静的な数のパーティションを作成することにより、チャンク パーティション分割を使用</span><span class="sxs-lookup"><span data-stu-id="fdb00-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="fdb00-189">サポートしていない機能にアクセスしたときの例外をスロー</span><span class="sxs-lookup"><span data-stu-id="fdb00-189">Throws not-supported exception</span></span>|<span data-ttu-id="fdb00-190">リストおよび動的なパーティションに最適化されたチャンク パーティション分割を使用</span><span class="sxs-lookup"><span data-stu-id="fdb00-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="fdb00-191">動的な数のパーティションを作成することにより、チャンク パーティション分割を使用</span><span class="sxs-lookup"><span data-stu-id="fdb00-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="fdb00-192">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-192">Returns `true`</span></span>|<span data-ttu-id="fdb00-193">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-193">Returns `true`</span></span>|<span data-ttu-id="fdb00-194">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-194">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="fdb00-195">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-195">Returns `true`</span></span>|<span data-ttu-id="fdb00-196">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-196">Returns `false`</span></span>|<span data-ttu-id="fdb00-197">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-197">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="fdb00-198">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-198">Returns `true`</span></span>|<span data-ttu-id="fdb00-199">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-199">Returns `true`</span></span>|<span data-ttu-id="fdb00-200">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-200">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="fdb00-201">`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-201">Returns `false`</span></span>|<span data-ttu-id="fdb00-202">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-202">Returns `true`</span></span>|<span data-ttu-id="fdb00-203">`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-203">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="fdb00-204">動的パーティション</span><span class="sxs-lookup"><span data-stu-id="fdb00-204">Dynamic Partitions</span></span>

<span data-ttu-id="fdb00-205">パーティショナーを <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドで使用する場合、動的な数のパーティションを返すことができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="fdb00-206">これは、パーティショナーがループの実行中の任意の時点で、新しいパーティションの列挙子をオンデマンドで供給できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="fdb00-207">基本的に、ループで新しい並列タスクを追加するたびに、そのタスク用の新しいパーティションが要求されます。</span><span class="sxs-lookup"><span data-stu-id="fdb00-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="fdb00-208">データが順序付け可能である必要がある場合は、<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> から派生させて、各パーティション内の各項目に一意のインデックスが割り当てられるようにします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="fdb00-209">詳細および使用例については、[「方法: 動的パーティションを実装する」](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fdb00-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="fdb00-210">パーティショナーのコントラクト</span><span class="sxs-lookup"><span data-stu-id="fdb00-210">Contract for Partitioners</span></span>

<span data-ttu-id="fdb00-211">カスタム パーティショナーを実装するときは、次のガイドラインに従って、PLINQ および TPL 内の <xref:System.Threading.Tasks.Parallel.ForEach%2A> との適切な相互作用を保証します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="fdb00-212"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> が `partitionsCount` に 0 以下の引数を指定して呼び出された場合は、<xref:System.ArgumentOutOfRangeException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="fdb00-213">PLINQ および TPL が 0 と等しい `partitionCount` を渡すことはありませんが、このような場合に備えることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="fdb00-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> および <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> では、常に `partitionsCount` 個のパーティションを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="fdb00-215">パーティショナーがデータを使い果たし、要求された数のパーティションを作成できない場合、このメソッドでは残りのパーティションのそれぞれについて、空の列挙子を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="fdb00-216">それ以外の場合、PLINQ と TPL はいずれも <xref:System.InvalidOperationException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="fdb00-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>、<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>、<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>、<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> では、`null` (Visual Basic では `Nothing`) を返さないようにします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="fdb00-218">返した場合、PLINQ または TPL は <xref:System.InvalidOperationException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="fdb00-219">パーティションを返すメソッドでは、データ ソースを完全かつ一意に列挙できるパーティションを常に返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="fdb00-220">パーティショナーの設計により特別に必要な場合を除いて、データ ソース内の項目が重複したり、スキップされたりすることがないようにします。</span><span class="sxs-lookup"><span data-stu-id="fdb00-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="fdb00-221">この規則に従わないと、出力順序が乱れる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-221">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="fdb00-222">次のブール型の getter では、常に以下の値を正確に返して、出力順序が乱れないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="fdb00-223">`KeysOrderedInEachPartition`: 各パーティションは、昇順のキー インデックスを持つ要素を返します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="fdb00-224">`KeysOrderedAcrossPartitions`: 返されるすべてのパーティションについて、パーティション *i* のキー インデックスは、パーティション *i*-1 のキー インデックスよりも大きくなります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="fdb00-225">`KeysNormalized`: すべてのキー インデックスは、0 から始まりギャップなしで単調に増加します。</span><span class="sxs-lookup"><span data-stu-id="fdb00-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="fdb00-226">どのインデックスも一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-226">All indices must be unique.</span></span> <span data-ttu-id="fdb00-227">インデックスを重複させることはできません。</span><span class="sxs-lookup"><span data-stu-id="fdb00-227">There may not be duplicate indices.</span></span> <span data-ttu-id="fdb00-228">この規則に従わないと、出力順序が乱れる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-228">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="fdb00-229">どのインデックスも負数以外である必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-229">All indices must be nonnegative.</span></span> <span data-ttu-id="fdb00-230">この規則に従わないと、PLINQ または TPL が例外をスローする場合があります。</span><span class="sxs-lookup"><span data-stu-id="fdb00-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="fdb00-231">参照</span><span class="sxs-lookup"><span data-stu-id="fdb00-231">See also</span></span>

- [<span data-ttu-id="fdb00-232">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="fdb00-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="fdb00-233">方法: 動的パーティションを実装する</span><span class="sxs-lookup"><span data-stu-id="fdb00-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="fdb00-234">方法: 静的パーティション分割用にパーティショナーを実装する</span><span class="sxs-lookup"><span data-stu-id="fdb00-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
