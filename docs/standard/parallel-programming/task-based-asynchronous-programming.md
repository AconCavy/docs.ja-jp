---
title: タスク ベースの非同期プログラミング - .NET
description: この記事では、.NET のタスク並列ライブラリ (TPL) を使用した、タスクベースの非同期プログラミングについて説明します。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: d735cb56c5914dd33ba694c95a8e92446ca47088
ms.sourcegitcommit: 6d09ae36acba0b0e2ba47999f8f1a725795462a2
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/29/2020
ms.locfileid: "92925247"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="1b029-103">タスク ベースの非同期プログラミング</span><span class="sxs-lookup"><span data-stu-id="1b029-103">Task-based asynchronous programming</span></span>

<span data-ttu-id="1b029-104">タスク並列ライブラリ (TPL) は、非同期操作を表す *タスク* の概念に基づいています。</span><span class="sxs-lookup"><span data-stu-id="1b029-104">The Task Parallel Library (TPL) is based on the concept of a *task* , which represents an asynchronous operation.</span></span> <span data-ttu-id="1b029-105">いくつかの点で、タスクはスレッドまたは <xref:System.Threading.ThreadPool> 作業項目に似ていますが、高いレベルで抽象化しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-105">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="1b029-106">*タスクの並列化* とは、1 つ以上の独立したタスクを同時に実行することです。</span><span class="sxs-lookup"><span data-stu-id="1b029-106">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="1b029-107">タスクが提供する主な利点は次の 2 つです。</span><span class="sxs-lookup"><span data-stu-id="1b029-107">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="1b029-108">システム リソースをより効率的かつスケーラブルに利用する。</span><span class="sxs-lookup"><span data-stu-id="1b029-108">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="1b029-109">背後では、タスクは <xref:System.Threading.ThreadPool> へのキューとして配置されます。これはスレッド数を判別および調整し、負荷分散によってスループットを最大化する、アルゴリズムを使用して強化されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-109">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="1b029-110">これによりタスクが比較的軽量化されるため、多数のタスクを作成して粒度の高い並列化を実現できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-110">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="1b029-111">スレッドまたは作業項目より、プログラムによる制御を詳細に行うことができる。</span><span class="sxs-lookup"><span data-stu-id="1b029-111">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="1b029-112">タスクおよびタスクを中心に構築されたフレームワークでは、待機、キャンセル、継続、信頼性の高い例外処理、詳細なステータス、カスタムのスケジュール設定などをサポートする豊富な API が用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-112">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="1b029-113">この 2 つの理由により、.NET でマルチスレッド、非同期および並列コードを記述する場合に推奨される API は TPL になります。</span><span class="sxs-lookup"><span data-stu-id="1b029-113">For both of these reasons, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code in .NET.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="1b029-114">暗黙的なタスクの作成と実行</span><span class="sxs-lookup"><span data-stu-id="1b029-114">Creating and running tasks implicitly</span></span>

<span data-ttu-id="1b029-115"><xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> メソッドには、任意の数のステートメントを同時に実行する便利な方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-115">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="1b029-116">作業項目ごとに <xref:System.Action> デリゲートに渡すだけです。</span><span class="sxs-lookup"><span data-stu-id="1b029-116">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="1b029-117">これらのデリゲートを最も簡単に作成するには、ラムダ式を使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-117">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="1b029-118">ラムダ式では、名前付きメソッドを呼び出したり、コード インラインを指定したりできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-118">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="1b029-119">次の例では、2 つのタスクを同時に作成および開始する基本の <xref:System.Threading.Tasks.Parallel.Invoke%2A> 呼び出しを示しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-119">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="1b029-120">最初のタスクは `DoSomeWork` という名のメソッドを呼び出すラムダ式によって表され、2 番目のタスクは `DoSomeOtherWork` という名のメソッドを呼び出すラムダ式によって表されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-120">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="1b029-121">ここでは、ラムダ式を使用して TPL でデリゲートを定義します。</span><span class="sxs-lookup"><span data-stu-id="1b029-121">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="1b029-122">C# または Visual Basic のラムダ式についての情報が必要な場合は、「[Lambda Expressions in PLINQ and TPL (PLINQ および TPL のラムダ式)](lambda-expressions-in-plinq-and-tpl.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-122">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="1b029-123"><xref:System.Threading.Tasks.Task> によって背後で作成される <xref:System.Threading.Tasks.Parallel.Invoke%2A> インスタンスの数は、指定するデリゲートの数と等しくなくてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="1b029-123">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="1b029-124">TPL では、特に多数のデリゲートによるさまざまな最適化方法を採用しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-124">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="1b029-125">詳細については、[Parallel.Invoke を使用して並列操作を実行する](how-to-use-parallel-invoke-to-execute-parallel-operations.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-125">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="1b029-126">タスクの実行をさらに制御する場合、またはタスクから値を返す場合、<xref:System.Threading.Tasks.Task> オブジェクトをより明示的に操作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-126">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="1b029-127">明示的なタスクの作成と実行</span><span class="sxs-lookup"><span data-stu-id="1b029-127">Creating and running tasks explicitly</span></span>

<span data-ttu-id="1b029-128">値を返さないタスクは、<xref:System.Threading.Tasks.Task?displayProperty=nameWithType> クラスによって表されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-128">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="1b029-129">値を返すタスクは、<xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> から継承された <xref:System.Threading.Tasks.Task> クラスで表されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-129">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1b029-130">タスク オブジェクトはインフラストラクチャの詳細を処理し、タスクの有効期間内に呼び出し元のスレッドからアクセスできるメソッドとプロパティを提供します。</span><span class="sxs-lookup"><span data-stu-id="1b029-130">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="1b029-131">たとえば、タスクの <xref:System.Threading.Tasks.Task.Status%2A> プロパティに任意のタイミングでアクセスして、タスクが開始されたか、完了まで実行されたか、取り消されたか、または例外がスローされたかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-131">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="1b029-132">状態は、<xref:System.Threading.Tasks.TaskStatus> 列挙型によって表されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-132">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="1b029-133">タスクを作成するときは、タスクが実行するコードをカプセル化するユーザー デリゲートを指定します。</span><span class="sxs-lookup"><span data-stu-id="1b029-133">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="1b029-134">このデリゲートは名前付きデリゲート、匿名メソッド、またはラムダ式として表すことができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-134">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="1b029-135">ラムダ式には、次の例で示すような名前付きメソッドへの呼び出しを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-135">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="1b029-136">この例は <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドの呼び出しを含み、コンソール モードのアプリケーションが終了する前にタスクの実行が完了するようにしていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-136">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="1b029-137"><xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> メソッドを使用して、一度の操作でタスクを作成および開始することもできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-137">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="1b029-138">タスクを管理するため、<xref:System.Threading.Tasks.Task.Run%2A> メソッドは、現在のスレッドに関連付けられたタスク スケジューラにかかわらず、既定のタスク スケジューラを使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-138">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="1b029-139"><xref:System.Threading.Tasks.Task.Run%2A> メソッドは、タスクの作成とスケジュールの詳細な制御が必要ない場合に、タスクを作成および開始するために適しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-139">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="1b029-140"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> メソッドを使用して、一度の操作でタスクを作成および開始することもできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-140">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="1b029-141">次の例に示すように、作成とスケジュール設定を分ける必要がない場合、追加のタスク作成オプションまたは特定のスケジューラを使う必要がある場合、または <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> プロパティを使用して取得できるタスクに追加の状態を渡す必要がある場合は、このメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-141">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="1b029-142"><xref:System.Threading.Tasks.Task> および <xref:System.Threading.Tasks.Task%601> はそれぞれ、<xref:System.Threading.Tasks.Task.Factory%2A> の既定のインスタンスを返す、静的な <xref:System.Threading.Tasks.TaskFactory> プロパティを公開するので、メソッドを `Task.Factory.StartNew()` として呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-142"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="1b029-143">また、次の例のタスクは <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 型であるため、それぞれのタスクは計算の結果を格納するパブリックな <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティを持ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-143">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="1b029-144">タスクは非同期に実行され、任意の順序で完了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="1b029-144">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="1b029-145">計算が終了する前に <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティにアクセスした場合、このプロパティは値が使用可能な状態になるまで呼び出しスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="1b029-145">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="1b029-146">詳細については、[タスクから値を返す](how-to-return-a-value-from-a-task.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-146">For more information, see [How to: Return a Value from a Task](how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="1b029-147">ラムダ式を使用してデリゲートを作成すると、ソース コード内の該当ポイントで参照できるすべての変数にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-147">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="1b029-148">ただし、特にループ内では、ラムダによって変数が予想どおりにキャプチャされない場合があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-148">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="1b029-149">ラムダでは、反復処理が実行されるたびに変更された値をキャプチャするのではなく、最終値だけがキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="1b029-149">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="1b029-150">この問題を説明する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1b029-150">The following example illustrates the problem.</span></span> <span data-ttu-id="1b029-151">これは `CustomData` オブジェクトをインスタンス化するラムダ式にループ カウンターを渡し、オブジェクトの識別子としてループ カウンターを使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-151">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="1b029-152">この例の出力結果が示すように、`CustomData` の各オブジェクトは同じ識別子を持ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-152">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="1b029-153">反復処理が実行されるたびに値にアクセスできるようにするには、コンストラクターによって状態オブジェクトをタスクに提供します。</span><span class="sxs-lookup"><span data-stu-id="1b029-153">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="1b029-154">次の例では、ラムダ式に渡される `CustomData` オブジェクトを作成するときに、ループ カウンターを使用して前の例を変更しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-154">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="1b029-155">この例の出力結果が示すように、`CustomData` の各オブジェクトは、オブジェクトがインスタンス化されたときのループ カウンターの値に基づいて、一意の識別子を持ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-155">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="1b029-156">この状態は、タスク デリゲートに引数として渡されます。<xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> プロパティを使用することで、タスク オブジェクトから状態にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-156">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="1b029-157">次の例は、前の例を変更したものです。</span><span class="sxs-lookup"><span data-stu-id="1b029-157">The following example is a variation on the previous example.</span></span> <span data-ttu-id="1b029-158"><xref:System.Threading.Tasks.Task.AsyncState%2A> プロパティを使用して、ラムダ式に渡される `CustomData` オブジェクトに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="1b029-158">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="1b029-159">タスク ID</span><span class="sxs-lookup"><span data-stu-id="1b029-159">Task ID</span></span>

<span data-ttu-id="1b029-160">各タスクは、アプリケーション ドメイン内で一意に識別され、<xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> プロパティを使用してアクセスできる整数の ID を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="1b029-160">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1b029-161">この ID は、Visual Studio デバッガーの **[並列スタック]** ウィンドウおよび **[タスク]** ウィンドウでタスク情報を確認する場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-161">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="1b029-162">この ID は ID が要求されるまでは作成されません。したがって、タスクの ID はプログラムが実行されるたびに異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-162">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="1b029-163">デバッガーでタスク ID を表示する方法の詳細については、「[[タスク] ウィンドウの使用](/visualstudio/debugger/using-the-tasks-window)」と「[[並列スタック] ウィンドウの使用](/visualstudio/debugger/using-the-parallel-stacks-window)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-163">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="1b029-164">タスクの作成オプション</span><span class="sxs-lookup"><span data-stu-id="1b029-164">Task creation options</span></span>

<span data-ttu-id="1b029-165">タスクを作成するほとんどの API には、<xref:System.Threading.Tasks.TaskCreationOptions> パラメーターを受け入れるオーバーロードが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-165">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="1b029-166">これらのオプションを 1 つ以上指定すると、タスク スケジューラにスレッド プール上のタスクをスケジュールする方法を指定できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-166">By specifying one or more of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="1b029-167">ビット **OR** 演算を使用して、オプションを組み合わせることもできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-167">Options may be combined by using a bitwise **OR** operation.</span></span>

<span data-ttu-id="1b029-168">次の例は、<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> および <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> オプションが指定されたタスクを示しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-168">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> options.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="1b029-169">タスク、スレッド、およびカルチャ</span><span class="sxs-lookup"><span data-stu-id="1b029-169">Tasks, threads, and culture</span></span>

<span data-ttu-id="1b029-170">各スレッドには、それぞれのカルチャが <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> および <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティで定義された、カルチャと UI カルチャが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="1b029-170">Each thread has an associated culture and UI culture, which are defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="1b029-171">スレッドのカルチャは、書式設定、解析、並べ替え、文字列比較などの操作で使用されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-171">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="1b029-172">スレッドの UI カルチャはリソースの検索で使用されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-172">A thread's UI culture is used in resource lookup.</span></span>

<span data-ttu-id="1b029-173"><xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> および <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> プロパティを使用してアプリケーション ドメイン内のすべてのスレッドに既定のカルチャを指定していない限り、スレッドの既定のカルチャと UI カルチャはシステム カルチャで定義されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-173">Unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="1b029-174">スレッドのカルチャを明示的に設定して新しいスレッドを開始すると、新しいスレッドは呼び出し元スレッドのカルチャを継承せず、既定のシステム カルチャがそのカルチャとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-174">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="1b029-175">ただし、タスクベースのプログラミングでは、タスクが別のスレッドで非同期で実行される場合でも、呼び出し元スレッドのカルチャが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-175">However, in task-based programming, tasks use the calling thread's culture, even if the task runs asynchronously on a different thread.</span></span>

<span data-ttu-id="1b029-176">簡単な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="1b029-176">The following example provides a simple illustration.</span></span> <span data-ttu-id="1b029-177">アプリの現在のカルチャがフランス語 (フランス) に変更されます (現在のカルチャがフランス語 (フランス) である場合、英語 (米国) に変更されます)。</span><span class="sxs-lookup"><span data-stu-id="1b029-177">It changes the app's current culture to French (France) (or, if French (France) is already the current culture, to English (United States)).</span></span> <span data-ttu-id="1b029-178">次に、変更後のカルチャの通貨値として書式設定された数値を返す `formatDelegate` という名前のデリゲートを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1b029-178">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="1b029-179">デリゲートがタスクによって同期的にまたは非同期的に呼び出されるかどうかに関わらず、タスクにより呼び出し元スレッドのカルチャが使用されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-179">Whether the delegate is invoked by a task either synchronously or asynchronously, the task uses the culture of the calling thread.</span></span>

:::code language="csharp" source="snippets/cs/asyncculture1.cs" id="1":::

:::code language="vbnet" source="snippets/vb/asyncculture1.vb" id="1":::

> [!NOTE]
> <span data-ttu-id="1b029-180">.NET Framework 4.6 より前の .NET Framework のバージョンでは、タスクのカルチャは、" *呼び出し元スレッド* " のカルチャではなく、" *実行されている* " スレッドのそれによって決定されていました。</span><span class="sxs-lookup"><span data-stu-id="1b029-180">In versions of .NET Framework prior to .NET Framework 4.6, a task's culture is determined by the culture of the thread on which it *runs* , not the culture of the *calling thread*.</span></span> <span data-ttu-id="1b029-181">これは非同期タスクの場合、タスクが使用するカルチャは、呼び出し元スレッドのカルチャと異なる可能性があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1b029-181">For asynchronous tasks, this means the culture used by the task could be different to the calling thread's culture.</span></span>

<span data-ttu-id="1b029-182">非同期タスクとカルチャの詳細については、「<xref:System.Globalization.CultureInfo>」トピックの「カルチャおよび非同期タスク ベースの操作」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-182">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="1b029-183">タスクの継続の作成</span><span class="sxs-lookup"><span data-stu-id="1b029-183">Creating task continuations</span></span>

<span data-ttu-id="1b029-184"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> メソッドおよび <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> メソッドで、" *継続元タスク* " が終了したときに開始されるタスクを指定できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-184">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="1b029-185">継続タスクのデリゲートは継続元タスクへの参照を渡し、継続元タスクのステータスを調査できるようにし、また <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> プロパティの値を取得して、継続元の出力を継続への入力として使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="1b029-185">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="1b029-186">次の例では、`getData` タスクは <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> メソッドの呼び出しによって開始されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-186">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1b029-187">`processData` タスクは `getData` が終了したときに自動的に開始され、`displayData` は `processData` が終了したときに開始されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-187">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="1b029-188">`getData` は、`processData` タスクの `getData` プロパティを使用して <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> タスクがアクセス可能な、整数の配列を生成します。</span><span class="sxs-lookup"><span data-stu-id="1b029-188">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1b029-189">`processData` タスクはその配列を処理し、<xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> メソッドに渡されるラムダ式の戻り値の型から推論される型を持つ結果を返します。</span><span class="sxs-lookup"><span data-stu-id="1b029-189">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1b029-190">`displayData` タスクは、`processData` が終了したときに自動的に実行され、<xref:System.Tuple%603> ラムダ式が返した `processData` オブジェクトは、`displayData` タスクの `processData` プロパティを使用して、<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> タスクからアクセス可能です。</span><span class="sxs-lookup"><span data-stu-id="1b029-190">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1b029-191">`displayData` タスクは `processData` タスクから結果を受け取り、同様の方法を使用して (プログラムで使用できるようになったと) 推論される型を持つ結果を <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティで生成します。</span><span class="sxs-lookup"><span data-stu-id="1b029-191">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="1b029-192"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> がインスタンス メソッドであるため、<xref:System.Threading.Tasks.Task%601> のオブジェクトをそれぞれの継続元タスクにインスタンス化する代わりに、メソッド呼び出しを連結することができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-192">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="1b029-193">次の例は前の例と機能的には同じものですが、呼び出しを <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> メソッドに連結している点が異なります。</span><span class="sxs-lookup"><span data-stu-id="1b029-193">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1b029-194">メソッドの呼び出しチェーンによって返される <xref:System.Threading.Tasks.Task%601> オブジェクトが最終的な継続タスクであることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-194">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="1b029-195"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドおよび <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> メソッドを使用すると、複数のタスクから継続できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-195">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="1b029-196">詳細については、「[継続タスクを使用したタスクの連結](chaining-tasks-by-using-continuation-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-196">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="1b029-197">デタッチされた子タスクの作成</span><span class="sxs-lookup"><span data-stu-id="1b029-197">Creating detached child tasks</span></span>

<span data-ttu-id="1b029-198">タスクで実行中のユーザー コードで新しいタスクを作成し、<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> オプションを指定しない場合、新しいタスクはどのような方法でも親タスクとは同期されません。</span><span class="sxs-lookup"><span data-stu-id="1b029-198">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="1b029-199">非同期タスクのこの型は、 *デタッチされた入れ子のタスク* 、または *デタッチされた子タスク* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="1b029-199">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="1b029-200">次の例は、デタッチされた子タスクを 1 つ作成するタスクを示しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-200">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="1b029-201">親タスクはデタッチされた子タスクの終了を待機しないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-201">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="1b029-202">子タスクの作成</span><span class="sxs-lookup"><span data-stu-id="1b029-202">Creating child tasks</span></span>

<span data-ttu-id="1b029-203">タスクで実行中のユーザー コードで <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> オプションを使用してタスクが作成されると、その新しいタスクは、親タスクに " *アタッチされた子タスク* " になります。</span><span class="sxs-lookup"><span data-stu-id="1b029-203">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as an *attached child task* of the parent task.</span></span> <span data-ttu-id="1b029-204"><xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> オプションを使用すると、構成されたタスクの並列化を表現できます。親タスクは、すべてのアタッチされた子タスクが終了するのを暗黙的に待機するためです。</span><span class="sxs-lookup"><span data-stu-id="1b029-204">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="1b029-205">次の例は、アタッチされた子タスクを 10 個作成する親タスクを示しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-205">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="1b029-206">この例は <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドを呼び出して親タスクの完了を待機しているが、アタッチされた子タスクの完了を明示的には待機する必要がないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-206">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="1b029-207">親タスクは <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> オプションを使用して、他のタスクが親タスクにアタッチすることを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-207">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="1b029-208">詳細については、「[アタッチされた子タスクとデタッチされた子タスク](attached-and-detached-child-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-208">For more information, see [Attached and Detached Child Tasks](attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="1b029-209">タスクの完了を待機する</span><span class="sxs-lookup"><span data-stu-id="1b029-209">Waiting for tasks to finish</span></span>

<span data-ttu-id="1b029-210"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 型と <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 型には、タスクが終了するまで待機できる <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドのオーバーロードがいくつか用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-210">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="1b029-211">さらに、静的な <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドおよび <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> メソッドのオーバーロードにより、一部またはすべてのタスクの配列が終了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-211">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="1b029-212">通常は、タスクを待機するのは次のいずれかの場合です。</span><span class="sxs-lookup"><span data-stu-id="1b029-212">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="1b029-213">メイン スレッドが、タスクで計算される最終的な結果に依存する。</span><span class="sxs-lookup"><span data-stu-id="1b029-213">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="1b029-214">タスクからスローされる可能性のある例外を処理する必要がある。</span><span class="sxs-lookup"><span data-stu-id="1b029-214">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="1b029-215">アプリケーションは、すべてのタスクが実行を完了する前に終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-215">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="1b029-216">たとえば、コンソール アプリケーションは `Main` (アプリケーションのエントリ ポイント) のすべての同期コードが実行されると、すぐに終了します。</span><span class="sxs-lookup"><span data-stu-id="1b029-216">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="1b029-217">次の例は、例外処理を含まない基本的なパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-217">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="1b029-218">例外処理を示す例については、[例外処理](exception-handling-task-parallel-library.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-218">For an example that shows exception handling, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="1b029-219">タイムアウトを指定できるオーバーロードおよび別の <xref:System.Threading.CancellationToken> を入力パラメーターとして受け取るオーバーロードの中には、プログラムによって、またはユーザーの入力に応答して待機自体を取り消すことができるものがあります。</span><span class="sxs-lookup"><span data-stu-id="1b029-219">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="1b029-220">タスクを待機する場合は、<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> オプションを使用して作成されたタスクのすべての子タスクを暗黙的に待機します。</span><span class="sxs-lookup"><span data-stu-id="1b029-220">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="1b029-221">タスクが既に完了している場合、直ちに <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> が返されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-221"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="1b029-222">タスクで発生した例外は、<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドがタスクの完了後に呼び出された場合でも <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> メソッドによってスローされます。</span><span class="sxs-lookup"><span data-stu-id="1b029-222">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="1b029-223">タスクを構成する</span><span class="sxs-lookup"><span data-stu-id="1b029-223">Composing tasks</span></span>

<span data-ttu-id="1b029-224"><xref:System.Threading.Tasks.Task> と <xref:System.Threading.Tasks.Task%601> クラスは複数のメソッドを提供し、共通のパターンを実装したり、C#、Visual Basic、F# によって提供される非同期言語機能を使うために、複数のタスクを構成したりするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-224">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="1b029-225">このセクションでは <xref:System.Threading.Tasks.Task.WhenAll%2A>、<xref:System.Threading.Tasks.Task.WhenAny%2A>、<xref:System.Threading.Tasks.Task.Delay%2A> および <xref:System.Threading.Tasks.Task.FromResult%2A> メソッドについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-225">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="1b029-226">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="1b029-226">Task.WhenAll</span></span>

<span data-ttu-id="1b029-227"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> メソッドは、複数の <xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> オブジェクトが終了するのを、非同期的に待機します。</span><span class="sxs-lookup"><span data-stu-id="1b029-227">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="1b029-228">提供されるオーバーロード バージョンにより、不均一なタスクのセットを待機することができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-228">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="1b029-229">たとえば、1 回のメソッド呼び出しで完了する、複数の <xref:System.Threading.Tasks.Task> および <xref:System.Threading.Tasks.Task%601> オブジェクトを待機できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-229">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="1b029-230">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="1b029-230">Task.WhenAny</span></span>

<span data-ttu-id="1b029-231"><xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> メソッドは、複数の <xref:System.Threading.Tasks.Task> の 1 つ、または <xref:System.Threading.Tasks.Task%601> オブジェクトが終了するのを、非同期的に待機します。</span><span class="sxs-lookup"><span data-stu-id="1b029-231">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="1b029-232"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> メソッドと同様に、このメソッドはオーバーロード バージョンを提供し、これによって不均一なタスクのセットを待機することができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-232">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="1b029-233"><xref:System.Threading.Tasks.Task.WhenAny%2A> メソッドは、特に次のシナリオに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1b029-233">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="1b029-234">重複した操作。</span><span class="sxs-lookup"><span data-stu-id="1b029-234">Redundant operations.</span></span> <span data-ttu-id="1b029-235">多くの方法で実行できるアルゴリズムまたは操作を検討してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-235">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="1b029-236"><xref:System.Threading.Tasks.Task.WhenAny%2A> メソッドを使用すると、最初の操作を完了して残りの操作を取り消すように、操作を選択できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-236">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="1b029-237">インタリーブされた操作。</span><span class="sxs-lookup"><span data-stu-id="1b029-237">Interleaved operations.</span></span> <span data-ttu-id="1b029-238">複数の操作を開始して、それらの操作のすべてが完了し、各操作が完了したら <xref:System.Threading.Tasks.Task.WhenAny%2A> メソッドを使って結果を処理できるようにします。</span><span class="sxs-lookup"><span data-stu-id="1b029-238">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="1b029-239">1 つの操作が完了したら、1 つ以上の追加タスクを開始できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-239">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="1b029-240">制限された操作。</span><span class="sxs-lookup"><span data-stu-id="1b029-240">Throttled operations.</span></span> <span data-ttu-id="1b029-241"><xref:System.Threading.Tasks.Task.WhenAny%2A> メソッドを使用して、前のシナリオを拡張し、同時操作の数を制限することができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-241">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="1b029-242">有効期限切れの操作。</span><span class="sxs-lookup"><span data-stu-id="1b029-242">Expired operations.</span></span> <span data-ttu-id="1b029-243"><xref:System.Threading.Tasks.Task.WhenAny%2A> メソッドを使うと、1 つ以上のタスクと特定の時間後に終了する 1 つのタスクから選択できます。たとえば、<xref:System.Threading.Tasks.Task.Delay%2A> メソッドが返すタスクなどです。</span><span class="sxs-lookup"><span data-stu-id="1b029-243">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="1b029-244"><xref:System.Threading.Tasks.Task.Delay%2A> メソッドについては、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-244">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="1b029-245">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="1b029-245">Task.Delay</span></span>

<span data-ttu-id="1b029-246"><xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> メソッドは、指定時間後に終了する <xref:System.Threading.Tasks.Task> オブジェクトを生成します。</span><span class="sxs-lookup"><span data-stu-id="1b029-246">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="1b029-247">このメソッドを使用すると、データのポーリングをときどき行うループをビルドしたり、タイムアウトを使用したり、ユーザー入力の処理を遅延させたりすることができます。</span><span class="sxs-lookup"><span data-stu-id="1b029-247">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="1b029-248">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="1b029-248">Task(T).FromResult</span></span>

<span data-ttu-id="1b029-249"><xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> メソッドを使用すると、あらかじめ計算された結果を保持する <xref:System.Threading.Tasks.Task%601> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-249">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="1b029-250">このメソッドは <xref:System.Threading.Tasks.Task%601> オブジェクトの結果があらかじめ計算されている <xref:System.Threading.Tasks.Task%601> オブジェクトを返す、非同期操作を実行する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="1b029-250">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="1b029-251">キャッシュに保持されている非同期ダウンロード操作の結果を取得する <xref:System.Threading.Tasks.Task.FromResult%2A> の使用例の詳細については、「[方法:事前計算済みのタスクを作成する](how-to-create-pre-computed-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-251">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="1b029-252">タスクでの例外処理</span><span class="sxs-lookup"><span data-stu-id="1b029-252">Handling exceptions in tasks</span></span>

<span data-ttu-id="1b029-253">タスクで 1 つ以上の例外がスローされると、例外は <xref:System.AggregateException> 例外でラップされます。</span><span class="sxs-lookup"><span data-stu-id="1b029-253">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="1b029-254">例外はタスクに連結されたスレッドに反映されます。通常は、タスクの終了を待機しているスレッドか、または <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティにアクセスするスレッドです。</span><span class="sxs-lookup"><span data-stu-id="1b029-254">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="1b029-255">この動作では、.NET Framework ポリシーが適用され、既定ではすべてのハンドルされない例外によってプロセスが終了されます。</span><span class="sxs-lookup"><span data-stu-id="1b029-255">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="1b029-256">呼び出し元のコードは `try`/`catch` ブロックで、次のいずれかを使用して、例外を処理できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-256">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="1b029-257"><xref:System.Threading.Tasks.Task.Wait%2A> メソッド</span><span class="sxs-lookup"><span data-stu-id="1b029-257">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="1b029-258"><xref:System.Threading.Tasks.Task.WaitAll%2A> メソッド</span><span class="sxs-lookup"><span data-stu-id="1b029-258">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="1b029-259"><xref:System.Threading.Tasks.Task.WaitAny%2A> メソッド</span><span class="sxs-lookup"><span data-stu-id="1b029-259">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="1b029-260"><xref:System.Threading.Tasks.Task%601.Result%2A> プロパティ</span><span class="sxs-lookup"><span data-stu-id="1b029-260">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="1b029-261">連結しているスレッドでも、タスクがガベージ コレクトされる前に <xref:System.Threading.Tasks.Task.Exception%2A> プロパティにアクセスすることで例外を処理できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-261">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="1b029-262">このプロパティにアクセスすると、ハンドルされない例外が、オブジェクトが最終処理されたときにプロセスを終了する例外の反映動作をトリガーしないようにできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-262">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="1b029-263">例外とタスクの詳細については、[例外処理](exception-handling-task-parallel-library.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-263">For more information about exceptions and tasks, see [Exception Handling](exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="1b029-264">タスクの取り消し</span><span class="sxs-lookup"><span data-stu-id="1b029-264">Canceling tasks</span></span>

<span data-ttu-id="1b029-265"><xref:System.Threading.Tasks.Task> クラスは他の処理と連携したキャンセル処理をサポートしており、.NET Framework 4 で導入された <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> クラスおよび <xref:System.Threading.CancellationToken?displayProperty=nameWithType> クラスと完全に統合されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-265">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="1b029-266"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> クラスの多くのコンストラクターは、<xref:System.Threading.CancellationToken> オブジェクトを入力パラメーターとして受け取ります。</span><span class="sxs-lookup"><span data-stu-id="1b029-266">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="1b029-267"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A> および <xref:System.Threading.Tasks.Task.Run%2A> オーバーロードの多くも、<xref:System.Threading.CancellationToken> パラメーターを含みます。</span><span class="sxs-lookup"><span data-stu-id="1b029-267">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="1b029-268"><xref:System.Threading.CancellationTokenSource> クラスを使用すると、トークンを作成し、後でキャンセル要求を発行できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-268">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="1b029-269">このトークンを <xref:System.Threading.Tasks.Task> に引数として渡し、同じトークンをキャンセル要求に応答するユーザー デリゲートで参照します。</span><span class="sxs-lookup"><span data-stu-id="1b029-269">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="1b029-270">詳細については、「[タスクのキャンセル](task-cancellation.md)」と「[方法:タスクとその子を取り消す](how-to-cancel-a-task-and-its-children.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-270">For more information, see [Task Cancellation](task-cancellation.md) and [How to: Cancel a Task and Its Children](how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="1b029-271">TaskFactory クラス</span><span class="sxs-lookup"><span data-stu-id="1b029-271">The TaskFactory class</span></span>

<span data-ttu-id="1b029-272"><xref:System.Threading.Tasks.TaskFactory> クラスには、タスクおよび継続タスクの作成と開始について、一般的なパターンをカプセル化する静的メソッドが用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-272">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="1b029-273">最も一般的なパターンは、1 つのステートメントで 1 つのタスクを作成および開始する <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> です。</span><span class="sxs-lookup"><span data-stu-id="1b029-273">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="1b029-274">複数の継続元から継続タスクを作成する場合は、<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドまたは <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> メソッドを使用するか、<xref:System.Threading.Tasks.Task%601> クラスの同等のメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-274">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="1b029-275">詳細については、「[継続タスクを使用したタスクの連結](chaining-tasks-by-using-continuation-tasks.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-275">For more information, see [Chaining Tasks by Using Continuation Tasks](chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="1b029-276">`BeginX` インスタンスまたは `EndX` インスタンスで非同期プログラミング モデルの <xref:System.Threading.Tasks.Task> メソッドおよび <xref:System.Threading.Tasks.Task%601> メソッドをカプセル化するには、<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="1b029-276">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="1b029-277">詳細については、「[TPL と従来の .NET Framework 非同期プログラミング](tpl-and-traditional-async-programming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-277">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="1b029-278">既定の <xref:System.Threading.Tasks.TaskFactory> へは、<xref:System.Threading.Tasks.Task> クラスまたは <xref:System.Threading.Tasks.Task%601> クラス上の静的なプロパティとしてアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-278">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="1b029-279"><xref:System.Threading.Tasks.TaskFactory> を直接インスタンス化し、さまざまなオプションを指定することもできます。たとえば、<xref:System.Threading.CancellationToken>、<xref:System.Threading.Tasks.TaskCreationOptions> オプション、<xref:System.Threading.Tasks.TaskContinuationOptions> オプション、<xref:System.Threading.Tasks.TaskScheduler> などです。</span><span class="sxs-lookup"><span data-stu-id="1b029-279">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="1b029-280">タスク ファクトリを作成するときに指定されるオプションは、タスク ファクトリで作成したすべてのタスクに適用されます。ただし、<xref:System.Threading.Tasks.Task> が <xref:System.Threading.Tasks.TaskCreationOptions> 列挙型を使用して作成された場合は例外で、タスクのオプションによってタスク ファクトリのオプションがオーバーライドされます。</span><span class="sxs-lookup"><span data-stu-id="1b029-280">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="1b029-281">デリゲートなしのタスク</span><span class="sxs-lookup"><span data-stu-id="1b029-281">Tasks without delegates</span></span>

<span data-ttu-id="1b029-282"><xref:System.Threading.Tasks.Task> を使用して、固有のユーザー デリゲートではなく外部コンポーネントによって実行される非同期操作をカプセル化する場合があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-282">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="1b029-283">操作が非同期プログラミング モデルの Begin/End パターンに基づいている場合、<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1b029-283">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="1b029-284">そうでない場合は、<xref:System.Threading.Tasks.TaskCompletionSource%601> オブジェクトを使用して、タスク内の操作をラップして、<xref:System.Threading.Tasks.Task> を外部からプログラミング可能にする利点を活用できます。たとえば、例外の反映および継続のサポートです。</span><span class="sxs-lookup"><span data-stu-id="1b029-284">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="1b029-285">詳細については、「<xref:System.Threading.Tasks.TaskCompletionSource%601>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-285">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="1b029-286">カスタム スケジューラ</span><span class="sxs-lookup"><span data-stu-id="1b029-286">Custom schedulers</span></span>

<span data-ttu-id="1b029-287">アプリケーションまたはライブラリのほとんどの開発者は、タスクを実行するプロセッサ、他のタスクと動作を同期する方法、<xref:System.Threading.ThreadPool?displayProperty=nameWithType> でスケジュールする方法などについては気にしません。</span><span class="sxs-lookup"><span data-stu-id="1b029-287">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b029-288">気にするのは、ホスト コンピューター上でできるだけ効率的に実行することだけです。</span><span class="sxs-lookup"><span data-stu-id="1b029-288">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="1b029-289">スケジュールの詳細についてより詳細に制御する必要がある場合、タスク並列ライブラリでは、既定のタスク スケジューラの設定を構成でき、さらにカスタム スケジューラを利用することもできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-289">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="1b029-290">詳細については、「<xref:System.Threading.Tasks.TaskScheduler>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-290">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="1b029-291">関連のデータ構造</span><span class="sxs-lookup"><span data-stu-id="1b029-291">Related data structures</span></span>

<span data-ttu-id="1b029-292">TPL には、並列のシナリオおよび順次的なシナリオの両方に役立つ複数の新しいパブリック型があります。</span><span class="sxs-lookup"><span data-stu-id="1b029-292">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="1b029-293">これらの型には、<xref:System.Collections.Concurrent?displayProperty=nameWithType> 名前空間における、スレッド セーフで、高速、スケーラブルなコレクション クラス、および新しい同期の型が含まれます。たとえば、<xref:System.Threading.Semaphore?displayProperty=nameWithType> および <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> は、特定の種類の作業負荷に関しては、先行タスクより効率的です。</span><span class="sxs-lookup"><span data-stu-id="1b029-293">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="1b029-294">その他の .NET Framework 4 の新しい型には、<xref:System.Threading.Barrier?displayProperty=nameWithType> と <xref:System.Threading.SpinLock?displayProperty=nameWithType> があり、以前のリリースでは利用できなかった機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="1b029-294">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="1b029-295">詳細については、「[並列プログラミング向けのデータ構造](data-structures-for-parallel-programming.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-295">For more information, see [Data Structures for Parallel Programming](data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="1b029-296">カスタムのタスクの型</span><span class="sxs-lookup"><span data-stu-id="1b029-296">Custom task types</span></span>

<span data-ttu-id="1b029-297"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> または <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> から継承しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1b029-297">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b029-298">代わりに、<xref:System.Threading.Tasks.Task.AsyncState%2A> プロパティを使用して、追加のデータまたは状態を <xref:System.Threading.Tasks.Task> オブジェクトまたは <xref:System.Threading.Tasks.Task%601> オブジェクトに関連付けることをおすすめします。</span><span class="sxs-lookup"><span data-stu-id="1b029-298">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="1b029-299">拡張メソッドを使用して、<xref:System.Threading.Tasks.Task> クラスおよび <xref:System.Threading.Tasks.Task%601> クラスの機能を拡張することもできます。</span><span class="sxs-lookup"><span data-stu-id="1b029-299">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="1b029-300">拡張メソッドの詳細については、[拡張メソッド (C# プログラミングガイド)](../../csharp/programming-guide/classes-and-structs/extension-methods.md) と[拡張メソッド (Visual Basic)](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md) に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1b029-300">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="1b029-301"><xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> から継承する必要がある場合、<xref:System.Threading.Tasks.Task.Run%2A>、<xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>、<xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>、<xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> の各クラスを使用して、カスタムのタスクの型のインスタンスを作成することはできません。これらのクラスで作成されるのは、<xref:System.Threading.Tasks.Task> および <xref:System.Threading.Tasks.Task%601> オブジェクトだけであるためです。</span><span class="sxs-lookup"><span data-stu-id="1b029-301">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="1b029-302">また、<xref:System.Threading.Tasks.Task>、<xref:System.Threading.Tasks.Task%601>、<xref:System.Threading.Tasks.TaskFactory>、および <xref:System.Threading.Tasks.TaskFactory%601> で提供されるタスク継続機構でも、<xref:System.Threading.Tasks.Task> オブジェクトと <xref:System.Threading.Tasks.Task%601> オブジェクトしか作成されないため、これらの機構を使用してカスタムのタスクの型のインスタンスを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="1b029-302">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1b029-303">関連トピック</span><span class="sxs-lookup"><span data-stu-id="1b029-303">Related topics</span></span>

|<span data-ttu-id="1b029-304">Title</span><span class="sxs-lookup"><span data-stu-id="1b029-304">Title</span></span>|<span data-ttu-id="1b029-305">説明</span><span class="sxs-lookup"><span data-stu-id="1b029-305">Description</span></span>|
|-|-|
|[<span data-ttu-id="1b029-306">継続タスクを使用したタスクの連結</span><span class="sxs-lookup"><span data-stu-id="1b029-306">Chaining Tasks by Using Continuation Tasks</span></span>](chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="1b029-307">継続の機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-307">Describes how continuations work.</span></span>|
|[<span data-ttu-id="1b029-308">アタッチされた子タスクとデタッチされた子タスク</span><span class="sxs-lookup"><span data-stu-id="1b029-308">Attached and Detached Child Tasks</span></span>](attached-and-detached-child-tasks.md)|<span data-ttu-id="1b029-309">アタッチされた子タスクとデタッチされた子タスクの違いについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-309">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="1b029-310">タスクのキャンセル</span><span class="sxs-lookup"><span data-stu-id="1b029-310">Task Cancellation</span></span>](task-cancellation.md)|<span data-ttu-id="1b029-311"><xref:System.Threading.Tasks.Task> オブジェクトに組み込まれているキャンセルのサポートについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-311">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="1b029-312">例外処理</span><span class="sxs-lookup"><span data-stu-id="1b029-312">Exception Handling</span></span>](exception-handling-task-parallel-library.md)|<span data-ttu-id="1b029-313">同時実行スレッド上の例外を処理する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-313">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="1b029-314">方法: Parallel.Invoke を使用して並列操作を実行する</span><span class="sxs-lookup"><span data-stu-id="1b029-314">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="1b029-315"><xref:System.Threading.Tasks.Parallel.Invoke%2A> の使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-315">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="1b029-316">方法: タスクから値を返す</span><span class="sxs-lookup"><span data-stu-id="1b029-316">How to: Return a Value from a Task</span></span>](how-to-return-a-value-from-a-task.md)|<span data-ttu-id="1b029-317">タスクから値を返す方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-317">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="1b029-318">方法: タスクとその子を取り消す</span><span class="sxs-lookup"><span data-stu-id="1b029-318">How to: Cancel a Task and Its Children</span></span>](how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="1b029-319">タスクを取り消す方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-319">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="1b029-320">方法: 事前計算済みのタスクを作成する</span><span class="sxs-lookup"><span data-stu-id="1b029-320">How to: Create Pre-Computed Tasks</span></span>](how-to-create-pre-computed-tasks.md)|<span data-ttu-id="1b029-321">キャッシュに保持されている非同期ダウンロード操作の結果を取得する <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> メソッドの使用例の詳細について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-321">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="1b029-322">方法: 並列タスクでバイナリ ツリーを走査する</span><span class="sxs-lookup"><span data-stu-id="1b029-322">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="1b029-323">タスクを使用してバイナリ ツリーを走査する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-323">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="1b029-324">方法: 入れ子のタスクのラップを解除する</span><span class="sxs-lookup"><span data-stu-id="1b029-324">How to: Unwrap a Nested Task</span></span>](how-to-unwrap-a-nested-task.md)|<span data-ttu-id="1b029-325"><xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> 拡張メソッドの使用方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="1b029-325">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="1b029-326">データの並列化</span><span class="sxs-lookup"><span data-stu-id="1b029-326">Data Parallelism</span></span>](data-parallelism-task-parallel-library.md)|<span data-ttu-id="1b029-327"><xref:System.Threading.Tasks.Parallel.For%2A> および <xref:System.Threading.Tasks.Parallel.ForEach%2A> を使用してデータを対象に並列ループを作成する方法について説明しています。</span><span class="sxs-lookup"><span data-stu-id="1b029-327">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="1b029-328">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="1b029-328">Parallel Programming</span></span>](index.md)|<span data-ttu-id="1b029-329">.NET Framework 並列プログラミングのトップ レベル ノード。</span><span class="sxs-lookup"><span data-stu-id="1b029-329">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="1b029-330">関連項目</span><span class="sxs-lookup"><span data-stu-id="1b029-330">See also</span></span>

- [<span data-ttu-id="1b029-331">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="1b029-331">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="1b029-332">.NET Core および .NET Standard による並列プログラミングのサンプル</span><span class="sxs-lookup"><span data-stu-id="1b029-332">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
