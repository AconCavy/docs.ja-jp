---
title: PLINQ の概要
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, introduction to
ms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0
ms.openlocfilehash: ed1b2df57c118a0ebb6b5ffa4326b3e2eac81dec
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/15/2020
ms.locfileid: "75632364"
---
# <a name="introduction-to-plinq"></a><span data-ttu-id="65b7c-102">PLINQ の概要</span><span class="sxs-lookup"><span data-stu-id="65b7c-102">Introduction to PLINQ</span></span>

## <a name="what-is-a-parallel-query"></a><span data-ttu-id="65b7c-103">並列クエリとは</span><span class="sxs-lookup"><span data-stu-id="65b7c-103">What is a Parallel Query?</span></span>

<span data-ttu-id="65b7c-104">統合言語クエリ (LINQ) は .NET Framework 3.5 で導入されました。</span><span class="sxs-lookup"><span data-stu-id="65b7c-104">Language-Integrated Query (LINQ) was introduced in the .NET Framework 3.5.</span></span> <span data-ttu-id="65b7c-105">これはタイプ セーフな方法で任意の <xref:System.Collections.IEnumerable?displayProperty=nameWithType> または <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> のデータ ソースを照会する、統一されたモデルです。</span><span class="sxs-lookup"><span data-stu-id="65b7c-105">It features a unified model for querying any <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> data source in a type-safe manner.</span></span> <span data-ttu-id="65b7c-106">LINQ to Objects とは、<xref:System.Collections.Generic.List%601> や配列などのメモリ内コレクションに対して実行される LINQ クエリの名前です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-106">LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays.</span></span> <span data-ttu-id="65b7c-107">この記事では、LINQ の基礎を理解していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-107">This article assumes that you have a basic understanding of LINQ.</span></span> <span data-ttu-id="65b7c-108">詳細については、「[統合言語クエリ (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md)」または「[統合言語クエリ (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-108">For more information, see [Language-Integrated Query (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md) or [Language-Integrated Query (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).</span></span>

<span data-ttu-id="65b7c-109">Parallel LINQ (PLINQ) は、LINQ パターンの並列実装です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-109">Parallel LINQ (PLINQ) is a parallel implementation of the LINQ pattern.</span></span> <span data-ttu-id="65b7c-110">PLINQ クエリは、あらゆる意味において、並列ではない LINQ to Objects クエリに似ています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-110">A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</span></span> <span data-ttu-id="65b7c-111">PLINQ クエリは、LINQ の順次クエリと同様、メモリ内の <xref:System.Collections.IEnumerable> または <xref:System.Collections.Generic.IEnumerable%601> データ ソースで実行され、遅延実行が存在するので、クエリが列挙されるまでは実行されません。</span><span class="sxs-lookup"><span data-stu-id="65b7c-111">PLINQ queries, just like sequential LINQ queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</span></span> <span data-ttu-id="65b7c-112">主な相違点は、PLINQ は、システムのすべてのプロセッサを十分に活用しようとする点です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-112">The primary difference is that PLINQ attempts to make full use of all the processors on the system.</span></span> <span data-ttu-id="65b7c-113">そのために、データ ソースをセグメントにパーティション分割し、複数のプロセッサで個々のワーカー スレッドの各セグメントに対してクエリを並行実行します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-113">It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</span></span> <span data-ttu-id="65b7c-114">多くの場合、並行実行によって、クエリは非常に高速に処理されます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-114">In many cases, parallel execution means that the query runs significantly faster.</span></span>

<span data-ttu-id="65b7c-115">一部の種類のクエリについては、データ ソースに <xref:System.Linq.ParallelEnumerable.AsParallel%2A> クエリ操作を追加して並行実行することで、レガシ コードよりも大幅なパフォーマンスの向上を PLINQ で実現できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-115">Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source.</span></span> <span data-ttu-id="65b7c-116">ただし、並列処理にはある程度の複雑さが伴うため、すべてのクエリ操作が PLINQ でより速く実行されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="65b7c-116">However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.</span></span> <span data-ttu-id="65b7c-117">実際、一部のクエリについては、並列化によって処理速度が遅くなります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-117">In fact, parallelization actually slows down certain queries.</span></span> <span data-ttu-id="65b7c-118">そのため、順序付けなどの問題が並列クエリに与える影響を理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-118">Therefore, you should understand how issues such as ordering affect parallel queries.</span></span> <span data-ttu-id="65b7c-119">詳細については、「[Understanding Speedup in PLINQ (PLINQ での高速化について)](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-119">For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span></span>

> [!NOTE]
> <span data-ttu-id="65b7c-120">ここでは、ラムダ式を使用して PLINQ でデリゲートを定義します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-120">This documentation uses lambda expressions to define delegates in PLINQ.</span></span> <span data-ttu-id="65b7c-121">C# または Visual Basic のラムダ式についての情報が必要な場合は、「[Lambda Expressions in PLINQ and TPL (PLINQ および TPL のラムダ式)](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="65b7c-122">この記事の残りの部分では、主な PLINQ クラスの概要を紹介し、PLINQ クエリの作成方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-122">The remainder of this article gives an overview of the main PLINQ classes, and discusses how to create PLINQ queries.</span></span> <span data-ttu-id="65b7c-123">各セクションには、詳細情報とコード例へのリンクも含まれています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-123">Each section contains links to more detailed information and code examples.</span></span>

## <a name="the-parallelenumerable-class"></a><span data-ttu-id="65b7c-124">ParallelEnumerable クラス</span><span class="sxs-lookup"><span data-stu-id="65b7c-124">The ParallelEnumerable Class</span></span>

<span data-ttu-id="65b7c-125"><xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> クラスは、ほぼすべての PLINQ 機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-125">The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality.</span></span> <span data-ttu-id="65b7c-126">このクラスと、その他の <xref:System.Linq?displayProperty=nameWithType> 名前空間の型は、System.Core.dll アセンブリにコンパイルされます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-126">It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly.</span></span> <span data-ttu-id="65b7c-127">Visual Studio の既定の C# プロジェクトと Visual Basic プロジェクトは、どちらもアセンブリを参照し、名前空間をインポートします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-127">The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.</span></span>

<span data-ttu-id="65b7c-128"><xref:System.Linq.ParallelEnumerable> には、LINQ to Objects がサポートするすべての標準クエリ演算子の実装が含まれていますが、各演算子の並列化は試行しません。</span><span class="sxs-lookup"><span data-stu-id="65b7c-128"><xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.</span></span> <span data-ttu-id="65b7c-129">LINQ に精通していない場合は、「[LINQ の概要 (C#)](../../csharp/programming-guide/concepts/linq/index.md)」および「[LINQ の概要 (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-129">If you are not familiar with LINQ, see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span></span>

<span data-ttu-id="65b7c-130"><xref:System.Linq.ParallelEnumerable> クラスには、標準クエリ演算子に加え、並行実行固有の動作を可能にする一連のメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-130">In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution.</span></span> <span data-ttu-id="65b7c-131">次の表に、これらの PLINQ 固有のメソッドを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-131">These PLINQ-specific methods are listed in the following table.</span></span>

|<span data-ttu-id="65b7c-132">ParallelEnumerable 演算子</span><span class="sxs-lookup"><span data-stu-id="65b7c-132">ParallelEnumerable Operator</span></span>|<span data-ttu-id="65b7c-133">説明</span><span class="sxs-lookup"><span data-stu-id="65b7c-133">Description</span></span>|
|---------------------------------|-----------------|
|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|<span data-ttu-id="65b7c-134">PLINQ のエントリ ポイント。</span><span class="sxs-lookup"><span data-stu-id="65b7c-134">The entry point for PLINQ.</span></span> <span data-ttu-id="65b7c-135">可能な場合は、クエリの残りの部分は並列化されることを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-135">Specifies that the rest of the query should be parallelized, if it is possible.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|<span data-ttu-id="65b7c-136">クエリの残りの部分は、並列ではない LINQ クエリとして順次実行されることを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-136">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|<span data-ttu-id="65b7c-137">PLINQ は、クエリの残り部分について、または orderby (Visual Basic の場合は Order By) 句を使用するなどして順序が変更されるまでは、ソース シーケンスの順序を保持する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-137">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|<span data-ttu-id="65b7c-138">クエリの残りの部分の PLINQ では、ソース シーケンスの順序を保持する必要がないことを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-138">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|<span data-ttu-id="65b7c-139">PLINQ は、提示されたキャンセル トークンの状態を定期的に監視し、要求された場合は、実行を取り消す必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-139">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|<span data-ttu-id="65b7c-140">クエリを並列化するために PLINQ が使用する必要がある、プロセッサの最大数を示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-140">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|<span data-ttu-id="65b7c-141">PLINQ が並列化の結果を consumer スレッドの単一のシーケンスに再マージできる場合は、その方法についてのヒントを示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-141">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|<span data-ttu-id="65b7c-142">既定の動作が順次実行である場合でも、PLINQ がクエリを並列化する必要があるかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-142">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</span></span>|
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="65b7c-143">マルチスレッドの列挙型メソッド。クエリの結果の反復処理とは異なり、先に consumer スレッドに再マージしなくても、結果を並列処理できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-143">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</span></span>|
|<span data-ttu-id="65b7c-144"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> オーバーロード</span><span class="sxs-lookup"><span data-stu-id="65b7c-144"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload</span></span>|<span data-ttu-id="65b7c-145">PLINQ 固有のオーバーロードで、スレッド ローカルのパーティション上で中間的な集約を行うと共に、すべてのパーティションの結果を結合する最終的なアグリゲーション関数も使用できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-145">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</span></span>|

## <a name="the-opt-in-model"></a><span data-ttu-id="65b7c-146">オプトイン モデル</span><span class="sxs-lookup"><span data-stu-id="65b7c-146">The Opt-in Model</span></span>

<span data-ttu-id="65b7c-147">クエリを記述するときに、次の例に示すようにデータ ソースの <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> 拡張メソッドを呼び出し、PLINQ を有効にします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-147">When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.</span></span>

[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]
[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]

<span data-ttu-id="65b7c-148"><xref:System.Linq.ParallelEnumerable.AsParallel%2A> 拡張メソッドは、それ以降のクエリ演算子 (この場合は `where` および `select`) を <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> の実装にバインドします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-148">The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.</span></span>

## <a name="execution-modes"></a><span data-ttu-id="65b7c-149">実行モード</span><span class="sxs-lookup"><span data-stu-id="65b7c-149">Execution Modes</span></span>

<span data-ttu-id="65b7c-150">既定では、PLINQ は保守的です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-150">By default, PLINQ is conservative.</span></span> <span data-ttu-id="65b7c-151">PLINQ インフラストラクチャは、実行時に、クエリの全体的な構造を分析します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-151">At run time, the PLINQ infrastructure analyzes the overall structure of the query.</span></span> <span data-ttu-id="65b7c-152">並列化によってクエリを高速化できることが見込まれる場合は、PLINQ は、同時実行できるタスクにソース シーケンスをパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-152">If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.</span></span> <span data-ttu-id="65b7c-153">クエリの並列化が安全ではない場合は、PLINQ はクエリを順次実行します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-153">If it is not safe to parallelize a query, PLINQ just runs the query sequentially.</span></span> <span data-ttu-id="65b7c-154">PLINQ で、負荷が高くなる可能性がある並列アルゴリズムと負荷が低い順次アルゴリズムを選ぶ必要がある場合は、既定では順次アルゴリズムが選択されます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-154">If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.</span></span> <span data-ttu-id="65b7c-155">並列アルゴリズムを選択するよう PLINQ に指示するには、<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> メソッドと <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> 列挙型を使用します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-155">You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm.</span></span> <span data-ttu-id="65b7c-156">これは、テストと測定の結果、特定のクエリで並列化の方が速く実行されることが判明している場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-156">This is useful when you know by testing and measurement that a particular query executes faster in parallel.</span></span> <span data-ttu-id="65b7c-157">詳細については、[PLINQ の実行モードを指定する](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-157">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>

## <a name="degree-of-parallelism"></a><span data-ttu-id="65b7c-158">並列化の次数</span><span class="sxs-lookup"><span data-stu-id="65b7c-158">Degree of Parallelism</span></span>

<span data-ttu-id="65b7c-159">既定では、PLINQ はホスト コンピューター上のすべてのプロセッサを使用します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-159">By default, PLINQ uses all of the processors on the host computer.</span></span> <span data-ttu-id="65b7c-160"><xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> メソッドを使用すると、指定されたプロセッサ数よりも多くのプロセッサを使用するよう、PLINQ に指示できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-160">You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method.</span></span> <span data-ttu-id="65b7c-161">これは、コンピューター上で実行されるその他のプロセスが、一定の CPU 時間を確保できるようにする場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-161">This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.</span></span> <span data-ttu-id="65b7c-162">次のスニペットでは、クエリが最大で 2 つのプロセッサしか使用できないように制限します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-162">The following snippet limits the query to utilizing a maximum of two processors.</span></span>

[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]
[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]

<span data-ttu-id="65b7c-163">クエリが、ファイル I/O など計算主体ではない作業を大量に実行している場合は、マシンのコア数よりも大きい並列化の次数を指定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-163">In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.</span></span>

## <a name="ordered-versus-unordered-parallel-queries"></a><span data-ttu-id="65b7c-164">順序ありの並列クエリと順序なしの並列クエリ</span><span class="sxs-lookup"><span data-stu-id="65b7c-164">Ordered Versus Unordered Parallel Queries</span></span>

<span data-ttu-id="65b7c-165">一部のクエリでは、クエリ演算子は、ソース シーケンスの順序を保持する結果を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-165">In some queries, a query operator must produce results that preserve the ordering of the source sequence.</span></span> <span data-ttu-id="65b7c-166">そのために、PLINQ には <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 演算子が用意されています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-166">PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose.</span></span> <span data-ttu-id="65b7c-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> は、<xref:System.Linq.ParallelEnumerable.AsSequential%2A> とは異なります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span></span> <span data-ttu-id="65b7c-168"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> シーケンスは並列で処理されますが、その結果はバッファーに格納されて並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-168">An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted.</span></span> <span data-ttu-id="65b7c-169">通常、順序を保持するには追加の処理が必要となるため、<xref:System.Linq.ParallelEnumerable.AsOrdered%2A> シーケンスの処理は、既定の <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> シーケンスよりも遅くなることがあります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-169">Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence.</span></span> <span data-ttu-id="65b7c-170">特定の順序ありの並列操作が、同じ操作の順次処理よりも高速であるかどうかは、さまざまな要因によって左右されます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-170">Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.</span></span>

<span data-ttu-id="65b7c-171">次のコード例に、順序の維持を有効にする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-171">The following code example shows how to opt in to order preservation.</span></span>

[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]
[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]

<span data-ttu-id="65b7c-172">詳細については、「[Order Preservation in PLINQ (PLINQ における順序維持)](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-172">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>

## <a name="parallel-vs-sequential-queries"></a><span data-ttu-id="65b7c-173">並列クエリと順次クエリ</span><span class="sxs-lookup"><span data-stu-id="65b7c-173">Parallel vs. Sequential Queries</span></span>

<span data-ttu-id="65b7c-174">一部の操作では、ソース データを順次提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-174">Some operations require that the source data be delivered in a sequential manner.</span></span> <span data-ttu-id="65b7c-175"><xref:System.Linq.ParallelEnumerable> クエリ演算子は、必要に応じて、順次モードに自動的に切り替わります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-175">The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required.</span></span> <span data-ttu-id="65b7c-176">ユーザー定義のクエリ演算子と、順次実行を必要とするユーザー デリゲート向けに、PLINQ では <xref:System.Linq.ParallelEnumerable.AsSequential%2A> メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-176">For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method.</span></span> <span data-ttu-id="65b7c-177"><xref:System.Linq.ParallelEnumerable.AsSequential%2A> を使用すると、それ以降のクエリの演算子は、<xref:System.Linq.ParallelEnumerable.AsParallel%2A> が再度呼び出されるまで順次実行されます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-177">When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again.</span></span> <span data-ttu-id="65b7c-178">詳細については、[並列および順次の LINQ クエリを連結する](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-178">For more information, see [How to: Combine Parallel and Sequential LINQ Queries](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).</span></span>

## <a name="options-for-merging-query-results"></a><span data-ttu-id="65b7c-179">クエリ結果のマージのオプション</span><span class="sxs-lookup"><span data-stu-id="65b7c-179">Options for Merging Query Results</span></span>

<span data-ttu-id="65b7c-180">PLINQ クエリが並列実行される場合、`foreach` ループ (Visual Basic では `For Each`) による消費、またはリストや配列への挿入を行うことができるよう、各ワーカー スレッドからの結果をメイン スレッドに再マージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-180">When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array.</span></span> <span data-ttu-id="65b7c-181">結果をより迅速に生成する場合など、特定のマージ操作を指定すると便利なこともあります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-181">In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.</span></span> <span data-ttu-id="65b7c-182">そのために、PLINQ では <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> メソッドと <xref:System.Linq.ParallelMergeOptions> 列挙型をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-182">For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration.</span></span> <span data-ttu-id="65b7c-183">詳細については、「[Merge Options in PLINQ (PLINQ のマージ オプション)](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-183">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>

## <a name="the-forall-operator"></a><span data-ttu-id="65b7c-184">ForAll 演算子</span><span class="sxs-lookup"><span data-stu-id="65b7c-184">The ForAll Operator</span></span>

<span data-ttu-id="65b7c-185">LINQ の順次クエリでは、`foreach` (Visual Basic の場合は `For Each`) ループで列挙されるか、<xref:System.Linq.ParallelEnumerable.ToList%2A>、<xref:System.Linq.ParallelEnumerable.ToArray%2A>、<xref:System.Linq.ParallelEnumerable.ToDictionary%2A> などのメソッドを呼び出すまで、クエリの実行は延期されます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-185">In sequential LINQ queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span></span> <span data-ttu-id="65b7c-186">PLINQ では、`foreach` を使用してクエリを実行し、結果を反復処理することもできます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-186">In PLINQ, you can also use `foreach` to execute the query and iterate through the results.</span></span> <span data-ttu-id="65b7c-187">ただし、`foreach` 自体は並列実行されないので、ループが実行されるスレッドに、すべての並列タスクの出力を再マージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-187">However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</span></span> <span data-ttu-id="65b7c-188">PLINQ では、クエリ結果の最終的な順序を維持する必要がある場合や、結果を順次的に処理している場合は (たとえば、各要素に対して `foreach` を呼び出している場合など)、`Console.WriteLine` を使用できます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-188">In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element.</span></span> <span data-ttu-id="65b7c-189">順序の維持が必要ない場合や、結果の処理自体を並列化できる場合にクエリ実行を高速化するには、<xref:System.Linq.ParallelEnumerable.ForAll%2A> メソッドで PLINQ クエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-189">For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query.</span></span> <span data-ttu-id="65b7c-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> は、この最終的なマージ ステップを実行しません。</span><span class="sxs-lookup"><span data-stu-id="65b7c-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step.</span></span> <span data-ttu-id="65b7c-191"><xref:System.Linq.ParallelEnumerable.ForAll%2A> メソッドを使用するコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-191">The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method.</span></span> <span data-ttu-id="65b7c-192">ここで <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> が使用されるのは、項目を削除せずに、同時に複数スレッドの追加を行うために最適化されるためです。</span><span class="sxs-lookup"><span data-stu-id="65b7c-192"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.</span></span>

[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]
[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]

<span data-ttu-id="65b7c-193">次の図に、クエリ実行における `foreach` と <xref:System.Linq.ParallelEnumerable.ForAll%2A> の相違点を示します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-193">The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.</span></span>

<span data-ttu-id="65b7c-194">![ForAll とForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span><span class="sxs-lookup"><span data-stu-id="65b7c-194">![ForAll vs. ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span></span>

## <a name="cancellation"></a><span data-ttu-id="65b7c-195">キャンセル</span><span class="sxs-lookup"><span data-stu-id="65b7c-195">Cancellation</span></span>

<span data-ttu-id="65b7c-196">PLINQ は、.NET Framework 4 のキャンセルの型に統合されています。</span><span class="sxs-lookup"><span data-stu-id="65b7c-196">PLINQ is integrated with the cancellation types in .NET Framework 4.</span></span> <span data-ttu-id="65b7c-197">詳細については、「[Cancellation in Managed Threads (マネージド スレッドのキャンセル)](../../../docs/standard/threading/cancellation-in-managed-threads.md)」を参照してください。そのため、順次的な LINQ to Objects クエリとは異なり、PLINQ クエリは取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-197">(For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.</span></span> <span data-ttu-id="65b7c-198">キャンセル可能な PLINQ クエリを作成するには、クエリで <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> 演算子を使用し、引数として <xref:System.Threading.CancellationToken> インスタンスを指定します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-198">To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument.</span></span> <span data-ttu-id="65b7c-199">トークンの <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> プロパティが true に設定されていると、PLINQ はそれに気付き、すべてのスレッドの処理を中止して <xref:System.OperationCanceledException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-199">When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="65b7c-200">キャンセル トークンが設定された後も、PLINQ クエリが一部の要素の処理を継続する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-200">It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.</span></span>

<span data-ttu-id="65b7c-201">応答性を高めるため、長時間にわたるユーザー デリゲートのキャンセル要求に対応することもできます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-201">For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.</span></span> <span data-ttu-id="65b7c-202">詳細については、[PLINQ クエリを取り消す](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-202">For more information, see [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>

## <a name="exceptions"></a><span data-ttu-id="65b7c-203">例外</span><span class="sxs-lookup"><span data-stu-id="65b7c-203">Exceptions</span></span>

<span data-ttu-id="65b7c-204">PLINQ クエリが実行されると、異なるスレッドから複数の例外が同時にスローされることがあります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-204">When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.</span></span> <span data-ttu-id="65b7c-205">また、例外を処理するコードが、例外をスローしたコードとは異なるスレッドにあることもあります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-205">Also, the code to handle the exception might be on a different thread than the code that threw the exception.</span></span> <span data-ttu-id="65b7c-206">PLINQ では <xref:System.AggregateException> 型を使用し、クエリによってスローされたすべての例外をカプセル化し、それらの例外を呼び出し元のスレッドにマーシャリングします。</span><span class="sxs-lookup"><span data-stu-id="65b7c-206">PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.</span></span> <span data-ttu-id="65b7c-207">呼び出し元のクエリでは、try-catch ブロックが 1 つだけ必要です。</span><span class="sxs-lookup"><span data-stu-id="65b7c-207">On the calling thread, only one try-catch block is required.</span></span> <span data-ttu-id="65b7c-208">ただし、<xref:System.AggregateException> でカプセル化されたすべての例外を反復処理し、安全に回復できる例外をキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-208">However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from.</span></span> <span data-ttu-id="65b7c-209">まれに、<xref:System.AggregateException> にラップされていない例外がスローされ、<xref:System.Threading.ThreadAbortException> もラップされていないことがあります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-209">In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.</span></span>

<span data-ttu-id="65b7c-210">連結しているスレッドへ例外が上方向へ通知されると、例外が発生した後も、クエリによって一部の項目の処理が続行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-210">When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.</span></span>

<span data-ttu-id="65b7c-211">詳細については、[PLINQ クエリの例外を処理する](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-211">For more information, see [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="65b7c-212">カスタム パーティショナー</span><span class="sxs-lookup"><span data-stu-id="65b7c-212">Custom Partitioners</span></span>

<span data-ttu-id="65b7c-213">ソース データの特性を活用するカスタム パーティショナーを記述することによって、クエリのパフォーマンスを向上できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-213">In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.</span></span> <span data-ttu-id="65b7c-214">クエリでは、カスタム パーティショナー自体は、クエリの対象となる列挙可能なオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="65b7c-214">In the query, the custom partitioner itself is the enumerable object that is queried.</span></span>

[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]
[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]

<span data-ttu-id="65b7c-215">PLINQ は、固定数のパーティションをサポートしています (ただし、負荷分散の目的で、これらのパーティションに対してデータが実行時に動的に再割り当てされることもあります)。</span><span class="sxs-lookup"><span data-stu-id="65b7c-215">PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).</span></span> <span data-ttu-id="65b7c-216"><xref:System.Threading.Tasks.Parallel.For%2A> および <xref:System.Threading.Tasks.Parallel.ForEach%2A> は動的なパーティション分割しかサポートしていないので、パーティションの数は実行時に変化します。</span><span class="sxs-lookup"><span data-stu-id="65b7c-216"><xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time.</span></span> <span data-ttu-id="65b7c-217">詳細については、「[Custom Partitioners for PLINQ and TPL (PLINQ および TPL 用のカスタム パーティショナー)](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-217">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>

## <a name="measuring-plinq-performance"></a><span data-ttu-id="65b7c-218">PLINQ のパフォーマンスの測定</span><span class="sxs-lookup"><span data-stu-id="65b7c-218">Measuring PLINQ Performance</span></span>

<span data-ttu-id="65b7c-219">クエリは、多くの場合並列化できますが、並列クエリの設定に伴うオーバーヘッドは、並列化によって得られるパフォーマンスの利点よりも大きくなります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-219">In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.</span></span> <span data-ttu-id="65b7c-220">クエリが大量の計算を実行しない場合、またはデータ ソースが小さい場合、PLINQ クエリは、順次的な LINQ to Objects クエリよりも低速になります。</span><span class="sxs-lookup"><span data-stu-id="65b7c-220">If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.</span></span> <span data-ttu-id="65b7c-221">Visual Studio Team Server の Parallel Performance Analyzer を使用し、さまざまなクエリのパフォーマンスの比較、処理のボトルネックの場所の特定、クエリが並行処理されているか順次処理されているかの確認を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="65b7c-221">You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.</span></span> <span data-ttu-id="65b7c-222">詳細については、「[コンカレンシー ビジュアライザー](/visualstudio/profiling/concurrency-visualizer)」および「[方法:PLINQ クエリのパフォーマンスを測定する](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="65b7c-222">For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="65b7c-223">関連項目</span><span class="sxs-lookup"><span data-stu-id="65b7c-223">See also</span></span>

- [<span data-ttu-id="65b7c-224">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="65b7c-224">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
- [<span data-ttu-id="65b7c-225">PLINQ での高速化について</span><span class="sxs-lookup"><span data-stu-id="65b7c-225">Understanding Speedup in PLINQ</span></span>](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)
