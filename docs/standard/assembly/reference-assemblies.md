---
title: 参照アセンブリ
description: 参照アセンブリについて説明します。これはライブラリのパブリック API サーフェイスのみを含む .NET の特殊なアセンブリです。
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 43a9dab037f4d0f1926ff67f8f38eaa6734a6d67
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/24/2020
ms.locfileid: "87164516"
---
# <a name="reference-assemblies"></a><span data-ttu-id="b1f66-103">参照アセンブリ</span><span class="sxs-lookup"><span data-stu-id="b1f66-103">Reference assemblies</span></span>

<span data-ttu-id="b1f66-104">"*参照アセンブリ*" は、ライブラリのパブリック API サーフェイスを表すために必要最小限のメタデータのみを含む特殊なアセンブリです。</span><span class="sxs-lookup"><span data-stu-id="b1f66-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="b1f66-105">これには、ビルド ツールでアセンブリを参照するときに重要なすべてのメンバーの宣言が含まれます。ただし、すべてのメンバーの実装と、その API コントラクトに影響を与えないプライベート メンバーの宣言は除外されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="b1f66-106">これに対して、通常のアセンブリは "*実装アセンブリ*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="b1f66-107">参照アセンブリを実行用に読み込むことはできませんが、実装アセンブリと同じ方法でコンパイラの入力として渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="b1f66-108">参照アセンブリは、通常、特定のプラットフォームまたはライブラリのソフトウェア開発キット (SDK) と共に配布されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="b1f66-109">開発者は、参照アセンブリを使用すると、そのバージョンの完全な実装アセンブリを持たなくても、特定のライブラリ バージョンを対象とするプログラムをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="b1f66-110">たとえば、マシンに最新バージョンのライブラリのみがインストールされ、ライブラリの以前のバージョンを対象とするプログラムを構築するとします。</span><span class="sxs-lookup"><span data-stu-id="b1f66-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="b1f66-111">実装アセンブリに対して直接コンパイルする場合、以前のバージョンでは使用できない API メンバーを誤って使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="b1f66-112">この誤りは、ターゲット マシンでプログラムをテストするときにのみ見つかります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="b1f66-113">以前のバージョンの参照アセンブリに対してコンパイルすると、すぐにコンパイル時エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="b1f66-114">参照アセンブリでは、コントラクト、つまり具象実装アセンブリに対応しない API のセットを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="b1f66-115">"*コントラクト アセンブリ*" と呼ばれるこのような参照アセンブリを使用すると、同じ API のセットをサポートする複数のプラットフォームを対象にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="b1f66-116">たとえば、.NET Standard には、複数の .NET プラットフォーム間で共有される共通 API のセットを表すコントラクト アセンブリ *netstandard.dll* が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b1f66-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="b1f66-117">このような API の実装は、.NET Framework 上の *mscorlib.dll* や .NET Core 上の *System.Private.CoreLib.dll* など、さまざまなプラットフォーム上のさまざまなアセンブリに含まれています。</span><span class="sxs-lookup"><span data-stu-id="b1f66-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="b1f66-118">.NET Standard をターゲットとするライブラリは、.NET Standard をサポートするすべてのプラットフォームで実行できます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="b1f66-119">参照アセンブリの使用</span><span class="sxs-lookup"><span data-stu-id="b1f66-119">Using reference assemblies</span></span>

<span data-ttu-id="b1f66-120">プロジェクトから特定の API を使用するには、アセンブリへの参照を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="b1f66-121">参照は、実装アセンブリに追加するか、参照アセンブリに追加できます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="b1f66-122">使用可能な場合は常に参照アセンブリを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b1f66-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="b1f66-123">これにより、API デザイナーによる使用を意図されている、ターゲット バージョンでサポートされている API メンバーのみが使用されるようになります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="b1f66-124">参照アセンブリを使用すると、確実に実装の詳細に依存しないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="b1f66-125">.NET Framework ライブラリの参照アセンブリは、ターゲット パックと共に配布されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="b1f66-126">これらを入手するには、スタンドアロン インストーラーをダウンロードするか、Visual Studio インストーラーでコンポーネントを選択します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="b1f66-127">詳細については、「[開発者向けの .NET Framework のインストール](../../framework/install/guide-for-developers.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b1f66-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="b1f66-128">.NET Core と .NET Standard の場合、参照アセンブリは必要に応じて (NuGet 経由で) 自動的にダウンロードされ、参照されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="b1f66-129">.NET Core 3.0 以降では、コア フレームワーク用の参照アセンブリが [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) パッケージに含まれています (3.0 より前のバージョンでは、代わりに [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) パッケージが使用されます)。</span><span class="sxs-lookup"><span data-stu-id="b1f66-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span>

<span data-ttu-id="b1f66-130">Visual Studio で **[参照の追加]** ダイアログを使用して .NET Framework アセンブリへの参照を追加する場合、リストからアセンブリを選択すると、Visual Studio ではプロジェクトで選択されたターゲット フレームワーク バージョンに対応する参照アセンブリが自動的に検索されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-130">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="b1f66-131">[[参照]](/visualstudio/msbuild/common-msbuild-project-items#reference) プロジェクト項目を使用して MSBuild プロジェクトに参照を直接追加する場合も同様です。完全なファイルのパスではなく、アセンブリ名のみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-131">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="b1f66-132">`-reference` コンパイラ オプション ([C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) および [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) を使用するか、Roslyn API の <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> メソッドを使用して、コマンド ラインでこれらのアセンブリに参照を追加する場合、正しいターゲット プラットフォーム バージョンの参照アセンブリ ファイルを手動で指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-132">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="b1f66-133">.NET Framework 参照アセンブリ ファイルは、 *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* ディレクトリにあります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-133">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="b1f66-134">.NET Core の場合、`PreserveCompilationContext` プロジェクト プロパティを `true` に設定することにより、ターゲット プラットフォームの参照アセンブリを出力ディレクトリの *publish/refs* サブディレクトリにコピーするように発行操作を強制できます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-134">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="b1f66-135">次に、これらの参照アセンブリ ファイルをコンパイラに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-135">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="b1f66-136">[Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) パッケージから `DependencyContext` を使用すると、パスを特定するために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-136">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="b1f66-137">実装が含まれていないため、参照アセンブリを実行用に読み込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="b1f66-137">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="b1f66-138">これを行おうとすると、<xref:System.BadImageFormatException?displayProperty=nameWithType> の結果になります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-138">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b1f66-139">参照アセンブリの内容を確認する場合は、それを、.NET Framework 内のリフレクションのみのコンテキストに (<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> メソッドを使用)、または .NET Core 内の <xref:System.Reflection.MetadataLoadContext> に読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-139">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="b1f66-140">参照アセンブリの生成</span><span class="sxs-lookup"><span data-stu-id="b1f66-140">Generating reference assemblies</span></span>

<span data-ttu-id="b1f66-141">ライブラリの参照アセンブリを生成することは、ライブラリ コンシューマーが多数の異なるバージョンのライブラリに対してプログラムをビルドする必要がある場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="b1f66-142">これらのすべてのバージョンに対する実装アセンブリの配布は、サイズが大きいために現実的ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="b1f66-143">参照アセンブリのサイズは小さいため、ライブラリの SDK の一部として配布すると、ダウンロード サイズが減り、ディスク領域が節約されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="b1f66-144">また、IDE とビルド ツールでは、参照アセンブリを利用すると、複数のクラス ライブラリで構成される大規模なソリューションの場合にビルド時間を短縮することもできます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="b1f66-145">通常、インクリメンタル ビルドのシナリオでは、プロジェクトは、依存するアセンブリを含め、入力ファイルが変更されるとリビルドされます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="b1f66-146">実装アセンブリは、プログラマーが任意のメンバーの実装を変更するたびに変わります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="b1f66-147">参照アセンブリは、パブリック API が影響を受ける場合にのみ変更されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="b1f66-148">そのため、参照アセンブリを実装アセンブリではなく入力ファイルとして使用すると、場合によっては、依存プロジェクトのビルドがスキップされることがあります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="b1f66-149">参照アセンブリは次のように生成できます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="b1f66-150">MSBuild プロジェクトでは、[`ProduceReferenceAssembly` プロジェクト プロパティ](/visualstudio/msbuild/common-msbuild-project-properties)を使用します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="b1f66-151">コマンド ラインからプログラムをコンパイルする場合は、`-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) または `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) コンパイラ オプションを指定します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="b1f66-152">Roslyn API を使用する場合は、<xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> メソッドに渡されるオブジェクトで <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> を `true` に、<xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> を `false` に設定します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="b1f66-153">NuGet パッケージと共に参照アセンブリを配布する場合は、実装アセンブリに使用される *lib\\* サブディレクトリではなく、パッケージ ディレクトリ以下の *ref\\* サブディレクトリに含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="b1f66-154">参照アセンブリの構造</span><span class="sxs-lookup"><span data-stu-id="b1f66-154">Reference assemblies structure</span></span>

<span data-ttu-id="b1f66-155">参照アセンブリは、"*メタデータのみのアセンブリ*" という関連する概念を拡張したものです。</span><span class="sxs-lookup"><span data-stu-id="b1f66-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="b1f66-156">メタデータのみアセンブリには、1 つの `throw null` 本体で置き換えられたメソッド本体がありますが、匿名型を除くすべてのメンバーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="b1f66-157">(本体なしではなく) `throw null` 本体を使用する理由は、**PEVerify** を実行して渡せるようにするためです (そのためにメタデータの完全性を検証します)。</span><span class="sxs-lookup"><span data-stu-id="b1f66-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="b1f66-158">参照アセンブリは、メタデータのみアセンブリからさらにメタデータ (プライベート メンバー) を削除します。</span><span class="sxs-lookup"><span data-stu-id="b1f66-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="b1f66-159">参照アセンブリには、API サーフェスでそれが必要とする参照のみがあります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="b1f66-160">実際のアセンブリには、特定の実装に関連するその他の参照がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="b1f66-161">たとえば、`class C { private void M() { dynamic d = 1; ... } }` の参照アセンブリは、`dynamic` に必要などの型も参照しません。</span><span class="sxs-lookup"><span data-stu-id="b1f66-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="b1f66-162">プライベート関数のメンバー (メソッド、プロパティ、およびイベント) は、それらの削除がコンパイルに著しい影響を与えない場合に削除されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="b1f66-163">[InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) 属性がない場合は、内部関数メンバーも削除されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="b1f66-164">参照アセンブリ内のメタデータでは、引き続き次の情報が保持されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="b1f66-165">プライベート型と入れ子にされた型を含むすべての型。</span><span class="sxs-lookup"><span data-stu-id="b1f66-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="b1f66-166">すべての属性 (内部的なものも含む)。</span><span class="sxs-lookup"><span data-stu-id="b1f66-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="b1f66-167">すべての仮想メソッド。</span><span class="sxs-lookup"><span data-stu-id="b1f66-167">All virtual methods.</span></span>
- <span data-ttu-id="b1f66-168">明示的なインターフェイスの実装。</span><span class="sxs-lookup"><span data-stu-id="b1f66-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="b1f66-169">プロパティとイベントは、アクセサーが仮想であるため、明示的に実装されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="b1f66-170">構造体のすべてのフィールド。</span><span class="sxs-lookup"><span data-stu-id="b1f66-170">All fields of structures.</span></span>

<span data-ttu-id="b1f66-171">参照アセンブリには、アセンブリレベルの [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) 属性が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="b1f66-172">この属性は、ソースで指定できます。指定すると、コンパイラではこれを合成する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="b1f66-173">この属性により、ランタイムで実行のための参照アセンブリの読み込みが拒否されます (ただし、リフレクションのみモードでは読み込むことができます)。</span><span class="sxs-lookup"><span data-stu-id="b1f66-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="b1f66-174">正確な参照アセンブリ構造の詳細は、コンパイラのバージョンによって異なります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="b1f66-175">新しいバージョンでは、パブリック API のサーフェスに影響がないと判断された場合、より多くのメタデータを除外することを選択できます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="b1f66-176">このセクションの情報は、C# バージョン 7.1 または Visual Basic バージョン 15.3 以降の Roslyn コンパイラによって生成された参照アセンブリにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="b1f66-177">.NET Framework および .NET Core ライブラリの参照アセンブリの構造は、参照アセンブリを生成する独自のメカニズムを使用するため、詳細が多少異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="b1f66-178">たとえば、`throw null` の本体ではなく、メソッドの本体が完全に空の場合があります。</span><span class="sxs-lookup"><span data-stu-id="b1f66-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="b1f66-179">ただし、一般的な原則は引き続き適用されます。つまり、使用可能なメソッド実装は含まれず、パブリック API の観点から目に見える影響があるメンバーのメタデータのみが含まれます。</span><span class="sxs-lookup"><span data-stu-id="b1f66-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="b1f66-180">関連項目</span><span class="sxs-lookup"><span data-stu-id="b1f66-180">See also</span></span>

- [<span data-ttu-id="b1f66-181">.NET のアセンブリ</span><span class="sxs-lookup"><span data-stu-id="b1f66-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="b1f66-182">フレームワーク対象設定機能の概要</span><span class="sxs-lookup"><span data-stu-id="b1f66-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="b1f66-183">方法: 参照マネージャーを使用して参照を追加または削除する</span><span class="sxs-lookup"><span data-stu-id="b1f66-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
