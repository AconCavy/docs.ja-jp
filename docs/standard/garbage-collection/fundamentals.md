---
title: ガベージ コレクションの基礎
description: ガベージ コレクターのしくみと、パフォーマンスを最適化するための構成方法について説明します。
ms.date: 11/15/2019
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 1536aaf936eb8d55aa56b80b50639541e89c9d2c
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2020
ms.locfileid: "94827816"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="c17ae-103">ガベージ コレクションの基礎</span><span class="sxs-lookup"><span data-stu-id="c17ae-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="c17ae-104">共通言語ランタイム (CLR) では、自動メモリ マネージャーとしてガベージ コレクター (GC) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="c17ae-105">ガベージ コレクターは、アプリケーションのメモリの割り当てと解放を管理します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-105">The garbage collector manages the allocation and release of memory for an application.</span></span> <span data-ttu-id="c17ae-106">マネージド コードを扱う開発者にとって、これは、メモリ管理タスクを実行するためのコードを記述する必要がないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-106">For developers working with managed code, this means that you don't have to write code to perform memory management tasks.</span></span> <span data-ttu-id="c17ae-107">自動メモリ管理により、オブジェクトを解放し忘れたためにメモリ リークが発生する、既に解放されているオブジェクトのメモリにアクセスしようとするなどの一般的な問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-107">Automatic memory management can eliminate common problems, such as forgetting to free an object and causing a memory leak or attempting to access memory for an object that's already been freed.</span></span>

<span data-ttu-id="c17ae-108">この記事では、ガベージ コレクションの主要な概念について説明します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-108">This article describes the core concepts of garbage collection.</span></span>

## <a name="benefits"></a><span data-ttu-id="c17ae-109">利点</span><span class="sxs-lookup"><span data-stu-id="c17ae-109">Benefits</span></span>

<span data-ttu-id="c17ae-110">ガベージ コレクターには、次のような利点があります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-110">The garbage collector provides the following benefits:</span></span>

- <span data-ttu-id="c17ae-111">開発者がメモリを手動で解放する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-111">Frees developers from having to manually release memory.</span></span>

- <span data-ttu-id="c17ae-112">オブジェクトが効率的にマネージド ヒープに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-112">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="c17ae-113">使用されなくなったオブジェクトが解放され、メモリがクリアされてその後の割り当てに使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-113">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="c17ae-114">マネージド オブジェクトは自動的にクリーンな内容で開始されるため、コンストラクターでデータ フィールドごとに初期化する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-114">Managed objects automatically get clean content to start with, so their constructors don't have to initialize every data field.</span></span>

- <span data-ttu-id="c17ae-115">オブジェクトで別のオブジェクトの内容を使用できなくすることで、メモリの安全が確保されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-115">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="c17ae-116">メモリの基礎</span><span class="sxs-lookup"><span data-stu-id="c17ae-116">Fundamentals of memory</span></span>

<span data-ttu-id="c17ae-117">CLR のメモリに関する重要な概念の概要を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-117">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="c17ae-118">各プロセスは、分離された独自の仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-118">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="c17ae-119">同じコンピューターのすべてのプロセスが同じ物理メモリとページ ファイル (存在する場合) を共有します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-119">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="c17ae-120">32 ビット コンピューターでは、各プロセスが既定で 2 GB のユーザー モード仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-120">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="c17ae-121">アプリケーション開発者が操作するのは仮想アドレス空間だけで、直接物理メモリを操作することはありません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-121">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="c17ae-122">マネージド ヒープの仮想メモリの割り当てと解放はガベージ コレクターによって行われます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-122">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="c17ae-123">ネイティブ コードを記述する場合は、Windows 関数を使用して仮想アドレス空間を操作します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-123">If you're writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="c17ae-124">ネイティブ ヒープの仮想メモリの割り当てと解放はこれらの関数によって行われます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-124">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="c17ae-125">仮想メモリには次の 3 つの状態があります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-125">Virtual memory can be in three states:</span></span>

  | <span data-ttu-id="c17ae-126">状態</span><span class="sxs-lookup"><span data-stu-id="c17ae-126">State</span></span> | <span data-ttu-id="c17ae-127">説明</span><span class="sxs-lookup"><span data-stu-id="c17ae-127">Description</span></span> |
  |---------|---------|
  | <span data-ttu-id="c17ae-128">Free</span><span class="sxs-lookup"><span data-stu-id="c17ae-128">Free</span></span> | <span data-ttu-id="c17ae-129">参照されていない、割り当てに使用できるメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-129">The block of memory has no references to it and is available for allocation.</span></span> |
  | <span data-ttu-id="c17ae-130">予約されています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-130">Reserved</span></span> | <span data-ttu-id="c17ae-131">使用できるように確保された、他の割り当て要求には使用できないメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-131">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="c17ae-132">ただし、このメモリ ブロックがコミットされるまではデータを格納できません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-132">However, you cannot store data to this memory block until it is committed.</span></span> |
  | <span data-ttu-id="c17ae-133">Committed</span><span class="sxs-lookup"><span data-stu-id="c17ae-133">Committed</span></span> | <span data-ttu-id="c17ae-134">物理ストレージに割り当てられたメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-134">The block of memory is assigned to physical storage.</span></span> |

- <span data-ttu-id="c17ae-135">仮想アドレス空間は、断片化することがあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-135">Virtual address space can get fragmented.</span></span> <span data-ttu-id="c17ae-136">断片化とは、アドレス空間に複数の空きブロック (ホールとも呼ばれます) がある状態です。</span><span class="sxs-lookup"><span data-stu-id="c17ae-136">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="c17ae-137">仮想メモリの割り当てが要求された場合、仮想メモリ マネージャーは、その割り当て要求を満たすのに十分な大きさの単一の空きブロックを見つけなければなりません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-137">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="c17ae-138">2 GB の空き領域があっても、そのすべての空き領域が 1 つのアドレス ブロックの中にない場合、2 GB の領域を必要とする割り当ては失敗します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-138">Even if you have 2 GB of free space, an allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="c17ae-139">メモリが足りなくなるのは、予約する仮想アドレス空間が足りなくなった場合か、コミットする物理領域が足りなくなった場合です。</span><span class="sxs-lookup"><span data-stu-id="c17ae-139">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="c17ae-140">ページ ファイルは、物理メモリの圧迫度 (物理メモリに対する需要) が低い場合にも使用されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-140">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="c17ae-141">最初に物理メモリの圧迫度が高まったときに、オペレーティング システムでは、データを格納するための領域の確保が必要となり、物理メモリのデータの一部がページ ファイルにバックアップされますが、</span><span class="sxs-lookup"><span data-stu-id="c17ae-141">The first time that physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="c17ae-142">そのデータは必要になるまでページングされないため、物理メモリの圧迫度が低い状況でページングが発生する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-142">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>
  
### <a name="memory-allocation"></a><span data-ttu-id="c17ae-143">メモリ割り当て</span><span class="sxs-lookup"><span data-stu-id="c17ae-143">Memory allocation</span></span>

<span data-ttu-id="c17ae-144">新しいプロセスが初期化されると、ランタイムは連続したアドレス空間領域をそのプロセスのために予約します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-144">When you initialize a new process, the runtime reserves a contiguous region of address space for the process.</span></span> <span data-ttu-id="c17ae-145">この予約済みのアドレス空間をマネージド ヒープと呼びます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-145">This reserved address space is called the managed heap.</span></span> <span data-ttu-id="c17ae-146">マネージド ヒープは、ヒープ内で次のオブジェクトを割り当てるアドレスへのポインターを管理します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-146">The managed heap maintains a pointer to the address where the next object in the heap will be allocated.</span></span> <span data-ttu-id="c17ae-147">初期状態では、このポインターはマネージド ヒープのベース アドレスに設定されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-147">Initially, this pointer is set to the managed heap's base address.</span></span> <span data-ttu-id="c17ae-148">すべての参照型は、マネージド ヒープ上に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-148">All reference types are allocated on the managed heap.</span></span> <span data-ttu-id="c17ae-149">アプリケーションが最初の参照型を作成すると、マネージド ヒープのベース アドレスの位置にその型のメモリが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-149">When an application creates the first reference type, memory is allocated for the type at the base address of the managed heap.</span></span> <span data-ttu-id="c17ae-150">アプリケーションが次のオブジェクトを作成すると、ガベージ コレクターは、アドレス空間で最初のオブジェクトの直後のメモリをそのオブジェクトに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-150">When the application creates the next object, the garbage collector allocates memory for it in the address space immediately following the first object.</span></span> <span data-ttu-id="c17ae-151">ガベージ コレクターは、使用できるアドレス空間がある限り、この方法で新しいオブジェクトにアドレス空間を割り当てていきます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-151">As long as address space is available, the garbage collector continues to allocate space for new objects in this manner.</span></span>

<span data-ttu-id="c17ae-152">マネージド ヒープからのメモリ割り当ては、アンマネージド メモリ割り当てよりも高速に処理されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-152">Allocating memory from the managed heap is faster than unmanaged memory allocation.</span></span> <span data-ttu-id="c17ae-153">ランタイムはポインターに値を加算することによってオブジェクトにメモリを割り当てるため、これは、スタックからのメモリ割り当てとほとんど同じ速度になります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-153">Because the runtime allocates memory for an object by adding a value to a pointer, it's almost as fast as allocating memory from the stack.</span></span> <span data-ttu-id="c17ae-154">また、連続して割り当てられた複数の新規オブジェクトは、マネージド ヒープに連続して格納されるため、アプリケーションからそれらのオブジェクトに高速でアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-154">In addition, because new objects that are allocated consecutively are stored contiguously in the managed heap, an application can access the objects quickly.</span></span>

### <a name="memory-release"></a><span data-ttu-id="c17ae-155">メモリの解放</span><span class="sxs-lookup"><span data-stu-id="c17ae-155">Memory release</span></span>

<span data-ttu-id="c17ae-156">ガベージ コレクターの最適化エンジンは、現在の割り当て状況に基づいて、ガベージ コレクションの実行に最適な時期を判断します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-156">The garbage collector's optimizing engine determines the best time to perform a collection based on the allocations being made.</span></span> <span data-ttu-id="c17ae-157">ガベージ コレクターは、ガベージ コレクションを実行するときに、アプリケーションが使用しなくなったオブジェクトのメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-157">When the garbage collector performs a collection, it releases the memory for objects that are no longer being used by the application.</span></span> <span data-ttu-id="c17ae-158">使用されなくなったオブジェクトを判断するために、アプリケーションの "*ルート*" を調べます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-158">It determines which objects are no longer being used by examining the application's *roots*.</span></span> <span data-ttu-id="c17ae-159">アプリケーションのルートには、静的フィールド、スレッドのスタック上のローカル変数、CPU レジスタ、GC ハンドル、ファイナライズ キューが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-159">An application's roots include static fields, local variables on a thread's stack, CPU registers, GC handles, and the finalize queue.</span></span> <span data-ttu-id="c17ae-160">各ルートは、マネージド ヒープ上のオブジェクトを参照しているか、または null に設定されています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-160">Each root either refers to an object on the managed heap or is set to null.</span></span> <span data-ttu-id="c17ae-161">ガベージ コレクターでこれらのルートのランタイムの残りを要求できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-161">The garbage collector can ask the rest of the runtime for these roots.</span></span> <span data-ttu-id="c17ae-162">ガベージ コレクターは、このリストを使用して、ルートから到達できるすべてのオブジェクトを含むグラフを作成します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-162">Using this list, the garbage collector creates a graph that contains all the objects that are reachable from the roots.</span></span>

<span data-ttu-id="c17ae-163">このグラフに含まれないオブジェクトは、アプリケーションのルートからは到達できません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-163">Objects that are not in the graph are unreachable from the application's roots.</span></span> <span data-ttu-id="c17ae-164">ガベージ コレクターは、到達できないオブジェクトをガベージであると判断し、それらに割り当てられたメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-164">The garbage collector considers unreachable objects garbage and releases the memory allocated for them.</span></span> <span data-ttu-id="c17ae-165">ガベージ コレクション中に、ガベージ コレクターはマネージド ヒープを調べ、到達できないオブジェクトが占有しているアドレス空間ブロックを検索します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-165">During a collection, the garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</span></span> <span data-ttu-id="c17ae-166">到達できないオブジェクトを検出すると、それらのオブジェクトに割り当てられていたアドレス空間ブロックを解放し、メモリ コピー機能を使用して、到達できるオブジェクトのメモリを圧縮します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-166">As it discovers each unreachable object, it uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</span></span> <span data-ttu-id="c17ae-167">到達できるオブジェクトのメモリを圧縮した後で、ガベージ コレクターは、アプリケーションのルートがそれらのオブジェクトの新しい位置を指すようにポインターを修正します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-167">Once the memory for the reachable objects has been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</span></span> <span data-ttu-id="c17ae-168">また、マネージド ヒープのポインターも、最後の到達できるオブジェクトの後を指すように修正します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-168">It also positions the managed heap's pointer after the last reachable object.</span></span>

<span data-ttu-id="c17ae-169">メモリが圧縮されるのは、コレクション中に、大量の到達できないオブジェクトが検出された場合だけです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-169">Memory is compacted only if a collection discovers a significant number of unreachable objects.</span></span> <span data-ttu-id="c17ae-170">マネージド ヒープ内のすべてのオブジェクトがごみではないと判断された場合は、メモリを圧縮する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-170">If all the objects in the managed heap survive a collection, then there is no need for memory compaction.</span></span>

<span data-ttu-id="c17ae-171">パフォーマンスを向上させるために、ランタイムは、大きいオブジェクトのメモリは独立したヒープに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-171">To improve performance, the runtime allocates memory for large objects in a separate heap.</span></span> <span data-ttu-id="c17ae-172">ガベージ コレクターは、これらの大きいオブジェクトのメモリを自動的に解放します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-172">The garbage collector automatically releases the memory for large objects.</span></span> <span data-ttu-id="c17ae-173">ただし、メモリ内で大きいオブジェクトを移動するのを避けるため、通常このメモリは圧縮されません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-173">However, to avoid moving large objects in memory, this memory is usually not compacted.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="c17ae-174">ガベージ コレクションの条件</span><span class="sxs-lookup"><span data-stu-id="c17ae-174">Conditions for a garbage collection</span></span>

<span data-ttu-id="c17ae-175">ガベージ コレクションは、次のいずれかの条件に当てはまる場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-175">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="c17ae-176">システムの物理メモリが少ない場合。</span><span class="sxs-lookup"><span data-stu-id="c17ae-176">The system has low physical memory.</span></span> <span data-ttu-id="c17ae-177">OS からのメモリ不足通知またはホストによって示されたメモリ不足のいずれかによって検出されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-177">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="c17ae-178">マネージド ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合。</span><span class="sxs-lookup"><span data-stu-id="c17ae-178">The memory that's used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="c17ae-179">このしきい値は、プロセスの進行に合わせて絶えず調整されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-179">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="c17ae-180"><xref:System.GC.Collect%2A?displayProperty=nameWithType> メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-180">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="c17ae-181">ほとんどの場合、ガベージ コレクターは継続して実行されるため、このメソッドを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-181">In almost all cases, you don't have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="c17ae-182">このメソッドは、主に特別な状況やテストで使用されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-182">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="c17ae-183">マネージド ヒープ</span><span class="sxs-lookup"><span data-stu-id="c17ae-183">The managed heap</span></span>

<span data-ttu-id="c17ae-184">ガベージ コレクターは、CLR によって初期化された後、オブジェクトを格納および管理するためのメモリのセグメントを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-184">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="c17ae-185">オペレーティング システムのネイティブ ヒープに対し、このメモリのことをマネージド ヒープと呼びます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-185">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="c17ae-186">マネージド ヒープはマネージド プロセスごとに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-186">There is a managed heap for each managed process.</span></span> <span data-ttu-id="c17ae-187">プロセス内のすべてのスレッドは、同じヒープにオブジェクト用のメモリを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-187">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="c17ae-188">メモリを予約するために、ガベージ コレクターは Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 関数を呼び出し、マネージド アプリケーション用のメモリのセグメントを一度に 1 つずつ予約します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-188">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="c17ae-189">また、ガベージ コレクターは、必要に応じてセグメントを予約したり、Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) 関数を呼び出すことで (オブジェクトのセグメントをクリアしてから) セグメントを解放してオペレーティング システムに戻したりします。</span><span class="sxs-lookup"><span data-stu-id="c17ae-189">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c17ae-190">ガベージ コレクターによって割り当てらるセグメントのサイズは実装に固有であり、定期的な更新プログラムによる場合を含め、いつでも変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-190">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="c17ae-191">アプリでは、セグメント サイズを推測することや、特定のセグメント サイズに依存することを絶対に避けてください。また、セグメントの割り当てに使用可能なメモリの量を構成しようとしてもなりません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-191">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="c17ae-192">ヒープに割り当てられたオブジェクトが少ないほど、ガベージ コレクターの処理も少なくなります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-192">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="c17ae-193">オブジェクトを割り当てるときは、必要以上に切り上げた値を使用しないでください。たとえば、15 バイトしか必要がないときに 32 バイトの配列を割り当てるなどです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-193">When you allocate objects, don't use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="c17ae-194">ガベージ コレクションがトリガーされると、ガベージ コレクターは、使用されなくなったオブジェクトに占有されているメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-194">When a garbage collection is triggered, the garbage collector reclaims the memory that's occupied by dead objects.</span></span> <span data-ttu-id="c17ae-195">この解放プロセスでは、まとめて移動できるように有効なオブジェクトを圧縮し、使用されなくなったスペースを削除することで、ヒープを小さくします。</span><span class="sxs-lookup"><span data-stu-id="c17ae-195">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="c17ae-196">これにより、一緒に割り当てられたオブジェクトが同じマネージド ヒープにまとめられ、局所性が保持されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-196">This ensures that objects that are allocated together stay together on the managed heap to preserve their locality.</span></span>

<span data-ttu-id="c17ae-197">ガベージ コレクションの割り込みの動作 (頻度と期間) は、割り当てのボリュームとマネージド ヒープ上の残ったメモリの量によって決まります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-197">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="c17ae-198">ヒープは、[大きなオブジェクト ヒープ](large-object-heap.md)と小さなオブジェクト ヒープの 2 つを累積したものと見なすことができます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-198">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span> <span data-ttu-id="c17ae-199">大きなオブジェクト ヒープには、85,000 バイトを超えるオブジェクト (通常は配列) が格納されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-199">The large object heap contains objects that are 85,000 bytes and larger, which are usually arrays.</span></span> <span data-ttu-id="c17ae-200">インスタンス オブジェクトが極端に大きくなることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-200">It's rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="c17ae-201">オブジェクトの[しきい値サイズを構成](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)すれば、大きなオブジェクト ヒープに移ることができます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-201">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="c17ae-202">ジェネレーション</span><span class="sxs-lookup"><span data-stu-id="c17ae-202">Generations</span></span>

<span data-ttu-id="c17ae-203">GC アルゴリズムは、次のよういないくつかの考慮事項に基づいています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-203">The GC algorithm is based on several considerations:</span></span>

- <span data-ttu-id="c17ae-204">マネージド ヒープ全体よりも、マネージド ヒープの一部のメモリを圧縮する方が高速です。</span><span class="sxs-lookup"><span data-stu-id="c17ae-204">It's faster to compact the memory for a portion of the managed heap than for the entire managed heap.</span></span>
- <span data-ttu-id="c17ae-205">オブジェクトが新しいほどその存続期間は短く、オブジェクトが古いほど存続期間は長くなります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-205">Newer objects have shorter lifetimes and older objects have longer lifetimes.</span></span>
- <span data-ttu-id="c17ae-206">新しいオブジェクトは相互に関連し、アプリケーションからほぼ同時にアクセスされる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-206">Newer objects tend to be related to each other and accessed by the application around the same time.</span></span>

<span data-ttu-id="c17ae-207">ガベージ コレクションは主に、有効期間が短いオブジェクトを解放する場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-207">Garbage collection primarily occurs with the reclamation of short-lived objects.</span></span> <span data-ttu-id="c17ae-208">ガベージ コレクターのパフォーマンスを最適化するために、マネージド ヒープは 0、1、および 2 の 3 つのジェネレーションに分割されます。そのため、有効期間が長いオブジェクトと短いオブジェクトを別々に処理できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-208">To optimize the performance of the garbage collector, the managed heap is divided into three generations, 0, 1, and 2, so it can handle long-lived and short-lived objects separately.</span></span> <span data-ttu-id="c17ae-209">ガベージ コレクターは、新しいオブジェクトをジェネレーション 0 に格納します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-209">The garbage collector stores new objects in generation 0.</span></span> <span data-ttu-id="c17ae-210">アプリケーションの有効期間の初期に作成され、ガベージ コレクションでごみではないと判断されたオブジェクトは昇格してジェネレーション 1 とジェネレーション 2 に格納されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-210">Objects created early in the application's lifetime that survive collections are promoted and stored in generations 1 and 2.</span></span> <span data-ttu-id="c17ae-211">マネージド ヒープの一部を圧縮する方がヒープ全体を圧縮するよりも高速であるため、この手法では、ガベージ コレクターがコレクションを実行するたびにマネージド ヒープ全体のメモリを解放するのではなく、特定のジェネレーションのメモリだけを解放できるようにします。</span><span class="sxs-lookup"><span data-stu-id="c17ae-211">Because it's faster to compact a portion of the managed heap than the entire heap, this scheme allows the garbage collector to release the memory in a specific generation rather than release the memory for the entire managed heap each time it performs a collection.</span></span>

- <span data-ttu-id="c17ae-212">**ジェネレーション 0**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-212">**Generation 0**.</span></span> <span data-ttu-id="c17ae-213">これは一番最初のジェネレーションで、有効期間が短いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-213">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="c17ae-214">有効期間が短いオブジェクトには、たとえば、テンポラリ変数などがあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-214">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="c17ae-215">ガベージ コレクションは、このジェネレーションで最も頻繁に発生します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-215">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="c17ae-216">新しく割り当てられたオブジェクトにより、新しいオブジェクトが生成されます。また、新しく割り当てられたオブジェクトは暗黙的にジェネレーション 0 コレクションになります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-216">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="c17ae-217">ただし、大きなオブジェクトであれば、大きなオブジェクト ヒープ (LOH) に移されます。これは、"*ジェネレーション 3*" と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-217">However, if they are large objects, they go on the large object heap (LOH), which is sometimes referred to as *generation 3*.</span></span> <span data-ttu-id="c17ae-218">ジェネレーション 3 は、ジェネレーション 2 の一部として論理的に収集される、物理的なジェネレーションです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-218">Generation 3 is a physical generation that's logically collected as part of generation 2.</span></span>

  <span data-ttu-id="c17ae-219">ジェネレーション 0 では、ほとんどのオブジェクトがガベージ コレクションで解放され、次のジェネレーションには残りません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-219">Most objects are reclaimed for garbage collection in generation 0 and don't survive to the next generation.</span></span>
  
  <span data-ttu-id="c17ae-220">ジェネレーション 0 がいっぱいになったときにアプリケーションが新しいオブジェクトを作成しようとすると、ガベージ コレクターは、そのオブジェクト用のアドレス空間を解放するためにコレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-220">If an application attempts to create a new object when generation 0 is full, the garbage collector performs a collection in an attempt to free address space for the object.</span></span> <span data-ttu-id="c17ae-221">まず、ガベージ コレクターは、マネージド ヒープ内の全オブジェクトではなく、ジェネレーション 0 のオブジェクトだけを調べます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-221">The garbage collector starts by examining the objects in generation 0 rather than all objects in the managed heap.</span></span> <span data-ttu-id="c17ae-222">多くの場合、ジェネレーション 0 のコレクションを行うだけで、アプリケーションが新しいオブジェクトの作成を続行するために十分なメモリを解放できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-222">A collection of generation 0 alone often reclaims enough memory to enable the application to continue creating new objects.</span></span>

- <span data-ttu-id="c17ae-223">**ジェネレーション 1**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-223">**Generation 1**.</span></span> <span data-ttu-id="c17ae-224">このジェネレーションには有効期間が短いオブジェクトが格納されます。有効期間が短いオブジェクトと有効期間が長いオブジェクトの間のバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-224">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

  <span data-ttu-id="c17ae-225">ガベージ コレクターは、ジェネレーション 0 のコレクションを実行した後で、到達できるオブジェクトのメモリを圧縮し、それらをジェネレーション 1 に昇格します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-225">After the garbage collector performs a collection of generation 0, it compacts the memory for the reachable objects and promotes them to generation 1.</span></span> <span data-ttu-id="c17ae-226">一般にガベージ コレクションでごみだと判断されなかったオブジェクトの存続期間は長いので、これらのオブジェクトを上位のジェネレーションに昇格させるのは有効です。</span><span class="sxs-lookup"><span data-stu-id="c17ae-226">Because objects that survive collections tend to have longer lifetimes, it makes sense to promote them to a higher generation.</span></span> <span data-ttu-id="c17ae-227">ガベージ コレクターがジェネレーション 0 のコレクションを実行するたびに、ジェネレーション 1 と 2 のオブジェクトを再び調べる必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-227">The garbage collector doesn't have to reexamine the objects in generations 1 and 2 each time it performs a collection of generation 0.</span></span>
  
  <span data-ttu-id="c17ae-228">ジェネレーション 0 のコレクションを行うだけでは、アプリケーションが新しいオブジェクトを作成するために必要なメモリを確保できない場合、ガベージ コレクターはジェネレーション 1、ジェネレーション 2 の順にコレクションを実行できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-228">If a collection of generation 0 does not reclaim enough memory for the application to create a new object, the garbage collector can perform a collection of generation 1, then generation 2.</span></span> <span data-ttu-id="c17ae-229">ガベージ コレクションでごみだと判断されなかったジェネレーション 1 のオブジェクトは、ジェネレーション 2 に昇格します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-229">Objects in generation 1 that survive collections are promoted to generation 2.</span></span>

- <span data-ttu-id="c17ae-230">**ジェネレーション 2**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-230">**Generation 2**.</span></span> <span data-ttu-id="c17ae-231">このジェネレーションには、有効期間が長いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-231">This generation contains long-lived objects.</span></span> <span data-ttu-id="c17ae-232">有効期間が長いオブジェクトには、たとえば、プロセスの存続期間を通じて有効な静的データを含むサーバー アプリケーションのオブジェクトなどがあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-232">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

  <span data-ttu-id="c17ae-233">コレクションで解放されなかったジェネレーション 2 のオブジェクトは、その後のコレクションで到達不能であると判断されるまで、ジェネレーション 2 に残ります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-233">Objects in generation 2 that survive a collection remain in generation 2 until they are determined to be unreachable in a future collection.</span></span>
  
  <span data-ttu-id="c17ae-234">大きなオブジェクト ヒープ ("*ジェネレーション 3*" と呼ばれることもあります) 上のオブジェクトは、ジェネレーション 2 でも収集されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-234">Objects on the large object heap (which is sometimes referred to as *generation 3*) are also collected in generation 2.</span></span>

<span data-ttu-id="c17ae-235">ガベージ コレクションは、条件に応じて特定のジェネレーションで発生します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-235">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="c17ae-236">ジェネレーションのコレクションでは、そのジェネレーションとそれよりも前のすべてのジェネレーションのオブジェクトがコレクションの対象になります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-236">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="c17ae-237">ジェネレーション 2 のガベージ コレクションは、すべてのジェネレーションのオブジェクト (つまり、マネージド ヒープのすべてのオブジェクト) を解放することから、フル ガベージ コレクションとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-237">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="c17ae-238">存続と昇格</span><span class="sxs-lookup"><span data-stu-id="c17ae-238">Survival and promotions</span></span>

<span data-ttu-id="c17ae-239">ガベージ コレクションで解放されなかったオブジェクトは残存オブジェクトと呼ばれ、次のジェネレーションに昇格されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-239">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation:</span></span>

- <span data-ttu-id="c17ae-240">ジェネレーション 0 のガベージ コレクションで解放されなかったオブジェクトは、ジェネレーション 1 に昇格します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-240">Objects that survive a generation 0 garbage collection are promoted to generation 1.</span></span>
- <span data-ttu-id="c17ae-241">ジェネレーション 1 のガベージ コレクションで解放されなかったオブジェクトは、ジェネレーション 2 に昇格します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-241">Objects that survive a generation 1 garbage collection are promoted to generation 2.</span></span>
- <span data-ttu-id="c17ae-242">ジェネレーション 2 のガベージコレクションで解放されなかったオブジェクトは、ジェネレーション 2 に残ります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-242">Objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="c17ae-243">ジェネレーションでごみではないと判断される割合が高いことがガベージ コレクターで検出されると、そのジェネレーションに対する割り当てのしきい値が高くなります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-243">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="c17ae-244">次のジェネレーションで十分なサイズの解放されたメモリが受け取られます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-244">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="c17ae-245">CLR では、ガベージ コレクションを遅延させることでアプリケーションのワーキング セットが大きくなりすぎないようにすることと、ガベージ コレクションの実行頻度が多すぎないようにすることに注意して、それらの 2 つの優先事項のバランスを絶えず調整します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-245">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="c17ae-246">短期のジェネレーションとセグメント</span><span class="sxs-lookup"><span data-stu-id="c17ae-246">Ephemeral generations and segments</span></span>

<span data-ttu-id="c17ae-247">ジェネレーション 0 および 1 のオブジェクトは有効期間が短いことから、それらのジェネレーションのことを "*短期ジェネレーション*" と呼びます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-247">Because objects in generations 0 and 1 are short-lived, these generations are known as the *ephemeral generations*.</span></span>

<span data-ttu-id="c17ae-248">短期ジェネレーションは、短期セグメントと呼ばれるメモリ セグメントに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-248">Ephemeral generations are allocated in the memory segment that's known as the ephemeral segment.</span></span> <span data-ttu-id="c17ae-249">ガベージ コレクターによって新しいセグメントが取得されると、いずれも新しい短期セグメントになり、ジェネレーション 0 のガベージ コレクションで残ったオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-249">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="c17ae-250">古い短期セグメントは新しいジェネレーション 2 のセグメントになります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-250">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="c17ae-251">短期セグメントのサイズは、システムが 32 ビットと 64 ビットのどちらであるか、および実行されているガベージ コレクターの種類 ([ワークステーションの GC またはサーバーの GC](workstation-server-gc.md)) に応じて異なります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-251">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit and on the type of garbage collector it is running ([workstation or server GC](workstation-server-gc.md)).</span></span> <span data-ttu-id="c17ae-252">次の表は、短期セグメントの既定のサイズを示しています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-252">The following table shows the default sizes of the ephemeral segment.</span></span>

|<span data-ttu-id="c17ae-253">ワークステーションの GC またはサーバーの GC</span><span class="sxs-lookup"><span data-stu-id="c17ae-253">Workstation/server GC</span></span>|<span data-ttu-id="c17ae-254">32 ビット</span><span class="sxs-lookup"><span data-stu-id="c17ae-254">32-bit</span></span>|<span data-ttu-id="c17ae-255">64 ビット</span><span class="sxs-lookup"><span data-stu-id="c17ae-255">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="c17ae-256">ワークステーションの GC</span><span class="sxs-lookup"><span data-stu-id="c17ae-256">Workstation GC</span></span>|<span data-ttu-id="c17ae-257">16 MB</span><span class="sxs-lookup"><span data-stu-id="c17ae-257">16 MB</span></span>|<span data-ttu-id="c17ae-258">256 MB</span><span class="sxs-lookup"><span data-stu-id="c17ae-258">256 MB</span></span>|
|<span data-ttu-id="c17ae-259">サーバーの GC</span><span class="sxs-lookup"><span data-stu-id="c17ae-259">Server GC</span></span>|<span data-ttu-id="c17ae-260">64 MB</span><span class="sxs-lookup"><span data-stu-id="c17ae-260">64 MB</span></span>|<span data-ttu-id="c17ae-261">4 GB</span><span class="sxs-lookup"><span data-stu-id="c17ae-261">4 GB</span></span>|
|<span data-ttu-id="c17ae-262">サーバーの GC (論理 CPU が 4 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="c17ae-262">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="c17ae-263">32 MB</span><span class="sxs-lookup"><span data-stu-id="c17ae-263">32 MB</span></span>|<span data-ttu-id="c17ae-264">2 GB</span><span class="sxs-lookup"><span data-stu-id="c17ae-264">2 GB</span></span>|
|<span data-ttu-id="c17ae-265">サーバーの GC (論理 CPU が 8 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="c17ae-265">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="c17ae-266">16 MB</span><span class="sxs-lookup"><span data-stu-id="c17ae-266">16 MB</span></span>|<span data-ttu-id="c17ae-267">1 GB</span><span class="sxs-lookup"><span data-stu-id="c17ae-267">1 GB</span></span>|

<span data-ttu-id="c17ae-268">短期セグメントには、ジェネレーション 2 のオブジェクトも含めることができます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-268">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="c17ae-269">ジェネレーション 2 のオブジェクトでは複数のセグメントを使用できます (プロセスでの必要に応じてメモリが許容できる限りいくつでも使用できます)。</span><span class="sxs-lookup"><span data-stu-id="c17ae-269">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="c17ae-270">短期ガベージ コレクションによって解放されるメモリの量は、短期セグメントのサイズまでに限られます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-270">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="c17ae-271">解放されるメモリの量は、使用されなくなったオブジェクトに占有されていた領域に比例します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-271">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="c17ae-272">ガベージ コレクションの実行時の動作</span><span class="sxs-lookup"><span data-stu-id="c17ae-272">What happens during a garbage collection</span></span>

<span data-ttu-id="c17ae-273">ガベージ コレクションには次のフェーズがあります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-273">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="c17ae-274">マーキング フェーズ。有効なすべてのオブジェクトを探し、そのリストを作成します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-274">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="c17ae-275">再配置フェーズ。圧縮するオブジェクトへの参照を更新します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-275">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="c17ae-276">圧縮フェーズ。使用されなくなったオブジェクトに占有されている領域を解放し、残ったオブジェクトを圧縮します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-276">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="c17ae-277">圧縮フェーズでは、ガベージ コレクションで残ったオブジェクトをセグメントの後ろに移動します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-277">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="c17ae-278">ジェネレーション 2 のコレクションでは複数のセグメントを占有できるため、ジェネレーション 2 に昇格されたオブジェクトはより古いセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-278">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="c17ae-279">ジェネレーション 1 とジェネレーション 2 の残存オブジェクトは、どちらもジェネレーション 2 に昇格されるため、別のセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-279">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="c17ae-280">通常、大きなオブジェクト ヒープ (LOH) は圧縮されません。これは、大きなオブジェクトをコピーするとパフォーマンスが低下するためです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-280">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="c17ae-281">ただし、.NET Core と .NET Framework 4.5.1 以降では、<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> プロパティを使用して、大きなオブジェクト ヒープを必要に応じて圧縮できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-281">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="c17ae-282">また、LOH は、次のいずれかを指定することでハード上限が設定されるとき、自動的に圧縮されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-282">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="c17ae-283">コンテナーのメモリ上限。</span><span class="sxs-lookup"><span data-stu-id="c17ae-283">A memory limit on a container.</span></span>
  - <span data-ttu-id="c17ae-284">[GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) または [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) ランタイム構成オプション。</span><span class="sxs-lookup"><span data-stu-id="c17ae-284">The [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#heap-limit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#heap-limit-percent) run-time configuration options.</span></span>

<span data-ttu-id="c17ae-285">ガベージ コレクターは、次の情報に基づいてオブジェクトが有効かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="c17ae-285">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="c17ae-286">**スタック ルート**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-286">**Stack roots**.</span></span> <span data-ttu-id="c17ae-287">Just-In-Time (JIT) コンパイラとスタック ウォーカーによって提供されるスタック変数。</span><span class="sxs-lookup"><span data-stu-id="c17ae-287">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="c17ae-288">JIT の最適化では、スタック変数がガベージ コレクターに報告されるコードの領域が延長または短縮される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-288">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="c17ae-289">**ガベージ コレクション ハンドル**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-289">**Garbage collection handles**.</span></span> <span data-ttu-id="c17ae-290">マネージド オブジェクトを参照するハンドル。これらのハンドルは、ユーザー コードまたは共通言語ランタイムで割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-290">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="c17ae-291">**静的データ**。</span><span class="sxs-lookup"><span data-stu-id="c17ae-291">**Static data**.</span></span> <span data-ttu-id="c17ae-292">他のオブジェクトを参照している可能性があるアプリケーション ドメインの静的オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c17ae-292">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="c17ae-293">静的オブジェクトはそれぞれのアプリケーション ドメインで追跡されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-293">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="c17ae-294">ガベージ コレクションが開始される前に、そのガベージ コレクションをトリガーしたスレッドを除くすべてのマネージド スレッドが中断されます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-294">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="c17ae-295">次の図は、ガベージ コレクションを発生させて他のスレッドの中断を引き起こすスレッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="c17ae-295">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![スレッドでガベージ コレクションをトリガーする場合](media/gc-triggered.png)

## <a name="unmanaged-resources"></a><span data-ttu-id="c17ae-297">アンマネージ リソース</span><span class="sxs-lookup"><span data-stu-id="c17ae-297">Unmanaged resources</span></span>

<span data-ttu-id="c17ae-298">アプリケーションで作成されるオブジェクトの大部分については、ガベージ コレクションによって、必要なメモリ管理タスクを自動的に実行できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-298">For most of the objects that your application creates, you can rely on garbage collection to automatically perform the necessary memory management tasks.</span></span> <span data-ttu-id="c17ae-299">しかし、アンマネージ リソースでは、明示的なクリーンアップが必要です。</span><span class="sxs-lookup"><span data-stu-id="c17ae-299">However, unmanaged resources require explicit cleanup.</span></span> <span data-ttu-id="c17ae-300">最も一般的な種類のアンマネージ リソースは、ファイル ハンドル、ウィンドウ ハンドル、ネットワーク接続などのオペレーティング システム リソースをラップしたオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="c17ae-300">The most common type of unmanaged resource is an object that wraps an operating system resource, such as a file handle, window handle, or network connection.</span></span> <span data-ttu-id="c17ae-301">ガベージ コレクターは、アンマネージ リソースをカプセル化するマネージド オブジェクトの存続期間を追跡することはできますが、そのリソースのクリーンアップ方法については具体的な情報を持っていません。</span><span class="sxs-lookup"><span data-stu-id="c17ae-301">Although the garbage collector is able to track the lifetime of a managed object that encapsulates an unmanaged resource, it doesn't have specific knowledge about how to clean up the resource.</span></span>

<span data-ttu-id="c17ae-302">アンマネージ リソースをカプセル化するオブジェクトを作成する場合は、そのアンマネージ リソースをクリーンアップするために必要なコードをパブリックな `Dispose` メソッドという形で提供することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c17ae-302">When you create an object that encapsulates an unmanaged resource, it's recommended that you provide the necessary code to clean up the unmanaged resource in a public `Dispose` method.</span></span> <span data-ttu-id="c17ae-303">`Dispose` メソッドを提供すると、ユーザーがオブジェクトを使い終わったときに、そのオブジェクトのメモリを明示的に解放できます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-303">By providing a `Dispose` method, you enable users of your object to explicitly free its memory when they are finished with the object.</span></span> <span data-ttu-id="c17ae-304">アンマネージ リソースをカプセル化するオブジェクトを使用する場合は、必要に応じて `Dispose` を呼び出すようにしてください。</span><span class="sxs-lookup"><span data-stu-id="c17ae-304">When you use an object that encapsulates an unmanaged resource, make sure to call `Dispose` as necessary.</span></span>

<span data-ttu-id="c17ae-305">また、使用する型のコンシューマーが `Dispose` の呼び出しを忘れた場合に、アンマネージ リソースを解放する手段を用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c17ae-305">You must also provide a way for your unmanaged resources to be released in case a consumer of your type forgets to call `Dispose`.</span></span> <span data-ttu-id="c17ae-306">セーフ ハンドルを使用してアンマネージ リソースをラップするか、<xref:System.Object.Finalize?displayProperty=nameWithType> メソッドをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="c17ae-306">You can either use a safe handle to wrap the unmanaged resource, or override the <xref:System.Object.Finalize?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="c17ae-307">アンマネージ リソースのクリーンアップの詳細については、「[アンマネージ リソースのクリーンアップ](unmanaged.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c17ae-307">For more information about cleaning up unmanaged resources, see [Clean up unmanaged resources](unmanaged.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c17ae-308">関連項目</span><span class="sxs-lookup"><span data-stu-id="c17ae-308">See also</span></span>

- [<span data-ttu-id="c17ae-309">ワークステーションとサーバーのガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="c17ae-309">Workstation and server garbage collection</span></span>](workstation-server-gc.md)
- [<span data-ttu-id="c17ae-310">バックグラウンド ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="c17ae-310">Background garbage collection</span></span>](background-gc.md)
- [<span data-ttu-id="c17ae-311">GC の構成オプション</span><span class="sxs-lookup"><span data-stu-id="c17ae-311">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="c17ae-312">ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="c17ae-312">Garbage collection</span></span>](index.md)
