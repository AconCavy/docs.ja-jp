---
title: ガベージ コレクションの基礎
description: ガベージ コレクターのしくみと、パフォーマンスを最適化するための構成方法について説明します。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: ea8aef03d2f5837f35ecb31209e57853c0c8257b
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/22/2019
ms.locfileid: "74330415"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="9a806-103">ガベージ コレクションの基礎</span><span class="sxs-lookup"><span data-stu-id="9a806-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="9a806-104">共通言語ランタイム (CLR) では、自動メモリ マネージャーとしてガベージ コレクター (GC) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="9a806-105">次のような利点があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-105">It provides the following benefits:</span></span>

- <span data-ttu-id="9a806-106">アプリケーションを開発するときにメモリを手動で解放する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="9a806-106">Enables you to develop your application without having to manually free memory.</span></span>

- <span data-ttu-id="9a806-107">オブジェクトが効率的にマネージド ヒープに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9a806-107">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="9a806-108">使用されなくなったオブジェクトが解放され、メモリがクリアされてその後の割り当てに使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9a806-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="9a806-109">マネージド オブジェクトは自動的にクリーンな内容で開始されるため、コンストラクターでデータ フィールドごとに初期化する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9a806-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>

- <span data-ttu-id="9a806-110">オブジェクトで別のオブジェクトの内容を使用できなくすることで、メモリの安全が確保されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

<span data-ttu-id="9a806-111">この記事では、ガベージ コレクションの主要な概念について説明します。</span><span class="sxs-lookup"><span data-stu-id="9a806-111">This article describes the core concepts of garbage collection.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="9a806-112">メモリの基礎</span><span class="sxs-lookup"><span data-stu-id="9a806-112">Fundamentals of memory</span></span>

<span data-ttu-id="9a806-113">CLR のメモリに関する重要な概念の概要を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="9a806-113">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="9a806-114">各プロセスは、分離された独自の仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="9a806-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="9a806-115">同じコンピューターのすべてのプロセスが同じ物理メモリとページ ファイル (存在する場合) を共有します。</span><span class="sxs-lookup"><span data-stu-id="9a806-115">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="9a806-116">32 ビット コンピューターでは、各プロセスが既定で 2 GB のユーザー モード仮想アドレス空間を持ちます。</span><span class="sxs-lookup"><span data-stu-id="9a806-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="9a806-117">アプリケーション開発者が操作するのは仮想アドレス空間だけで、直接物理メモリを操作することはありません。</span><span class="sxs-lookup"><span data-stu-id="9a806-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="9a806-118">マネージド ヒープの仮想メモリの割り当てと解放はガベージ コレクターによって行われます。</span><span class="sxs-lookup"><span data-stu-id="9a806-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="9a806-119">ネイティブ コードを記述する場合は、Windows 関数を使用して仮想アドレス空間を操作します。</span><span class="sxs-lookup"><span data-stu-id="9a806-119">If you are writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="9a806-120">ネイティブ ヒープの仮想メモリの割り当てと解放はこれらの関数によって行われます。</span><span class="sxs-lookup"><span data-stu-id="9a806-120">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="9a806-121">仮想メモリには次の 3 つの状態があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-121">Virtual memory can be in three states:</span></span>

  - <span data-ttu-id="9a806-122">空き。</span><span class="sxs-lookup"><span data-stu-id="9a806-122">Free.</span></span> <span data-ttu-id="9a806-123">参照されていない、割り当てに使用できるメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="9a806-123">The block of memory has no references to it and is available for allocation.</span></span>

  - <span data-ttu-id="9a806-124">予約済み。</span><span class="sxs-lookup"><span data-stu-id="9a806-124">Reserved.</span></span> <span data-ttu-id="9a806-125">使用できるように確保された、他の割り当て要求には使用できないメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="9a806-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="9a806-126">ただし、このメモリ ブロックがコミットされるまではデータを格納できません。</span><span class="sxs-lookup"><span data-stu-id="9a806-126">However, you cannot store data to this memory block until it is committed.</span></span>

  - <span data-ttu-id="9a806-127">コミット済み。</span><span class="sxs-lookup"><span data-stu-id="9a806-127">Committed.</span></span> <span data-ttu-id="9a806-128">物理ストレージに割り当てられたメモリ ブロックです。</span><span class="sxs-lookup"><span data-stu-id="9a806-128">The block of memory is assigned to physical storage.</span></span>

- <span data-ttu-id="9a806-129">仮想アドレス空間は、断片化することがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="9a806-130">断片化とは、アドレス空間に複数の空きブロック (ホールとも呼ばれます) がある状態です。</span><span class="sxs-lookup"><span data-stu-id="9a806-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="9a806-131">仮想メモリの割り当てが要求された場合、仮想メモリ マネージャーは、その割り当て要求を満たすのに十分な大きさの単一の空きブロックを見つけなければなりません。</span><span class="sxs-lookup"><span data-stu-id="9a806-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="9a806-132">2 GB の空き領域があっても、そのすべての空き領域が 1 つのアドレス ブロックの中にない場合、2 GB の領域を必要とする割り当ては失敗します。</span><span class="sxs-lookup"><span data-stu-id="9a806-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="9a806-133">メモリが足りなくなるのは、予約する仮想アドレス空間が足りなくなった場合か、コミットする物理領域が足りなくなった場合です。</span><span class="sxs-lookup"><span data-stu-id="9a806-133">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="9a806-134">ページ ファイルは、物理メモリの圧迫度 (物理メモリに対する需要) が低い場合にも使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-134">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="9a806-135">最初に物理メモリの圧迫度が高まると、データを格納するための領域を確保するために物理メモリのデータの一部がページ ファイルにバックアップされますが、</span><span class="sxs-lookup"><span data-stu-id="9a806-135">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="9a806-136">そのデータは必要になるまでページングされないため、物理メモリの圧迫度が低い状況でページングが発生する可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-136">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="9a806-137">ガベージ コレクションの条件</span><span class="sxs-lookup"><span data-stu-id="9a806-137">Conditions for a garbage collection</span></span>

<span data-ttu-id="9a806-138">ガベージ コレクションは、次のいずれかの条件に当てはまる場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9a806-138">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="9a806-139">システムの物理メモリが少ない場合。</span><span class="sxs-lookup"><span data-stu-id="9a806-139">The system has low physical memory.</span></span> <span data-ttu-id="9a806-140">OS からのメモリ不足通知またはホストによって示されたメモリ不足のいずれかによって検出されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-140">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="9a806-141">マネージド ヒープで割り当てられたオブジェクトによって使用されているメモリが、許容されるしきい値を超える場合。</span><span class="sxs-lookup"><span data-stu-id="9a806-141">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="9a806-142">このしきい値は、プロセスの進行に合わせて絶えず調整されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-142">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="9a806-143"><xref:System.GC.Collect%2A?displayProperty=nameWithType> メソッドが呼び出された場合。</span><span class="sxs-lookup"><span data-stu-id="9a806-143">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="9a806-144">ほとんどの場合、ガベージ コレクターは継続して実行されるため、このメソッドを呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9a806-144">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="9a806-145">このメソッドは、主に特別な状況やテストで使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-145">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="9a806-146">マネージド ヒープ</span><span class="sxs-lookup"><span data-stu-id="9a806-146">The managed heap</span></span>

<span data-ttu-id="9a806-147">ガベージ コレクターは、CLR によって初期化された後、オブジェクトを格納および管理するためのメモリのセグメントを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="9a806-147">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="9a806-148">オペレーティング システムのネイティブ ヒープに対し、このメモリのことをマネージド ヒープと呼びます。</span><span class="sxs-lookup"><span data-stu-id="9a806-148">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="9a806-149">マネージド ヒープはマネージド プロセスごとに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9a806-149">There is a managed heap for each managed process.</span></span> <span data-ttu-id="9a806-150">プロセス内のすべてのスレッドは、同じヒープにオブジェクト用のメモリを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="9a806-150">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="9a806-151">メモリを予約するために、ガベージ コレクターは Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 関数を呼び出し、マネージド アプリケーション用のメモリのセグメントを一度に 1 つずつ予約します。</span><span class="sxs-lookup"><span data-stu-id="9a806-151">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="9a806-152">また、ガベージ コレクターは、必要に応じてセグメントを予約したり、Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) 関数を呼び出すことで (オブジェクトのセグメントをクリアしてから) セグメントを解放してオペレーティング システムに戻したりします。</span><span class="sxs-lookup"><span data-stu-id="9a806-152">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9a806-153">ガベージ コレクターによって割り当てらるセグメントのサイズは実装に固有であり、定期的な更新プログラムによる場合を含め、いつでも変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-153">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="9a806-154">アプリでは、セグメント サイズを推測することや、特定のセグメント サイズに依存することを絶対に避けてください。また、セグメントの割り当てに使用可能なメモリの量を構成しようとしてもなりません。</span><span class="sxs-lookup"><span data-stu-id="9a806-154">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="9a806-155">ヒープに割り当てられたオブジェクトが少ないほど、ガベージ コレクターの処理も少なくなります。</span><span class="sxs-lookup"><span data-stu-id="9a806-155">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="9a806-156">そのため、オブジェクトを割り当てるときに、必要な量より多く割り当てないようにしてください。たとえば、15 バイトしか必要がないときに 32 バイトの配列を割り当てないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="9a806-156">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="9a806-157">ガベージ コレクションがトリガーされると、ガベージ コレクターは、使用されなくなったオブジェクトに占有されているメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="9a806-157">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="9a806-158">この解放プロセスでは、まとめて移動できるように有効なオブジェクトを圧縮し、使用されなくなったスペースを削除することで、ヒープを小さくします。</span><span class="sxs-lookup"><span data-stu-id="9a806-158">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="9a806-159">これにより、一緒に割り当てられたオブジェクトが同じマネージド ヒープにまとめられ、局所性が保持されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-159">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>

<span data-ttu-id="9a806-160">ガベージ コレクションの割り込みの動作 (頻度と期間) は、割り当てのボリュームとマネージド ヒープ上の残ったメモリの量によって決まります。</span><span class="sxs-lookup"><span data-stu-id="9a806-160">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="9a806-161">ヒープは、[大きなオブジェクト ヒープ](large-object-heap.md)と小さなオブジェクト ヒープの 2 つを累積したものと見なすことができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-161">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>

<span data-ttu-id="9a806-162">[大きなオブジェクト ヒープ](large-object-heap.md)には、85,000 バイトを超える非常に大きなオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-162">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="9a806-163">大きなオブジェクト ヒープの中のオブジェクトは、通常は配列になります。</span><span class="sxs-lookup"><span data-stu-id="9a806-163">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="9a806-164">インスタンス オブジェクトが極端に大きくなることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="9a806-164">It is rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="9a806-165">オブジェクトの[しきい値サイズを構成](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)すれば、大きなオブジェクト ヒープに移ることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-165">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="9a806-166">ジェネレーション</span><span class="sxs-lookup"><span data-stu-id="9a806-166">Generations</span></span>

<span data-ttu-id="9a806-167">ヒープは、有効期間が長いオブジェクトと有効期間が短いオブジェクトに対処できるようにジェネレーションにまとめられます。</span><span class="sxs-lookup"><span data-stu-id="9a806-167">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="9a806-168">ガベージ コレクションは主に、通常はヒープのごく一部だけを占有する有効期間が短いオブジェクトを解放する場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9a806-168">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="9a806-169">ヒープのオブジェクトのジェネレーションには次の 3 つがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-169">There are three generations of objects on the heap:</span></span>

- <span data-ttu-id="9a806-170">**ジェネレーション 0**。</span><span class="sxs-lookup"><span data-stu-id="9a806-170">**Generation 0**.</span></span> <span data-ttu-id="9a806-171">これは一番最初のジェネレーションで、有効期間が短いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-171">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="9a806-172">有効期間が短いオブジェクトには、たとえば、テンポラリ変数などがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-172">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="9a806-173">ガベージ コレクションは、このジェネレーションで最も頻繁に発生します。</span><span class="sxs-lookup"><span data-stu-id="9a806-173">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="9a806-174">新しく割り当てられたオブジェクトにより、新しいオブジェクトが生成されます。また、新しく割り当てられたオブジェクトは暗黙的にジェネレーション 0 コレクションになります。</span><span class="sxs-lookup"><span data-stu-id="9a806-174">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="9a806-175">ただし、大きなオブジェクトであれば、ジェネレーション 2 コレクションの大きなオブジェクト ヒープに移ります。</span><span class="sxs-lookup"><span data-stu-id="9a806-175">However, if they are large objects, they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="9a806-176">ジェネレーション 0 では、ほとんどのオブジェクトがガベージ コレクションで解放され、次のジェネレーションには残りません。</span><span class="sxs-lookup"><span data-stu-id="9a806-176">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>

- <span data-ttu-id="9a806-177">**ジェネレーション 1**。</span><span class="sxs-lookup"><span data-stu-id="9a806-177">**Generation 1**.</span></span> <span data-ttu-id="9a806-178">このジェネレーションには有効期間が短いオブジェクトが格納されます。有効期間が短いオブジェクトと有効期間が長いオブジェクトの間のバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="9a806-178">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

- <span data-ttu-id="9a806-179">**ジェネレーション 2**。</span><span class="sxs-lookup"><span data-stu-id="9a806-179">**Generation 2**.</span></span> <span data-ttu-id="9a806-180">このジェネレーションには、有効期間が長いオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-180">This generation contains long-lived objects.</span></span> <span data-ttu-id="9a806-181">有効期間が長いオブジェクトには、たとえば、プロセスの存続期間を通じて有効な静的データを含むサーバー アプリケーションのオブジェクトなどがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-181">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

<span data-ttu-id="9a806-182">ガベージ コレクションは、条件に応じて特定のジェネレーションで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a806-182">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="9a806-183">ジェネレーションのコレクションでは、そのジェネレーションとそれよりも前のすべてのジェネレーションのオブジェクトがコレクションの対象になります。</span><span class="sxs-lookup"><span data-stu-id="9a806-183">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="9a806-184">ジェネレーション 2 のガベージ コレクションは、すべてのジェネレーションのすべてのオブジェクト (つまり、マネージド ヒープのすべてのオブジェクト) を解放することから、フル ガベージ コレクションとも呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9a806-184">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="9a806-185">存続と昇格</span><span class="sxs-lookup"><span data-stu-id="9a806-185">Survival and promotions</span></span>

<span data-ttu-id="9a806-186">ガベージ コレクションで解放されなかったオブジェクトは残存オブジェクトと呼ばれ、次のジェネレーションに昇格されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-186">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation.</span></span> <span data-ttu-id="9a806-187">ジェネレーション 0 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 1 に昇格されます。ジェネレーション 1 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に昇格されます。ジェネレーション 2 のガベージ コレクションでごみではないと判断されたオブジェクトは、ジェネレーション 2 に残ります。</span><span class="sxs-lookup"><span data-stu-id="9a806-187">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="9a806-188">ジェネレーションでごみではないと判断される割合が高いことがガベージ コレクターで検出されると、そのジェネレーションに対する割り当てのしきい値が高くなります。</span><span class="sxs-lookup"><span data-stu-id="9a806-188">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="9a806-189">次のジェネレーションで十分なサイズの解放されたメモリが受け取られます。</span><span class="sxs-lookup"><span data-stu-id="9a806-189">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="9a806-190">CLR では、ガベージ コレクションを遅延させることでアプリケーションのワーキング セットが大きくなりすぎないようにすることと、ガベージ コレクションの実行頻度が多すぎないようにすることに注意して、それらの 2 つの優先事項のバランスを絶えず調整します。</span><span class="sxs-lookup"><span data-stu-id="9a806-190">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="9a806-191">短期のジェネレーションとセグメント</span><span class="sxs-lookup"><span data-stu-id="9a806-191">Ephemeral generations and segments</span></span>

<span data-ttu-id="9a806-192">ジェネレーション 0 および 1 のオブジェクトは有効期間が短いことから、それらのジェネレーションのことを短期ジェネレーションと呼びます。</span><span class="sxs-lookup"><span data-stu-id="9a806-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>

<span data-ttu-id="9a806-193">短期ジェネレーションは、短期セグメントと呼ばれるメモリ セグメントに割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="9a806-194">ガベージ コレクターによって新しいセグメントが取得されると、いずれも新しい短期セグメントになり、ジェネレーション 0 のガベージ コレクションで残ったオブジェクトが格納されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="9a806-195">古い短期セグメントは新しいジェネレーション 2 のセグメントになります。</span><span class="sxs-lookup"><span data-stu-id="9a806-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="9a806-196">短期セグメントのサイズは、システムが 32 ビットと 64 ビットのどちらであるか、および実行されているガベージ コレクターの種類に応じて異なります。</span><span class="sxs-lookup"><span data-stu-id="9a806-196">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="9a806-197">既定の値を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="9a806-197">Default values are shown in the following table.</span></span>

||<span data-ttu-id="9a806-198">32 ビット</span><span class="sxs-lookup"><span data-stu-id="9a806-198">32-bit</span></span>|<span data-ttu-id="9a806-199">64 ビット</span><span class="sxs-lookup"><span data-stu-id="9a806-199">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="9a806-200">ワークステーションの GC</span><span class="sxs-lookup"><span data-stu-id="9a806-200">Workstation GC</span></span>|<span data-ttu-id="9a806-201">16 MB</span><span class="sxs-lookup"><span data-stu-id="9a806-201">16 MB</span></span>|<span data-ttu-id="9a806-202">256 MB</span><span class="sxs-lookup"><span data-stu-id="9a806-202">256 MB</span></span>|
|<span data-ttu-id="9a806-203">サーバーの GC</span><span class="sxs-lookup"><span data-stu-id="9a806-203">Server GC</span></span>|<span data-ttu-id="9a806-204">64 MB</span><span class="sxs-lookup"><span data-stu-id="9a806-204">64 MB</span></span>|<span data-ttu-id="9a806-205">4 GB</span><span class="sxs-lookup"><span data-stu-id="9a806-205">4 GB</span></span>|
|<span data-ttu-id="9a806-206">サーバーの GC (論理 CPU が 4 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="9a806-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="9a806-207">32 MB</span><span class="sxs-lookup"><span data-stu-id="9a806-207">32 MB</span></span>|<span data-ttu-id="9a806-208">2 GB</span><span class="sxs-lookup"><span data-stu-id="9a806-208">2 GB</span></span>|
|<span data-ttu-id="9a806-209">サーバーの GC (論理 CPU が 8 個以上の場合)</span><span class="sxs-lookup"><span data-stu-id="9a806-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="9a806-210">16 MB</span><span class="sxs-lookup"><span data-stu-id="9a806-210">16 MB</span></span>|<span data-ttu-id="9a806-211">1 GB</span><span class="sxs-lookup"><span data-stu-id="9a806-211">1 GB</span></span>|

<span data-ttu-id="9a806-212">短期セグメントには、ジェネレーション 2 のオブジェクトも含めることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="9a806-213">ジェネレーション 2 のオブジェクトでは複数のセグメントを使用できます (プロセスでの必要に応じてメモリが許容できる限りいくつでも使用できます)。</span><span class="sxs-lookup"><span data-stu-id="9a806-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="9a806-214">短期ガベージ コレクションによって解放されるメモリの量は、短期セグメントのサイズまでに限られます。</span><span class="sxs-lookup"><span data-stu-id="9a806-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="9a806-215">解放されるメモリの量は、使用されなくなったオブジェクトに占有されていた領域に比例します。</span><span class="sxs-lookup"><span data-stu-id="9a806-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="9a806-216">ガベージ コレクションの実行時の動作</span><span class="sxs-lookup"><span data-stu-id="9a806-216">What happens during a garbage collection</span></span>

<span data-ttu-id="9a806-217">ガベージ コレクションには次のフェーズがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-217">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="9a806-218">マーキング フェーズ。有効なすべてのオブジェクトを探し、そのリストを作成します。</span><span class="sxs-lookup"><span data-stu-id="9a806-218">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="9a806-219">再配置フェーズ。圧縮するオブジェクトへの参照を更新します。</span><span class="sxs-lookup"><span data-stu-id="9a806-219">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="9a806-220">圧縮フェーズ。使用されなくなったオブジェクトに占有されている領域を解放し、残ったオブジェクトを圧縮します。</span><span class="sxs-lookup"><span data-stu-id="9a806-220">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="9a806-221">圧縮フェーズでは、ガベージ コレクションで残ったオブジェクトをセグメントの後ろに移動します。</span><span class="sxs-lookup"><span data-stu-id="9a806-221">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="9a806-222">ジェネレーション 2 のコレクションでは複数のセグメントを占有できるため、ジェネレーション 2 に昇格されたオブジェクトはより古いセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-222">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="9a806-223">ジェネレーション 1 とジェネレーション 2 の残存オブジェクトは、どちらもジェネレーション 2 に昇格されるため、別のセグメントに移動できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-223">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="9a806-224">通常、大きなオブジェクト ヒープ (LOH) は圧縮されません。これは、大きなオブジェクトをコピーするとパフォーマンスが低下するためです。</span><span class="sxs-lookup"><span data-stu-id="9a806-224">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="9a806-225">ただし、.NET Core と .NET Framework 4.5.1 以降では、<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> プロパティを使用して、大きなオブジェクト ヒープを必要に応じて圧縮できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-225">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="9a806-226">また、LOH は、次のいずれかを指定することでハード上限が設定されるとき、自動的に圧縮されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-226">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="9a806-227">コンテナーのメモリ上限、または</span><span class="sxs-lookup"><span data-stu-id="9a806-227">a memory limit on a container, or</span></span>
  - <span data-ttu-id="9a806-228">[GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) または [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) ランタイム構成オプション</span><span class="sxs-lookup"><span data-stu-id="9a806-228">the [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options</span></span>

<span data-ttu-id="9a806-229">ガベージ コレクターは、次の情報に基づいてオブジェクトが有効かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9a806-229">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="9a806-230">**スタック ルート**。</span><span class="sxs-lookup"><span data-stu-id="9a806-230">**Stack roots**.</span></span> <span data-ttu-id="9a806-231">Just-In-Time (JIT) コンパイラとスタック ウォーカーによって提供されるスタック変数。</span><span class="sxs-lookup"><span data-stu-id="9a806-231">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="9a806-232">JIT の最適化では、スタック変数がガベージ コレクターに報告されるコードの領域が延長または短縮される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-232">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="9a806-233">**ガベージ コレクション ハンドル**。</span><span class="sxs-lookup"><span data-stu-id="9a806-233">**Garbage collection handles**.</span></span> <span data-ttu-id="9a806-234">マネージド オブジェクトを参照するハンドル。これらのハンドルは、ユーザー コードまたは共通言語ランタイムで割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-234">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="9a806-235">**静的データ**。</span><span class="sxs-lookup"><span data-stu-id="9a806-235">**Static data**.</span></span> <span data-ttu-id="9a806-236">他のオブジェクトを参照している可能性があるアプリケーション ドメインの静的オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9a806-236">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="9a806-237">静的オブジェクトはそれぞれのアプリケーション ドメインで追跡されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-237">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="9a806-238">ガベージ コレクションが開始される前に、そのガベージ コレクションをトリガーしたスレッドを除くすべてのマネージド スレッドが中断されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-238">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="9a806-239">次の図は、ガベージ コレクションを発生させて他のスレッドの中断を引き起こすスレッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a806-239">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![スレッドでガベージ コレクションをトリガーする場合](./media/gc-triggered.png)

## <a name="manipulate-unmanaged-resources"></a><span data-ttu-id="9a806-241">アンマネージ リソースの操作</span><span class="sxs-lookup"><span data-stu-id="9a806-241">Manipulate unmanaged resources</span></span>

<span data-ttu-id="9a806-242">ガベージ コレクターではマネージド ヒープのメモリのみを追跡するため、マネージド オブジェクトでネイティブのファイル ハンドルを使用してアンマネージド オブジェクトを参照している場合は、そのアンマネージド オブジェクトを明示的に解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-242">If managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector only tracks memory on the managed heap.</span></span>

<span data-ttu-id="9a806-243">マネージド オブジェクトのユーザーは、オブジェクトで使用されているネイティブ リソースを破棄できません。</span><span class="sxs-lookup"><span data-stu-id="9a806-243">Users of the managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="9a806-244">そのため、クリーンアップを行うには、マネージド オブジェクトをファイナライズ可能にします。</span><span class="sxs-lookup"><span data-stu-id="9a806-244">To perform the cleanup, you can make the managed object finalizable.</span></span> <span data-ttu-id="9a806-245">ファイナライズは、オブジェクトが使用されなくなったときに実行するクリーンアップ アクションで構成されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-245">Finalization consists of cleanup actions that execute when the object is no longer in use.</span></span> <span data-ttu-id="9a806-246">マネージド オブジェクトが使用されなくなると、ファイナライザー メソッドで指定されたクリーンアップ アクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-246">When the managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>

<span data-ttu-id="9a806-247">ファイナライズ可能なオブジェクトが使用されなくなったことが検出されると、クリーンアップ アクションを実行するためにファイナライザーによってキューに入れられますが、オブジェクト自体は次のジェネレーションに昇格されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-247">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="9a806-248">そのため、そのジェネレーションで次のガベージ コレクション (次回のガベージ コレクションではない場合もあります) が発生するまで、オブジェクトが解放されたかどうかは確認できません。</span><span class="sxs-lookup"><span data-stu-id="9a806-248">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>

<span data-ttu-id="9a806-249">ファイナライズの詳細については、「<xref:System.Object.Finalize?displayProperty=nameWithType>」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9a806-249">For more information about finalization, see <xref:System.Object.Finalize?displayProperty=nameWithType>.</span></span>

## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="9a806-250">ワークステーションとサーバーのガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="9a806-250">Workstation and server garbage collection</span></span>

<span data-ttu-id="9a806-251">ガベージ コレクターは、さまざまなシナリオに対応できるように自動的に調整されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-251">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="9a806-252">[構成ファイルの設定](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection)を使用し、作業負荷の特性に基づいてガベージ コレクションの種類を設定できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-252">You can use a [configuration file setting](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection) to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="9a806-253">CLR には、次の種類のガベージ コレクションが用意されています。</span><span class="sxs-lookup"><span data-stu-id="9a806-253">The CLR provides the following types of garbage collection:</span></span>

- <span data-ttu-id="9a806-254">ワークステーションのガベージ コレクション (GC) はクライアント アプリ向けに設計されています。</span><span class="sxs-lookup"><span data-stu-id="9a806-254">Workstation garbage collection (GC) is designed for client apps.</span></span> <span data-ttu-id="9a806-255">それはスタンドアロン アプリの既定の GC フレーバーです。</span><span class="sxs-lookup"><span data-stu-id="9a806-255">It is the default GC flavor for standalone apps.</span></span> <span data-ttu-id="9a806-256">ホストされているアプリ (ASP.NET によってホストされるアプリなど) の場合、ホストにより既定の GC フレーバーが決定されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-256">For hosted apps, for example, those hosted by ASP.NET, the host determines the default GC flavor.</span></span>

  <span data-ttu-id="9a806-257">ワークステーションのガベージ コレクションは、同時実行または非同時実行のどちらかで実行できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-257">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="9a806-258">同時実行ガベージ コレクションでは、ガベージ コレクションの実行中にマネージド スレッドの操作を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-258">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span> <span data-ttu-id="9a806-259">.NET Framework 4 以降では、[同時実行ガベージ コレクション](#concurrent-garbage-collection)は、[バックグラウンド ガベージ コレクション](#background-workstation-garbage-collection)に置き換えられています。</span><span class="sxs-lookup"><span data-stu-id="9a806-259">[Background garbage collection](#background-workstation-garbage-collection) replaces [concurrent garbage collection](#concurrent-garbage-collection) in .NET Framework 4 and later versions.</span></span>

- <span data-ttu-id="9a806-260">サーバーのガベージ コレクション。高いスループットとスケーラビリティが必要なサーバー アプリケーションを対象としたオプションです。</span><span class="sxs-lookup"><span data-stu-id="9a806-260">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span>

  - <span data-ttu-id="9a806-261">.NET Core では、サーバーのガベージ コレクションは、非同時実行ガベージ コレクションまたはバックグラウンド ガベージ コレクションである場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a806-261">In .NET Core, server garbage collection can be non-concurrent or background.</span></span>

  - <span data-ttu-id="9a806-262">.NET Framework 4.5 以降のバージョンでは、サーバー ガベージ コレクションは非同時実行かバックグラウンドになります (バックグラウンド ガベージ コレクションは同時実行ガベージ コレクションに代わるものです)。</span><span class="sxs-lookup"><span data-stu-id="9a806-262">In .NET Framework 4.5 and later versions, server garbage collection can be non-concurrent or background (background garbage collection replaces concurrent garbage collection).</span></span> <span data-ttu-id="9a806-263">.NET Framework 4 以前のバージョンでは、サーバー ガベージ コレクションは非同時実行になります。</span><span class="sxs-lookup"><span data-stu-id="9a806-263">In .NET Framework 4 and previous versions, server garbage collection is non-concurrent.</span></span>

<span data-ttu-id="9a806-264">次の図は、サーバー上でガベージ コレクションを実行する専用のスレッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a806-264">The following illustration shows the dedicated threads that perform the garbage collection on a server:</span></span>

![サーバー ガベージ コレクションのスレッド](./media/gc-server.png)

### <a name="compare-workstation-and-server-garbage-collection"></a><span data-ttu-id="9a806-266">ワークステーションとサーバーのガベージ コレクションを比較する</span><span class="sxs-lookup"><span data-stu-id="9a806-266">Compare workstation and server garbage collection</span></span>

<span data-ttu-id="9a806-267">ワークステーションのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9a806-267">The following are threading and performance considerations for workstation garbage collection:</span></span>

- <span data-ttu-id="9a806-268">コレクションは、ガベージ コレクションをトリガーしたユーザー スレッドで、それと同じ優先順位で実行されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-268">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="9a806-269">ユーザー スレッドは一般に通常の優先順位で実行されるため、その場合 (通常の優先順位のスレッドで実行された場合)、ガベージ コレクターの CPU 時間が他のスレッドと競合します。</span><span class="sxs-lookup"><span data-stu-id="9a806-269">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span> <span data-ttu-id="9a806-270">(ネイティブ コードを実行するスレッドは、サーバーまたはワークステーションのガベージ コレクションでは中断されません)</span><span class="sxs-lookup"><span data-stu-id="9a806-270">(Threads that run native code are not suspended on either server or workstation garbage collection.)</span></span>

- <span data-ttu-id="9a806-271">プロセッサが 1 つしかないコンピューターでは、[構成設定](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver)に関係なく、常にワークステーションのガベージ コレクションが使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-271">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [configuration setting](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver).</span></span>

<span data-ttu-id="9a806-272">サーバーのガベージ コレクションにおける、スレッド処理とパフォーマンスについての注意点を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9a806-272">The following are threading and performance considerations for server garbage collection:</span></span>

- <span data-ttu-id="9a806-273">コレクションは、 `THREAD_PRIORITY_HIGHEST` の優先順位で実行される複数の専用スレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-273">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>

- <span data-ttu-id="9a806-274">ヒープおよびガベージ コレクションを実行するための専用スレッドは CPU ごとに 1 つずつ用意され、複数のヒープのコレクションが同時に行われます。</span><span class="sxs-lookup"><span data-stu-id="9a806-274">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="9a806-275">各ヒープには小さなオブジェクト ヒープと大きなオブジェクト ヒープがあり、どのヒープもユーザー コードからアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="9a806-275">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="9a806-276">異なるヒープのオブジェクトを相互に参照できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-276">Objects on different heaps can refer to each other.</span></span>

- <span data-ttu-id="9a806-277">複数のガベージ コレクション スレッドが連携して処理を行うため、同じサイズのヒープを処理した場合、サーバーのガベージ コレクションの方がワークステーションのガベージ コレクションよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="9a806-277">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>

- <span data-ttu-id="9a806-278">一般に、サーバーのガベージ コレクションの方が、格納されるセグメントのサイズは大きくなります。</span><span class="sxs-lookup"><span data-stu-id="9a806-278">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="9a806-279">ただし、これは一般論に過ぎません。セグメントのサイズは実装に固有であり、変更されることがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-279">However, this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="9a806-280">アプリをチューニングするときに、ガベージ コレクターによって割り当てられるセグメントのサイズに関して何らかの仮定をすることは避けてください。</span><span class="sxs-lookup"><span data-stu-id="9a806-280">Don't make assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>

- <span data-ttu-id="9a806-281">サーバーのガベージ コレクションでは、リソースが大量に消費されることがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-281">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="9a806-282">たとえば、プロセッサが 4 つのコンピューターで実行されているサーバー GC が 12 個のプロセスで使用されているとします。</span><span class="sxs-lookup"><span data-stu-id="9a806-282">For example, imagine that there are 12 processes that use server GC running on a computer that has 4 processors.</span></span> <span data-ttu-id="9a806-283">すべてのプロセスで偶然、同時にガベージを回収すると、互いに干渉することになります。同じプロセッサで 12 のスレッドがスケジュールされるためです。</span><span class="sxs-lookup"><span data-stu-id="9a806-283">If all the processes happen to collect garbage at the same time, they would interfere with each other, as there would be 12 threads scheduled on the same processor.</span></span> <span data-ttu-id="9a806-284">プロセスがアクティブの場合、すべてのプロセスでサーバー GC を使用することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="9a806-284">If the processes are active, it's not a good idea to have them all use server GC.</span></span>

<span data-ttu-id="9a806-285">実行するアプリケーションのインスタンスが数百に及ぶ場合は、同時実行ガベージ コレクションを無効にしてワークステーションのガベージ コレクションを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9a806-285">If you're running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="9a806-286">これによって、コンテキストの切り替えが少なくなり、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9a806-286">This will result in less context switching, which can improve performance.</span></span>

## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="9a806-287">バックグラウンド ワークステーション ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="9a806-287">Background workstation garbage collection</span></span>

<span data-ttu-id="9a806-288">バックグラウンド ワークステーションのガベージ コレクションでは、ジェネレーション 2 のコレクションの実行中に、必要に応じて短期ジェネレーション (0 および 1) のコレクションが行われます。</span><span class="sxs-lookup"><span data-stu-id="9a806-288">In background workstation garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="9a806-289">バックグラウンド ワークステーションのガベージ コレクションは専用のスレッドで実行され、ジェネレーション 2 コレクションにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-289">Background workstation garbage collection is performed on a dedicated thread and applies only to generation 2 collections.</span></span>

<span data-ttu-id="9a806-290">バックグラウンド ガベージ コレクションは、既定で有効にされており、.NET Framework アプリケーションの [gcConcurrent>](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 構成設定または .NET Core アプリの [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) 設定で有効または無効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-290">Background garbage collection is enabled by default and can be enabled or disabled with the [gcConcurrent](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) configuration setting in .NET Framework apps or the [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) setting in .NET Core apps.</span></span>

> [!NOTE]
> <span data-ttu-id="9a806-291">[バックグラウンド ガベージ コレクション](#concurrent-garbage-collection)は同時実行ガベージ コレクションに取って代わり、.NET Framework 4 以降で利用できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-291">Background garbage collection replaces [concurrent garbage collection](#concurrent-garbage-collection) and is available in .NET Framework 4 and later versions.</span></span> <span data-ttu-id="9a806-292">.NET Framework 4 では、ワークステーション ガベージ コレクションのみでサポートされます。</span><span class="sxs-lookup"><span data-stu-id="9a806-292">In .NET Framework 4, it's supported only for workstation garbage collection.</span></span> <span data-ttu-id="9a806-293">.NET Framework 4.5 以降では、バックグラウンド ガベージ コレクションは、ワークステーションとサーバーのガベージ コレクションの両方で使用できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-293">Starting with .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>

<span data-ttu-id="9a806-294">バックグラウンド ガベージ コレクションの実行中に行われる短期ジェネレーションに対するコレクションのことを、フォアグラウンド ガベージ コレクションと呼びます。</span><span class="sxs-lookup"><span data-stu-id="9a806-294">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="9a806-295">フォアグラウンド ガベージ コレクションが発生すると、マネージド スレッドはすべて中断されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-295">When foreground garbage collections occur, all managed threads are suspended.</span></span>

<span data-ttu-id="9a806-296">バックグラウンド ガベージ コレクションの実行中にジェネレーション 0 に十分なオブジェクトが割り当てられていれば、CLR はジェネレーション 0 またはジェネレーション 1 のフォアグラウンド ガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="9a806-296">When background garbage collection is in progress and you've allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="9a806-297">バックグラウンド ガベージ コレクションの専用スレッドは、フォアグラウンド ガベージ コレクションの要求がないかどうかをセーフ ポイントで頻繁に確認します。</span><span class="sxs-lookup"><span data-stu-id="9a806-297">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="9a806-298">要求があると、バックグラウンド コレクションを中断して、フォアグラウンド ガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="9a806-298">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="9a806-299">フォアグラウンド ガベージ コレクションが完了すると、バックグラウンド ガベージ コレクションの専用スレッドとユーザー スレッドが再開されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-299">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>

<span data-ttu-id="9a806-300">バックグラウンド ガベージ コレクションでは、バックグラウンド ガベージ コレクションの実行中に短期ガベージ コレクションが発生する可能性があるため、同時実行ガベージ コレクションによる割り当ての制限が解除されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-300">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="9a806-301">バックグラウンド ガベージ コレクションでは、短期ジェネレーションの使用されなくなったオブジェクトを削除できます。</span><span class="sxs-lookup"><span data-stu-id="9a806-301">Background garbage collection can remove dead objects in ephemeral generations.</span></span> <span data-ttu-id="9a806-302">ジェネレーション 1 ガベージ コレクション中に必要になった場合、ヒープを拡張することもできます。</span><span class="sxs-lookup"><span data-stu-id="9a806-302">It can also expand the heap if needed during a generation 1 garbage collection.</span></span>

<span data-ttu-id="9a806-303">次の図は、ワークステーション上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a806-303">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>

![バックグラウンド ワークステーション ガベージ コレクション](./media/fundamentals/background-workstation-garbage-collection.png)

### <a name="background-server-garbage-collection"></a><span data-ttu-id="9a806-305">バックグラウンド サーバー ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="9a806-305">Background server garbage collection</span></span>

<span data-ttu-id="9a806-306">.NET Framework 4.5 以降では、サーバーのバックグラウンド ガベージ コレクションは、サーバーのガベージ コレクションの既定のモードです。</span><span class="sxs-lookup"><span data-stu-id="9a806-306">Starting with .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span>

<span data-ttu-id="9a806-307">バックグラウンド サーバーのガベージ コレクションは、前のセクションで説明したワークステーションのバックグラウンド ガベージ コレクションと同様に機能しますが、いくつかの違いがあります。</span><span class="sxs-lookup"><span data-stu-id="9a806-307">Background server garbage collection functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences:</span></span>

- <span data-ttu-id="9a806-308">ワークステーションのバックグラウンド ガベージ コレクションでは専用のバックグラウンド ガベージ コレクション スレッドを 1 つ使用します。これに対して、サーバーのバックグラウンド ガベージ コレクションでは複数のスレッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9a806-308">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads.</span></span> <span data-ttu-id="9a806-309">通常、論理プロセッサごとに専用のスレッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-309">Typically, there's a dedicated thread for each logical processor.</span></span>

- <span data-ttu-id="9a806-310">ワークステーションのバックグラウンド ガベージ コレクション スレッドとは異なり、これらのスレッドはタイムアウトになりません。</span><span class="sxs-lookup"><span data-stu-id="9a806-310">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>

<span data-ttu-id="9a806-311">次の図は、サーバー上の別々の専用スレッドで実行されるバックグラウンド ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a806-311">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>

![バックグラウンド サーバー ガベージ コレクション](./media/fundamentals/background-server-garbage-collection.png)

## <a name="concurrent-garbage-collection"></a><span data-ttu-id="9a806-313">同時実行ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="9a806-313">Concurrent garbage collection</span></span>

> [!TIP]
> <span data-ttu-id="9a806-314">このセクションは次に適用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-314">This section applies to:</span></span>
>
> - <span data-ttu-id="9a806-315">ワークステーション ガベージ コレクションの .NET Framework 3.5 以前</span><span class="sxs-lookup"><span data-stu-id="9a806-315">.NET Framework 3.5 and earlier for workstation garbage collection</span></span>
> - <span data-ttu-id="9a806-316">サーバー ガベージ コレクションの .NET Framework 4 以前</span><span class="sxs-lookup"><span data-stu-id="9a806-316">.NET Framework 4 and earlier for server garbage collection</span></span>
>
> <span data-ttu-id="9a806-317">後のバージョンでは、[バックグラウンド ガベージ コレクション](#background-workstation-garbage-collection)が同時実行ガベージに取って代わります。</span><span class="sxs-lookup"><span data-stu-id="9a806-317">Concurrent garbage is replaced by [background garbage collection](#background-workstation-garbage-collection) in later versions.</span></span>

<span data-ttu-id="9a806-318">ワークステーションまたはサーバーのガベージ コレクションでは、[同時実行ガベージ コレクションを有効にする](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)ことで、複数のスレッドを同時に実行できます。同時実行ガベージ コレクションでは、コレクションの実行中は、ほとんどの場合、ガベージ コレクションの処理を行う専用のスレッドが使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-318">In workstation or server garbage collection, you can [enable concurrent garbage collection](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md), which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="9a806-319">このオプションは、ジェネレーション 2 のガベージ コレクションにのみ影響します。ジェネレーション 0 と 1 の処理はすぐに終了するため、常に非同時実行で行われます。</span><span class="sxs-lookup"><span data-stu-id="9a806-319">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>

<span data-ttu-id="9a806-320">同時実行ガベージ コレクションでは、コレクションの一時停止を最小限にすることで、インタラクティブ アプリケーションの応答性を高めることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-320">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="9a806-321">マネージド スレッドは、同時実行ガベージ コレクションのスレッドが実行されている間も、ほぼ常に処理を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="9a806-321">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="9a806-322">そのため、ガベージ コレクションの実行中の一時停止が短くなります。</span><span class="sxs-lookup"><span data-stu-id="9a806-322">This results in shorter pauses while a garbage collection is occurring.</span></span>

<span data-ttu-id="9a806-323">同時実行ガベージ コレクションは、専用のスレッドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="9a806-323">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="9a806-324">既定では、CLR は、同時実行ガベージ コレクションを有効にしてワークステーションのガベージ コレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="9a806-324">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="9a806-325">これは、シングルプロセッサのコンピューターでもマルチプロセッサのコンピューターでも同じです。</span><span class="sxs-lookup"><span data-stu-id="9a806-325">This is true for single-processor and multi-processor computers.</span></span>

<span data-ttu-id="9a806-326">次の図は、別々の専用のスレッドで実行される同時実行ガベージ コレクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a806-326">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>

![同時実行ガベージ コレクションのスレッド](./media/gc-concurrent.png)

## <a name="see-also"></a><span data-ttu-id="9a806-328">関連項目</span><span class="sxs-lookup"><span data-stu-id="9a806-328">See also</span></span>

- [<span data-ttu-id="9a806-329">GC の構成オプション</span><span class="sxs-lookup"><span data-stu-id="9a806-329">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="9a806-330">ガベージ コレクション</span><span class="sxs-lookup"><span data-stu-id="9a806-330">Garbage collection</span></span>](index.md)
