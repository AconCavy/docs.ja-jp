---
title: コンストラクターのデザイン
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, constructors
- constructors, design guidelines
- instance constructors
- type constructors
- virtual members
- constructors, types
- parameterless constructors
- static constructors
ms.assetid: b4496afe-5fa7-4bb0-85ca-70b0ef21e6fc
author: KrzysztofCwalina
ms.openlocfilehash: a43ec815275e58f4bc6462fb4f5cb4733267de31
ms.sourcegitcommit: a97ecb94437362b21fffc5eb3c38b6c0b4368999
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/13/2019
ms.locfileid: "68972116"
---
# <a name="constructor-design"></a>コンストラクターのデザイン

コンストラクターには、型コンストラクターとインスタンスコンストラクターの2種類があります。

型コンストラクターは静的であり、型が使用される前に CLR によって実行されます。 インスタンスコンストラクターは、型のインスタンスが作成されるときに実行されます。

型コンストラクターはパラメーターを受け取ることができません。 インスタンスコンストラクターは使用できます。 パラメーターを受け取らないインスタンスコンストラクターは、通常、パラメーターなしのコンストラクターと呼ばれます。

コンストラクターは、型のインスタンスを作成する最も自然な方法です。 ほとんどの開発者は、インスタンスを作成する別の方法 (ファクトリメソッドなど) を検討する前に、コンストラクターを検索して使用しようとします。

**✓ CONSIDER** simple、理想的には、既定コンストラクターを提供します。

単純なコンストラクターには、ごく少数のパラメーターがあり、すべてのパラメーターはプリミティブまたは列挙型です。 このような単純なコンストラクターにより、フレームワークの使いやすさが向上します。

**✓ CONSIDER** 目的の操作のセマンティクスは、新しいインスタンスの構築に直接マップされない場合、またはコンストラクターのデザイン ガイドラインに従うが不自然にコンストラクターではなく静的ファクトリ メソッドを使用します。

**✓ DO** 主要なプロパティを設定するためのショートカットとしてコンストラクターのパラメーターを使用します。

空のコンストラクターを使用した後にいくつかのプロパティセットを使用し、複数の引数を持つコンストラクターを使用すると、セマンティクスに違いはありません。

**✓ DO** コンストラクターのパラメーターを使用して単にプロパティを設定する場合は、コンストラクターのパラメーターとプロパティに同じ名前を使用します。

このようなパラメーターとプロパティの違いは、大文字と小文字を区別することだけです。

**✓ DO** コンストラクターで作業を最小限に抑える。

コンストラクターでは、コンストラクターパラメーターをキャプチャする以外に多くの作業を行うことはできません。 その他の処理のコストは、必要になるまで延期する必要があります。

**✓ DO** 該当する場合は、インスタンス コンストラクターから例外をスローします。

このようなコンストラクターが必要な場合は、 **✓は**クラスでパブリックなパラメーターなしのコンストラクターを明示的に宣言します。

型のコンストラクターを明示的に宣言しない場合、多くの言語 ( C#など) によって、パブリックなパラメーターなしのコンストラクターが自動的に追加されます。 (抽象クラスは、保護されたコンストラクターを取得します)。

パラメーター化されたコンストラクターをクラスに追加すると、コンパイラはパラメーターなしのコンストラクターを追加できなくなります。 これにより、誤って重大な変更が行われることがよくあります。

X 構造体でパラメーターなしのコンストラクターを明示的に定義し**ないよう**にします。

これにより、パラメーターなしのコンストラクターが定義されていない場合に、配列内のすべてのスロットで実行する必要がないため、配列の作成が高速になります。 多くのコンパイラ (を含むC#) では、このような理由で構造体にパラメーターなしのコンストラクターを使用できないことに注意してください。

**X AVOID** コンストラクター内のオブジェクトでの仮想メンバーを呼び出すことです。

仮想メンバーを呼び出すと、最も派生した型のコンストラクターがまだ完全には実行されていない場合でも、最も派生されたオーバーライドが呼び出されます。

## <a name="type-constructor-guidelines"></a>型コンストラクターのガイドライン

**✓ DO** 静的コンストラクターをプライベートに設定します。

静的コンストラクター (クラスコンストラクターとも呼ばれます) を使用して、型を初期化します。 CLR は、型の最初のインスタンスが作成される前、またはその型の静的メンバーが呼び出される前に、静的コンストラクターを呼び出します。 静的コンストラクターが呼び出されるタイミングは、ユーザーが制御できません。 静的コンストラクターがプライベートでない場合は、CLR 以外のコードで呼び出すことができます。 コンストラクターで実行される操作によっては、予期しない動作が発生する可能性があります。 コンパイラC#は、静的コンストラクターを強制的にプライベートにします。

**X DO NOT** 静的コンストラクターから例外をスローします。

型コンストラクターから例外がスローされた場合、その型は現在のアプリケーションドメインでは使用できません。

**✓ CONSIDER** ランタイムが、明示的に定義された静的コンストラクターを持たない型のパフォーマンスを最適化するために、静的コンストラクターを明示的に使用するのではなく、静的フィールドをインラインを初期化します。

*Portions © 2005, 2009 Microsoft Corporation.All rights reserved.*

*次のフレームワークの設計ガイドラインから[、ピアソン教育, inc. のアクセス許可によって再度ご説明します。Microsoft Windows 開発シリーズの一部として、Addison-Wesley](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Professional によって2008年10月22日公開された、再利用可能な .net ライブラリの Krzysztof Cwalina および Brad abrams の規則、表現、パターン。*

## <a name="see-also"></a>関連項目

- [メンバーのデザインのガイドライン](../../../docs/standard/design-guidelines/member.md)
- [フレームワーク デザインのガイドライン](../../../docs/standard/design-guidelines/index.md)
