---
title: コンストラクターのデザイン
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, constructors
- constructors, design guidelines
- instance constructors
- type constructors
- virtual members
- constructors, types
- parameterless constructors
- static constructors
ms.assetid: b4496afe-5fa7-4bb0-85ca-70b0ef21e6fc
ms.openlocfilehash: 7ab795cd4c6e0ff5e1451c05987848c41bd69577
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401245"
---
# <a name="constructor-design"></a>コンストラクターのデザイン

コンストラクターには、型コンストラクターとインスタンス コンストラクターの 2 種類があります。

型コンストラクターは静的であり、型が使用される前に CLR によって実行されます。 インスタンス コンストラクターは、型のインスタンスが作成されるときに実行されます。

型コンストラクタはパラメータを受け取ることができません。 インスタンス コンストラクターは、できます。 パラメーターを受け取らないインスタンス コンストラクターは、パラメーターなしのコンストラクターと呼ばれることがよくあります。

コンストラクタは、型のインスタンスを作成する最も自然な方法です。 ほとんどの開発者は、インスタンスを作成する別の方法 (ファクトリ メソッドなど) を検討する前に、コンストラクタを検索して使用しようとします。

✔️は、単純で理想的なデフォルトのコンストラクタを提供することを検討してください。

単純なコンストラクターは、パラメーターの数が非常に少なくて、すべてのパラメーターはプリミティブまたは列挙型です。 このような単純なコンストラクタは、フレームワークの使いやすさを高める。

✔️必要な操作のセマンティクスが新しいインスタンスの構築に直接マップされない場合、またはコンストラクタ設計ガイドラインに従う際に不自然な場合は、コンストラクタの代わりに静的ファクトリメソッドを使用することを検討してください。

メイン プロパティを設定するためのショートカットとしてコンストラクタ パラメータを使用✔️。

空のコンストラクタの後に何らかのプロパティセットを使用することと、複数の引数を持つコンストラクタを使用する場合のセマンティクスに違いはありません。

コンストラクターパラメーターを使用して単にプロパティを設定する場合は、コンストラクターパラメーターとプロパティに同じ名前を使用✔️ DO。

このようなパラメータとプロパティの違いは大文字と小文字の区別だけです。

✔️コンストラクタで最小限の作業を行います。

コンストラクターは、コンストラクター パラメーターをキャプチャする以外に多くの作業を行う必要があります。 他の処理のコストは、必要になるまで遅延する必要があります。

必要に応じて、インスタンス コンストラクターから例外をスロー✔️ DO。

✔️は、クラスで public パラメーターなしのコンストラクターを明示的に宣言します (そのようなコンストラクターが必要な場合)。

型のコンストラクターを明示的に宣言しない場合、多くの言語 (C# など) は、パラメーターなしのパブリック コンストラクターを自動的に追加します。 (抽象クラスは、プロテクト コンストラクタを取得します。

パラメーター化されたコンストラクターをクラスに追加すると、コンパイラはパラメーターなしのコンストラクターを追加できなくなります。 これにより、誤って破損した変更が発生することがよくあります。

❌構造体にパラメーターなしのコンストラクターを明示的に定義する回避。

これにより、パラメーターなしのコンストラクターが定義されていない場合、配列内のすべてのスロットで実行する必要がないため、配列の作成が高速化されます。 C# を含む多くのコンパイラでは、このような理由で構造体にパラメーターなしのコンストラクターを含めることができない点に注意してください。

❌コンストラクタ内のオブジェクトの仮想メンバーを呼び出すことは避けてください。

仮想メンバーを呼び出すと、最派生型のコンストラクターがまだ完全に実行されていない場合でも、最も派生したオーバーライドが呼び出されます。

## <a name="type-constructor-guidelines"></a>型コンストラクタのガイドライン

静的コンストラクターをプライベートに✔️します。

静的コンストラクターは、クラス コンストラクターとも呼ばれ、型の初期化に使用されます。 CLR は、型の最初のインスタンスが作成される前に静的コンストラクターを呼び出すか、その型の静的メンバーが呼び出されます。 ユーザーは、静的コンストラクターが呼び出されたときに制御できません。 静的コンストラクターがプライベートでない場合は、CLR 以外のコードから呼び出すことができます。 コンストラクターで実行される操作によっては、予期しない動作が発生する場合があります。 C# コンパイラは、静的コンストラクターをプライベートに強制します。

❌静的コンストラクターから例外をスローしないでください。

型コンストラクターから例外がスローされた場合、その型は現在のアプリケーション ドメインで使用できません。

✔️は、静的コンストラクターを明示的に使用するのではなく、静的フィールドをインラインで初期化します。

*2005年、2009年©マイクロソフト株式会社。すべての権利が予約されています。*

*2008 年 10 月 22 日に Microsoft Windows Development シリーズの一部として、Addison-Wesley Professional によって発行された、Krzysztof Cwalina および Brad Abrams による「[Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)」 (フレームワーク デザイン ガイドライン: 再利用可能な .NET ライブラリの規則、用法、パターン、第 2 版) から Pearson Education, Inc. の許可を得て再印刷されています。*

## <a name="see-also"></a>関連項目

- [メンバーのデザインのガイドライン](../../../docs/standard/design-guidelines/member.md)
- [フレームワーク デザインのガイドライン](../../../docs/standard/design-guidelines/index.md)
