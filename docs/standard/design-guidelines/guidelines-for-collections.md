---
title: コレクションに関するガイドライン
ms.date: 10/22/2008
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
ms.openlocfilehash: 50497de6569b448ab036af8a1fbf76a47565e2bb
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741864"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="eea35-102">コレクションに関するガイドライン</span><span class="sxs-lookup"><span data-stu-id="eea35-102">Guidelines for Collections</span></span>
<span data-ttu-id="eea35-103">一般的な特性を持つオブジェクトのグループを操作するために特に設計された型はすべて、コレクションと見なすことができます。</span><span class="sxs-lookup"><span data-stu-id="eea35-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="eea35-104">ほとんどの場合、このような型は <xref:System.Collections.IEnumerable> または <xref:System.Collections.Generic.IEnumerable%601>を実装するのに適しています。したがって、このセクションでは、これらのインターフェイスのいずれかまたは両方を実装する型のみをコレクションにすることを検討します。</span><span class="sxs-lookup"><span data-stu-id="eea35-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>

 <span data-ttu-id="eea35-105">❌ は、パブリック Api で弱く型指定されたコレクションを使用しません。</span><span class="sxs-lookup"><span data-stu-id="eea35-105">❌ DO NOT use weakly typed collections in public APIs.</span></span>

 <span data-ttu-id="eea35-106">コレクションアイテムを表すすべての戻り値とパラメーターの型は、その基本型ではなく、完全な項目の種類である必要があります (これはコレクションのパブリックメンバーにのみ適用されます)。</span><span class="sxs-lookup"><span data-stu-id="eea35-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>

 <span data-ttu-id="eea35-107">❌ は、パブリック Api で <xref:System.Collections.ArrayList> または <xref:System.Collections.Generic.List%601> を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="eea35-107">❌ DO NOT use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>

 <span data-ttu-id="eea35-108">これらの型は、パブリック Api ではなく、内部実装で使用するように設計されたデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="eea35-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="eea35-109">`List<T>` は、Api と柔軟性を cleanness 使用することで、パフォーマンスと性能が最適化されています。</span><span class="sxs-lookup"><span data-stu-id="eea35-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="eea35-110">たとえば、`List<T>`を返した場合、クライアントコードがコレクションを変更したときに通知を受け取ることはできません。</span><span class="sxs-lookup"><span data-stu-id="eea35-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="eea35-111">また、`List<T>` は、多くのシナリオでは役に立たない、または適用できない多くのメンバー (<xref:System.Collections.Generic.List%601.BinarySearch%2A>など) を公開します。</span><span class="sxs-lookup"><span data-stu-id="eea35-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="eea35-112">次の2つのセクションでは、パブリック Api 専用に設計された型 (抽象化) について説明します。</span><span class="sxs-lookup"><span data-stu-id="eea35-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>

 <span data-ttu-id="eea35-113">❌ は、パブリック Api で `Hashtable` または `Dictionary<TKey,TValue>` を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="eea35-113">❌ DO NOT use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>

 <span data-ttu-id="eea35-114">これらの型は、内部実装で使用するように設計されたデータ構造体です。</span><span class="sxs-lookup"><span data-stu-id="eea35-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="eea35-115">パブリック Api では、インターフェイスの1つまたは両方を実装する <xref:System.Collections.IDictionary>、`IDictionary <TKey, TValue>`、またはカスタム型を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>

 <span data-ttu-id="eea35-116">❌ は、`GetEnumerator` メソッドの戻り値の型を除き、<xref:System.Collections.Generic.IEnumerator%601>、<xref:System.Collections.IEnumerator>、またはこれらのインターフェイスのいずれかを実装するその他の型を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="eea35-116">❌ DO NOT use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>

 <span data-ttu-id="eea35-117">`GetEnumerator` 以外のメソッドから列挙子を返す型は、`foreach` ステートメントと共に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="eea35-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>

 <span data-ttu-id="eea35-118">❌ `IEnumerator<T>` と `IEnumerable<T>` の両方を同じ型に実装することはできません。</span><span class="sxs-lookup"><span data-stu-id="eea35-118">❌ DO NOT implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="eea35-119">これは、非ジェネリックインターフェイス `IEnumerator` および `IEnumerable`にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="eea35-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>

## <a name="collection-parameters"></a><span data-ttu-id="eea35-120">コレクションパラメーター</span><span class="sxs-lookup"><span data-stu-id="eea35-120">Collection Parameters</span></span>
 <span data-ttu-id="eea35-121">✔️は、パラメーター型として可能な限り、最も特殊化されていない型を使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-121">✔️ DO use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="eea35-122">コレクションをパラメーターとして受け取るほとんどのメンバーは、`IEnumerable<T>` インターフェイスを使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>

 <span data-ttu-id="eea35-123">❌ `Count` プロパティにアクセスするためだけに、パラメーターとして <xref:System.Collections.Generic.ICollection%601> または <xref:System.Collections.ICollection> を使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="eea35-123">❌ AVOID using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>

 <span data-ttu-id="eea35-124">代わりに、`IEnumerable<T>` または `IEnumerable` を使用し、オブジェクトが `ICollection<T>` または `ICollection`を実装しているかどうかを動的に確認することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>

## <a name="collection-properties-and-return-values"></a><span data-ttu-id="eea35-125">コレクションのプロパティと戻り値</span><span class="sxs-lookup"><span data-stu-id="eea35-125">Collection Properties and Return Values</span></span>
 <span data-ttu-id="eea35-126">❌ 設定可能なコレクションプロパティを提供しません。</span><span class="sxs-lookup"><span data-stu-id="eea35-126">❌ DO NOT provide settable collection properties.</span></span>

 <span data-ttu-id="eea35-127">コレクションの内容を置き換えるには、まずコレクションをクリアしてから、新しい内容を追加します。</span><span class="sxs-lookup"><span data-stu-id="eea35-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="eea35-128">コレクション全体を置き換えることが一般的なシナリオである場合は、コレクションに `AddRange` メソッドを指定することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>

 <span data-ttu-id="eea35-129">✔️は、`Collection<T>` または `Collection<T>` のサブクラスを使用して、プロパティまたは読み取り/書き込みコレクションを表す値を返します。</span><span class="sxs-lookup"><span data-stu-id="eea35-129">✔️ DO use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>

 <span data-ttu-id="eea35-130">`Collection<T>` がいくつかの要件を満たしていない場合 (たとえば、コレクションで <xref:System.Collections.IList>を実装する必要がない場合) は、`IEnumerable<T>`、`ICollection<T>`、または <xref:System.Collections.Generic.IList%601>を実装してカスタムコレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>

 <span data-ttu-id="eea35-131"><xref:System.Collections.ObjectModel.ReadOnlyCollection%601>、`ReadOnlyCollection<T>`のサブクラス、またはまれに、読み取り専用コレクションを表すプロパティまたは戻り値の `IEnumerable<T>` を使用✔️ます。</span><span class="sxs-lookup"><span data-stu-id="eea35-131">✔️ DO use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>

 <span data-ttu-id="eea35-132">一般に、`ReadOnlyCollection<T>`をお勧めします。</span><span class="sxs-lookup"><span data-stu-id="eea35-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="eea35-133">いくつかの要件を満たしていない場合 (コレクションで `IList`を実装する必要がない場合など) は、`IEnumerable<T>`、`ICollection<T>`、または `IList<T>`を実装してカスタムコレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="eea35-134">カスタムの読み取り専用コレクションを実装する場合は、`ICollection<T>.IsReadOnly` を実装して `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="eea35-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>

 <span data-ttu-id="eea35-135">サポートするシナリオが、順方向専用イテレーションだけであることが確実な場合は、単に `IEnumerable<T>`を使用できます。</span><span class="sxs-lookup"><span data-stu-id="eea35-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>

 <span data-ttu-id="eea35-136">コレクションを直接使用するのではなく、ジェネリック基本コレクションのサブクラスの使用を検討✔️。</span><span class="sxs-lookup"><span data-stu-id="eea35-136">✔️ CONSIDER using subclasses of generic base collections instead of using the collections directly.</span></span>

 <span data-ttu-id="eea35-137">これにより、より適切な名前を使用したり、基本コレクション型に存在しないヘルパーメンバーを追加したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="eea35-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="eea35-138">これは、特に高レベルの Api に適用されます。</span><span class="sxs-lookup"><span data-stu-id="eea35-138">This is especially applicable to high-level APIs.</span></span>

 <span data-ttu-id="eea35-139">✔️、よく使用されるメソッドとプロパティから、`Collection<T>` または `ReadOnlyCollection<T>` のサブクラスを返すことを検討してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-139">✔️ CONSIDER returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>

 <span data-ttu-id="eea35-140">これにより、後でヘルパーメソッドを追加したり、コレクションの実装を変更したりできるようになります。</span><span class="sxs-lookup"><span data-stu-id="eea35-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>

 <span data-ttu-id="eea35-141">コレクションに格納されている項目に一意のキー (名前、Id など) が含まれている場合は、キー付きコレクションの使用を検討✔️。</span><span class="sxs-lookup"><span data-stu-id="eea35-141">✔️ CONSIDER using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="eea35-142">キー付きコレクションは、整数とキーの両方でインデックスを作成できるコレクションで、通常は `KeyedCollection<TKey,TItem>`から継承することによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="eea35-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>

 <span data-ttu-id="eea35-143">キー付きコレクションは、通常、メモリフットプリントが大きいため、メモリのオーバーヘッドがキーの利点よりも大きなメリットを上回る場合は使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="eea35-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>

 <span data-ttu-id="eea35-144">❌ は、コレクションのプロパティまたはコレクションを返すメソッドからは null 値を返しません。</span><span class="sxs-lookup"><span data-stu-id="eea35-144">❌ DO NOT return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="eea35-145">代わりに空のコレクションまたは空の配列を返します。</span><span class="sxs-lookup"><span data-stu-id="eea35-145">Return an empty collection or an empty array instead.</span></span>

 <span data-ttu-id="eea35-146">一般的な規則として、null と空の (0 項目) のコレクションまたは配列は同じように扱う必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>

### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="eea35-147">スナップショットとライブコレクション</span><span class="sxs-lookup"><span data-stu-id="eea35-147">Snapshots Versus Live Collections</span></span>
 <span data-ttu-id="eea35-148">ある時点の状態を表すコレクションは、スナップショットコレクションと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="eea35-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="eea35-149">たとえば、データベースクエリから返された行を含むコレクションはスナップショットです。</span><span class="sxs-lookup"><span data-stu-id="eea35-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="eea35-150">常に現在の状態を表すコレクションは、live collections と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="eea35-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="eea35-151">たとえば、`ComboBox` 項目のコレクションはライブコレクションです。</span><span class="sxs-lookup"><span data-stu-id="eea35-151">For example, a collection of `ComboBox` items is a live collection.</span></span>

 <span data-ttu-id="eea35-152">❌ は、プロパティからスナップショットコレクションを返しません。</span><span class="sxs-lookup"><span data-stu-id="eea35-152">❌ DO NOT return snapshot collections from properties.</span></span> <span data-ttu-id="eea35-153">プロパティはライブコレクションを返します。</span><span class="sxs-lookup"><span data-stu-id="eea35-153">Properties should return live collections.</span></span>

 <span data-ttu-id="eea35-154">プロパティの getter は、非常に軽量な操作である必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="eea35-155">スナップショットを返すには、O (n) 操作で内部コレクションのコピーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>

 <span data-ttu-id="eea35-156">スナップショットコレクションまたはライブ `IEnumerable<T>` (またはそのサブタイプ) のいずれかを使用して、揮発性のコレクション (つまり、コレクションを明示的に変更せずに変更できる) を表す✔️ます。</span><span class="sxs-lookup"><span data-stu-id="eea35-156">✔️ DO use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>

 <span data-ttu-id="eea35-157">一般に、共有リソース (ディレクトリ内のファイルなど) を表すすべてのコレクションは揮発性です。</span><span class="sxs-lookup"><span data-stu-id="eea35-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="eea35-158">このようなコレクションは、実装が単なる順方向専用列挙子の場合を除き、ライブコレクションとして実装するのは非常に困難または不可能です。</span><span class="sxs-lookup"><span data-stu-id="eea35-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>

## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="eea35-159">配列とコレクションの選択</span><span class="sxs-lookup"><span data-stu-id="eea35-159">Choosing Between Arrays and Collections</span></span>
 <span data-ttu-id="eea35-160">✔️は、配列に対してコレクションを優先します。</span><span class="sxs-lookup"><span data-stu-id="eea35-160">✔️ DO prefer collections over arrays.</span></span>

 <span data-ttu-id="eea35-161">コレクションを使用すると、コンテンツの制御が強化され、時間の経過と共に進化して、より使いやすくなります。</span><span class="sxs-lookup"><span data-stu-id="eea35-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="eea35-162">また、配列の複製にかかるコストが膨大であるため、読み取り専用のシナリオに配列を使用することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="eea35-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="eea35-163">使いやすさの研究では、コレクションベースの Api を使用する開発者の方が快適であることがわかりました。</span><span class="sxs-lookup"><span data-stu-id="eea35-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>

 <span data-ttu-id="eea35-164">ただし、低レベルの Api を開発している場合は、読み取り/書き込みのシナリオで配列を使用する方が適切な場合があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="eea35-165">配列のメモリフットプリントは小さくなるため、ワーキングセットを減らすことができます。また、配列内の要素へのアクセスは、ランタイムによって最適化されるため、より高速になります。</span><span class="sxs-lookup"><span data-stu-id="eea35-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>

 <span data-ttu-id="eea35-166">メモリ消費を最小限に抑え、パフォーマンスを最大化するために、低レベルの Api で配列を使用することを検討して✔️。</span><span class="sxs-lookup"><span data-stu-id="eea35-166">✔️ CONSIDER using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>

 <span data-ttu-id="eea35-167">✔️バイトのコレクションではなく、バイト配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-167">✔️ DO use byte arrays instead of collections of bytes.</span></span>

 <span data-ttu-id="eea35-168">プロパティ getter が呼び出されるたびに、プロパティが新しい配列 (内部配列のコピーなど) を返す必要がある場合は、プロパティに配列を使用 ❌。</span><span class="sxs-lookup"><span data-stu-id="eea35-168">❌ DO NOT use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>

## <a name="implementing-custom-collections"></a><span data-ttu-id="eea35-169">カスタムコレクションの実装</span><span class="sxs-lookup"><span data-stu-id="eea35-169">Implementing Custom Collections</span></span>
 <span data-ttu-id="eea35-170">新しいコレクションをデザインするときに、`Collection<T>`、`ReadOnlyCollection<T>`、または `KeyedCollection<TKey,TItem>` から継承することを検討✔️。</span><span class="sxs-lookup"><span data-stu-id="eea35-170">✔️ CONSIDER inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>

 <span data-ttu-id="eea35-171">新しいコレクションをデザインするときに `IEnumerable<T>` を実装✔️ます。</span><span class="sxs-lookup"><span data-stu-id="eea35-171">✔️ DO implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="eea35-172">`ICollection<T>` または `IList<T>` を実装することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>

 <span data-ttu-id="eea35-173">このようなカスタムコレクションを実装する場合は、`Collection<T>` によって確立された API パターンに従い、できるだけ近い方法で `ReadOnlyCollection<T>` します。</span><span class="sxs-lookup"><span data-stu-id="eea35-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="eea35-174">つまり、同じメンバーを明示的に実装し、これらの2つのコレクションのようなパラメーターに名前を付けるなどです。</span><span class="sxs-lookup"><span data-stu-id="eea35-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>

 <span data-ttu-id="eea35-175">これらのインターフェイスを入力として使用する Api にコレクションを渡すことが頻繁に行われる場合は、非ジェネリックコレクションインターフェイス (`IList` と `ICollection`) を実装する✔️を検討してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-175">✔️ CONSIDER implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>

 <span data-ttu-id="eea35-176">❌ コレクションの概念とは関係のない複雑な Api を使用して、型にコレクションインターフェイスを実装しないようにします。</span><span class="sxs-lookup"><span data-stu-id="eea35-176">❌ AVOID implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>

 <span data-ttu-id="eea35-177">❌ は、`CollectionBase`などの非ジェネリック基本コレクションから継承しません。</span><span class="sxs-lookup"><span data-stu-id="eea35-177">❌ DO NOT inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="eea35-178">代わりに `Collection<T>`、`ReadOnlyCollection<T>`、および `KeyedCollection<TKey,TItem>` 型を使用してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>

### <a name="naming-custom-collections"></a><span data-ttu-id="eea35-179">カスタムコレクションの名前付け</span><span class="sxs-lookup"><span data-stu-id="eea35-179">Naming Custom Collections</span></span>
 <span data-ttu-id="eea35-180">コレクション (`IEnumerable`を実装する型) は主に次の2つの理由で作成されます。 (1) 構造固有の操作を使用して新しいデータ構造を作成し、多くの場合、既存のデータ構造 (<xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.LinkedList%601>、<xref:System.Collections.Generic.Stack%601>など) とは異なるパフォーマンス特性を作成する (例: <xref:System.Collections.Specialized.StringCollection>)</span><span class="sxs-lookup"><span data-stu-id="eea35-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="eea35-181">データ構造は、アプリケーションとライブラリの内部実装で最もよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="eea35-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="eea35-182">特に、特化されたコレクションは Api で公開されます (プロパティとパラメーターの型として)。</span><span class="sxs-lookup"><span data-stu-id="eea35-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>

 <span data-ttu-id="eea35-183">✔️ `IDictionary` または `IDictionary<TKey,TValue>`を実装する抽象化の名前に "Dictionary" サフィックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-183">✔️ DO use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>

 <span data-ttu-id="eea35-184">✔️は、`IEnumerable` (またはその子孫) を実装し、項目のリストを表す型の名前に "Collection" サフィックスを使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-184">✔️ DO use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>

 <span data-ttu-id="eea35-185">✔️カスタムデータ構造には、適切なデータ構造名を使用します。</span><span class="sxs-lookup"><span data-stu-id="eea35-185">✔️ DO use the appropriate data structure name for custom data structures.</span></span>

 <span data-ttu-id="eea35-186">コレクションの抽象化の名前に "LinkedList" や "Hashtable" など、特定の実装を意味するサフィックスを使用しないように ❌ します。</span><span class="sxs-lookup"><span data-stu-id="eea35-186">❌ AVOID using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>

 <span data-ttu-id="eea35-187">コレクション名の前に項目の種類の名前を付けることを✔️してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-187">✔️ CONSIDER prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="eea35-188">たとえば、`Address` 型の項目を格納するコレクション (`IEnumerable<Address>`を実装する) の名前は `AddressCollection`にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="eea35-189">項目の種類がインターフェイスの場合は、項目の種類の "I" プレフィックスを省略できます。</span><span class="sxs-lookup"><span data-stu-id="eea35-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="eea35-190">したがって、<xref:System.IDisposable> 項目のコレクションを `DisposableCollection`と呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="eea35-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>

 <span data-ttu-id="eea35-191">対応する書き込み可能なコレクションが追加されているか、既にフレームワークに存在する可能性がある場合は、読み取り専用コレクションの名前に "ReadOnly" プレフィックスを使用することを✔️してください。</span><span class="sxs-lookup"><span data-stu-id="eea35-191">✔️ CONSIDER using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>

 <span data-ttu-id="eea35-192">たとえば、文字列の読み取り専用コレクションを `ReadOnlyStringCollection`と呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="eea35-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>

 <span data-ttu-id="eea35-193">*©2005、2009 Microsoft Corporation の部分。すべての権限が予約されています。*</span><span class="sxs-lookup"><span data-stu-id="eea35-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="eea35-194">*2008 年 10 月 22 日に Microsoft Windows Development シリーズの一部として、Addison-Wesley Professional によって発行された、Krzysztof Cwalina および Brad Abrams による「[Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)」 (フレームワーク デザイン ガイドライン: 再利用可能な .NET ライブラリの規則、用法、パターン、第 2 版) から Pearson Education, Inc. の許可を得て再印刷されています。*</span><span class="sxs-lookup"><span data-stu-id="eea35-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="eea35-195">参照</span><span class="sxs-lookup"><span data-stu-id="eea35-195">See also</span></span>

- [<span data-ttu-id="eea35-196">フレームワーク デザインのガイドライン</span><span class="sxs-lookup"><span data-stu-id="eea35-196">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
- [<span data-ttu-id="eea35-197">使用方法のガイドライン</span><span class="sxs-lookup"><span data-stu-id="eea35-197">Usage Guidelines</span></span>](../../../docs/standard/design-guidelines/usage-guidelines.md)
