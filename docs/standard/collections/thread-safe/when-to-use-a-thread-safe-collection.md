---
title: スレッドセーフなコレクションを使用する状況
description: .NET でスレッドセーフなコレクションを使用する状況を理解します。 マルチ スレッドの追加および削除の操作をサポートするために、5 つのコレクション型が特別に設計されています。
ms.date: 03/30/2017
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 92fb912cdd2030f87bee1109b9944e1fa857dddd
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/18/2020
ms.locfileid: "94819462"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="8b008-104">スレッドセーフなコレクションを使用する状況</span><span class="sxs-lookup"><span data-stu-id="8b008-104">When to use a thread-safe collection</span></span>

<span data-ttu-id="8b008-105">.NET Framework 4 では、マルチスレッドでの追加や削除の操作をサポートするよう特別に設計された、5 つのコレクション型が導入されました。</span><span class="sxs-lookup"><span data-stu-id="8b008-105">.NET Framework 4 introduced five collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="8b008-106">これらの型では、スレッド セーフを確保するために、さまざまな種類の効率的なロックやロック制御不要の同期機構が用いられます。</span><span class="sxs-lookup"><span data-stu-id="8b008-106">To achieve thread-safety, these types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="8b008-107">同期を行うと、操作にオーバーヘッドが加わります。</span><span class="sxs-lookup"><span data-stu-id="8b008-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="8b008-108">どれほどのオーバーヘッドが加わるかは、同期や操作の種類、およびその他の要因 (コレクションに同時にアクセスしようとするスレッドの数など) によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8b008-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="8b008-109">一部のシナリオでは、同期のオーバーヘッドがほとんどなく、外部ロックで保護される同等の非スレッドセーフ型よりもマルチスレッド型の方が、パフォーマンスとスケーラビリティが大幅に向上することがあります。</span><span class="sxs-lookup"><span data-stu-id="8b008-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="8b008-110">その他のシナリオでは、オーバーヘッドにより、スレッドセーフ型のパフォーマンスとスケーラビリティが、外部からロックされる非スレッドセーフ型と同等かそれ以下になることもあります。</span><span class="sxs-lookup"><span data-stu-id="8b008-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="8b008-111">以下のセクションでは、スレッド セーフなコレクションと、読み取り操作および書き込み操作でユーザー指定のロックを使用するスレッド セーフでない同等のコレクションの使い分けに関する一般的なガイダンスを示します。</span><span class="sxs-lookup"><span data-stu-id="8b008-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="8b008-112">パフォーマンスはさまざまな要因に左右されるため、このガイダンスは特定の状況には沿っておらず、すべての状況で有効であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="8b008-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="8b008-113">パフォーマンスが重要な場合、使用するコレクション型を判断する最適な方法は、代表的なコンピューター構成および負荷に基づいてパフォーマンスを計測することです。</span><span class="sxs-lookup"><span data-stu-id="8b008-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="8b008-114">このドキュメントでは、次の用語が使用されています。</span><span class="sxs-lookup"><span data-stu-id="8b008-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="8b008-115">*純粋プロデューサー/コンシューマー シナリオ*</span><span class="sxs-lookup"><span data-stu-id="8b008-115">*Pure producer-consumer scenario*</span></span>\
 <span data-ttu-id="8b008-116">任意のスレッドで、要素の追加または削除のいずれかが実行されますが、両方は実行されません。</span><span class="sxs-lookup"><span data-stu-id="8b008-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="8b008-117">*混合プロデューサー/コンシューマー シナリオ*</span><span class="sxs-lookup"><span data-stu-id="8b008-117">*Mixed producer-consumer scenario*</span></span>\
 <span data-ttu-id="8b008-118">任意のスレッドで、要素の追加および削除の両方が実行されます。</span><span class="sxs-lookup"><span data-stu-id="8b008-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="8b008-119">*高速化*</span><span class="sxs-lookup"><span data-stu-id="8b008-119">*Speedup*</span></span>\
 <span data-ttu-id="8b008-120">同じシナリオで別の型と比較してアルゴリズムのパフォーマンスが向上することです。</span><span class="sxs-lookup"><span data-stu-id="8b008-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="8b008-121">*拡張性*</span><span class="sxs-lookup"><span data-stu-id="8b008-121">*Scalability*</span></span>\
 <span data-ttu-id="8b008-122">コンピューターのコア数に比例したパフォーマンスの向上。</span><span class="sxs-lookup"><span data-stu-id="8b008-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="8b008-123">スケーリングするアルゴリズムのパフォーマンスは、コア数が 2 の場合よりも 8 の場合の方が向上します。</span><span class="sxs-lookup"><span data-stu-id="8b008-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="8b008-124">ConcurrentQueue(T) 対 Queue(T)</span><span class="sxs-lookup"><span data-stu-id="8b008-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="8b008-125">純粋プロデューサー/コンシューマー シナリオで、各要素の処理時間がとても短い (命令が少ない) 場合には、外部ロックを使用する<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> よりも  <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> の方が若干優れたパフォーマンスを得られます。</span><span class="sxs-lookup"><span data-stu-id="8b008-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="8b008-126">このシナリオでは、キューへの配置とキューからの取り出しをそれぞれ専用のスレッドが実行している場合に、<xref:System.Collections.Concurrent.ConcurrentQueue%601> のパフォーマンスが最大限に引き出されます。</span><span class="sxs-lookup"><span data-stu-id="8b008-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="8b008-127">この規則を強制していない場合、<xref:System.Collections.Generic.Queue%601> は、複数のコアを持つコンピューター上の <xref:System.Collections.Concurrent.ConcurrentQueue%601> よりも若干向上する場合があります。</span><span class="sxs-lookup"><span data-stu-id="8b008-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="8b008-128">処理時間が 500 FLOPS (浮動小数点演算) 以上の場合、2 つのスレッドを使用する規則は <xref:System.Collections.Concurrent.ConcurrentQueue%601> に適用されません。この型でとても優れたスケーラビリティが実現します。</span><span class="sxs-lookup"><span data-stu-id="8b008-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="8b008-129"><xref:System.Collections.Generic.Queue%601> は、このシナリオではスケーラビリティの点で劣ります。</span><span class="sxs-lookup"><span data-stu-id="8b008-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="8b008-130">混合プロデューサー/コンシューマー シナリオでは、処理時間がとても短い場合、外部ロックを使用する <xref:System.Collections.Generic.Queue%601> のスケーラビリティは <xref:System.Collections.Concurrent.ConcurrentQueue%601> よりも優れています。</span><span class="sxs-lookup"><span data-stu-id="8b008-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="8b008-131">ただし、処理時間が約 500 FLOPS 以上の場合、<xref:System.Collections.Concurrent.ConcurrentQueue%601> の方がスケーラビリティに優れます。</span><span class="sxs-lookup"><span data-stu-id="8b008-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="8b008-132">ConcurrentStack 対 Stack</span><span class="sxs-lookup"><span data-stu-id="8b008-132">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="8b008-133">純粋プロデューサー/コンシューマー シナリオで処理時間が非常に短い場合には、プッシュとポップをそれぞれ専用のスレッドで実行しているのであれば、<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> と外部ロックを使用する <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> のパフォーマンスはほぼ同じになると考えられます。</span><span class="sxs-lookup"><span data-stu-id="8b008-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="8b008-134">ただし、スレッド数が増えると、競合が増えることで両方の型のパフォーマンスが低下し、<xref:System.Collections.Generic.Stack%601> の方が <xref:System.Collections.Concurrent.ConcurrentStack%601> よりも優れたパフォーマンスを示すことがあります。</span><span class="sxs-lookup"><span data-stu-id="8b008-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="8b008-135">処理時間が約 500 FLOPS 以上の場合は、両方の型がほぼ同じスケーラビリティを示します。</span><span class="sxs-lookup"><span data-stu-id="8b008-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="8b008-136">混合プロデューサー/コンシューマー シナリオでは、ワークロードの大小にかかわらず、<xref:System.Collections.Concurrent.ConcurrentStack%601> の方が高速です。</span><span class="sxs-lookup"><span data-stu-id="8b008-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="8b008-137"><xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> と <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> を使用すると、アクセス時間が大幅に短縮される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8b008-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="8b008-138">ConcurrentDictionary 対 Dictionary</span><span class="sxs-lookup"><span data-stu-id="8b008-138">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="8b008-139">一般に、複数のスレッドから同時にキーまたは値を追加および更新するシナリオであれば、<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> を使用します。</span><span class="sxs-lookup"><span data-stu-id="8b008-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="8b008-140">更新を頻繁に行い、読み取りは比較的少ないシナリオでは、通常、<xref:System.Collections.Concurrent.ConcurrentDictionary%602> には大きな利点はありません。</span><span class="sxs-lookup"><span data-stu-id="8b008-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="8b008-141">読み取りも更新も多いシナリオでは、通常、コンピューターに任意の数のコアを備えられる場合は <xref:System.Collections.Concurrent.ConcurrentDictionary%602> の方が大幅に高速です。</span><span class="sxs-lookup"><span data-stu-id="8b008-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="8b008-142">更新を頻繁に行うシナリオでは、<xref:System.Collections.Concurrent.ConcurrentDictionary%602> でコンカレンシーの程度を上げて、コンピューターのコア数が多いほどパフォーマンスが向上するかどうかを計測できます。</span><span class="sxs-lookup"><span data-stu-id="8b008-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="8b008-143">コンカレンシー レベルを変更する場合、グローバル操作はできるだけ避けてください。</span><span class="sxs-lookup"><span data-stu-id="8b008-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="8b008-144">キーまたは値の読み取りのみを行う場合、ディクショナリがスレッドによって変更されないのであれば同期は不要なため、<xref:System.Collections.Generic.Dictionary%602> の方が高速です。</span><span class="sxs-lookup"><span data-stu-id="8b008-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="8b008-145">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="8b008-145">ConcurrentBag</span></span>  
 <span data-ttu-id="8b008-146">純粋プロデューサー/コンシューマー シナリオでは、<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> は、その他の同時実行コレクション型よりもパフォーマンスの点で劣ると考えられます。</span><span class="sxs-lookup"><span data-stu-id="8b008-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="8b008-147">混合プロデューサー/コンシューマー シナリオでは、通常、ワークロードの大小にかかわらず、<xref:System.Collections.Concurrent.ConcurrentBag%601> は他の同時実行コレクション型よりもはるかに高速でスケーラビリティに優れます。</span><span class="sxs-lookup"><span data-stu-id="8b008-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="8b008-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="8b008-148">BlockingCollection</span></span>  
 <span data-ttu-id="8b008-149">境界ブロッキング セマンティクスが必要な場合は、<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> の方がカスタム実装よりもパフォーマンスの点で優れると考えられます。</span><span class="sxs-lookup"><span data-stu-id="8b008-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="8b008-150">この型では、高度なキャンセル、列挙、および例外処理もサポートされます。</span><span class="sxs-lookup"><span data-stu-id="8b008-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8b008-151">関連項目</span><span class="sxs-lookup"><span data-stu-id="8b008-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="8b008-152">スレッドセーフなコレクション</span><span class="sxs-lookup"><span data-stu-id="8b008-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="8b008-153">並列プログラミング</span><span class="sxs-lookup"><span data-stu-id="8b008-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
