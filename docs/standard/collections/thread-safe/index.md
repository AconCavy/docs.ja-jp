---
title: スレッド セーフなコレクション
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 790543118b18b0422f41c3249512b62aae0cfb03
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/15/2020
ms.locfileid: "75938106"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="1a899-102">スレッド セーフなコレクション</span><span class="sxs-lookup"><span data-stu-id="1a899-102">Thread-Safe Collections</span></span>
<span data-ttu-id="1a899-103">.NET Framework 4 では、スレッド セーフかつスケーラブルなコレクション クラスをいくつか含む <xref:System.Collections.Concurrent?displayProperty=nameWithType> 名前空間が導入されています。</span><span class="sxs-lookup"><span data-stu-id="1a899-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="1a899-104">ユーザー コードで同期を追加することなく、複数のスレッドでこのようなコレクションの項目を安全かつ効率的に追加または削除できます。</span><span class="sxs-lookup"><span data-stu-id="1a899-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="1a899-105">新しいコードを記述する場合、コレクションに対して複数のスレッドが同時に書き込みを行うときは常に同時実行コレクション クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="1a899-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="1a899-106">共有コレクションの読み取りのみを行う場合は、<xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間のクラスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1a899-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1a899-107">.NET Framework 1.1 以前のランタイムを対象にする必要がない場合は、1.0 コレクション クラスを使用しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="1a899-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="1a899-108">.NET Framework 1.0 と 2.0 のコレクションのスレッドの同期</span><span class="sxs-lookup"><span data-stu-id="1a899-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="1a899-109">.NET Framework 1.0 で導入されたコレクションは、<xref:System.Collections?displayProperty=nameWithType> 名前空間にあります。</span><span class="sxs-lookup"><span data-stu-id="1a899-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1a899-110">一般的に使用される <xref:System.Collections.ArrayList> や <xref:System.Collections.Hashtable> を含むこのコレクションは、コレクションのスレッド セーフ ラッパーを返す `Synchronized` プロパティを通じてスレッド セーフを確保します。</span><span class="sxs-lookup"><span data-stu-id="1a899-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="1a899-111">このラッパーは、すべての追加操作または削除操作でコレクション全体をロックすることで機能します。</span><span class="sxs-lookup"><span data-stu-id="1a899-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="1a899-112">したがって、コレクションにアクセスしようとする各スレッドは、ロックを取得する順番を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1a899-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="1a899-113">これはスケーラブルではなく、大規模なコレクションの場合はパフォーマンスが大幅に低下するおそれがあります。</span><span class="sxs-lookup"><span data-stu-id="1a899-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="1a899-114">また、競合状態を完全に防ぐことはできません。</span><span class="sxs-lookup"><span data-stu-id="1a899-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="1a899-115">詳細については、「[Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer)」 (ジェネリック コレクションでの同期) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1a899-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="1a899-116">.NET Framework 2.0 で導入されたコレクション クラスは、<xref:System.Collections.Generic?displayProperty=nameWithType> 名前空間にあります。</span><span class="sxs-lookup"><span data-stu-id="1a899-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="1a899-117">これには、<xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.Dictionary%602> などがあります。</span><span class="sxs-lookup"><span data-stu-id="1a899-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="1a899-118">これらのクラスを使用すると、.NET Framework 1.0 クラスと比較して、タイプ セーフおよびパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="1a899-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="1a899-119">ただし、.NET Framework 2.0 コレクション クラスではスレッドの同期は行われません。複数のスレッドで同時に項目を追加または削除する場合は、ユーザー コードですべての同期を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="1a899-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="1a899-120">.NET Framework 4 の同時実行コレクション クラスを使用することをお勧めします。このクラスは、.NET Framework 2.0 コレクション クラスのタイプ セーフを確保するだけでなく、.NET Framework 1.0 コレクションよりも効率的で完全なスレッド セーフも確保します。</span><span class="sxs-lookup"><span data-stu-id="1a899-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="1a899-121">粒度の細かいロック機構とロック制御の不要な機構</span><span class="sxs-lookup"><span data-stu-id="1a899-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="1a899-122">同時実行コレクション型には、.NET Framework 4 の新機能である <xref:System.Threading.SpinLock>、<xref:System.Threading.SpinWait>、<xref:System.Threading.SemaphoreSlim>、<xref:System.Threading.CountdownEvent> などの軽量な同期機構を使用するものもあります。</span><span class="sxs-lookup"><span data-stu-id="1a899-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="1a899-123">これらの同期型では、通常、スレッドを実際の待機状態にする前の短期間に*ビジー スピン*が使用されます。</span><span class="sxs-lookup"><span data-stu-id="1a899-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="1a899-124">待機時間が非常に短くなると予測される場合は、スピンを使用すると、負荷がかかるカーネル遷移を伴う待機を行うよりも負荷が格段に小さくなります。</span><span class="sxs-lookup"><span data-stu-id="1a899-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="1a899-125">スピンを使用するコレクション クラスでは、この効率性は、複数のスレッドで項目を高速で追加および削除できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1a899-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="1a899-126">スピンとブロッキングの詳細については、「[SpinLock](../../../../docs/standard/threading/spinlock.md)」および「[SpinWait](../../../../docs/standard/threading/spinwait.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1a899-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="1a899-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601> クラスと <xref:System.Collections.Concurrent.ConcurrentStack%601> クラスでは、ロックは使用されません。</span><span class="sxs-lookup"><span data-stu-id="1a899-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="1a899-128">代わりに、<xref:System.Threading.Interlocked> 操作によってスレッド セーフを確保します。</span><span class="sxs-lookup"><span data-stu-id="1a899-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1a899-129">同時実行コレクション クラスでは <xref:System.Collections.ICollection> がサポートされるので、<xref:System.Collections.ICollection.IsSynchronized%2A> プロパティと <xref:System.Collections.ICollection.SyncRoot%2A> プロパティの実装が、これらのプロパティが無関係の場合でも提供されます。</span><span class="sxs-lookup"><span data-stu-id="1a899-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="1a899-130">`IsSynchronized` は常に `false` を返し、`SyncRoot` は常に `null` (Visual Basic の場合は `Nothing`) になります。</span><span class="sxs-lookup"><span data-stu-id="1a899-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="1a899-131"><xref:System.Collections.Concurrent?displayProperty=nameWithType> 名前空間に属するコレクション型を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="1a899-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="1a899-132">[種類]</span><span class="sxs-lookup"><span data-stu-id="1a899-132">Type</span></span>|<span data-ttu-id="1a899-133">[説明]</span><span class="sxs-lookup"><span data-stu-id="1a899-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="1a899-134"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601> を実装する任意の型の境界ブロッキング機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="1a899-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="1a899-135">詳細については、「[BlockingCollection の概要](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="1a899-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="1a899-136">キーと値のペアのディクショナリのスレッド セーフな実装。</span><span class="sxs-lookup"><span data-stu-id="1a899-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="1a899-137">先入れ先出し (FIFO: First In First Out) キューのスレッド セーフな実装。</span><span class="sxs-lookup"><span data-stu-id="1a899-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="1a899-138">後入れ先出し (LIFO: Last In First Out) スタックのスレッド セーフな実装。</span><span class="sxs-lookup"><span data-stu-id="1a899-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="1a899-139">要素の順序付けられていないコレクションのスレッド セーフな実装。</span><span class="sxs-lookup"><span data-stu-id="1a899-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="1a899-140">`BlockingCollection` で使用するために型が実装する必要があるインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="1a899-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="1a899-141">関連トピック</span><span class="sxs-lookup"><span data-stu-id="1a899-141">Related Topics</span></span>  
  
|<span data-ttu-id="1a899-142">タイトル</span><span class="sxs-lookup"><span data-stu-id="1a899-142">Title</span></span>|<span data-ttu-id="1a899-143">[説明]</span><span class="sxs-lookup"><span data-stu-id="1a899-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="1a899-144">BlockingCollection の概要</span><span class="sxs-lookup"><span data-stu-id="1a899-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="1a899-145"><xref:System.Collections.Concurrent.BlockingCollection%601> 型で提供される機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="1a899-146">方法: ConcurrentDictionary の項目を追加および削除する</span><span class="sxs-lookup"><span data-stu-id="1a899-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="1a899-147"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> の要素を追加および削除する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="1a899-148">方法: BlockingCollection の項目を個別に追加および取得する</span><span class="sxs-lookup"><span data-stu-id="1a899-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="1a899-149">読み取り専用の列挙子を使用せずにブロッキング コレクションの項目を追加および取得する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="1a899-150">方法: 境界ブロッキング機能をコレクションに追加する</span><span class="sxs-lookup"><span data-stu-id="1a899-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="1a899-151">任意のコレクション クラスを <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> コレクションの基になるストレージ機構として使用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="1a899-152">方法: ForEach を使用して BlockingCollection 内の項目を削除する</span><span class="sxs-lookup"><span data-stu-id="1a899-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="1a899-153">`foreach` (Visual Basic の場合は `For Each`) を使用してブロッキング コレクションのすべての項目を削除する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="1a899-154">方法: パイプラインでブロッキング コレクションの配列を使用する</span><span class="sxs-lookup"><span data-stu-id="1a899-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="1a899-155">複数のブロッキング コレクションを同時に使用してパイプラインを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="1a899-156">方法: ConcurrentBag を使用してオブジェクト プールを作成する</span><span class="sxs-lookup"><span data-stu-id="1a899-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="1a899-157">新しいオブジェクトを頻繁に作成する代わりにオブジェクトを再利用できるシナリオで、同時実行バッグを使用してパフォーマンスを向上させる方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a899-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="1a899-158">リファレンス</span><span class="sxs-lookup"><span data-stu-id="1a899-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
