---
title: gRPC ストリーミングサービスと繰り返し使用するフィールド-WCF 開発者向け gRPC
description: GRPC を使用してデータのコレクションを渡す方法として、繰り返しフィールドとストリーミングサービスを比較します。
ms.date: 09/02/2019
ms.openlocfilehash: f2f13776586607ed489c45ebb324c0c5713bed99
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/12/2019
ms.locfileid: "73966917"
---
# <a name="grpc-streaming-services-versus-repeated-fields"></a><span data-ttu-id="2fd38-103">gRPC streaming services と繰り返されるフィールド</span><span class="sxs-lookup"><span data-stu-id="2fd38-103">gRPC streaming services versus repeated fields</span></span>

<span data-ttu-id="2fd38-104">gRPC サービスには、データセットを返すための2つの方法、またはオブジェクトの一覧が用意されています。</span><span class="sxs-lookup"><span data-stu-id="2fd38-104">gRPC services provide two ways of returning datasets, or lists of objects.</span></span> <span data-ttu-id="2fd38-105">プロトコルバッファーメッセージの指定では、別のメッセージ内のメッセージのリストまたは配列を宣言するために `repeated` キーワードを使用します。</span><span class="sxs-lookup"><span data-stu-id="2fd38-105">The Protocol Buffers message specification uses the `repeated` keyword for declaring lists or arrays of messages within another message.</span></span> <span data-ttu-id="2fd38-106">GRPC サービスの仕様では、`stream` キーワードを使用して、複数のメッセージを個別に送信して処理できる、長時間実行される永続的な接続を宣言します。</span><span class="sxs-lookup"><span data-stu-id="2fd38-106">The gRPC service specification uses the `stream` keyword to declare a long-running persistent connection over which multiple messages are sent, and can be processed, individually.</span></span> <span data-ttu-id="2fd38-107">`stream` 機能は、通知やログメッセージなどの長時間実行されるテンポラルデータにも使用できますが、この章では、1つのデータセットを返すための使用方法を検討します。</span><span class="sxs-lookup"><span data-stu-id="2fd38-107">The `stream` feature can also be used for long-running temporal data such as notifications or log messages, but this chapter will consider its use for returning a single dataset.</span></span>

<span data-ttu-id="2fd38-108">使用する必要があるのは、データセット全体のサイズ、クライアントまたはサーバー側でデータセットを作成するのにかかった時間、および最初の項目が使用可能になったらすぐにデータセットのコンシューマーがアクションを開始できるかどうかなど、さまざまな要因によって異なります。またはは、役に立つすべてのデータセットを必要とします。</span><span class="sxs-lookup"><span data-stu-id="2fd38-108">Which you should use depends on various factors, such as the overall size of the dataset, the time it took to create the dataset at either the client or server end, and whether the consumer of the dataset can start acting on it as soon as the first item is available, or needs the complete dataset to do anything useful.</span></span>

## <a name="when-to-use-repeated-fields"></a><span data-ttu-id="2fd38-109">`repeated` フィールドを使用する場合</span><span class="sxs-lookup"><span data-stu-id="2fd38-109">When to use `repeated` fields</span></span>

<span data-ttu-id="2fd38-110">サイズが制限され、短時間で完全に生成できるデータセットの場合 (1 秒未満の場合など) は、通常の Protobuf メッセージで `repeated` フィールドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-110">For any dataset that is constrained in size and that can be generated in its entirety in a short time—say, under one second—you should use a `repeated` field in a regular Protobuf message.</span></span> <span data-ttu-id="2fd38-111">たとえば、e コマースシステムでは、注文内の項目のリストを作成するのは簡単であり、リストが非常に大きくなるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="2fd38-111">For example, in an e-commerce system, to build a list of items within an order is probably quick and the list won't be very large.</span></span> <span data-ttu-id="2fd38-112">`repeated` フィールドを持つ1つのメッセージを返すのは、`stream` を使用する場合よりもはるかに高速であり、ネットワークオーバーヘッドが少なくなります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-112">Returning a single message with a `repeated` field is an order of magnitude faster than using a `stream` and incurs less network overhead.</span></span>

<span data-ttu-id="2fd38-113">クライアントが処理を開始する前にすべてのデータを必要とし、データセットがメモリに構築するのに十分な大きさである場合は、サーバーのメモリにデータセットの実際の作成速度が遅い場合でも、`repeated` フィールドの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="2fd38-113">If the client needs all the data before starting to process it and the dataset is small enough to construct in memory, then consider using a `repeated` field even if the actual creation of the dataset in memory on the server is slower.</span></span>

## <a name="when-to-use-stream-methods"></a><span data-ttu-id="2fd38-114">`stream` メソッドを使用する場合</span><span class="sxs-lookup"><span data-stu-id="2fd38-114">When to use `stream` methods</span></span>

<span data-ttu-id="2fd38-115">メッセージオブジェクトが非常に大きくなる可能性があるデータセットは、ストリーミング要求または応答を使用して転送することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="2fd38-115">Datasets where the message objects are potentially very large are best transferred using streaming requests or responses.</span></span> <span data-ttu-id="2fd38-116">メモリ内に大きなオブジェクトを構築し、それをネットワークに書き込んで、リソースを解放する方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="2fd38-116">It's more efficient to construct a large object in memory, write it to the network and then free up the resources.</span></span> <span data-ttu-id="2fd38-117">このアプローチにより、サービスのスケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="2fd38-117">This approach will improve the scalability of your service.</span></span>

<span data-ttu-id="2fd38-118">同様に、制約のないサイズのデータセットをストリーム経由で送信して、メモリが不足しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-118">Similarly, datasets of unconstrained size should be sent over streams to avoid running out of memory while constructing them.</span></span>

<span data-ttu-id="2fd38-119">コンシューマーが個々の項目を個別に処理できるデータセットの場合、進行状況をエンドユーザーに示すことができる場合は、ストリームの使用を検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-119">For datasets where each individual item can be processed separately by the consumer, you should consider using a stream if it means that progress can be indicated to the end user.</span></span> <span data-ttu-id="2fd38-120">これにより、アプリケーションのパフォーマンスが低下する可能性がありますが、アプリケーションの全体的なパフォーマンスに対してバランスを取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-120">This could improve the apparent responsiveness of an application, although this should be balanced against the overall performance of the application.</span></span>

<span data-ttu-id="2fd38-121">また、ストリームが役に立つ可能性があるもう1つのシナリオは、メッセージが複数のサービスにわたって処理される場所です。</span><span class="sxs-lookup"><span data-stu-id="2fd38-121">Another scenario where streams can be useful is where a message is being processed across multiple services.</span></span> <span data-ttu-id="2fd38-122">チェーン内の各サービスが1つのストリームを返す場合、ターミナルサービス (つまり、チェーン内の最後のサービス) は、処理して元の要求元に渡すことができるメッセージを返すことができます。これは、ストリームを返すか、または結果は1つの応答メッセージになります。</span><span class="sxs-lookup"><span data-stu-id="2fd38-122">If each service in a chain returns a stream, then the terminal service (that is, the last one in the chain) can start returning messages that can be processed and passed back along the chain to the original requestor, which can either return a stream or aggregate the results into a single response message.</span></span> <span data-ttu-id="2fd38-123">このアプローチは、Map/Reduce のようなパターンに適しています。</span><span class="sxs-lookup"><span data-stu-id="2fd38-123">This approach lends itself well to patterns like Map/Reduce.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="2fd38-124">[前へ](migrate-duplex-services.md)
>[次へ](client-libraries.md)</span><span class="sxs-lookup"><span data-stu-id="2fd38-124">[Previous](migrate-duplex-services.md)
[Next](client-libraries.md)</span></span>
