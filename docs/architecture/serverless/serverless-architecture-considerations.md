---
title: サーバーレス アーキテクチャに関する考慮事項 - サーバーレス アプリ
description: 状態管理や永続的ストレージから、スケーリング、ログ記録、トレース、診断まで、サーバーレス アプリケーションを設計する際の課題について説明します。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 04/06/2020
ms.openlocfilehash: 3c07e1149e6af41a6b9a9317238e5c71015d2c4e
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135673"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="6b67f-103">サーバーレス アーキテクチャの考慮事項</span><span class="sxs-lookup"><span data-stu-id="6b67f-103">Serverless architecture considerations</span></span>

<span data-ttu-id="6b67f-104">サーバーレス アーキテクチャを採用することには、いくつかの課題が伴います。</span><span class="sxs-lookup"><span data-stu-id="6b67f-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="6b67f-105">このセクションでは、注意すべき一般的な考慮事項をいくつか説明します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="6b67f-106">これらの課題にはすべて解決策が存在します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-106">All of these challenges have solutions.</span></span> <span data-ttu-id="6b67f-107">すべてのアーキテクチャの選択肢と同様に、サーバーレスにするかどうかの決定は、長所と短所を慎重に検討した上で行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="6b67f-108">アプリケーションのニーズによっては、サーバーレス実装が特定のコンポーネントには適した解決策ではないと判断する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="6b67f-109">状態の管理</span><span class="sxs-lookup"><span data-stu-id="6b67f-109">Managing state</span></span>

<span data-ttu-id="6b67f-110">一般にマイクロサービスと同様に、サーバーレス関数は既定でステートレスです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="6b67f-111">状態を回避することで、サーバーレスを一時的なものにすることができます。また、スケールアウトし、中央障害点なしで回復性を提供することができます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="6b67f-112">状況によっては、ビジネス プロセスで状態が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="6b67f-113">プロセスに状態が必要な場合は、2 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="6b67f-114">サーバーレス以外のモデルを採用すること、または状態を提供する別のサービスとやり取りすることができます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="6b67f-115">状態を追加すると、ソリューションが複雑になり、スケーリングが難しくなり、単一障害点が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="6b67f-116">関数で状態が絶対的に必要であるかどうかを慎重に検討してください。</span><span class="sxs-lookup"><span data-stu-id="6b67f-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="6b67f-117">答えが「はい」の場合は、それでもサーバーレスで実装するのが理にかなっているのかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="6b67f-118">サーバーレスの利点を損なうことなく状態を導入するための解決策がいくつか存在します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="6b67f-119">一般的な解決策には、次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="6b67f-120">Redis などの一時的なデータ ストアまたは分散キャッシュを使用する</span><span class="sxs-lookup"><span data-stu-id="6b67f-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="6b67f-121">SQL や CosmosDB などのデータベースに状態を格納する</span><span class="sxs-lookup"><span data-stu-id="6b67f-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="6b67f-122">[Durable Functions](https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview) のようなワークフロー エンジンを使用して状態を処理する</span><span class="sxs-lookup"><span data-stu-id="6b67f-122">Handle state through a workflow engine like [durable functions](https://docs.microsoft.com/azure/azure-functions/durable/durable-functions-overview)</span></span>

<span data-ttu-id="6b67f-123">最後の行は、サーバーレスで実装することを検討しているプロセス内で、状態管理が必要であることを認識する必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="6b67f-124">実行時間の長いプロセス</span><span class="sxs-lookup"><span data-stu-id="6b67f-124">Long-running processes</span></span>

<span data-ttu-id="6b67f-125">サーバーレスの多くの利点は、プロセスが一時的なものであるということに依存します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="6b67f-126">実行時間が短いことにより、サーバーレス プロバイダーは、関数の終了時にリソースを解放し、ホスト間で関数を共有することが容易になります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="6b67f-127">ほとんどのクラウド プロバイダーでは、関数が実行可能な合計時間が約 10 分に制限されています。</span><span class="sxs-lookup"><span data-stu-id="6b67f-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="6b67f-128">プロセスにかかる時間が長くなる場合は、別の実装を検討してください。</span><span class="sxs-lookup"><span data-stu-id="6b67f-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="6b67f-129">いくつかの例外と解決策が存在します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="6b67f-130">解決策の 1 つは、プロセスを小さなコンポーネントに分割して、個々の実行に要する時間を短縮することです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="6b67f-131">依存関係が原因でプロセスが長時間実行される場合は、Durable Functions などのソリューションを使用した非同期ワークフローを検討することもできます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="6b67f-132">Durable Functions では、外部プロセスが終了するのを待機している間に、プロセスの状態が一時停止され維持されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="6b67f-133">非同期処理により、実際のプロセスの実行時間が短縮されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="6b67f-134">起動時間</span><span class="sxs-lookup"><span data-stu-id="6b67f-134">Startup time</span></span>

<span data-ttu-id="6b67f-135">サーバーレス実装で考えられる問題の 1 つは、起動時間です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="6b67f-136">リソースを節約するために、多くのサーバーレス プロバイダーは "オンデマンド" でインフラストラクチャを作成します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="6b67f-137">サーバーレス関数が一定時間の経過後にトリガーされる場合、その関数をホストするためのリソースを作成または再起動する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="6b67f-138">場合によっては、コールド スタートによって数秒の遅延が発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="6b67f-139">起動時間は、プロバイダーとサービス レベルによって異なります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="6b67f-140">アプリが正常に機能するために起動時間を最小限に抑えることが重要な場合は、いくつかの対処方法があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="6b67f-141">一部のプロバイダーでは、ユーザーはインフラストラクチャが "常にオン" になっていることを保証するサービス レベルに対して支払いを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="6b67f-142">keep-alive 機構を実装します (エンドポイントに ping を実行して、"起動状態" のままにします)。</span><span class="sxs-lookup"><span data-stu-id="6b67f-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="6b67f-143">コンテナー化された関数の手法で Kubernetes のようなオーケストレーションを使用します (ホストは既に実行されているため、新しいインスタンスの起動が非常に高速になります)。</span><span class="sxs-lookup"><span data-stu-id="6b67f-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="6b67f-144">データベースの更新と移行</span><span class="sxs-lookup"><span data-stu-id="6b67f-144">Database updates and migrations</span></span>

<span data-ttu-id="6b67f-145">サーバーレス コードの利点は、アプリケーション全体を再展開しなくても、新しい関数をリリースできることです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="6b67f-146">この利点は、リレーショナル データベースがある場合に欠点になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="6b67f-147">データベース スキーマに対する変更は、サーバーレスの更新と同期するのが困難です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="6b67f-148">不具合があるため変更をロールバックする必要がある場合は、さらに問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="6b67f-149">マイクロサービスやサーバーレス関数のベスト プラクティスは独自のデータを所有していることであるという理由の 1 つが、データ整合性です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="6b67f-150">変更は、コンピューティングとデータの 1 つの単位として展開することができます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="6b67f-151">現実には、多くのレガシ システムは、サーバーレス アーキテクチャで調整する必要がある大規模なバックエンド データベースを特徴としています。</span><span class="sxs-lookup"><span data-stu-id="6b67f-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="6b67f-152">スキーマのバージョン管理を解決するための一般的な方法は、既存のプロパティや列を決して変更せずに、新しい情報を追加することです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="6b67f-153">たとえば、Todo リストのブール値 [完了] フラグから [完了日] に移動する変更を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="6b67f-154">古いフィールドを削除するのではなく、データベースを次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="6b67f-155">新しい [完了日] フィールドを追加します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="6b67f-156">[完了] ブール値フィールドを、完了日が現在の日付より後であるかどうかを評価する計算関数に変換します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="6b67f-157">[完了] ブール値が true に設定されている場合に現在の日付を完了日として設定するトリガーを追加します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="6b67f-158">一連の変更によって、レガシ コードが "そのまま" 実行され、新しいサーバーレス関数では新しいフィールドを利用できます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="6b67f-159">サーバーレス アーキテクチャのデータの詳細については、「[分散データ管理に関する課題と解決策](../microservices/architect-microservice-container-applications/distributed-data-management.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6b67f-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="6b67f-160">スケーリング</span><span class="sxs-lookup"><span data-stu-id="6b67f-160">Scaling</span></span>

<span data-ttu-id="6b67f-161">サーバーレスは "サーバーなし" を意味するという誤解がよくあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="6b67f-162">実際には、"少ないサーバー" です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-162">It's in fact "less server."</span></span> <span data-ttu-id="6b67f-163">スケーリングに関しては、バッキング ンフラストラクチャが重要であることを理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="6b67f-164">ほとんどのサーバーレス プラットフォームでは、イベント密度が増加したときにインフラストラクチャがどのようにスケーリングされる必要があるのかを処理するコントロールのセットが提供されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="6b67f-165">さまざまなオプションから選択できますが、その方法は関数によって異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="6b67f-166">さらに、関数は通常関連するホストで実行されるので、同じホスト上の関数のスケール オプションは同じになります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="6b67f-167">そのため、スケール要件に基づいてホストされる関数を整理し、実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="6b67f-168">多くの場合、スケールアップ (ホスト リソースの増加) とスケールアウト (ホスト インスタンスの数の増加) の方法が、さまざまなパラメーターに基づいてルールで指定されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="6b67f-169">スケールのトリガーには、スケジュール、要求レート、CPU 使用率、メモリ使用量などがあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="6b67f-170">多くの場合、高パフォーマンスはコストが高くなります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="6b67f-171">コストが安く、使用量ベースの方法の場合、要求レートが突然増加した場合にはすぐにはスケーリングされないことがあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="6b67f-172">前払いの "保険コスト" を支払うことと、"従量課金制" で厳密に支払い需要が急激に増加することによる応答速度の低下のリスクを負うことの間で、トレードオフが存在します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="6b67f-173">監視、トレース、およびログ記録</span><span class="sxs-lookup"><span data-stu-id="6b67f-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="6b67f-174">DevOps の見落としがちな側面に、展開されたアプリケーションの監視があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="6b67f-175">サーバーレス関数を監視するための戦略を用意することが重要です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="6b67f-176">最大の課題は、多くの場合、ユーザーが同じ操作の一部として複数の関数を呼び出すときの、相関関係、または認識です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="6b67f-177">ほとんどのサーバーレス プラットフォームでは、サードパーティ製ツールにインポートできるコンソールのログ記録を使用できます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="6b67f-178">詳細な分析情報を提供するための、テレメトリの収集の自動化、関連付け ID の生成と追跡、および特定のアクションの監視オプションもあります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="6b67f-179">Azure には、監視と分析のための高度な [Application Insights プラットフォーム](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)が用意されています。</span><span class="sxs-lookup"><span data-stu-id="6b67f-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="6b67f-180">サービス間の依存関係</span><span class="sxs-lookup"><span data-stu-id="6b67f-180">Inter-service dependencies</span></span>

<span data-ttu-id="6b67f-181">サーバーレス アーキテクチャには、他の関数に依存する関数が含まれている場合があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="6b67f-182">実際、サーバーレス アーキテクチャでは、相互作用または分散トランザクションの一部として複数のサービスが相互に呼び出されることは珍しくありません。</span><span class="sxs-lookup"><span data-stu-id="6b67f-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="6b67f-183">密接な結びつきを避けるために、サービスは互いに直接参照しないことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6b67f-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="6b67f-184">サービスのエンドポイントを変更する必要がある場合、直接参照によって大幅なリファクタリングが行われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="6b67f-185">推奨される解決策は、要求の種類に対して適切なエンドポイントを提供する、レジストリなどのサービス検出メカニズムを提供することです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="6b67f-186">もう 1 つの解決策は、サービス間の通信に関するキューやトピックなどのメッセージング サービスを利用することです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="6b67f-187">障害の管理と回復性の提供</span><span class="sxs-lookup"><span data-stu-id="6b67f-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="6b67f-188">*サーキット ブレーカー パターン*を考慮することも重要です。何らかの理由でサービスが継続的に失敗する場合は、そのサービスを繰り返し呼び出すことはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="6b67f-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="6b67f-189">代わりに、代替サービスが呼び出されるか、依存するサービスの正常性が再確立されるまでメッセージが返されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="6b67f-190">サーバーレス アーキテクチャでは、サービス間の依存関係を解決および管理するための戦略を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="6b67f-191">サーキット ブレーカー パターンを継続するには、サービスがフォールト トレランスと回復性を備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="6b67f-192">フォールト トレランスとは、予期しない例外が発生した場合や無効な状態が検出された場合でも、アプリケーションの実行を継続する能力を指します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="6b67f-193">フォールト トレランスは、通常コード自体の機能であり、例外を処理するためにどのように記述されているかを示します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="6b67f-194">回復性とは、アプリが障害から回復する能力を指します。</span><span class="sxs-lookup"><span data-stu-id="6b67f-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="6b67f-195">回復性は多くの場合、サーバーレス プラットフォームによって管理されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="6b67f-196">既存のサーバーに障害が発生した場合、プラットフォームは新しいサーバーレス関数インスタンスを起動できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="6b67f-197">また、プラットフォームは、新しいインスタンスがすべて失敗する場合に、新しいインスタンスの起動を停止できるインテリジェンスも備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="6b67f-198">詳細については、「[サーキット ブレーカー パターンを実装する](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6b67f-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="6b67f-199">バージョン管理とグリーン/ブルー展開</span><span class="sxs-lookup"><span data-stu-id="6b67f-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="6b67f-200">サーバーレスの大きな利点は、アプリケーション全体を再展開しなくても、特定の関数をアップグレードできることです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="6b67f-201">アップグレードを正常に実行するには、関数を呼び出すサービスが正しいバージョンのコードにルーティングされるように、関数をバージョン管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="6b67f-202">新しいバージョンを展開するための戦略も重要です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="6b67f-203">一般的な方法は、"グリーン/ブルー展開" を使用することです。</span><span class="sxs-lookup"><span data-stu-id="6b67f-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="6b67f-204">グリーン展開は、現在の関数です。</span><span class="sxs-lookup"><span data-stu-id="6b67f-204">The green deployment is the current function.</span></span> <span data-ttu-id="6b67f-205">新しい "ブルー" バージョンが運用環境に展開され、テストされます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="6b67f-206">テストに合格すると、新しいバージョンが公開されるように、グリーンとブルーのバージョンが交換されます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="6b67f-207">問題が発生した場合は、交換を元に戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="6b67f-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="6b67f-208">バージョン管理とグリーン/ブルー展開をサポートするには、バージョンの変更に対応する関数を作成し、サーバーレス プラットフォームを使用して展開を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6b67f-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="6b67f-209">[前へ](serverless-architecture.md)
>[次へ](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="6b67f-209">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
