---
title: アーキテクチャアプローチ-サーバーレスアプリ
description: N 層アーキテクチャからサーバーレスにクラウドベースのエンタープライズアプリケーションを構築するためのアーキテクチャのアプローチについて説明します。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: ee529abd1f6955d4f542464dd9a2380dd663571f
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/30/2019
ms.locfileid: "69577805"
---
# <a name="architecture-approaches"></a>アーキテクチャのアプローチ

エンタープライズアプリケーションを設計するために既存のアプローチを理解することは、サーバレスで果たす役割を明確にするのに役立ちます。 ソフトウェア開発は何十年にも渡って進化を遂げた多くのアプローチとパターンがあり、すべてがそれぞれ長所と短所を持っています。 多くの場合、究極のソリューションは、単一のアプローチを決定するのではなく、いくつかのアプローチを統合することになるかもしれません。 移行シナリオでは、あるアーキテクチャのアプローチから、ハイブリッドなアーキテクチャーのアプローチへのシフトすることがしばしばあります。

この章では、エンタープライズアプリケーションの論理アーキテクチャ パターンと物理アーキテクチャ パターンの概要を説明します。

## <a name="architecture-patterns"></a>アーキテクチャーパターン

最新のビジネスアプリケーションは、さまざまなアーキテクチャーパターンに従っています。 ここでは、一般的なパターンの調査について説明します。 ここで示したパターンでは、必ずしもすべてのベストプラクティスはありませんが、さまざまな方法を示しています。

詳細については、「 [Azure アプリケーションアーキテクチャガイド](https://docs.microsoft.com/azure/architecture/guide/)」を参照してください。

## <a name="monoliths"></a>モノリス

多くのビジネスアプリケーションは、モノリスパターンに従っています。 レガシーアプリケーションは、モノリスに実装されていることがよくあります。 モノリスパターンでは、アプリケーションが1つのデプロイに含まれていることが問題です。 データベースの呼び出しからユーザーインターフェースまですべてが、同じコードベースに含まれています。

![モノリスアーキテクチャ](./media/monolith-architecture.png)

モノリスのアプローチにもいくつかの利点はあります。 1つのコードベースをプルして作業を開始するのは簡単です。 構築時間は短縮され、テスト環境の作成は新しいコピーを提供するのと同じくらいシンプルです。 モノリスは、複数のコンポーネントまたはアプリケーションを含むように設計されています。

残念なことに、モノリスパターンはスケールで破綻する傾向があります。 モノリスのアプローチの主な欠点は次のとおりです。

* 同じコードベースで並列して作業するのは困難
* どんな些細な変更でも、アプリケーション全体を新しいバージョンにデプロイする必要がある
* リファクタリングは、潜在的にアプリケーション全体に影響を及ぼす
* 多くの場合、スケールする唯一のソリューションは、リソースが集約されたモノリスのコピーを複数作ることです。
* システムの拡張や他システムとの結合といったインテグレーションは難しい可能性があります。
* テストは、モノリス全体の構成をする必要があるため難しい可能性があります。
* コードの再利用は困難であり、多くの場合、他のアプリは元のコードのコピーを持つことになります。

多くの企業は、モノリスのアプリケーションを移行する機会としてクラウドに注目し、同時により有用なパターンにリファクタリングします。 個々のアプリケーションやコンポーネントを切り離して、個別に保守、デプロイ、およびスケーリングできるようにするのが一般的です。

## <a name="n-layer-applications"></a>N層アプリケーション

N層アプリケーションは、アプリケーションのロジックを特定のレイヤーに分けます。 最も一般的なレイヤーは次の通りです。

* ユーザーインターフェイス
* ビジネスロジック
* データアクセス

他の層には、ミドルウェア、バッチ処理、および API が含まれるでしょう。 レイヤーは論理的であることに注意することが重要です。 それらは独立して開発されますが、すべて同じターゲットプラットフォームに展開されることがあります。

![N 層アーキテクチャ](./media/n-layer-architecture.png)

N層のアプローチには、次のようないくつかの利点があります。

* リファクタリングは、レイヤーで分離されます。
* チームは、分離しているレイヤー個々に、ビルド、テスト、デプロイ、および保守することができます。
* レイヤーをスワップすることができます。例えば、データレイヤーは、UIレイヤーを変更することなく、複数のデータベースにアクセスすることができます。

サーバーレスは、1つまたは複数のレイヤーを実装できます。

## <a name="microservices"></a>マイクロサービス

**[マイクロ サービス](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/microservices)** アーキテクチャは、次のような一般的な特徴があります。

* アプリケーションはいくつかの小さなサービスで構成されます。
* 各サービスは独自のプロセスで実行されます。
* 各サービスはビジネスドメインを中心に配置されます。
* 各サービスは軽量の API を介して通信されます。トランスポートとして HTTP がよく使用されます。
* 各サービスは個別にデプロイおよびアップグレードできます。
* 各サービスが単一のデータストアには依存しません。
* システムはエラーを考慮して設計されており、特定のサービスに失敗しても、そのアプリは動作するようになっています。

マイクロサービスは、他のアーキテクチャのアプローチと相互に排他的である必要はありません。 例えばN層アーキテクチャでは、中間層にマイクロサービスを利用することができます。 IIS ホスト上の仮想ディレクトリからコンテナーまで、様々な方法でマイクロサービスの実装が可能です。 マイクロサービスの特性は、サーバーレス実装に特に適しています。

![マイクロサービス アーキテクチャ](./media/microservices-architecture.png)

マイクロサービス アーキテクチャの利点は次のとおりです。

* リファクタリングは、単一のサービスごとに分離できます。
* 各サービスは互いに独立してアップグレードできます。
* 回復性と弾力性は、各サービスの要求に合わせて調整することができます。
* 開発は、異なるチームや異なるプラットフォーム間で並行して行われます。
* サービスが分離されていることで、包括的なテストの記述が容易です。

マイクロサービスには、以下のような課題があります。

* 利用可能なサービスとその呼び出し方法の決定
* 各サービスのライフサイクルの管理
* 各サービスがどのようにアプリケーション全体にフィットするかの理解
* 異なるサービス間で行われた呼び出しの完全なシステムテスト

最終的には、後述するサーバーレスの利点を活用するなど、これらすべての課題に対処するためのソリューションがあります。

>[!div class="step-by-step"]
>[前へ](index.md)
>[次へ](architecture-deployment-approaches.md)
