---
title: API ゲートウェイ パターンと、クライアントからマイクロサービスへの直接通信との比較
description: API ゲートウェイ パターンと、クライアントからマイクロサービスへの直接通信との相違点およびそれぞれの用途について説明します。
ms.date: 01/07/2019
ms.openlocfilehash: 47e9a383c1fcb6c9fec38cb376b60a4ab839077d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401557"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="208f9-103">API ゲートウェイ パターンと、クライアントからマイクロサービスへの直接通信との比較</span><span class="sxs-lookup"><span data-stu-id="208f9-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="208f9-104">マイクロサービス アーキテクチャでは、各マイクロサービスによって (通常) 細かいエンドポイントのセットが公開されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="208f9-105">このセクションの説明のとおり、このことがクライアントからマイクロサービスへの通信に影響する場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="208f9-106">クライアントからマイクロサービスへの直接通信</span><span class="sxs-lookup"><span data-stu-id="208f9-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="208f9-107">クライアントからマイクロサービスへの直接通信アーキテクチャを使用する方法が考えられます。</span><span class="sxs-lookup"><span data-stu-id="208f9-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="208f9-108">この方法では、図 4-12 に示すように、クライアント アプリは一部のマイクロサービスに直接要求することができます。</span><span class="sxs-lookup"><span data-stu-id="208f9-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![クライアントからマイクロサービスへの通信アーキテクチャを示す図。](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="208f9-110">**図 4-12**.</span><span class="sxs-lookup"><span data-stu-id="208f9-110">**Figure 4-12**.</span></span> <span data-ttu-id="208f9-111">クライアントからマイクロサービスへの直接通信アーキテクチャの使用</span><span class="sxs-lookup"><span data-stu-id="208f9-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="208f9-112">この方法では、各マイクロサービスにパブリック エンドポイントがあり、マイクロサービスごとに異なる TCP ポートがある場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="208f9-113">特定のサービスの URL の例として、Azure での URL を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="208f9-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="208f9-114">クラスターに基づく運用環境では、その URL がクラスターで使用されるロード バランサーにマップされ、その後、マイクロサービス全体に要求が分散されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="208f9-115">運用環境では、マイクロサービスとインターネット間で [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) などのアプリケーション配信コントローラー (ADC) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="208f9-116">これは、負荷分散を実行するだけでなく、SSL 終了を提供することにより、サービスをセキュリティで保護する透過層として機能します。</span><span class="sxs-lookup"><span data-stu-id="208f9-116">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="208f9-117">CPU 負荷の高い SSL 終了と他のルーティング作業を Azure Application Gateway にオフロードすることで、ホストの負荷が改善されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-117">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="208f9-118">いずれの場合も、論理アプリケーション アーキテクチャの観点からロード バランサーと ADC は透過的となります。</span><span class="sxs-lookup"><span data-stu-id="208f9-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="208f9-119">マイクロサービス ベースの小さなアプリケーションの場合、特にクライアント アプリが ASP.NET MVC アプリなどのサーバー側の Web アプリケーションである場合はクライアントからマイクロサービスへの直接通信アーキテクチャで十分です。</span><span class="sxs-lookup"><span data-stu-id="208f9-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="208f9-120">ただし、マイクロサービス ベースの大きい複雑なアプリケーションをビルドする場合 (たとえば、多数の種類のマイクロサービスを処理する場合) と、特にクライアント アプリがリモート モバイル アプリまたは SPA Web アプリケーションである場合、この方法ではいくつかの問題に直面します。</span><span class="sxs-lookup"><span data-stu-id="208f9-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="208f9-121">マイクロサービスに基づいて大きなアプリケーションを開発する際には、以下の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="208f9-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="208f9-122">*クライアント アプリではバックエンドへの要求数をどのように最小化し、複数のマイクロサービスへの頻繁な通信をどのように減らすことができるか*</span><span class="sxs-lookup"><span data-stu-id="208f9-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="208f9-123">1 つの UI 画面をビルドするために複数のマイクロサービスと対話することは、インターネット上のラウンド トリップの数を増加させます。</span><span class="sxs-lookup"><span data-stu-id="208f9-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="208f9-124">これにより、UI 側の待機時間と複雑さが増します。</span><span class="sxs-lookup"><span data-stu-id="208f9-124">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="208f9-125">理想を言えば、サーバー側で応答を効率的に集約する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="208f9-126">そうすれば、複数のデータ片が並列に返され、一部の UI では準備ができしだいデータを表示できるため、待機時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="208f9-126">This reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="208f9-127">*承認、データ変換、動的な要求のディスパッチなど、横断的な問題をどのように処理できるか*</span><span class="sxs-lookup"><span data-stu-id="208f9-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="208f9-128">すべてのマイクロサービスでのセキュリティと承認などのセキュリティと横断的な問題の実装には、開発作業がかなり必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="208f9-129">考えられる 1 つの方法は、それらのサービスを Docker ホストまたは内部クラスター内に配置して外部からの直接アクセスを制限し、API ゲートウェイなどの中央の場所からそうした横断的な問題を実装することです。</span><span class="sxs-lookup"><span data-stu-id="208f9-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="208f9-130">*クライアント アプリは非インターネット対応プロトコルを使用するサービスとどのように通信できるのか*</span><span class="sxs-lookup"><span data-stu-id="208f9-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="208f9-131">サーバー側で使用されるプロトコル (AMQP やバイナリ プロトコルなど) は、通常、クライアント アプリではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="208f9-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="208f9-132">そのため、要求は HTTP/HTTPS などのプロトコル経由で実行し、その後、他のプロトコルに変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="208f9-133">このような状況では*中間者* 方法が役立つ場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="208f9-134">*モバイル アプリ専用のファサードはどのように形成できるのか*</span><span class="sxs-lookup"><span data-stu-id="208f9-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="208f9-135">複数のマイクロサービスの API は、さまざまなクライアント アプリケーションのニーズに合わせて適切に設計されていない場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="208f9-136">たとえば、モバイル アプリのニーズは、Web アプリのニーズとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="208f9-137">モバイル アプリでは、データ応答をより効率的にできるようにさらに最適化する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="208f9-138">この操作は、複数のマイクロサービスからデータを集約し、単一のデータ セットを返し、場合によってはモバイル アプリには必要のない応答内のデータを排除することで行うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="208f9-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="208f9-139">また、当然ながら、そのデータを圧縮する場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="208f9-140">モバイル アプリとマイクロサービス間の API またはファサードはこのシナリオでも便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="208f9-141">クライアントからマイクロサービスへの直接通信の代わりに API ゲートウェイを検討する理由</span><span class="sxs-lookup"><span data-stu-id="208f9-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="208f9-142">マイクロサービス アーキテクチャでは、通常、クライアント アプリは複数のマイクロサービスからの機能を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="208f9-143">その使用が直接行われる場合、クライアントは、マイクロサービス エンドポイントの呼び出しを数多く処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="208f9-144">アプリが進化して、新しいマイクロサービスが導入されたり既存のマイクロサービスが更新されるとどうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="208f9-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="208f9-145">アプリに対して多数のマイクロサービスがある場合、クライアント アプリから膨大な数のエンドポイントを処理するのは大変な作業になります。</span><span class="sxs-lookup"><span data-stu-id="208f9-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="208f9-146">クライアント アプリはそれらの内部エンドポイントと結合されるので、将来マイクロサービスが進化するとクライアント アプリに大きな影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="208f9-147">したがって、マイクロサービス ベースのアプリケーションでは、中間レベルまたは間接層 (ゲートウェイ) を導入すると非常に便利です。</span><span class="sxs-lookup"><span data-stu-id="208f9-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be very convenient for microservice-based applications.</span></span> <span data-ttu-id="208f9-148">API ゲートウェイを設置しないと、クライアント アプリはマイクロサービスに要求を直接送信しなければならず、それによって次のような問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="208f9-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="208f9-149">**結合**: API ゲートウェイ パターンがないと、クライアント アプリは内部マイクロサービスと結合されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="208f9-150">クライアント アプリでは、アプリケーションのさまざまな領域がマイクロサービスにどのように分解されたかを把握する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="208f9-151">内部マイクロサービスを進化させてリファクタリングするときに、そのようなアクションは、クライアント アプリから内部マイクロサービスへの直接参照によってクライアント アプリに対する変更が中断される原因となるため、メンテナンスにかなりの悪影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="208f9-151">When evolving and refactoring the internal microservices, those actions impact maintenance pretty badly because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="208f9-152">クライアント アプリには頻繁な更新が必要なので、ソリューションの進化が困難になります。</span><span class="sxs-lookup"><span data-stu-id="208f9-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="208f9-153">**膨大な数のラウンド トリップ**: クライアント アプリの 1 つのページ/画面のために、複数のサービスを何回も呼び出す必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="208f9-154">その結果、クライアントとサーバー間のネットワーク ラウンド トリップが多くなり、待機時間が大幅に長くなることがあります。</span><span class="sxs-lookup"><span data-stu-id="208f9-154">That can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="208f9-155">中間レベルで処理される集約によって、クライアント アプリのパフォーマンスとユーザー エクスペリエンスを向上できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="208f9-156">**セキュリティ上の問題**: ゲートウェイがない場合、すべてのマイクロサービスが "外の世界" に対して公開されることになり、クライアント アプリで直接使用されない内部マイクロサービスを非表示にした場合よりも攻撃サーフェスが大きくなります。</span><span class="sxs-lookup"><span data-stu-id="208f9-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="208f9-157">攻撃サーフェスが小さいほど、アプリケーションの安全性は高くなります。</span><span class="sxs-lookup"><span data-stu-id="208f9-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="208f9-158">**横断的な問題**: パブリックに公開される各マイクロサービスは、承認、SSL などの横断的な問題を処理する必要があります。多くの場合、これらの問題を 1 つの層で処理することができるため、内部マイクロサービスが単純化されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization, SSL, etc. In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="208f9-159">API ゲートウェイ パターンとは</span><span class="sxs-lookup"><span data-stu-id="208f9-159">What is the API Gateway pattern?</span></span>

<span data-ttu-id="208f9-160">複数のクライアント アプリを持つマイクロサービス ベースの大きく複雑なアプリケーションを設計してビルドする場合、[API ゲートウェイ](https://microservices.io/patterns/apigateway.html)の使用を検討することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="208f9-160">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="208f9-161">これは、特定のマイクロサービス グループに対して単一のエントリ ポイントを提供するサービスです。</span><span class="sxs-lookup"><span data-stu-id="208f9-161">This is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="208f9-162">オブジェクト指向設計の[ファサード パターン](https://en.wikipedia.org/wiki/Facade_pattern)に似ていますが、この場合は分散システムの一部となります。</span><span class="sxs-lookup"><span data-stu-id="208f9-162">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="208f9-163">API ゲートウェイ パターンは、クライアント アプリのニーズを考えながらビルドするため、"backend for frontend" [(BFF)](https://samnewman.io/patterns/architectural/bff/) と呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="208f9-163">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="208f9-164">したがって、API ゲートウェイはクライアント アプリとマイクロサービスの間に位置します。</span><span class="sxs-lookup"><span data-stu-id="208f9-164">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="208f9-165">リバース プロキシとして機能し、クライアントからサービスへと要求をルーティングします。</span><span class="sxs-lookup"><span data-stu-id="208f9-165">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="208f9-166">また、認証、SSL 終了、キャッシュといった追加の横断的な機能も提供できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-166">It can also provide additional cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="208f9-167">図 4-13 は、いくつかのマイクロサービスのみを含む簡略化されたマイクロサービス ベースのアーキテクチャに、カスタム API ゲートウェイを組み込む方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="208f9-167">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![カスタム サービスとして実装された API ゲートウェイを示す図。](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="208f9-169">**図 4-13**.</span><span class="sxs-lookup"><span data-stu-id="208f9-169">**Figure 4-13**.</span></span> <span data-ttu-id="208f9-170">カスタム サービスとして実装された API ゲートウェイの使用</span><span class="sxs-lookup"><span data-stu-id="208f9-170">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="208f9-171">アプリは、個々のマイクロサービスに要求を転送するように構成された 1 つのエンドポイント (API ゲートウェイ) に接続します。</span><span class="sxs-lookup"><span data-stu-id="208f9-171">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="208f9-172">この例では、API ゲートウェイは、コンテナーとして実行されるカスタム ASP.NET Core WebHost サービスとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-172">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="208f9-173">この図では、複数の異なるクライアント アプリに接続されている単一のカスタム API ゲートウェイ サービスを使用していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="208f9-173">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="208f9-174">クライアント アプリからの多くのさまざまな要件に基づいて API ゲートウェイ サービスが拡大し、進化するため、このことが重要なリスクになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-174">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="208f9-175">最終的に、これらのさまざまなニーズにより肥大化し、実際はモノシリック アプリケーションまたはモノシリック サービスにとてもよく似たものになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-175">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="208f9-176">そのため、API ゲートウェイを複数のサービスまたは複数のより小さい API ゲートウェイ (たとえば、クライアント アプリのフォーム ファクターの種類ごとに 1 つ) に分割することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="208f9-176">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="208f9-177">API ゲートウェイ パターンを実装するときには注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="208f9-177">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="208f9-178">通常は、単一の API ゲートウェイでアプリケーションの内部マイクロサービスをすべて集約することはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="208f9-178">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="208f9-179">これを行うと、モノシリック アグリゲーターまたはオーケストレーターとして機能し、すべてのマイクロサービスを結合することでマイクロサービスの自律性を侵害することになります。</span><span class="sxs-lookup"><span data-stu-id="208f9-179">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="208f9-180">そのため、API ゲートウェイはビジネス境界とクライアント アプリに基づいて分離する必要があり、すべての内部マイクロサービスに対する単一のアグリゲーターとして機能しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-180">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="208f9-181">API ゲートウェイ層を複数の API ゲートウェイに分割するとき、ご利用のアプリケーションが複数のクライアント アプリを備えている場合は、それを複数の API ゲートウェイの種類を区別する際の第一の軸とすることで、各クライアント アプリのニーズに合わせた異なるファサードを用意できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-181">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="208f9-182">このケースは "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) と呼ばれるパターンです。次の図に示すように、このパターンでは、複数の内部マイクロサービスを裏で呼び出す特定のアダプター コードを実装することにより、各 API ゲートウェイが (クライアント フォーム ファクター ベースであっても) クライアント アプリの種類ごとに調整された異なる API を提供できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-182">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![複数のカスタム API ゲートウェイを示す図。](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="208f9-184">**図 4-13.1**.</span><span class="sxs-lookup"><span data-stu-id="208f9-184">**Figure 4-13.1**.</span></span> <span data-ttu-id="208f9-185">複数のカスタム API ゲートウェイの使用</span><span class="sxs-lookup"><span data-stu-id="208f9-185">Using multiple custom API Gateways</span></span>

<span data-ttu-id="208f9-186">図 4-13.1 は、クライアントの種類別に分離された API ゲートウェイを示します。1 つはモバイル クライアント用で、もう 1 つは Web クライアント用です。</span><span class="sxs-lookup"><span data-stu-id="208f9-186">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="208f9-187">従来の Web アプリは、Web API ゲートウェイを使用する MVC マイクロサービスに接続されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-187">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="208f9-188">この例は、複数の粒度の API ゲートウェイを使用した簡素化されたアーキテクチャを示しています。</span><span class="sxs-lookup"><span data-stu-id="208f9-188">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="208f9-189">このケースでは、各 API ゲートウェイに対して指定された境界は純粋に "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) パターンに基づくものであり、したがって、各クライアント アプリで必要とされる API にのみ基づいています。</span><span class="sxs-lookup"><span data-stu-id="208f9-189">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="208f9-190">しかし、より大規模なアプリケーションではさらに、設計の第二の軸としてビジネス境界に基づく追加の API ゲートウェイを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-190">But in larger applications you should also go further and create additional API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="208f9-191">API ゲートウェイ パターンの主な機能</span><span class="sxs-lookup"><span data-stu-id="208f9-191">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="208f9-192">API ゲートウェイではさまざまな機能が提供されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-192">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="208f9-193">提供される機能の幅は製品によって異なりますが、すべての API ゲートウェイにとって最も重要かつ基本的な機能は次の設計パターンです。</span><span class="sxs-lookup"><span data-stu-id="208f9-193">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="208f9-194">**リバース プロキシ/ゲートウェイ ルーティング。**</span><span class="sxs-lookup"><span data-stu-id="208f9-194">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="208f9-195">API ゲートウェイは、マイクロサービスのエンドポイントに要求をリダイレクト/ルーティングする (レイヤー 7 ルーティング、通常は HTTP 要求) ためのリバース プロキシを提供します。</span><span class="sxs-lookup"><span data-stu-id="208f9-195">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="208f9-196">ゲートウェイはクライアント アプリ用に 1 つのエンドポイントまたは URL を提供し、要求を内部マイクロサービスのグループに内部的にマッピングします。</span><span class="sxs-lookup"><span data-stu-id="208f9-196">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="208f9-197">このルーティング機能は、クライアント アプリをマイクロサービスから分離するのに役立つだけでなく、モノリシック API とクライアント アプリの間に API ゲートウェイを設置してモノリシック API を刷新するときにも非常に便利です。将来多数のマイクロサービスに分割されるまでの間従来のモノリシック API を使い続けながら、新しい API を新しいマイクロサービスとして追加できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-197">This routing feature helps to decouple the client apps from the microservices but it's also pretty convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="208f9-198">API ゲートウェイがあるため、クライアント アプリは、使用されている API が内部マイクロサービスとして実装されているのか、モノリシック API として実装されているのかを関知しません。さらに重要なことに、モノリシック API をマイクロサービスに進化させてリファクタリングするときに、API ゲートウェイのルーティングのおかげでクライアント アプリが URI 変更の影響を受けずに済みます。</span><span class="sxs-lookup"><span data-stu-id="208f9-198">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="208f9-199">詳細については、「[ゲートウェイ ルーティング パターン](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="208f9-199">For more information, see [Gateway routing pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="208f9-200">**要求の集約。**</span><span class="sxs-lookup"><span data-stu-id="208f9-200">**Requests aggregation.**</span></span> <span data-ttu-id="208f9-201">ゲートウェイ パターンの一部として、複数の内部マイクロサービスに対する複数のクライアント要求 (通常は HTTP 要求) を 1 つのクライアント要求に集約することができます。</span><span class="sxs-lookup"><span data-stu-id="208f9-201">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="208f9-202">このパターンは特に、クライアントのページ/画面が複数のマイクロサービスからの情報を必要とする場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="208f9-202">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="208f9-203">この方法では、クライアント アプリが API ゲートウェイに 1 つの要求を送信します。API ゲートウェイは内部マイクロサービスに複数の要求をディスパッチし、結果を集約し、すべてをクライアント アプリに送り返します。</span><span class="sxs-lookup"><span data-stu-id="208f9-203">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="208f9-204">この設計パターンの主な利点と目的は、クライアント アプリとバックエンド API 間の頻繁な通信を削減することです。これは、マイクロサービスが置かれているデータセンターの外にあるリモート アプリ (モバイル アプリや、クライアントのリモート ブラウザー内の Javascript から送信された SPA アプリからの要求など) において特に重要です。</span><span class="sxs-lookup"><span data-stu-id="208f9-204">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from Javascript in client remote browsers.</span></span> <span data-ttu-id="208f9-205">サーバー環境で要求を実行する通常の Web アプリ (ASP.NET Core MVC Web アプリ) の場合は、リモート クライアント アプリよりも待機時間がはるかに短いため、このパターンはそれほど重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="208f9-205">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="208f9-206">使用する API ゲートウェイ製品によっては、この集約を実行できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-206">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="208f9-207">しかし、API ゲートウェイのスコープに基づいてマイクロサービスの集約を作成する方が柔軟性が高いため、多くの場合はコード (C# コード) で集約を定義します。</span><span class="sxs-lookup"><span data-stu-id="208f9-207">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="208f9-208">詳細については、「[ゲートウェイ集約パターン](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="208f9-208">For more information, see [Gateway aggregation pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="208f9-209">**横断的な問題またはゲートウェイのオフロード。**</span><span class="sxs-lookup"><span data-stu-id="208f9-209">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="208f9-210">各 API ゲートウェイ製品で提供される機能に応じて、個々のマイクロサービスからゲートウェイに機能をオフロードできます。これにより、横断的な問題を 1 つの層にまとめて、各マイクロサービスの実装を単純化することができます。</span><span class="sxs-lookup"><span data-stu-id="208f9-210">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="208f9-211">これは特に、次の機能のような、内部マイクロサービスごとに正しく実装することが難しい専門的な機能に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="208f9-211">This is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="208f9-212">認証と承認</span><span class="sxs-lookup"><span data-stu-id="208f9-212">Authentication and authorization</span></span>
- <span data-ttu-id="208f9-213">サービス探索の統合</span><span class="sxs-lookup"><span data-stu-id="208f9-213">Service discovery integration</span></span>
- <span data-ttu-id="208f9-214">応答キャッシュ</span><span class="sxs-lookup"><span data-stu-id="208f9-214">Response caching</span></span>
- <span data-ttu-id="208f9-215">再試行ポリシー、サーキット ブレーカー、QoS</span><span class="sxs-lookup"><span data-stu-id="208f9-215">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="208f9-216">レートの制限と調整</span><span class="sxs-lookup"><span data-stu-id="208f9-216">Rate limiting and throttling</span></span>
- <span data-ttu-id="208f9-217">負荷分散</span><span class="sxs-lookup"><span data-stu-id="208f9-217">Load balancing</span></span>
- <span data-ttu-id="208f9-218">ログ記録、トレース、相関関係</span><span class="sxs-lookup"><span data-stu-id="208f9-218">Logging, tracing, correlation</span></span>
- <span data-ttu-id="208f9-219">ヘッダー、クエリ文字列、クレーム変換</span><span class="sxs-lookup"><span data-stu-id="208f9-219">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="208f9-220">IP ホワイトリスト登録</span><span class="sxs-lookup"><span data-stu-id="208f9-220">IP whitelisting</span></span>

<span data-ttu-id="208f9-221">詳細については、「[ゲートウェイ オフロード パターン](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="208f9-221">For more information, see [Gateway offloading pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="208f9-222">API ゲートウェイ機能を備えた製品の使用</span><span class="sxs-lookup"><span data-stu-id="208f9-222">Using products with API Gateway features</span></span>

<span data-ttu-id="208f9-223">API ゲートウェイ製品の実装によっては、さらに幅広い横断的な問題が処理されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-223">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="208f9-224">ここでは、次の 2 つについて説明します。</span><span class="sxs-lookup"><span data-stu-id="208f9-224">We'll explore here:</span></span>

- [<span data-ttu-id="208f9-225">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="208f9-225">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="208f9-226">Ocelot</span><span class="sxs-lookup"><span data-stu-id="208f9-226">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="208f9-227">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="208f9-227">Azure API Management</span></span>

<span data-ttu-id="208f9-228">[Azure API Management](https://azure.microsoft.com/services/api-management/) (図 4-14 を参照) では、API ゲートウェイのニーズを解決するだけでなく、API からの分析情報の収集などの機能も提供されます。</span><span class="sxs-lookup"><span data-stu-id="208f9-228">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="208f9-229">API 管理ソリューションを使用している場合、API ゲートウェイはその完全な API 管理ソリューション内の単なるコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="208f9-229">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![Azure API Management を API ゲートウェイとして使用する方法を示す図](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="208f9-231">**図 4-14**.</span><span class="sxs-lookup"><span data-stu-id="208f9-231">**Figure 4-14**.</span></span> <span data-ttu-id="208f9-232">API ゲートウェイでの Azure API Management の使用</span><span class="sxs-lookup"><span data-stu-id="208f9-232">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="208f9-233">Azure API Management では、ログ記録、セキュリティ、使用状況測定など、API ゲートウェイおよび管理の両方のニーズが解決されます。この場合、Azure API Management などの製品を使用する際に単一の API ゲートウェイを使用することはそれほど危険ではありません。この種の API ゲートウェイは "細かい" ためです。つまり、モノシリック コンポーネントに進化する可能性のあるカスタム C# コードを実装することはありません。</span><span class="sxs-lookup"><span data-stu-id="208f9-233">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="208f9-234">API ゲートウェイ製品は通常、イングレス通信のリバース プロキシに近い動作をします。ここでは内部マイクロサービスから API をフィルター処理し、さらにこの単一層で公開された API に承認を適用することもできます。</span><span class="sxs-lookup"><span data-stu-id="208f9-234">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="208f9-235">API Management システムから得られる洞察は、API の使用方法と実行方法を理解するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="208f9-235">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="208f9-236">これは、ほぼリアルタイムに分析レポートを表示し、ビジネスに影響する可能性のある傾向を識別することで行います。</span><span class="sxs-lookup"><span data-stu-id="208f9-236">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="208f9-237">さらに、オンラインとオフラインの分析のために要求と応答のアクティビティに関するログを使用できます。</span><span class="sxs-lookup"><span data-stu-id="208f9-237">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="208f9-238">Azure API Management では、キー、トークン、および IP フィルタリングを使用して API をセキュリティで保護することができます。</span><span class="sxs-lookup"><span data-stu-id="208f9-238">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="208f9-239">これらの機能では、柔軟な細かいクォータと転送率の制限を適用し、ポリシーを使用して API の形状と動作を変更し、応答キャッシュによりパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="208f9-239">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="208f9-240">このガイドと参照用のサンプル アプリケーション (eShopOnContainers) では、アーキテクチャを Azure API Management などの PaaS 製品を使用しないプレーンなコンテナーに焦点を合わせるために、より単純で専用にコンテナー化されたアーキテクチャに限定しています。</span><span class="sxs-lookup"><span data-stu-id="208f9-240">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="208f9-241">しかし、Microsoft Azure にデプロイされる大規模なマイクロサービス ベースのアプリケーションでは、運用環境の API ゲートウェイのベースとして Azure API Management を検討されることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="208f9-241">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="208f9-242">Ocelot</span><span class="sxs-lookup"><span data-stu-id="208f9-242">Ocelot</span></span>

<span data-ttu-id="208f9-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) は、より簡単な方法としてお勧めする簡易な API ゲートウェイです。</span><span class="sxs-lookup"><span data-stu-id="208f9-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="208f9-244">Ocelot は、システムへの統合されたエントリ ポイントを必要とするマイクロサービス アーキテクチャ向けに特別に設計された、オープンソースの .NET Core ベースの API ゲートウェイです。</span><span class="sxs-lookup"><span data-stu-id="208f9-244">Ocelot is an Open Source .NET Core based API Gateway especially made for microservices architecture that need unified points of entry into their system.</span></span> <span data-ttu-id="208f9-245">これは軽量、高速、スケーラブルで、ルーティングや認証をはじめとするさまざまな機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="208f9-245">It's lightweight, fast, scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="208f9-246">[参照アプリケーション eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) 用に Ocelot を選択する主な理由は、Ocelot が、マイクロサービス/コンテナー (Docker ホスト、Kubernetes など) をデプロイするのと同じアプリケーション デプロイ環境にデプロイできる簡易な .NET Core API ゲートウェイであるためです。また、.NET Core をベースとしているのでクロスプラットフォームであり、Linux でも Windows でもデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="208f9-246">The main reason to choose Ocelot for the [eShopOnContainers reference application](https://github.com/dotnet-architecture/eShopOnContainers) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="208f9-247">コンテナー内で実行されるカスタム API ゲートウェイを示した前の図は、コンテナーとマイクロサービス ベースのアプリケーションで Ocelot を実行する方法も正確に示しています。</span><span class="sxs-lookup"><span data-stu-id="208f9-247">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="208f9-248">また、市場には API ゲートウェイの機能を提供する Apigee、Kong、MuleSoft、WSO2 などの製品や、サービス メッシュのイングレス コントローラー機能を提供する Linkerd や Istio などの製品が他にも数多くあります。</span><span class="sxs-lookup"><span data-stu-id="208f9-248">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="208f9-249">最初のいくつかのセクションでアーキテクチャとパターンについて説明した後、後続のセクションでは [Ocelot](https://github.com/ThreeMammals/Ocelot) を使用して API ゲートウェイを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="208f9-249">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="208f9-250">API ゲートウェイ パターンの欠点</span><span class="sxs-lookup"><span data-stu-id="208f9-250">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="208f9-251">最も重要な欠点は、API ゲートウェイを実装するときにその層を内部マイクロサービスと結合することです。</span><span class="sxs-lookup"><span data-stu-id="208f9-251">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="208f9-252">このような結合は、アプリケーションの重大な問題を発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-252">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="208f9-253">Azure Service Bus チームのアーキテクトである Clemens Vaster は、GOTO 2016 の "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" (メッセージングとマイクロサービス) セッションで、この潜在的な問題を "新しい ESB" と呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="208f9-253">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="208f9-254">マイクロサービス API ゲートウェイを使用すると、単一障害点が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-254">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="208f9-255">API ゲートウェイでは、追加のネットワーク呼び出しにより応答時間が増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-255">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="208f9-256">ただし、この追加呼び出しは通常、内部マイクロサービスを直接呼び出す、やり取りが多すぎるクライアント インターフェイスの場合より影響は少なくなります。</span><span class="sxs-lookup"><span data-stu-id="208f9-256">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="208f9-257">正しくスケールアウトされていない場合、API ゲートウェイがボトルネックになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-257">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="208f9-258">API ゲートウェイでは、カスタム ロジックとデータ集計が含まれる場合、追加の開発費と将来のメンテナンスが必要になります。</span><span class="sxs-lookup"><span data-stu-id="208f9-258">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="208f9-259">開発者は、各マイクロ サービスのエンドポイントを公開するために、API ゲートウェイを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-259">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="208f9-260">さらに、内部マイクロサービスでの実装変更により、API ゲートウェイ レベルでのコード変更が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-260">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="208f9-261">ただし、API ゲートウェイがセキュリティの適用、ログ記録、バージョン管理を行うだけの場合、この追加の開発費は適用されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-261">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="208f9-262">API ゲートウェイが単一チームによって開発される場合、開発のボトルネックが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="208f9-262">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="208f9-263">これが、さまざまなクライアントのニーズに対応する細かい API ゲートウェイをいくつか使用することをお勧めする理由です。</span><span class="sxs-lookup"><span data-stu-id="208f9-263">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="208f9-264">内部マイクロサービスに取り組むさまざまなチームによって所有されている複数の領域またはレイヤーに API ゲートウェイを内部的に分離することもできます。</span><span class="sxs-lookup"><span data-stu-id="208f9-264">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="208f9-265">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="208f9-265">Additional resources</span></span>

- <span data-ttu-id="208f9-266">**Chris Richardson。パターン: API ゲートウェイ/Backend for Front-End** </span><span class="sxs-lookup"><span data-stu-id="208f9-266">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="208f9-267">**API ゲートウェイ パターン** </span><span class="sxs-lookup"><span data-stu-id="208f9-267">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="208f9-268">**集約とコンポジションのパターン** </span><span class="sxs-lookup"><span data-stu-id="208f9-268">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="208f9-269">**Azure API Management** </span><span class="sxs-lookup"><span data-stu-id="208f9-269">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="208f9-270">**Udi Dahan。サービス指向のコンポジション** </span><span class="sxs-lookup"><span data-stu-id="208f9-270">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="208f9-271">**Clemens Vasters。GOTO 2016 でのメッセージングとマイクロサービス (ビデオ)**  </span><span class="sxs-lookup"><span data-stu-id="208f9-271">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="208f9-272">**Nutshell の API ゲートウェイ** (ASP.net Core API ゲートウェイのチュートリアル シリーズ) </span><span class="sxs-lookup"><span data-stu-id="208f9-272">**API Gateway in a Nutshell** (ASP.net Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="208f9-273">[前へ](identify-microservice-domain-model-boundaries.md)
>[次へ](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="208f9-273">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
