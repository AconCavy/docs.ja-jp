---
title: マイクロサービス アーキテクチャでの通信
description: 同期および非同期の方法による、マイクロサービス間のさまざまな通信方法について説明します。
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503313"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="1e592-103">マイクロサービス アーキテクチャでの通信</span><span class="sxs-lookup"><span data-stu-id="1e592-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="1e592-104">1 つのプロセスで実行されているモノリシック アプリケーションでは、コンポーネントは言語レベルのメソッドや関数呼び出しを使用して相互に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1e592-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="1e592-105">コード (`new ClassName()` など) でオブジェクトを作成する場合はこれらを厳密に結合することができます。あるいは、具象オブジェクト インスタンスではなく抽象化を参照して依存関係の挿入を使用する場合、分離された方法で呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="1e592-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="1e592-106">どちらの方法でも、オブジェクトは同じプロセス内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="1e592-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="1e592-107">モノリシック アプリケーションからマイクロサービス ベースのアプリケーションに変更する際の最大の課題は、通信メカニズムの変更にあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="1e592-108">サービスのインプロセス メソッド呼び出しから RPC 呼び出しへの直接変換により、やり取りが多くなり、効率的な通信が行われず、分散環境でのパフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="1e592-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="1e592-109">分散システムを適切に設計する際の課題はよく知られており、[分散コンピューティングの落とし穴](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)としてもまとめられています。これは、開発者がモノリシックから分散設計への移行時に想定してしまいがちな誤った前提を集めたものです。</span><span class="sxs-lookup"><span data-stu-id="1e592-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="1e592-110">ソリューションは 1 つではなく、いくつかあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-110">There isn't one solution, but several.</span></span> <span data-ttu-id="1e592-111">1 つのソリューションは、できるだけ多くのビジネス マイクロサービスを分離することです。</span><span class="sxs-lookup"><span data-stu-id="1e592-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="1e592-112">その後、内部マイクロサービス間の非同期通信を使用して、オブジェクトのプロセス間通信では一般的な粒度の細かい通信を粒度の粗い通信に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="1e592-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="1e592-113">そのためには、呼び出しをグループ化し、複数の内部呼び出しの結果を集約するデータをクライアントに返します。</span><span class="sxs-lookup"><span data-stu-id="1e592-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="1e592-114">マイクロサービス ベースのアプリケーションは、複数のプロセスまたはサービスで (通常は複数のサーバーまたはホスト間でも) 実行される分散システムです。</span><span class="sxs-lookup"><span data-stu-id="1e592-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="1e592-115">通常、各サービス インスタンスはプロセスです。</span><span class="sxs-lookup"><span data-stu-id="1e592-115">Each service instance is typically a process.</span></span> <span data-ttu-id="1e592-116">そのため、サービスは、各サービスの性質に応じて、HTTP、AMQP などのプロセス間通信プロトコル、または TCP などのバイナリ プロトコルを使用して対話する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="1e592-117">マイクロサービスのコミュニティでは、"[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" (スマートなエンドポイントと土管) の指針を奨励しています。このスローガンは、マイクロサービスをできるだけ分離し、単一のマイクロサービスにできるだけまとめる設計を促進します。</span><span class="sxs-lookup"><span data-stu-id="1e592-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="1e592-118">前述のとおり、各マイクロサービスは独自のデータとドメイン ロジックを所有しています。</span><span class="sxs-lookup"><span data-stu-id="1e592-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="1e592-119">ただし、エンド ツー エンド アプリケーションを構成するマイクロサービスは、一元化されたビジネス プロセス オーケストレーターの代わりの WS-\* および柔軟なイベント ドリブン通信などの複雑なプロトコルではなく、通常は REST 通信を使用して単に振り付けされます。</span><span class="sxs-lookup"><span data-stu-id="1e592-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="1e592-120">一般的に使用される 2 つのプロトコルは、リソース API を使用する HTTP 要求/応答 (ほとんどすべてのクエリを実行する場合) と、複数のマイクロサービス間で更新を伝達する場合の軽量な非同期メッセージングです。</span><span class="sxs-lookup"><span data-stu-id="1e592-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="1e592-121">これらについては、次のセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="1e592-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="1e592-122">通信の種類</span><span class="sxs-lookup"><span data-stu-id="1e592-122">Communication types</span></span>

<span data-ttu-id="1e592-123">クライアントとサービスはさまざまな種類の通信を介して通信することができ、ターゲットとなるシナリオと目標はそれぞれ異なります。</span><span class="sxs-lookup"><span data-stu-id="1e592-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="1e592-124">最初に、これらの種類の通信を 2 つの軸に分類することができます。</span><span class="sxs-lookup"><span data-stu-id="1e592-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="1e592-125">最初の軸では、プロトコルを同期とするか非同期とするかを定義します。</span><span class="sxs-lookup"><span data-stu-id="1e592-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="1e592-126">同期プロトコル。</span><span class="sxs-lookup"><span data-stu-id="1e592-126">Synchronous protocol.</span></span> <span data-ttu-id="1e592-127">HTTP は同期プロトコルです。</span><span class="sxs-lookup"><span data-stu-id="1e592-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="1e592-128">クライアントは要求を送信し、サービスからの応答を待機します。</span><span class="sxs-lookup"><span data-stu-id="1e592-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="1e592-129">これは、同期 (スレッドがブロックされている) または非同期 (スレッドがブロックされておらず、応答が最終的にコールバックに到達する) となる可能性のあるクライアント コードの実行とは無関係です。</span><span class="sxs-lookup"><span data-stu-id="1e592-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="1e592-130">ここで重要な点は、プロトコル (HTTP/HTTPS) が同期であり、クライアント コードは HTTP サーバー応答の受信時にのみ、そのタスクを続行できることです。</span><span class="sxs-lookup"><span data-stu-id="1e592-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="1e592-131">非同期プロトコル。</span><span class="sxs-lookup"><span data-stu-id="1e592-131">Asynchronous protocol.</span></span> <span data-ttu-id="1e592-132">AMQP (多くのオペレーティング システムとクラウド環境でサポートされているプロトコル) などの他のプロトコルでは、非同期メッセージを使用します。</span><span class="sxs-lookup"><span data-stu-id="1e592-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="1e592-133">クライアント コードまたはメッセージの送信者は、通常、応答を待機しません。</span><span class="sxs-lookup"><span data-stu-id="1e592-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="1e592-134">RabbitMQ キューまたはその他のメッセージ ブローカーにメッセージを送信するときにメッセージを送信するだけです。</span><span class="sxs-lookup"><span data-stu-id="1e592-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="1e592-135">2 つ目の軸では、通信の受信者が単一であるか複数であるかを定義します。</span><span class="sxs-lookup"><span data-stu-id="1e592-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="1e592-136">単一の受信者。</span><span class="sxs-lookup"><span data-stu-id="1e592-136">Single receiver.</span></span> <span data-ttu-id="1e592-137">各要求は、単一の受信者またはサービスのみに処理される必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="1e592-138">この通信の例は[コマンド パターン](https://en.wikipedia.org/wiki/Command_pattern)です。</span><span class="sxs-lookup"><span data-stu-id="1e592-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="1e592-139">複数の受信者。</span><span class="sxs-lookup"><span data-stu-id="1e592-139">Multiple receivers.</span></span> <span data-ttu-id="1e592-140">ゼロから複数の受信者が各要求を処理できます。</span><span class="sxs-lookup"><span data-stu-id="1e592-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="1e592-141">この種の通信は非同期である必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="1e592-142">例として、[イベント ドリブン アーキテクチャ](https://microservices.io/patterns/data/event-driven-architecture.html)などのパターンで使用される[パブリッシュ/サブスクライブ](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) メカニズムがあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="1e592-143">これは、イベントを介して複数のマイクロサービス間でデータ更新を伝搬する場合のイベント バス インターフェイスまたはメッセージ ブローカーに基づきます。通常は、サービス バスまたは[トピックとサブスクリプション](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)を使用する [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) などの同様の成果物を介して実装されます。</span><span class="sxs-lookup"><span data-stu-id="1e592-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="1e592-144">マイクロサービス ベースのアプリケーションでは、多くの場合、これらの通信スタイルを組み合わせて使用します。</span><span class="sxs-lookup"><span data-stu-id="1e592-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="1e592-145">最も一般的な種類は、通常の Web API HTTP サービスを呼び出すときに HTTP/HTTPS などの同期プロトコルを使用する単一受信者通信です。</span><span class="sxs-lookup"><span data-stu-id="1e592-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="1e592-146">マイクロサービスでは、通常、マイクロサービス間の非同期通信でメッセージング プロトコルも使用します。</span><span class="sxs-lookup"><span data-stu-id="1e592-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="1e592-147">これらの軸は、使用可能な通信メカニズムは明確であるが、マイクロサービスのビルド時の重要事項ではないことを認識するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="1e592-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="1e592-148">クライアント スレッド実行の非同期の性質と選択したプロトコルの非同期の性質のいずれも、マイクロサービスの統合時の重要な点ではありません。</span><span class="sxs-lookup"><span data-stu-id="1e592-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="1e592-149">重要な*こと* は、マイクロサービスの独立性を維持しながら、マイクロサービスを非同期的に統合できるということです。これについては、以下のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="1e592-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="1e592-150">マイクロサービスの非同期統合によるマイクロサービスの自律性の強制</span><span class="sxs-lookup"><span data-stu-id="1e592-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="1e592-151">前述のとおり、マイクロサービス ベースのアプリケーションをビルドする際の重要な点は、マイクロサービスを統合する方法です。</span><span class="sxs-lookup"><span data-stu-id="1e592-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="1e592-152">内部マイクロサービス間の通信の最小化を試みることが理想的です。</span><span class="sxs-lookup"><span data-stu-id="1e592-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="1e592-153">マイクロサービス間の通信が少ないほど良いです。</span><span class="sxs-lookup"><span data-stu-id="1e592-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="1e592-154">しかし、多くの場合、何らかの形でマイクロサービスを統合する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="1e592-155">その場合に重要なルールは、マイクロサービス間の通信が非同期である必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="1e592-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="1e592-156">これは、特定のプロトコル (たとえば、非同期メッセージングと同期 HTTP) を使用する必要があるという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="1e592-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="1e592-157">ただ、マイクロサービス間の通信はデータを非同期的に伝搬してのみ行う必要があるが、初期サービスの HTTP 要求/応答操作の一部として他の内部マイクロサービスに依存しないようにするという意味です。</span><span class="sxs-lookup"><span data-stu-id="1e592-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="1e592-158">可能であれば、複数のマイクロサービス間の同期通信 (要求/応答) に依存しないようにしてください (クエリの場合でも)。</span><span class="sxs-lookup"><span data-stu-id="1e592-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="1e592-159">各マイクロサービスの目標は、エンド ツー エンド アプリケーションの一部である他のサービスが停止しているか異常な状態である場合でも、自立しており、クライアント コンシューマーが使用できるようにすることです。</span><span class="sxs-lookup"><span data-stu-id="1e592-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="1e592-160">クライアント アプリケーションへの応答を提供できるように、マイクロサービス間で呼び出しを行う必要があると思われる場合 (データ クエリのために HTTP 要求を実行するなど)、いくつかのマイクロサービスが失敗したときに回復力のないアーキテクチャが存在します。</span><span class="sxs-lookup"><span data-stu-id="1e592-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="1e592-161">さらに、HTTP 要求チェーンがある長い要求/応答サイクルを作成するときなど、マイクロサービス間に HTTP 依存関係がある場合、図 4-15 の最初の部分に示すように、マイクロサービスが自律しなくなるだけでなく、そのチェーン内のサービスのいずれかが適切に実行されなくなるとすぐにパフォーマンスに影響します。</span><span class="sxs-lookup"><span data-stu-id="1e592-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="1e592-162">クエリ要求など、マイクロサービス間の同期依存関係を追加すればするほど、クライアント アプリの全体的な応答時間が悪化します。</span><span class="sxs-lookup"><span data-stu-id="1e592-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![マイクロサービス間の 3 種類の通信を示す図。](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="1e592-164">**図 4-15**.</span><span class="sxs-lookup"><span data-stu-id="1e592-164">**Figure 4-15**.</span></span> <span data-ttu-id="1e592-165">マイクロサービス間の通信におけるアンチ パターンとパターン</span><span class="sxs-lookup"><span data-stu-id="1e592-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="1e592-166">上の図に示すように、同期通信では、クライアント要求への対応中に要求の "チェーン" がマイクロサービス間に作成されます。</span><span class="sxs-lookup"><span data-stu-id="1e592-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="1e592-167">これは、パターンに当てはまりません。</span><span class="sxs-lookup"><span data-stu-id="1e592-167">This is an anti-pattern.</span></span> <span data-ttu-id="1e592-168">非同期通信では、マイクロサービスは他のマイクロサービスとの通信に非同期メッセージまたは HTTP ポーリングを使用しますが、クライアント要求はすぐに対処されます。</span><span class="sxs-lookup"><span data-stu-id="1e592-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="1e592-169">あるマイクロサービスが別のマイクロサービスで追加アクションを発生させる必要がある場合、可能であれば、そのアクションを元のマイクロサービスの要求と応答操作の一部として同期的に実行しないでください。</span><span class="sxs-lookup"><span data-stu-id="1e592-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="1e592-170">代わりに、(非同期メッセージングまたは統合イベント、キューなどを使用して) 非同期的に実行してください。</span><span class="sxs-lookup"><span data-stu-id="1e592-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="1e592-171">ただし、できるだけ、元の同期要求と応答操作の一部として同期的にアクションを呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="1e592-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="1e592-172">最後 (そしてこの時点でマイクロサービスのビルド時のほとんどの問題が発生します) に、初期のマイクロサービスで他のマイクロサービスが最初に所有していたデータが必要になった場合、そのデータの同期要求に依存しないでください。</span><span class="sxs-lookup"><span data-stu-id="1e592-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="1e592-173">代わりに、最終的な整合性を使用 (通常は、以降のセクションの説明のとおり、統合イベントを使用) して、そのデータ (必要な属性のみ) を初期サービスのデータベースにレプリケートまたは伝搬します。</span><span class="sxs-lookup"><span data-stu-id="1e592-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="1e592-174">「[マイクロサービスごとにドメイン モデルの境界を識別する](identify-microservice-domain-model-boundaries.md)」セクションの説明のとおり、複数のマイクロサービスでのデータ複製は不適切な設計ではありません。むしろ、その場合、データを追加ドメインまたは境界コンテキストの特定の言語または用語に変換できます。</span><span class="sxs-lookup"><span data-stu-id="1e592-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="1e592-175">たとえば、[eShopOnContainers アプリケーション](https://github.com/dotnet-architecture/eShopOnContainers)には、`User` という名前のエンティティを持つユーザーのほとんどのデータを担当する `identity-api` という名前のマイクロサービスがあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="1e592-176">ただし、`Ordering` マイクロサービス内でユーザーに関するデータを格納する必要がある場合は、`Buyer` という名前の別のエンティティとして格納します。</span><span class="sxs-lookup"><span data-stu-id="1e592-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="1e592-177">`Buyer` エンティティは元の `User` エンティティと同じ ID を共有しますが、ユーザー プロファイル全体ではなく、`Ordering` ドメインで必要ないくつかの属性のみが存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="1e592-178">最終的な整合性を確保するために、任意のプロトコルを使用して、マイクロサービス間でのデータ通信と伝搬を非同期に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="1e592-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="1e592-179">前述のとおり、イベント バスまたはメッセージ ブローカーを使用する統合イベントを使用することも、他のサービスを代わりにポーリングして HTTP を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="1e592-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="1e592-180">これは問題ありません。</span><span class="sxs-lookup"><span data-stu-id="1e592-180">It doesn't matter.</span></span> <span data-ttu-id="1e592-181">ここで重要なのは、マイクロサービス間の同期依存関係を作成しないことです。</span><span class="sxs-lookup"><span data-stu-id="1e592-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="1e592-182">次のセクションでは、マイクロサービス ベースのアプリケーションの使用を検討できる複数の通信スタイルについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1e592-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="1e592-183">通信スタイル</span><span class="sxs-lookup"><span data-stu-id="1e592-183">Communication styles</span></span>

<span data-ttu-id="1e592-184">使用する通信の種類に応じて、通信で使用できる多くのプロトコルと選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="1e592-185">同期要求/応答ベースの通信メカニズムを使用している場合 (特に、Docker ホストやマイクロサービス クラスターの外部でサービスを公開している場合)、HTTP や REST 方法などのプロトコルが最も一般的です。</span><span class="sxs-lookup"><span data-stu-id="1e592-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="1e592-186">内部的に (Docker ホストやマイクロサービス クラスター内) サービス間で通信を行っている場合、バイナリ形式の通信メカニズム (TCP およびバイナリ形式を使用する WCF など) を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="1e592-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="1e592-187">また、AMQP など、非同期のメッセージ ベースの通信メカニズムを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="1e592-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="1e592-188">JSON や XML などの複数のメッセージ形式 (バイナリ形式でも) がより効率的な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="1e592-189">選択したバイナリ形式が標準的なものでない場合、その形式を使用してサービスを一般公開することはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="1e592-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="1e592-190">マイクロサービス間の内部通信では標準以外の形式を使用できます。</span><span class="sxs-lookup"><span data-stu-id="1e592-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="1e592-191">Docker ホストまたはマイクロサービス クラスター (たとえば、Docker オーケストレーター) 内のマイクロサービス間で通信を行う場合や、マイクロサービスと通信する専用クライアント アプリケーションの場合にこの操作を行うことがあります。</span><span class="sxs-lookup"><span data-stu-id="1e592-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="1e592-192">HTTP および REST による要求/応答通信</span><span class="sxs-lookup"><span data-stu-id="1e592-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="1e592-193">クライアントが要求/応答通信を使用する場合、要求がサービスに送信されてから、サービスが要求を処理して応答を返します。</span><span class="sxs-lookup"><span data-stu-id="1e592-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="1e592-194">要求/応答通信は、クライアント アプリからのリアルタイム UI (ライブ ユーザー インターフェイス) のデータのクエリの場合に特に適しています。</span><span class="sxs-lookup"><span data-stu-id="1e592-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="1e592-195">したがって、マイクロサービス アーキテクチャでは、図 4-16 のように、ほとんどのクエリでこの通信メカニズムを使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![ライブ クエリと更新のための要求/応答通信を示す図。](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="1e592-197">**図 4-16**.</span><span class="sxs-lookup"><span data-stu-id="1e592-197">**Figure 4-16**.</span></span> <span data-ttu-id="1e592-198">HTTP 要求/応答通信 (同期または非同期) の使用</span><span class="sxs-lookup"><span data-stu-id="1e592-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="1e592-199">クライアントが要求/応答通信を使用する場合、応答は短時間 (通常は 1 秒未満、または最大でも数秒) で到達することを前提とします。</span><span class="sxs-lookup"><span data-stu-id="1e592-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="1e592-200">応答が遅延する場合は、[メッセージング パターン](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)と[メッセージング テクノロジ](https://en.wikipedia.org/wiki/Message-oriented_middleware) (次のセクションで説明しますが、これらは異なる方法です) に基づいて非同期通信を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e592-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="1e592-201">要求/応答通信で一般的に使用されるアーキテクチャ スタイルは [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) です。</span><span class="sxs-lookup"><span data-stu-id="1e592-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="1e592-202">これは、GET、POST、PUT などの HTTP 動詞を採用する、[HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) プロトコルに基づいており、また、密接に関連している方法です。</span><span class="sxs-lookup"><span data-stu-id="1e592-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="1e592-203">REST は、サービスの作成時に最もよく使用されるアーキテクチャ通信方法です。</span><span class="sxs-lookup"><span data-stu-id="1e592-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="1e592-204">ASP.NET Core Web API サービスの開発時に REST サービスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="1e592-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="1e592-205">インターフェイス定義言語として HTTP REST サービスを使用する場合には特に便利です。</span><span class="sxs-lookup"><span data-stu-id="1e592-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="1e592-206">たとえば、[Swagger メタデータ](https://swagger.io/)を使用してサービス API を記述する場合、サービスを直接検出して使用できるクライアント スタブを生成するツールを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1e592-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="1e592-207">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="1e592-207">Additional resources</span></span>

- <span data-ttu-id="1e592-208">**Martin Fowler。Richardson Maturity Model** REST モデルの説明。</span><span class="sxs-lookup"><span data-stu-id="1e592-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="1e592-209">**Swagger** 公式サイト。</span><span class="sxs-lookup"><span data-stu-id="1e592-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="1e592-210">HTTP に基づくプッシュおよびリアルタイム通信</span><span class="sxs-lookup"><span data-stu-id="1e592-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="1e592-211">[ASP.NET SignalR](https://www.asp.net/signalr) などの上位レベルのフレームワークと [WebSockets](https://en.wikipedia.org/wiki/WebSocket) などのプロトコルを使用するリアルタイムの一対多通信も考えられます (通常は REST とは異なる目的で使用)。</span><span class="sxs-lookup"><span data-stu-id="1e592-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="1e592-212">図 4-17 に示すとおり、リアルタイムの HTTP 通信は、クライアントが新しいデータを要求するまでサービスが待機するのではなく、データが使用可能になったときに接続されたクライアントにコンテンツをプッシュするサーバー コードを使用できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="1e592-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR に基づくプッシュおよびリアルタイムの通信を示す図。](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="1e592-214">**図 4-17**.</span><span class="sxs-lookup"><span data-stu-id="1e592-214">**Figure 4-17**.</span></span> <span data-ttu-id="1e592-215">一対一のリアルタイム非同期メッセージ通信</span><span class="sxs-lookup"><span data-stu-id="1e592-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="1e592-216">SignalR は、バックエンド サーバーからクライアントにコンテンツをプッシュするためのリアルタイム通信を実現する優れた方法です。</span><span class="sxs-lookup"><span data-stu-id="1e592-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="1e592-217">通信がリアルタイムであるため、クライアント アプリはほぼ瞬時に変更内容を表示します。</span><span class="sxs-lookup"><span data-stu-id="1e592-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="1e592-218">これは、通常、多くの WebSocket 接続 (クライアントごとに 1 つ) を使用して、WebSocket などのプロトコルで処理されます。</span><span class="sxs-lookup"><span data-stu-id="1e592-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="1e592-219">典型的な例は、サービスが多くのクライアント Web アプリにスポーツ ゲームのスコアの変更を同時に伝達する場合です。</span><span class="sxs-lookup"><span data-stu-id="1e592-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="1e592-220">[前へ](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[次へ](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="1e592-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
