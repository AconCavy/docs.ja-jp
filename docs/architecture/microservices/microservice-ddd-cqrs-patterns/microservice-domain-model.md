---
title: マイクロサービス ドメイン モデルの設計
description: コンテナー化された .NET アプリケーションの .NET マイクロサービス アーキテクチャ | DDD 指向ドメイン モデルの設計時の主な概念を理解する
ms.date: 01/30/2020
ms.openlocfilehash: 628fb5c76362ec8f48367b3d69d16ea6ebd24f09
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "77502331"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="b12cb-103">マイクロサービス ドメイン モデルの設計</span><span class="sxs-lookup"><span data-stu-id="b12cb-103">Design a microservice domain model</span></span>

<span data-ttu-id="b12cb-104">*ビジネス マイクロサービスまたは有界コンテキストごとに 1 つのリッチ ドメイン モデルを定義します。*</span><span class="sxs-lookup"><span data-stu-id="b12cb-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="b12cb-105">ここでの目標は、ビジネス マイクロサービスまたは有界コンテキスト (BC) ごとに 1 つのまとまりのあるドメイン モデルを作成することです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="b12cb-106">ただし、BC またはビジネス マイクロサービスは、1 つのドメイン モデルを共有する複数の物理サービスから構成される場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b12cb-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="b12cb-107">ドメイン モデルは、それが表す 1 つの有界コンテキストまたはビジネス マイクロサービスのルール、ビヘイビアー、ビジネス言語、および制約をキャプチャする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="b12cb-108">ドメイン エンティティ パターン</span><span class="sxs-lookup"><span data-stu-id="b12cb-108">The Domain Entity pattern</span></span>

<span data-ttu-id="b12cb-109">エンティティは、ドメイン オブジェクトを表すもので、主にその ID、継続性、および永続化によって時間とともに定義されます。エンティティを構成する属性によってのみ定義されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="b12cb-110">Eric Evans が言うように、"主にその ID で定義されるオブジェクトは、エンティティと呼ばれます。"</span><span class="sxs-lookup"><span data-stu-id="b12cb-110">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="b12cb-111">エンティティは、モデルの基礎となるため、ドメイン モデルで非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="b12cb-112">したがって、エンティティは、慎重に識別し、設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="b12cb-113">*エンティティの ID は、複数のマイクロサービスまたは有界コンテキストを横断できる。*</span><span class="sxs-lookup"><span data-stu-id="b12cb-113">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="b12cb-114">同じ ID (つまり、同じドメイン エンティティではない可能性がありますが、同じ `Id` 値) を複数の有界コンテキストまたはマイクロサービス全体でモデリングできます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="b12cb-115">ただし、同じ属性とロジックを持つ同じエンティティが複数の有界コンテキストに実装されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="b12cb-116">代わりに、それぞれの有界コンテキストのエンティティは、その属性とビヘイビアーを有界コンテキストのドメインで必要なものに制限します。</span><span class="sxs-lookup"><span data-stu-id="b12cb-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="b12cb-117">たとえば、バイヤー エンティティは、プロファイルまたは ID マイクロサービスのユーザー エンティティで定義された個人の属性の大部分を持っている可能性があります (ID を含む)。</span><span class="sxs-lookup"><span data-stu-id="b12cb-117">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="b12cb-118">しかし、注文マイクロサービスのバイヤー エンティティは、持っている属性が少ない可能性があります。注文プロセスに特定のバイヤー データしか関連付けられていないからです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="b12cb-119">各マイクロサービスまたは有界コンテキストのコンテキストは、そのドメイン モデルに影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="b12cb-120">*ドメイン エンティティは、データ属性を実装するだけでなく、ビヘイビアーも実装する必要があります。*</span><span class="sxs-lookup"><span data-stu-id="b12cb-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="b12cb-121">DDD のドメイン エンティティは、エンティティ データ (アクセスされるメモリ内のオブジェクト) に関連するドメイン ロジックまたはビヘイビアーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="b12cb-122">たとえば、注文エンティティ クラスの一部として、ビジネス ロジックと操作を、タスク (注文項目の追加、データ検証、合計計算など) のメソッドとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="b12cb-123">エンティティのメソッドは、エンティティのルールをアプリケーション レイヤー全体に広げるのではなく、エンティティの不変量とルールを処理します。</span><span class="sxs-lookup"><span data-stu-id="b12cb-123">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="b12cb-124">図 7-8 は、データの属性だけではなく、操作やメソッドを、関連するドメイン ロジックとともに実装するドメイン エンティティを示しています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![ドメイン エンティティのパターンを示す図。](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="b12cb-126">**図 7-8**。</span><span class="sxs-lookup"><span data-stu-id="b12cb-126">**Figure 7-8**.</span></span> <span data-ttu-id="b12cb-127">データとビヘイビアーを実装するドメイン エンティティ設計の例</span><span class="sxs-lookup"><span data-stu-id="b12cb-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="b12cb-128">ドメイン モデル エンティティでは、メソッドからビヘイビアーを実装します。つまり、"貧血症" モデルではありません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="b12cb-129">もちろん、エンティティ クラスの一部としてどのロジックも実装しないエンティティを持つ場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="b12cb-130">この状況は、大部分のロジックが集約ルートで定義されており、子エンティティが特別なロジックを持たない場合に、集約内の子エンティティで発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="b12cb-131">ドメイン エンティティではなく、サービス クラスに多数のロジックが実装されている複雑なマイクロサービスがある場合は、ドメイン モデル貧血症になる場合があります。ドメイン モデル貧血症については、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="b12cb-131">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="b12cb-132">リッチ ドメイン モデルと貧血症ドメイン モデルの比較</span><span class="sxs-lookup"><span data-stu-id="b12cb-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="b12cb-133">Martin Fowler は、投稿した [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html) で、ドメイン モデル貧血症について、次のように述べています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="b12cb-134">ドメイン モデル貧血症の基本的な症状は、一見、それが本物のドメイン モデルに見えるという点です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="b12cb-135">オブジェクトがいくつかあり、それらはドメイン空間にある名詞から名前をつけられています。それから、オブジェクト同士がしっかりとしたリレーションで結びついており、本物のドメイン モデルと同じような構造を持っているのです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="b12cb-136">ただし、オブジェクトのビヘイビアーを見れば違いがわかります。それらのオブジェクトにはわずかなビヘイビアーしかなく、ゲッターとセッターの入れ物にすぎないということに気づくと思います。</span><span class="sxs-lookup"><span data-stu-id="b12cb-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="b12cb-137">もちろん、貧血症ドメイン モデルを使用する場合、これらのデータ モデルは、すべてのドメインまたはビジネス ロジックをキャプチャする一連のサービス オブジェクト (従来名は "*ビジネス レイヤー*") から使用されます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="b12cb-138">ビジネス レイヤーは、データ モデル上にあり、データ モデルを単にデータとして使用します。</span><span class="sxs-lookup"><span data-stu-id="b12cb-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="b12cb-139">貧血症ドメイン モデルは、手続き型の設計にすぎません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="b12cb-140">貧血症エンティティ オブジェクトは、ビヘイビアー (メソッド) がないため、本当のオブジェクトではありません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="b12cb-141">また、データ プロパティを保持するだけなので、オブジェクト指向設計ではありません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="b12cb-142">すべてのビヘイビアーをサービス オブジェクト (ビジネス レイヤー) に入れると、どうしても最後には[スパゲッティ コード](https://en.wikipedia.org/wiki/Spaghetti_code)や[トランザクション スクリプト](https://martinfowler.com/eaaCatalog/transactionScript.html)が出来上がり、その結果、ドメイン モデルが持つ利点が失われます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-142">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="b12cb-143">とにかく、マイクロサービスまたは有界コンテキストが非常にシンプル (CRUD サービス) である場合は、エンティティ オブジェクト形式でデータ プロパティしか持たない貧血症ドメイン モデルで十分であり、より複雑な DDD パターンを実装する価値はないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="b12cb-144">その場合、CRUD を目的としてデータしか持たないエンティティを意図的に作成したので、これは単に永続化モデルになります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="b12cb-145">このため、有界コンテキストにもよりますが、マイクロサービス アーキテクチャは、マルチアーキテクチャ手法に最適となります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="b12cb-146">たとえば、eShopOnContainers の場合、注文マイクロサービスは、DDD パターンを実装しますが、カタログ マイクロサービス (シンプルな CRUD サービス) は、DDD パターンを実装しません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="b12cb-147">貧血症ドメイン モデルは、アンチパターンであると言われる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="b12cb-148">実際、このモデルは、実装する内容に依存しています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="b12cb-149">作成するマイクロサービスが十分にシンプルである場合 (CRUD サービスなどである場合) は、貧血症ドメイン モデルに従い、アンチパターンになりません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="b12cb-150">ただし、絶えず変化するビジネス ルールを多数含むマイクロサービスのドメインの複雑さに取り組む必要がある場合、貧血症ドメイン モデルは、そのマイクロサービスまたは有界コンテキストのアンチ パターンになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-150">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="b12cb-151">その場合は、データとビヘイビアーを含み、追加の DDD パターン (集約や値オブジェクトなど) を実装するエンティティを持つリッチ モデルとして貧血症ドメイン モデルを設計すると、そのようなマイクロサービスを長期的に成功させるために必要な大きな利点が得られる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b12cb-152">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="b12cb-152">Additional resources</span></span>

- <span data-ttu-id="b12cb-153">**DevIQ。ドメイン エンティティ** </span><span class="sxs-lookup"><span data-stu-id="b12cb-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="b12cb-154">**Martin Fowler。ドメイン モデル** </span><span class="sxs-lookup"><span data-stu-id="b12cb-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="b12cb-155">**Martin Fowler。貧血症ドメイン モデル** </span><span class="sxs-lookup"><span data-stu-id="b12cb-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="b12cb-156">値オブジェクト パターン</span><span class="sxs-lookup"><span data-stu-id="b12cb-156">The Value Object pattern</span></span>

<span data-ttu-id="b12cb-157">Eric Evans は、"多くのオブジェクトは、概念 ID を持ちません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-157">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="b12cb-158">これらのオブジェクトは、あるものについての特定の特性を記述しています。" と述べています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-158">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="b12cb-159">エンティティには ID が必要ですが、システム内には値オブジェクト パターンのように ID を持たないオブジェクトが多数あります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="b12cb-160">値オブジェクトは、ドメインのアスペクトを記述する概念 ID を持たないオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="b12cb-161">これは、一時的にしか関係しない設計要素を表すためにインスタンス化するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="b12cb-162">関心を持つ必要があるのは、それが "*誰*" であるのかではなく、"*何*" であるのかという点です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="b12cb-163">例には数値と文字列が含まれていますが、属性グループのような上位レベルの概念にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="b12cb-164">あるマイクロサービスではエンティティであるものが、別のマイクロサービスではエンティティでないことがあります。これは、2 番目のケースで、有界コンテキストが別の意味を持つことがあるからです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="b12cb-165">たとえば、eコマース アプリケーションのアドレスは、ID を持たない場合があります。これは、個人または会社の顧客プロファイルの属性グループしか表さない場合があるためです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="b12cb-166">この場合、アドレスは、値オブジェクトとして分類する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="b12cb-167">ただし、電力会社のアプリケーションでは、顧客のアドレスがビジネス ドメインで重要になります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="b12cb-168">そのため、請求システムがアドレスに直接リンクできるようにするために、アドレスには ID が必要です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="b12cb-169">この場合、アドレスは、ドメイン エンティティとして分類する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="b12cb-170">通常、個人は ID を持つため、名と姓を持つ個人はエンティティです。これは、その名と姓が別の値セットに一致した場合 (たとえば、それらの名前が別の個人も指している場合) にも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="b12cb-171">値オブジェクトは、リレーショナル データベースや Entity Framework (EF) などの ORM では管理が難しいですが、ドキュメント指向データベースでは簡単に実装して使用できます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="b12cb-172">EF Core 2.0 以降のバージョンには、後で詳しく説明しているように、値オブジェクトを処理しやすくする[所有エンティティ](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting)機能が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b12cb-173">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="b12cb-173">Additional resources</span></span>

- <span data-ttu-id="b12cb-174">**Martin Fowler。値オブジェクト パターン** </span><span class="sxs-lookup"><span data-stu-id="b12cb-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="b12cb-175">**値オブジェクト** </span><span class="sxs-lookup"><span data-stu-id="b12cb-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="b12cb-176">**テスト駆動型開発での値オブジェクト** </span><span class="sxs-lookup"><span data-stu-id="b12cb-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="b12cb-177">**Eric Evans。Domain-Driven Design:Tackling Complexity in the Heart of Software (ドメイン駆動設計: ソフトウェア中心部の複雑さへの取り組み)。**</span><span class="sxs-lookup"><span data-stu-id="b12cb-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="b12cb-178">(書籍、値オブジェクトについての記載あり) </span><span class="sxs-lookup"><span data-stu-id="b12cb-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="b12cb-179">集約パターン</span><span class="sxs-lookup"><span data-stu-id="b12cb-179">The Aggregate pattern</span></span>

<span data-ttu-id="b12cb-180">ドメイン モデルには、機能の重要な領域 (注文調達やインベントリなど) を制御できる、さまざまなデータ エンティティやプロセスのクラスターが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="b12cb-181">より細かな DDD 単位は集約であり、まとまりのある単位として処理できるエンティティとビヘイビアーのクラスターまたはグループが記述されています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="b12cb-182">通常は、必要なトランザクションに基づいて集約を定義します。</span><span class="sxs-lookup"><span data-stu-id="b12cb-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="b12cb-183">典型的な例は、注文項目のリストも含まれる注文です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="b12cb-184">通常、注文項目は、エンティティになります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-184">An order item will usually be an entity.</span></span> <span data-ttu-id="b12cb-185">ただし、注文集約内では子エンティティとなり、注文エンティティもそのルート エンティティとして含まれます (通常、ルート エンティティは、集約ルートと呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="b12cb-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="b12cb-186">集約を識別することが困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="b12cb-187">集約は、互いに一致する必要があるオブジェクトのグループですが、オブジェクトのグループを選び、集約のラベルをつけることはできません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="b12cb-188">ドメインの概念から開始し、その概念に関連する最も一般的なトランザクションで使用されるエンティティについて考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="b12cb-189">トランザクションで一致する必要があるエンティティは、集約を形成するエンティティです。</span><span class="sxs-lookup"><span data-stu-id="b12cb-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="b12cb-190">トランザクションの操作について考えることが、おそらく集約を識別するための最良の方法です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="b12cb-191">集約ルートまたはルート エンティティ パターン</span><span class="sxs-lookup"><span data-stu-id="b12cb-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="b12cb-192">集約は、集約ルートという 1 つ以上のエンティティから構成されています (集約ルートは、ルート エンティティまたはプライマリ エンティティとも呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="b12cb-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="b12cb-193">また、集約は、複数の子エンティティと値オブジェクトを持つことができ、すべてのエンティティとオブジェクトが連携して、必要なビヘイビアーやトランザクションを実装しています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="b12cb-194">集約ルートの目的は、集約の一貫性を維持することです。集約ルートは、集約ルート クラスのメソッドまたは操作を通じて集約に入るための唯一の更新用のエントリ ポイントである必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="b12cb-195">集約内のエンティティを変更するときは、必ず集約ルートを経由する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b12cb-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="b12cb-196">これは、集約の一貫性を管理するもので、集約で従う必要がある可能性があるすべての不変量および一貫性のルールを考慮しています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-196">It is the aggregate’s consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="b12cb-197">子エンティティまたは値オブジェクトを別々に変更した場合、集約ルートは、集約が有効な状態であることを保証できません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="b12cb-198">本来の機能を発揮できなくなるでしょう。</span><span class="sxs-lookup"><span data-stu-id="b12cb-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="b12cb-199">一貫性の管理は、集約のルートの主も重要な目的です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="b12cb-200">図 7-9 には、バイヤー集約などのサンプル集約が示されています。バイヤー集約には、1 つのエンティティ (集約ルート バイヤー) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="b12cb-201">注文集約には、複数のエンティティと値オブジェクトが含まれています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-201">The order aggregate contains multiple entities and a value object.</span></span>

![バイヤー集約と注文集約を比較している図。](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="b12cb-203">**図 7-9**。</span><span class="sxs-lookup"><span data-stu-id="b12cb-203">**Figure 7-9**.</span></span> <span data-ttu-id="b12cb-204">複数のエンティティまたは 1 つのエンティティを含む集約の例</span><span class="sxs-lookup"><span data-stu-id="b12cb-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="b12cb-205">DDD ドメイン モデルは集約から構成され、集約には 1 つまたは複数のエンティティを含めることができ、値オブジェクトも含めることができます。</span><span class="sxs-lookup"><span data-stu-id="b12cb-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="b12cb-206">バイヤー集約は、ドメインによっては、eShopOnContainers 参照アプリケーションの注文マイクロサービスの場合と同様、追加の子エンティティを持つことができることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b12cb-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="b12cb-207">図 7-9 は、集約ルートのみを含む集約の例として、バイヤーが 1 つのエンティティを持つケースを示しています。</span><span class="sxs-lookup"><span data-stu-id="b12cb-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="b12cb-208">集約を分離し、集約間の境界を明確にし続けるためには、DDD ドメイン モデルで、集約間の直接の移動を禁止し、eShopOnContainers の[注文マイクロサービス ドメイン モデル](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs)に実装されている外部キー (FK) フィールドのみを持つことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b12cb-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="b12cb-209">注文エンティティは、次のコードに示すように、バイヤーの FK フィールドのみを持ち、EF コア ナビゲーション プロパティは持ちません。</span><span class="sxs-lookup"><span data-stu-id="b12cb-209">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="b12cb-210">集約を識別し、操作するには、研究と経験が必要です。</span><span class="sxs-lookup"><span data-stu-id="b12cb-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="b12cb-211">詳細については、次の「その他の技術情報」のリストを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b12cb-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b12cb-212">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="b12cb-212">Additional resources</span></span>

- <span data-ttu-id="b12cb-213">**Vaughn Vernon。効果的な集約設計 - パート I:1 つの集約のモデリング** (<http://dddcommunity.org/> から) </span><span class="sxs-lookup"><span data-stu-id="b12cb-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="b12cb-214">**Vaughn Vernon。効果的な集約設計 - パート II:集約処理の連携** (<http://dddcommunity.org/> から) </span><span class="sxs-lookup"><span data-stu-id="b12cb-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="b12cb-215">**Vaughn Vernon。効果的な集約設計 - パート III:探索による分析情報の獲得** (<http://dddcommunity.org/> から) </span><span class="sxs-lookup"><span data-stu-id="b12cb-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="b12cb-216">**Sergey Grybniak。DDD 戦術的デザイン パターン** </span><span class="sxs-lookup"><span data-stu-id="b12cb-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="b12cb-217">**Chris Richardson。集約を使用したトランザクション マイクロサービスの開発** </span><span class="sxs-lookup"><span data-stu-id="b12cb-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="b12cb-218">**DevIQ。集約パターン** </span><span class="sxs-lookup"><span data-stu-id="b12cb-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="b12cb-219">[前へ](ddd-oriented-microservice.md)
>[次へ](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="b12cb-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
