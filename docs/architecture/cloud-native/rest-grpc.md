---
title: REST と gRPC
description: GRPC、クラウドネイティブアプリケーションでのその役割、および HTTP REST との違いについて説明します。
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: 80960a9042b1514fb78e7a8c993a1854067407e8
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/01/2019
ms.locfileid: "73842051"
---
# <a name="rest-and-grpc"></a><span data-ttu-id="012d8-103">REST と gRPC</span><span class="sxs-lookup"><span data-stu-id="012d8-103">REST and gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="012d8-104">ここまでは、 [REST ベース](https://docs.microsoft.com/azure/architecture/best-practices/api-design)の通信に重点を置いてきました。</span><span class="sxs-lookup"><span data-stu-id="012d8-104">So far in this book, we’ve focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="012d8-105">REST は、分散コンピューターシステム間の相互運用性を促進するアーキテクチャスタイルです。</span><span class="sxs-lookup"><span data-stu-id="012d8-105">REST is an architectural style that promotes interoperability between distributed computer systems.</span></span> <span data-ttu-id="012d8-106">要求/応答モデルを使用します。このモデルでは、サーバーからのすべての応答がクライアントからの要求になります。</span><span class="sxs-lookup"><span data-stu-id="012d8-106">It uses a request/response model where every response from the server is to a request from the client.</span></span> <span data-ttu-id="012d8-107">広く普及していますが、すべての問題に対して REST が完全に適合するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="012d8-107">While widely popular, REST isn't a perfect fit for every problem.</span></span> <span data-ttu-id="012d8-108">新しい通信テクノロジである gRPC は、人気を高め、クラウドネイティブ環境に向かっています。</span><span class="sxs-lookup"><span data-stu-id="012d8-108">A newer communication technology, entitled gRPC, is rapidly gaining popularity and making its way into the cloud-native world.</span></span>

## <a name="grpc"></a><span data-ttu-id="012d8-109">gRPC</span><span class="sxs-lookup"><span data-stu-id="012d8-109">gRPC</span></span>

<span data-ttu-id="012d8-110">gRPC は、Google から発信されたオープンソースの通信です。</span><span class="sxs-lookup"><span data-stu-id="012d8-110">gRPC is an open-source communication that originates from Google.</span></span> <span data-ttu-id="012d8-111">これは、分散コンピューティングで広く使われている[リモートプロシージャコール (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call)モデルに基づいて構築されています。</span><span class="sxs-lookup"><span data-stu-id="012d8-111">It's built upon the [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) model, popular in distributed computing.</span></span> <span data-ttu-id="012d8-112">このモデルに従って、ローカルクライアントプログラムは、操作を実行するためのインプロセスメソッドを公開します。</span><span class="sxs-lookup"><span data-stu-id="012d8-112">Following this model, a local client program exposes an in-process method to execute an operation.</span></span> <span data-ttu-id="012d8-113">この呼び出しは、分散ネットワーク経由でアウトプロセスマイクロサービスで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-113">Behind the scenes, that call is invoked on an out-of-process microservice across a distributed network.</span></span> <span data-ttu-id="012d8-114">開発者は、ローカルプロシージャ呼び出しとして操作をコードします。</span><span class="sxs-lookup"><span data-stu-id="012d8-114">The developer codes the operation as a local procedure call.</span></span> <span data-ttu-id="012d8-115">基になるプラットフォームによって、ポイントツーポイントのネットワーク通信、シリアル化、および実行が抽象化されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-115">The underlying platform abstracts the point-to-point networking communication, serialization, and execution.</span></span>

<span data-ttu-id="012d8-116">gRPC は、軽量で高いパフォーマンスを備えた最新の RPC フレームワークです。</span><span class="sxs-lookup"><span data-stu-id="012d8-116">gRPC is a modern RPC framework that is lightweight and highly performant.</span></span> <span data-ttu-id="012d8-117">トランスポートプロトコルには HTTP/2 を使用します。</span><span class="sxs-lookup"><span data-stu-id="012d8-117">It uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="012d8-118">Http/2 は HTTP 1.1 と互換性がありますが、多くの高度な機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="012d8-118">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="012d8-119">HTTP 1.1 はデータをクリアテキストとして送信しますが、HTTP/2 はバイナリプロトコルです。</span><span class="sxs-lookup"><span data-stu-id="012d8-119">While HTTP 1.1 sends data as clear text, HTTP/2 is a binary protocol.</span></span> <span data-ttu-id="012d8-120">これにより、メモリの使用量を減らし、ネットワーク待機時間を短縮し、ネットワークリソースをより効率的に管理できるようになります。</span><span class="sxs-lookup"><span data-stu-id="012d8-120">It parses data faster using less memory, reduces network latency with the related improvements to speed, and manages network resources more efficiently.</span></span>
- <span data-ttu-id="012d8-121">HTTP 1.1 は一度に1回のラウンドトリップ要求/応答の処理に制限されていますが、HTTP/2 では、同じ接続で多重化または複数の並列要求をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="012d8-121">While HTTP 1.1 is limited to processing one round-trip request/response at a time, HTTP/2 supports multiplexing, or multiple parallel requests over the same connection.</span></span>
- <span data-ttu-id="012d8-122">HTTP/2 では、クライアントとサーバーの両方が同時に通信できる、全二重または双方向の通信がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="012d8-122">HTTP/2 supports full-duplex, or bidirectional communication, where both client and server and can communicate at the same time.</span></span> <span data-ttu-id="012d8-123">クライアントは、サーバーが応答データを送信しているときと同時に要求データをアップロードできます。</span><span class="sxs-lookup"><span data-stu-id="012d8-123">The client can be uploading request data at the same time the server is sending back response data.</span></span>
- <span data-ttu-id="012d8-124">ストリーミングは HTTP/2 に組み込まれています。これは、要求と応答の両方が、大きなデータセットを非同期にストリーミングできることを意味します。</span><span class="sxs-lookup"><span data-stu-id="012d8-124">Streaming is built into HTTP/2 meaning that both requests and responses can asynchronously stream large data sets.</span></span>
- <span data-ttu-id="012d8-125">GRPC と HTTP/2 を組み合わせると、パフォーマンスが飛躍的に向上します。</span><span class="sxs-lookup"><span data-stu-id="012d8-125">Combining gRPC and HTTP/2, performance dramatically increases.</span></span> <span data-ttu-id="012d8-126">[Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)用語では、grpc のパフォーマンスは、 [nettcp バインド](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)の速度と効率を満たしています。</span><span class="sxs-lookup"><span data-stu-id="012d8-126">In [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance meets and exceeds the speed and efficiency of [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="012d8-127">ただし、NetTCP とは異なり、gRPC C#はや VB.NET などの Microsoft 言語に制約されません。</span><span class="sxs-lookup"><span data-stu-id="012d8-127">However, unlike NetTCP, gRPC isn't constrained to Microsoft languages such as C# or VB.NET.</span></span>

<span data-ttu-id="012d8-128">gRPC は、Java、 C#、Golang、nodejs など、最も一般的なプラットフォームでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="012d8-128">gRPC is supported across most popular platforms, including Java, C#, Golang, and NodeJS.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="012d8-129">プロトコル バッファー</span><span class="sxs-lookup"><span data-stu-id="012d8-129">Protocol Buffers</span></span>

<span data-ttu-id="012d8-130">gRPC は、[プロトコルバッファー](https://developers.google.com/protocol-buffers/docs/overview)または Protobuf メッセージと呼ばれる別のオープンソーステクノロジを利用して、データの送受信を行います。</span><span class="sxs-lookup"><span data-stu-id="012d8-130">gRPC embraces another open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview) or Protobuf messages to send and receive data.</span></span> <span data-ttu-id="012d8-131">[WCF データコントラクト](https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-data-contracts)と同様に、Protobuf はシステム用の構造化データをシリアル化して読み取りと書き込みを行います。</span><span class="sxs-lookup"><span data-stu-id="012d8-131">Similar to a [WCF Data Contract](https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-data-contracts), Protobuf serializes structured data for systems to read and write.</span></span> <span data-ttu-id="012d8-132">これにより、XML や JSON などの人間が判読できる形式のオーバーヘッドが軽減されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-132">It reduces the overhead that human-readable formats like XML or JSON incur.</span></span>

<span data-ttu-id="012d8-133">多くのオブジェクトシリアル化手法は、実行時にデータオブジェクトの構造全体に反映されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-133">Many object serialization techniques reflect across the structure of data objects at run-time.</span></span> <span data-ttu-id="012d8-134">Protobuf では、プラットフォームに依存しない言語 (プロトコルバッファー言語) を使用して、構造を事前に定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="012d8-134">Protobuf requires you to define the structure up front with a platform-agnostic language (Protocol Buffer Language).</span></span> <span data-ttu-id="012d8-135">各定義は、"proto" ファイルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-135">Each definition is stored in a ".proto" file.</span></span> <span data-ttu-id="012d8-136">次に、Protobuf compiler "Proton" を使用して、サポートされているプラットフォームのいずれかについて、クライアントとサーバーのコードを生成します。</span><span class="sxs-lookup"><span data-stu-id="012d8-136">Then using Protobuf compiler, "Proton," you generate client and server code for any of the supported platforms.</span></span> <span data-ttu-id="012d8-137">生成されたコードは、データの高速なシリアル化/逆シリアル化のために最適化されています。</span><span class="sxs-lookup"><span data-stu-id="012d8-137">The generated code is optimized for fast serialization/deserialization of data.</span></span> <span data-ttu-id="012d8-138">実行時には、各メッセージが厳密に型指定されたサービスコントラクトにラップされ、標準の Protobuf 表現でシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-138">At runtime, each message is wrapped in the strongly-typed service contract and serialized in a standard Protobuf representation.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="012d8-139">.NET での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="012d8-139">gRPC support in .NET</span></span>

<span data-ttu-id="012d8-140">Microsoft .NET Core framework 3.0 には、gRPC のツールとネイティブサポートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="012d8-140">The Microsoft .NET Core framework 3.0 includes tooling and native support for gRPC.</span></span> <span data-ttu-id="012d8-141">図4-20 は、gRPC サービス用に gRPC スケルトンプロジェクトをスキャフォールディングする Visual Studio 2019 テンプレートを示しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-141">Figure 4-20 shows the Visual Studio 2019 template that scaffolds a gRPC skeleton project for a gRPC service.</span></span> <span data-ttu-id="012d8-142">.NET Core では、Windows、Linux、および macOS プラットフォームがサポートされていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="012d8-142">Note how .NET Core supports the Windows, Linux, and macOS platforms.</span></span>

![Visual Studio 2019 での gRPC のサポート](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="012d8-144">**図 4-20**</span><span class="sxs-lookup"><span data-stu-id="012d8-144">**Figure 4-20**.</span></span> <span data-ttu-id="012d8-145">Visual Studio 2019 での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="012d8-145">gRPC support in Visual Studio 2019</span></span>

<span data-ttu-id="012d8-146">.NET Core 3.0 は、エンドポイントのルーティング、組み込みの IoC サポート、ログ記録など、gRPC をフレームワークにシームレスに統合します。</span><span class="sxs-lookup"><span data-stu-id="012d8-146">.NET Core 3.0 seamlessly integrates gRPC into its framework, including endpoint routing, built-in IoC support, and logging.</span></span> <span data-ttu-id="012d8-147">オープンソース Kestrel web サーバーは、HTTP/2 接続を完全にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="012d8-147">The open-source Kestrel web server fully supports HTTP/2 connections.</span></span>

<span data-ttu-id="012d8-148">図4-21 は、Visual Studio 2019 における gRPC サービスの構造を示しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-148">Figure 4-21 shows structure of a gRPC service in Visual Studio 2019.</span></span> <span data-ttu-id="012d8-149">フォルダー構造には、proto ファイルおよびサービスコードのフォルダーが含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="012d8-149">Note how the folder structure includes folders for the proto files and service code.</span></span>

![Visual Studio 2019 の gRPC プロジェクト](./media/grpc-project.png  )

<span data-ttu-id="012d8-151">**図 4-21**</span><span class="sxs-lookup"><span data-stu-id="012d8-151">**Figure 4-21**.</span></span> <span data-ttu-id="012d8-152">Visual Studio 2019 の gRPC プロジェクト</span><span class="sxs-lookup"><span data-stu-id="012d8-152">gRPC project in Visual Studio 2019</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="012d8-153">gRPC の使用</span><span class="sxs-lookup"><span data-stu-id="012d8-153">gRPC Usage</span></span>

<span data-ttu-id="012d8-154">gRPC は、次のシナリオに適しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-154">gRPC is well suited for the following scenarios:</span></span>

- <span data-ttu-id="012d8-155">低待機時間と高スループット通信。</span><span class="sxs-lookup"><span data-stu-id="012d8-155">Low latency and high throughput communication.</span></span> <span data-ttu-id="012d8-156">gRPC は、効率性が非常に重要な軽量マイクロサービスに適しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-156">gRPC is great for lightweight microservices where efficiency is critical.</span></span>
- <span data-ttu-id="012d8-157">ポイントツーポイントのリアルタイム通信。</span><span class="sxs-lookup"><span data-stu-id="012d8-157">Point-to-point real-time communication.</span></span> <span data-ttu-id="012d8-158">gRPC は双方向ストリーミングに対して優れたサポートをしています。</span><span class="sxs-lookup"><span data-stu-id="012d8-158">gRPC has excellent support for bi-directional streaming.</span></span> <span data-ttu-id="012d8-159">gRPC サービスは、ポーリングせずにリアルタイムでメッセージをプッシュできます。</span><span class="sxs-lookup"><span data-stu-id="012d8-159">gRPC services can push messages in real time without polling.</span></span>
- <span data-ttu-id="012d8-160">多言語環境– gRPC ツールでは、多くの一般的な開発言語がサポートされているため、多言語環境に適しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-160">Polyglot environments – gRPC tooling supports most popular development languages, making it a good choice for multi-language environments.</span></span>
- <span data-ttu-id="012d8-161">ネットワークの制約付き環境– gRPC メッセージは、軽量メッセージ形式である Protobuf を使用してシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-161">Network constrained environments – gRPC messages are serialized with Protobuf, a lightweight message format.</span></span> <span data-ttu-id="012d8-162">GRPC メッセージは、常に同等の JSON メッセージよりも小さくなります。</span><span class="sxs-lookup"><span data-stu-id="012d8-162">A gRPC message is always smaller than an equivalent JSON message.</span></span>

<span data-ttu-id="012d8-163">この書籍の執筆時点では、ほとんどのブラウザーで gRPC のサポートが制限されています。</span><span class="sxs-lookup"><span data-stu-id="012d8-163">At the time of writing of this book, most browsers have limited support for gRPC.</span></span> <span data-ttu-id="012d8-164">gRPC は HTTP/2 機能を多用しており、gRPC クライアントをサポートするために web 要求で必要な制御レベルを提供するブラウザーはありません。</span><span class="sxs-lookup"><span data-stu-id="012d8-164">gRPC heavily uses HTTP/2 features and no browser provides the level of control required over web requests to support a gRPC client.</span></span> <span data-ttu-id="012d8-165">gRPC は、通常、内部マイクロサービスからマイクロサービスへの通信に使用されます。</span><span class="sxs-lookup"><span data-stu-id="012d8-165">gRPC is typically used for internal microservice to microservice communication.</span></span> <span data-ttu-id="012d8-166">図4-22 は、単純な一般的な使用パターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-166">Figure 4-22 shows a simple, but common usage pattern.</span></span>

![gRPC の使用パターン](./media/grpc-usage.png)

<span data-ttu-id="012d8-168">**図 4-22**</span><span class="sxs-lookup"><span data-stu-id="012d8-168">**Figure 4-22**.</span></span> <span data-ttu-id="012d8-169">gRPC の使用パターン</span><span class="sxs-lookup"><span data-stu-id="012d8-169">gRPC usage patterns</span></span>

<span data-ttu-id="012d8-170">前の図では、バックエンドのマイクロサービスへのマイクロサービスが gRPC を使用しているときに、フロントエンドトラフィックが HTTP で呼び出されるしくみを示しています。</span><span class="sxs-lookup"><span data-stu-id="012d8-170">Note in the previous figure how front-end traffic is invoked with HTTP while back-end microservice to microservice uses gRPC.</span></span>

<span data-ttu-id="012d8-171">GRPC は、クラウドネイティブシステム向けに REST の支配を dethroning という大きな役割を果たすことができました。</span><span class="sxs-lookup"><span data-stu-id="012d8-171">Looking ahead, gRPC could play a major role in dethroning the dominance of REST for cloud-native systems.</span></span> <span data-ttu-id="012d8-172">パフォーマンスが向上し、開発が容易になりすぎます。</span><span class="sxs-lookup"><span data-stu-id="012d8-172">The performance benefits and ease of development are too good to pass up.</span></span> <span data-ttu-id="012d8-173">しかし、間違いはありませんが、残りの時間は長くなります。</span><span class="sxs-lookup"><span data-stu-id="012d8-173">However, make no mistake, REST will still be around for a long time.</span></span> <span data-ttu-id="012d8-174">パブリックに公開されている Api や旧バージョンとの互換性のためには引き続き威力を持っています。</span><span class="sxs-lookup"><span data-stu-id="012d8-174">It still excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="012d8-175">[前へ](service-to-service-communication.md)
>[次へ](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="012d8-175">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
