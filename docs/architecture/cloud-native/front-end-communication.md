---
title: フロントエンドのクライアント通信
description: フロントエンド クライアントがクラウド ネイティブ システムと通信する方法を確認する
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: af26873381509df7807db6ecb37a7d73669adb37
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989078"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="d5b4a-103">フロントエンドのクライアント通信</span><span class="sxs-lookup"><span data-stu-id="d5b4a-103">Front-end client communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="d5b4a-104">クラウド ネイティブ システムでは、フロントエンド クライアント (モバイル、Web、およびデスクトップ アプリケーション) は、独立したバックエンド マイクロサービスと対話するための通信チャネルを必要とします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="d5b4a-105">オプションは何ですか?</span><span class="sxs-lookup"><span data-stu-id="d5b4a-105">What are the options?</span></span>

<span data-ttu-id="d5b4a-106">フロントエンド クライアントは、単純な状態を保つために、バックエンド マイクロサービスと*直接通信*できます (図 4-2 参照)。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![クライアントをサービス通信にダイレクト](./media/direct-client-to-service-communication.png)

<span data-ttu-id="d5b4a-108">**図 4-2.**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-108">**Figure 4-2.**</span></span> <span data-ttu-id="d5b4a-109">クライアントをサービス通信にダイレクト</span><span class="sxs-lookup"><span data-stu-id="d5b4a-109">Direct client to service communication</span></span>

<span data-ttu-id="d5b4a-110">このアプローチでは、各マイクロサービスは、フロントエンド クライアントからアクセス可能なパブリック エンドポイントを持っています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="d5b4a-111">運用環境では、マイクロサービスの前にロード バランサーを配置し、トラフィックを比例的にルーティングします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="d5b4a-112">実装は簡単ですが、直接のクライアント通信は単純なマイクロサービス アプリケーションに対してのみ許容されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="d5b4a-113">このパターンは、フロントエンド クライアントとコア バックエンド サービスを緊密に結合し、次の問題に対する扉を開きます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="d5b4a-114">バックエンド サービス リファクタリングに対するクライアントの感受性。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="d5b4a-115">コア バックエンド サービスが直接公開されるほど、攻撃対象が広がります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="d5b4a-116">各マイクロサービス全体にわたる横断的な懸念の重複。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="d5b4a-117">非常に複雑なクライアント コード - クライアントは、複数のエンドポイントを追跡し、回復性の高い方法でエラーを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="d5b4a-118">代わりに、広く受け入れられているクラウド設計パターンは、フロントエンド アプリケーションとバックエンド サービスの間で[API ゲートウェイ サービス](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)を実装することです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="d5b4a-119">このパターンは図 4-3 に示されています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-119">The pattern is shown in Figure 4-3.</span></span>

![API ゲートウェイ パターン](./media/api-gateway-pattern.png)

<span data-ttu-id="d5b4a-121">**図 4-3.**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-121">**Figure 4-3.**</span></span> <span data-ttu-id="d5b4a-122">API ゲートウェイ パターン</span><span class="sxs-lookup"><span data-stu-id="d5b4a-122">API gateway pattern</span></span>

<span data-ttu-id="d5b4a-123">前の図では、API ゲートウェイ サービスがバックエンドコア マイクロサービスを抽象化する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="d5b4a-124">Web API として実装され、*リバース プロキシ*として機能し、着信トラフィックを内部マイクロサービスにルーティングします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="d5b4a-125">ゲートウェイは、内部サービスのパーティション分割とリファクタリングからクライアントを隔離します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="d5b4a-126">バックエンド サービスを変更すると、クライアントを壊すことなく、バックエンド サービスをゲートウェイに格納できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="d5b4a-127">また、ID、キャッシュ、復元性、計測、スロットルなどの横断的な懸念事項に対する最初の防御線でもあります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="d5b4a-128">これらの切削に関する懸念事項の多くは、バックエンドコアサービスからゲートウェイにオフロードされ、バックエンドサービスを簡素化できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="d5b4a-129">API ゲートウェイをシンプルかつ高速に保つには注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="d5b4a-130">通常、ビジネス ロジックはゲートウェイからはないです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="d5b4a-131">複雑なゲートウェイは、ボトルネックになり、最終的にはモノリスそのものになるリスクがあります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="d5b4a-132">大規模なシステムでは、クライアントの種類 (モバイル、Web、デスクトップ) またはバックエンドの機能別に分割された複数の API ゲートウェイが公開されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="d5b4a-133">[フロントエンドのバックエンド](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)パターンは、複数のゲートウェイを実装するための方向を提供します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="d5b4a-134">このパターンは図 4-4 に示されています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-134">The pattern is shown in Figure 4-4.</span></span>

![API ゲートウェイ パターン](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="d5b4a-136">**図4-4。**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-136">**Figure 4-4.**</span></span> <span data-ttu-id="d5b4a-137">フロントエンド パターンのバックエンド</span><span class="sxs-lookup"><span data-stu-id="d5b4a-137">Backend for frontend pattern</span></span>

<span data-ttu-id="d5b4a-138">前の図では、クライアントの種類 (Web、モバイル、またはデスクトップ アプリ) に基づいて、着信トラフィックが特定の API ゲートウェイに送信される方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="d5b4a-139">この方法は、各デバイスの機能がフォーム ファクター、パフォーマンス、および表示の制限によって大きく異なっているため、意味があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="d5b4a-140">通常、モバイル アプリケーションは、ブラウザーやデスクトップ アプリケーションよりも少ない機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="d5b4a-141">各ゲートウェイは、対応するデバイスの機能に合わせて最適化できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="d5b4a-142">まず、独自の API ゲートウェイ サービスを構築できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="d5b4a-143">GitHub のクイック検索では、多くの例が提供されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="d5b4a-144">しかし、いくつかのフレームワークと商用ゲートウェイ製品が利用可能です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="d5b4a-145">オセロットゲートウェイ</span><span class="sxs-lookup"><span data-stu-id="d5b4a-145">Ocelot Gateway</span></span>

<span data-ttu-id="d5b4a-146">単純な .NET クラウド ネイティブ アプリケーションの場合は[、Ocelot ゲートウェイ](https://github.com/ThreeMammals/Ocelot)を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="d5b4a-147">Ocelot は、システムへの統合エントリ ポイントを必要とする .NET マイクロサービス用に作成されたオープン ソース API ゲートウェイです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="d5b4a-148">軽量で、高速で、スケーラブルです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="d5b4a-149">他の API ゲートウェイと同様に、その主な機能は、着信 HTTP 要求をダウンストリーム サービスに転送することです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="d5b4a-150">さらに、.NET Core ミドルウェア パイプラインで構成可能なさまざまな機能をサポートします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="d5b4a-151">その機能セットは次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="d5b4a-152">オセロットの特長</span><span class="sxs-lookup"><span data-stu-id="d5b4a-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="d5b4a-153">ルーティング</span><span class="sxs-lookup"><span data-stu-id="d5b4a-153">Routing</span></span> | <span data-ttu-id="d5b4a-154">認証</span><span class="sxs-lookup"><span data-stu-id="d5b4a-154">Authentication</span></span> |
| <span data-ttu-id="d5b4a-155">要求集約</span><span class="sxs-lookup"><span data-stu-id="d5b4a-155">Request Aggregation</span></span> | <span data-ttu-id="d5b4a-156">承認</span><span class="sxs-lookup"><span data-stu-id="d5b4a-156">Authorization</span></span> |
| <span data-ttu-id="d5b4a-157">サービスディスカバリー(領事とユーレカと)</span><span class="sxs-lookup"><span data-stu-id="d5b4a-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="d5b4a-158">Throttling</span><span class="sxs-lookup"><span data-stu-id="d5b4a-158">Throttling</span></span> |
| <span data-ttu-id="d5b4a-159">負荷分散</span><span class="sxs-lookup"><span data-stu-id="d5b4a-159">Load Balancing</span></span> | <span data-ttu-id="d5b4a-160">ログ記録、トレース</span><span class="sxs-lookup"><span data-stu-id="d5b4a-160">Logging, Tracing</span></span> |
| <span data-ttu-id="d5b4a-161">キャッシュ</span><span class="sxs-lookup"><span data-stu-id="d5b4a-161">Caching</span></span> | <span data-ttu-id="d5b4a-162">ヘッダー/クエリ文字列変換</span><span class="sxs-lookup"><span data-stu-id="d5b4a-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="d5b4a-163">相関パススルー</span><span class="sxs-lookup"><span data-stu-id="d5b4a-163">Correlation Pass-Through</span></span> | <span data-ttu-id="d5b4a-164">カスタムミドルウェア</span><span class="sxs-lookup"><span data-stu-id="d5b4a-164">Custom Middleware</span></span> |
| <span data-ttu-id="d5b4a-165">サービスの品質 (QoS)</span><span class="sxs-lookup"><span data-stu-id="d5b4a-165">Quality of Service</span></span> | <span data-ttu-id="d5b4a-166">再試行ポリシー</span><span class="sxs-lookup"><span data-stu-id="d5b4a-166">Retry Policies</span></span> |

<span data-ttu-id="d5b4a-167">各 Ocelot ゲートウェイは、JSON 構成ファイル内のアップストリームアドレスとダウンストリーム アドレスと構成可能な機能を指定します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="d5b4a-168">クライアントは、OCelot ゲートウェイに HTTP 要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="d5b4a-169">受信すると、Ocelot はパイプラインを通じて HttpRequest オブジェクトを渡し、その構成で指定された状態に渡します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="d5b4a-170">パイプラインの最後に、Ocelot は新しい HTTPResponseObject を作成し、ダウンストリーム サービスに渡します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="d5b4a-171">応答の場合、Ocelot はパイプラインを反転させ、応答をクライアントに返します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="d5b4a-172">オセロットは、NuGet パッケージとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="d5b4a-173">NET 標準 2.0 を対象とし、.NET Core 2.0 以降と .NET Framework 4.6.1 以降の両方のランタイムと互換性を持たできるようにします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="d5b4a-174">Ocelot は、HTTP を話すあらゆるものと統合され、.NET Core がサポートするプラットフォームで実行されます: Linux、macOS、および Windows。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="d5b4a-175">Ocelot は拡張可能で、Docker コンテナー、Azure Kubernetes サービス、その他のパブリック クラウドなど、多くの最新プラットフォームをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="d5b4a-176">Ocelot は[、領事](https://www.consul.io)、 [GraphQL](https://graphql.org)、 ネットフリックスの[ユーレカ](https://github.com/Netflix/eureka)などのオープン ソース パッケージと統合されています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="d5b4a-177">商用 API ゲートウェイの豊富な機能セットを必要としないシンプルなクラウド ネイティブ アプリケーションの Ocelot を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="d5b4a-178">Azure Application Gateway</span><span class="sxs-lookup"><span data-stu-id="d5b4a-178">Azure Application Gateway</span></span>

<span data-ttu-id="d5b4a-179">単純なゲートウェイ要件については[、Azure アプリケーション ゲートウェイ](https://docs.microsoft.com/azure/application-gateway/overview)を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="d5b4a-180">Azure [PaaS サービス](https://azure.microsoft.com/overview/what-is-paas/)として利用できるのは、URL ルーティング、SSL 終了、Web アプリケーション ファイアウォールなどの基本的なゲートウェイ機能です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="d5b4a-181">このサービスは[、レイヤ 7 の負荷分散](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)機能をサポートします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="d5b4a-182">レイヤ 7 では、低レベルの TCP ネットワーク パケットだけでなく、HTTP メッセージの実際のコンテンツに基づいて要求をルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="d5b4a-183">この本を通して、私たちは[Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)でクラウドネイティブシステムをホストすることを伝道します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="d5b4a-184">コンテナ オーケストレーターである Kubernetes は、コンテナ化されたワークロードのデプロイ、スケーリング、および運用上の懸念を自動化します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="d5b4a-185">Azure アプリケーション ゲートウェイは[、Azure Kubernetes サービス](https://azure.microsoft.com/services/kubernetes-service/)クラスターの API ゲートウェイとして構成できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="d5b4a-186">[アプリケーション ゲートウェイの入力コントローラー](https://azure.github.io/application-gateway-kubernetes-ingress/)を使用すると、Azure アプリケーション ゲートウェイは[Azure Kubernetes サービス](https://azure.microsoft.com/services/kubernetes-service/)と直接連携できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="d5b4a-187">図 4.5 にアーキテクチャを示します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-187">Figure 4.5 shows the architecture.</span></span>

![Application Gateway イングレス コントローラー](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="d5b4a-189">**図 4-5.**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-189">**Figure 4-5.**</span></span> <span data-ttu-id="d5b4a-190">Application Gateway イングレス コントローラー</span><span class="sxs-lookup"><span data-stu-id="d5b4a-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="d5b4a-191">Kubernetes には、入力と呼ばれる HTTP (レベル 7) の負荷分散をサポートする組み込み機能[が](https://kubernetes.io/docs/concepts/services-networking/ingress/)含まれています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="d5b4a-192">Ingress は、AKS 内のマイクロサービス インスタンスを外部に公開する方法に関する一連のルールを定義します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="d5b4a-193">前のイメージでは、入力コントローラーはクラスターに対して構成された入力規則を解釈し、自動的に Azure アプリケーション ゲートウェイを構成します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="d5b4a-194">これらのルールに基づいて、アプリケーション ゲートウェイは AKS 内で実行されているマイクロサービスにトラフィックをルーティングします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="d5b4a-195">入力コントローラーは、入力規則の変更をリッスンし、Azure アプリケーション ゲートウェイに適切な変更を加えます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="d5b4a-196">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="d5b4a-196">Azure API Management</span></span>

<span data-ttu-id="d5b4a-197">中規模から大規模なクラウド ネイティブ システムの場合は[、Azure API 管理](https://azure.microsoft.com/services/api-management/)を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="d5b4a-198">これは、API Gateway のニーズを解決するだけでなく、開発者と管理のフル機能を提供するクラウドベースのサービスです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="d5b4a-199">API 管理を図 4-6 に示します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-199">API Management is shown in Figure 4-6.</span></span>

![Azure API Management](./media/azure-api-management.png)

<span data-ttu-id="d5b4a-201">**図4-6。**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-201">**Figure 4-6.**</span></span> <span data-ttu-id="d5b4a-202">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="d5b4a-202">Azure API Management</span></span>

<span data-ttu-id="d5b4a-203">まず、API Management は、構成可能なルールとポリシーに基づいてバックエンド サービスへの制御されたアクセスを許可するゲートウェイ サーバーを公開します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="d5b4a-204">これらのサービスは、Azure クラウド、オンプレミスのデータ センター、またはその他のパブリック クラウドに配置できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="d5b4a-205">API キーと JWT トークンによって、誰が何を実行できるかが決まります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="d5b4a-206">すべてのトラフィックは分析目的でログに記録されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="d5b4a-207">開発者向け API Management は、サービス、ドキュメント、およびそれらを呼び出すためのサンプル コードへのアクセスを提供する開発者ポータルを提供します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="d5b4a-208">開発者は、Swagger/Open API を使用してサービス エンドポイントを検査し、その使用状況を分析できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="d5b4a-209">このサービスは、.NET、Java、ゴランなどの主要な開発プラットフォームで機能します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="d5b4a-210">発行者ポータルは、管理者が API を公開し、その動作を管理する管理ダッシュボードを公開します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="d5b4a-211">サービス アクセスを許可したり、サービスの正常性を監視したり、サービス テレメトリを収集したりできます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="d5b4a-212">管理者は、*動作に影響*を与えるポリシーを各エンドポイントに適用します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="d5b4a-213">[ポリシー](https://docs.microsoft.com/azure/api-management/api-management-howto-policies)は、サービス呼び出しごとに順番に実行される、事前構築済みステートメントです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="d5b4a-214">ポリシーは、着信呼び出し、発信呼び出し、またはエラー発生時に呼び出されるように構成されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="d5b4a-215">ポリシーを組み合わせる際に決定論的な順序を有効にするように、ポリシーを異なるサービス スコープで適用できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="d5b4a-216">製品には、多数の事前構築済み[ポリシー](https://docs.microsoft.com/azure/api-management/api-management-policies)が付属しています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="d5b4a-217">ポリシーがクラウドネイティブサービスの動作に影響を与える例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="d5b4a-218">サービスアクセスを制限します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-218">Restrict service access.</span></span>
- <span data-ttu-id="d5b4a-219">認証を強制する。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-219">Enforce authentication.</span></span>  
- <span data-ttu-id="d5b4a-220">必要に応じて、単一ソースからの呼び出しを調整します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="d5b4a-221">キャッシュを有効にする。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-221">Enable caching.</span></span>
- <span data-ttu-id="d5b4a-222">特定の IP アドレスからの呼び出しをブロックします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="d5b4a-223">サービスのフローを制御します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-223">Control the flow of the service.</span></span>
- <span data-ttu-id="d5b4a-224">SOAP から REST への要求、または XML から JSON などの異なるデータ形式間で要求を変換します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="d5b4a-225">Azure API Management は、クラウドまたはデータ センター内の任意の場所でホストされているバックエンド サービスを公開できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="d5b4a-226">クラウドネイティブ システムで公開できるレガシ サービスの場合、REST API と SOAP API の両方をサポートします。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="d5b4a-227">他の Azure サービスも API 管理を通じて公開できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="d5b4a-228">Azure[サービス バス](https://azure.microsoft.com/services/service-bus/)や Azure[ロジック アプリ](https://azure.microsoft.com/services/logic-apps/)などの Azure バッキング サービスの上にマネージ API を配置できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="d5b4a-229">Azure API Management には、組み込みの負荷分散のサポートは含まれていないので、負荷分散サービスと組み合わせて使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="d5b4a-230">Azure API 管理は[、4 つの異なる層](https://azure.microsoft.com/pricing/details/api-management/)で利用できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="d5b4a-231">Developer</span><span class="sxs-lookup"><span data-stu-id="d5b4a-231">Developer</span></span>
- <span data-ttu-id="d5b4a-232">Basic</span><span class="sxs-lookup"><span data-stu-id="d5b4a-232">Basic</span></span>
- <span data-ttu-id="d5b4a-233">Standard</span><span class="sxs-lookup"><span data-stu-id="d5b4a-233">Standard</span></span>
- <span data-ttu-id="d5b4a-234">Premium</span><span class="sxs-lookup"><span data-stu-id="d5b4a-234">Premium</span></span>

<span data-ttu-id="d5b4a-235">開発者層は、非実稼働ワークロードと評価用です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="d5b4a-236">他の層では、徐々により多くの電力、機能、およびより高いサービス レベルアグリーメント (SLA) が提供されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="d5b4a-237">Premium レベルは[、Azure 仮想ネットワーク](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview)と[複数リージョンのサポート](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)を提供します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="d5b4a-238">すべての層には、1 時間あたりの固定価格があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="d5b4a-239">最近、マイクロソフトは Azure [API 管理用の API 管理サーバーレス層](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/)を発表しました。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-239">Recently, Microsoft announced a [API Management serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="d5b4a-240">このサービスは、*サーバー*レス コンピューティング モデルを中心に設計された API Management のバリアントです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="d5b4a-241">以前に示した「事前割り当て済み」の価格レベルとは異なり、消費レベルは即時プロビジョニングとアクションごとのペイパープライシングを提供します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="d5b4a-242">API ゲートウェイ機能は、次のユースケースで有効になります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="d5b4a-243">[Azure 関数](https://docs.microsoft.com/azure/azure-functions/functions-overview)や[Azure ロジック アプリ](https://azure.microsoft.com/services/logic-apps/)などのサーバーレス テクノロジを使用して実装されたマイクロサービス 。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="d5b4a-244">サービス バスのキューとトピック、Azure ストレージなどの Azure バッキング サービス リソース。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="d5b4a-245">トラフィックが時折大きなスパイクを持っているが、時間の大半が低いままであるマイクロサービス。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="d5b4a-246">消費層は、同じ基になるサービス API 管理コンポーネントを使用しますが、動的に割り当てられたリソースに基づいてまったく異なるアーキテクチャを使用します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="d5b4a-247">サーバレスコンピューティングモデルと完全に一致します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="d5b4a-248">管理するインフラストラクチャがありません。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="d5b4a-249">アイドル容量がありません。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-249">No idle capacity.</span></span>
- <span data-ttu-id="d5b4a-250">高可用性。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-250">High-availability.</span></span>
- <span data-ttu-id="d5b4a-251">自動スケーリング。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-251">Automatic scaling.</span></span>
- <span data-ttu-id="d5b4a-252">コストは実際の使用状況に基づいています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="d5b4a-253">新しい消費レベルは、サーバーレス リソースを API として公開するクラウド ネイティブ システムに最適です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

> <span data-ttu-id="d5b4a-254">執筆時点では、Azure クラウドでの使用量レベルはプレビュー段階にあります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-254">At the time of writing, the consumption tier is in preview in the Azure cloud.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="d5b4a-255">リアルタイム通信</span><span class="sxs-lookup"><span data-stu-id="d5b4a-255">Real-time communication</span></span>

<span data-ttu-id="d5b4a-256">リアルタイム通信 (プッシュ) は、HTTP 経由でバックエンド のクラウドネイティブ システムと通信するフロントエンド アプリケーションのオプションです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-256">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="d5b4a-257">財務ティッカー、オンライン教育、ゲーム、およびジョブの進行状況の更新などのアプリケーションでは、バックエンドからの即時かつリアルタイムの応答が必要です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-257">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="d5b4a-258">通常の HTTP 通信では、クライアントが新しいデータが使用可能なタイミングを知る方法はありません。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-258">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="d5b4a-259">クライアントは、サーバーに対して継続的に*ポーリング*または要求を送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-259">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="d5b4a-260">*リアルタイム*通信を使用すると、サーバはいつでもクライアントに新しいデータをプッシュできます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-260">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="d5b4a-261">リアルタイム システムは、多くの場合、高頻度のデータ フローと多数の同時クライアント接続によって特徴付けられる。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-261">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="d5b4a-262">リアルタイム接続を手動で実装すると、接続されたクライアントに対するスケーラビリティと信頼性の高いメッセージングを実現するために、簡単ではないインフラストラクチャが必要になるため、すぐに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-262">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="d5b4a-263">Azure Redis Cache のインスタンスと、クライアント アフィニティ用のスティッキー セッションで構成されたロード バランサーのセットを管理できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-263">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="d5b4a-264">[Azure SignalR サービス](https://azure.microsoft.com/services/signalr-service/)は、クラウド ネイティブ アプリケーションのリアルタイム通信を簡素化する、完全に管理された Azure サービスです。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-264">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="d5b4a-265">容量のプロビジョニング、スケーリング、永続的な接続などの技術的な実装の詳細は抽象化されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-265">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="d5b4a-266">99.9%のサービスレベル契約で処理されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-266">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="d5b4a-267">インフラストラクチャの配管ではなく、アプリケーションの機能に焦点を当てます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-267">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="d5b4a-268">クラウドベースの HTTP サービスを有効にすると、ブラウザー、モバイル、デスクトップ アプリケーションなど、接続されたクライアントにコンテンツの更新を直接プッシュできます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-268">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="d5b4a-269">クライアントは、サーバーをポーリングする必要なしに更新されます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-269">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="d5b4a-270">Azure SignalR は、WebSocket、サーバー側イベント、ロング ポーリングなど、リアルタイム接続を作成するトランスポート テクノロジを抽象化します。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-270">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="d5b4a-271">開発者は、接続されたクライアントのすべてまたは特定のサブセットにメッセージを送信することに重点を置いています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-271">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="d5b4a-272">図 4-7 は、Azure SignalR が有効になっているクラウド ネイティブ アプリケーションに接続する HTTP クライアントのセットを示しています。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-272">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="d5b4a-274">**図 4-7.**</span><span class="sxs-lookup"><span data-stu-id="d5b4a-274">**Figure 4-7.**</span></span> <span data-ttu-id="d5b4a-275">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="d5b4a-275">Azure SignalR</span></span>

<span data-ttu-id="d5b4a-276">Azure SignalR サービスのもう 1 つの利点は、サーバーレス クラウド ネイティブ サービスの実装です。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-276">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="d5b4a-277">コードは Azure 関数トリガーを使用してオンデマンドで実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-277">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="d5b4a-278">コードはクライアントとの長い接続を維持しないため、このシナリオは難しい場合があります。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-278">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="d5b4a-279">Azure SignalR サービスでは、サービスが既に接続を管理しているため、このような状況に対処できます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-279">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="d5b4a-280">Azure SignalR サービスは、Azure SQL データベース、サービス バス、Redis キャッシュなど、他の Azure サービスと密接に統合され、クラウド ネイティブ アプリケーションの多くの可能性が開かれます。</span><span class="sxs-lookup"><span data-stu-id="d5b4a-280">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d5b4a-281">[前へ](communication-patterns.md)
>[次へ](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="d5b4a-281">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>
