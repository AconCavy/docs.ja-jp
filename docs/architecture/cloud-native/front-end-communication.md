---
title: フロントエンドのクライアント通信
description: フロントエンド クライアントがクラウド ネイティブ システムと通信する方法を確認する
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: af26873381509df7807db6ecb37a7d73669adb37
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989078"
---
# <a name="front-end-client-communication"></a>フロントエンドのクライアント通信

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

クラウド ネイティブ システムでは、フロントエンド クライアント (モバイル、Web、およびデスクトップ アプリケーション) は、独立したバックエンド マイクロサービスと対話するための通信チャネルを必要とします。  

オプションは何ですか?

フロントエンド クライアントは、単純な状態を保つために、バックエンド マイクロサービスと*直接通信*できます (図 4-2 参照)。

![クライアントをサービス通信にダイレクト](./media/direct-client-to-service-communication.png)

**図 4-2.** クライアントをサービス通信にダイレクト

このアプローチでは、各マイクロサービスは、フロントエンド クライアントからアクセス可能なパブリック エンドポイントを持っています。 運用環境では、マイクロサービスの前にロード バランサーを配置し、トラフィックを比例的にルーティングします。

実装は簡単ですが、直接のクライアント通信は単純なマイクロサービス アプリケーションに対してのみ許容されます。 このパターンは、フロントエンド クライアントとコア バックエンド サービスを緊密に結合し、次の問題に対する扉を開きます。

- バックエンド サービス リファクタリングに対するクライアントの感受性。
- コア バックエンド サービスが直接公開されるほど、攻撃対象が広がります。
- 各マイクロサービス全体にわたる横断的な懸念の重複。
- 非常に複雑なクライアント コード - クライアントは、複数のエンドポイントを追跡し、回復性の高い方法でエラーを処理する必要があります。

代わりに、広く受け入れられているクラウド設計パターンは、フロントエンド アプリケーションとバックエンド サービスの間で[API ゲートウェイ サービス](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)を実装することです。 このパターンは図 4-3 に示されています。

![API ゲートウェイ パターン](./media/api-gateway-pattern.png)

**図 4-3.** API ゲートウェイ パターン

前の図では、API ゲートウェイ サービスがバックエンドコア マイクロサービスを抽象化する方法に注意してください。 Web API として実装され、*リバース プロキシ*として機能し、着信トラフィックを内部マイクロサービスにルーティングします。

ゲートウェイは、内部サービスのパーティション分割とリファクタリングからクライアントを隔離します。 バックエンド サービスを変更すると、クライアントを壊すことなく、バックエンド サービスをゲートウェイに格納できます。 また、ID、キャッシュ、復元性、計測、スロットルなどの横断的な懸念事項に対する最初の防御線でもあります。 これらの切削に関する懸念事項の多くは、バックエンドコアサービスからゲートウェイにオフロードされ、バックエンドサービスを簡素化できます。

API ゲートウェイをシンプルかつ高速に保つには注意が必要です。 通常、ビジネス ロジックはゲートウェイからはないです。 複雑なゲートウェイは、ボトルネックになり、最終的にはモノリスそのものになるリスクがあります。 大規模なシステムでは、クライアントの種類 (モバイル、Web、デスクトップ) またはバックエンドの機能別に分割された複数の API ゲートウェイが公開されることがよくあります。 [フロントエンドのバックエンド](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)パターンは、複数のゲートウェイを実装するための方向を提供します。 このパターンは図 4-4 に示されています。

![API ゲートウェイ パターン](./media/backend-for-frontend-pattern.png)

**図4-4。** フロントエンド パターンのバックエンド

前の図では、クライアントの種類 (Web、モバイル、またはデスクトップ アプリ) に基づいて、着信トラフィックが特定の API ゲートウェイに送信される方法に注意してください。 この方法は、各デバイスの機能がフォーム ファクター、パフォーマンス、および表示の制限によって大きく異なっているため、意味があります。 通常、モバイル アプリケーションは、ブラウザーやデスクトップ アプリケーションよりも少ない機能を公開します。 各ゲートウェイは、対応するデバイスの機能に合わせて最適化できます。

まず、独自の API ゲートウェイ サービスを構築できます。 GitHub のクイック検索では、多くの例が提供されます。 しかし、いくつかのフレームワークと商用ゲートウェイ製品が利用可能です。

## <a name="ocelot-gateway"></a>オセロットゲートウェイ

単純な .NET クラウド ネイティブ アプリケーションの場合は[、Ocelot ゲートウェイ](https://github.com/ThreeMammals/Ocelot)を検討してください。 Ocelot は、システムへの統合エントリ ポイントを必要とする .NET マイクロサービス用に作成されたオープン ソース API ゲートウェイです。 軽量で、高速で、スケーラブルです。

他の API ゲートウェイと同様に、その主な機能は、着信 HTTP 要求をダウンストリーム サービスに転送することです。 さらに、.NET Core ミドルウェア パイプラインで構成可能なさまざまな機能をサポートします。 その機能セットは次の表に示します。

|オセロットの特長  | |
| :-------- | :-------- |
| ルーティング | 認証 |
| 要求集約 | 承認 |
| サービスディスカバリー(領事とユーレカと) | Throttling |
| 負荷分散 | ログ記録、トレース |
| キャッシュ | ヘッダー/クエリ文字列変換 |
| 相関パススルー | カスタムミドルウェア |
| サービスの品質 (QoS) | 再試行ポリシー |

各 Ocelot ゲートウェイは、JSON 構成ファイル内のアップストリームアドレスとダウンストリーム アドレスと構成可能な機能を指定します。 クライアントは、OCelot ゲートウェイに HTTP 要求を送信します。 受信すると、Ocelot はパイプラインを通じて HttpRequest オブジェクトを渡し、その構成で指定された状態に渡します。 パイプラインの最後に、Ocelot は新しい HTTPResponseObject を作成し、ダウンストリーム サービスに渡します。 応答の場合、Ocelot はパイプラインを反転させ、応答をクライアントに返します。

オセロットは、NuGet パッケージとして使用できます。 NET 標準 2.0 を対象とし、.NET Core 2.0 以降と .NET Framework 4.6.1 以降の両方のランタイムと互換性を持たできるようにします。 Ocelot は、HTTP を話すあらゆるものと統合され、.NET Core がサポートするプラットフォームで実行されます: Linux、macOS、および Windows。 Ocelot は拡張可能で、Docker コンテナー、Azure Kubernetes サービス、その他のパブリック クラウドなど、多くの最新プラットフォームをサポートしています。  Ocelot は[、領事](https://www.consul.io)、 [GraphQL](https://graphql.org)、 ネットフリックスの[ユーレカ](https://github.com/Netflix/eureka)などのオープン ソース パッケージと統合されています。

商用 API ゲートウェイの豊富な機能セットを必要としないシンプルなクラウド ネイティブ アプリケーションの Ocelot を検討してください。

## <a name="azure-application-gateway"></a>Azure Application Gateway

単純なゲートウェイ要件については[、Azure アプリケーション ゲートウェイ](https://docs.microsoft.com/azure/application-gateway/overview)を検討してください。 Azure [PaaS サービス](https://azure.microsoft.com/overview/what-is-paas/)として利用できるのは、URL ルーティング、SSL 終了、Web アプリケーション ファイアウォールなどの基本的なゲートウェイ機能です。 このサービスは[、レイヤ 7 の負荷分散](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)機能をサポートします。 レイヤ 7 では、低レベルの TCP ネットワーク パケットだけでなく、HTTP メッセージの実際のコンテンツに基づいて要求をルーティングできます。

この本を通して、私たちは[Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)でクラウドネイティブシステムをホストすることを伝道します。 コンテナ オーケストレーターである Kubernetes は、コンテナ化されたワークロードのデプロイ、スケーリング、および運用上の懸念を自動化します。 Azure アプリケーション ゲートウェイは[、Azure Kubernetes サービス](https://azure.microsoft.com/services/kubernetes-service/)クラスターの API ゲートウェイとして構成できます。

[アプリケーション ゲートウェイの入力コントローラー](https://azure.github.io/application-gateway-kubernetes-ingress/)を使用すると、Azure アプリケーション ゲートウェイは[Azure Kubernetes サービス](https://azure.microsoft.com/services/kubernetes-service/)と直接連携できます。 図 4.5 にアーキテクチャを示します。

![Application Gateway イングレス コントローラー](./media/application-gateway-ingress-controller.png)

**図 4-5.** Application Gateway イングレス コントローラー

Kubernetes には、入力と呼ばれる HTTP (レベル 7) の負荷分散をサポートする組み込み機能[が](https://kubernetes.io/docs/concepts/services-networking/ingress/)含まれています。 Ingress は、AKS 内のマイクロサービス インスタンスを外部に公開する方法に関する一連のルールを定義します。 前のイメージでは、入力コントローラーはクラスターに対して構成された入力規則を解釈し、自動的に Azure アプリケーション ゲートウェイを構成します。 これらのルールに基づいて、アプリケーション ゲートウェイは AKS 内で実行されているマイクロサービスにトラフィックをルーティングします。 入力コントローラーは、入力規則の変更をリッスンし、Azure アプリケーション ゲートウェイに適切な変更を加えます。

## <a name="azure-api-management"></a>Azure API Management

中規模から大規模なクラウド ネイティブ システムの場合は[、Azure API 管理](https://azure.microsoft.com/services/api-management/)を検討してください。 これは、API Gateway のニーズを解決するだけでなく、開発者と管理のフル機能を提供するクラウドベースのサービスです。 API 管理を図 4-6 に示します。

![Azure API Management](./media/azure-api-management.png)

**図4-6。** Azure API Management

まず、API Management は、構成可能なルールとポリシーに基づいてバックエンド サービスへの制御されたアクセスを許可するゲートウェイ サーバーを公開します。 これらのサービスは、Azure クラウド、オンプレミスのデータ センター、またはその他のパブリック クラウドに配置できます。 API キーと JWT トークンによって、誰が何を実行できるかが決まります。 すべてのトラフィックは分析目的でログに記録されます。

開発者向け API Management は、サービス、ドキュメント、およびそれらを呼び出すためのサンプル コードへのアクセスを提供する開発者ポータルを提供します。 開発者は、Swagger/Open API を使用してサービス エンドポイントを検査し、その使用状況を分析できます。 このサービスは、.NET、Java、ゴランなどの主要な開発プラットフォームで機能します。

発行者ポータルは、管理者が API を公開し、その動作を管理する管理ダッシュボードを公開します。 サービス アクセスを許可したり、サービスの正常性を監視したり、サービス テレメトリを収集したりできます。 管理者は、*動作に影響*を与えるポリシーを各エンドポイントに適用します。 [ポリシー](https://docs.microsoft.com/azure/api-management/api-management-howto-policies)は、サービス呼び出しごとに順番に実行される、事前構築済みステートメントです。  ポリシーは、着信呼び出し、発信呼び出し、またはエラー発生時に呼び出されるように構成されます。 ポリシーを組み合わせる際に決定論的な順序を有効にするように、ポリシーを異なるサービス スコープで適用できます。 製品には、多数の事前構築済み[ポリシー](https://docs.microsoft.com/azure/api-management/api-management-policies)が付属しています。

ポリシーがクラウドネイティブサービスの動作に影響を与える例を次に示します。  

- サービスアクセスを制限します。
- 認証を強制する。  
- 必要に応じて、単一ソースからの呼び出しを調整します。
- キャッシュを有効にする。
- 特定の IP アドレスからの呼び出しをブロックします。
- サービスのフローを制御します。
- SOAP から REST への要求、または XML から JSON などの異なるデータ形式間で要求を変換します。

Azure API Management は、クラウドまたはデータ センター内の任意の場所でホストされているバックエンド サービスを公開できます。 クラウドネイティブ システムで公開できるレガシ サービスの場合、REST API と SOAP API の両方をサポートします。 他の Azure サービスも API 管理を通じて公開できます。 Azure[サービス バス](https://azure.microsoft.com/services/service-bus/)や Azure[ロジック アプリ](https://azure.microsoft.com/services/logic-apps/)などの Azure バッキング サービスの上にマネージ API を配置できます。 Azure API Management には、組み込みの負荷分散のサポートは含まれていないので、負荷分散サービスと組み合わせて使用する必要があります。

Azure API 管理は[、4 つの異なる層](https://azure.microsoft.com/pricing/details/api-management/)で利用できます。

- Developer
- Basic
- Standard
- Premium

開発者層は、非実稼働ワークロードと評価用です。 他の層では、徐々により多くの電力、機能、およびより高いサービス レベルアグリーメント (SLA) が提供されます。 Premium レベルは[、Azure 仮想ネットワーク](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview)と[複数リージョンのサポート](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)を提供します。 すべての層には、1 時間あたりの固定価格があります。

最近、マイクロソフトは Azure [API 管理用の API 管理サーバーレス層](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/)を発表しました。 このサービスは、*サーバー*レス コンピューティング モデルを中心に設計された API Management のバリアントです。 以前に示した「事前割り当て済み」の価格レベルとは異なり、消費レベルは即時プロビジョニングとアクションごとのペイパープライシングを提供します。

API ゲートウェイ機能は、次のユースケースで有効になります。

- [Azure 関数](https://docs.microsoft.com/azure/azure-functions/functions-overview)や[Azure ロジック アプリ](https://azure.microsoft.com/services/logic-apps/)などのサーバーレス テクノロジを使用して実装されたマイクロサービス 。
- サービス バスのキューとトピック、Azure ストレージなどの Azure バッキング サービス リソース。
- トラフィックが時折大きなスパイクを持っているが、時間の大半が低いままであるマイクロサービス。

消費層は、同じ基になるサービス API 管理コンポーネントを使用しますが、動的に割り当てられたリソースに基づいてまったく異なるアーキテクチャを使用します。 サーバレスコンピューティングモデルと完全に一致します。

- 管理するインフラストラクチャがありません。
- アイドル容量がありません。
- 高可用性。
- 自動スケーリング。
- コストは実際の使用状況に基づいています。
  
新しい消費レベルは、サーバーレス リソースを API として公開するクラウド ネイティブ システムに最適です。

> 執筆時点では、Azure クラウドでの使用量レベルはプレビュー段階にあります。

## <a name="real-time-communication"></a>リアルタイム通信

リアルタイム通信 (プッシュ) は、HTTP 経由でバックエンド のクラウドネイティブ システムと通信するフロントエンド アプリケーションのオプションです。 財務ティッカー、オンライン教育、ゲーム、およびジョブの進行状況の更新などのアプリケーションでは、バックエンドからの即時かつリアルタイムの応答が必要です。 通常の HTTP 通信では、クライアントが新しいデータが使用可能なタイミングを知る方法はありません。 クライアントは、サーバーに対して継続的に*ポーリング*または要求を送信する必要があります。 *リアルタイム*通信を使用すると、サーバはいつでもクライアントに新しいデータをプッシュできます。

リアルタイム システムは、多くの場合、高頻度のデータ フローと多数の同時クライアント接続によって特徴付けられる。 リアルタイム接続を手動で実装すると、接続されたクライアントに対するスケーラビリティと信頼性の高いメッセージングを実現するために、簡単ではないインフラストラクチャが必要になるため、すぐに複雑になります。 Azure Redis Cache のインスタンスと、クライアント アフィニティ用のスティッキー セッションで構成されたロード バランサーのセットを管理できます。

[Azure SignalR サービス](https://azure.microsoft.com/services/signalr-service/)は、クラウド ネイティブ アプリケーションのリアルタイム通信を簡素化する、完全に管理された Azure サービスです。 容量のプロビジョニング、スケーリング、永続的な接続などの技術的な実装の詳細は抽象化されます。 99.9%のサービスレベル契約で処理されます。 インフラストラクチャの配管ではなく、アプリケーションの機能に焦点を当てます。

クラウドベースの HTTP サービスを有効にすると、ブラウザー、モバイル、デスクトップ アプリケーションなど、接続されたクライアントにコンテンツの更新を直接プッシュできます。 クライアントは、サーバーをポーリングする必要なしに更新されます。 Azure SignalR は、WebSocket、サーバー側イベント、ロング ポーリングなど、リアルタイム接続を作成するトランスポート テクノロジを抽象化します。 開発者は、接続されたクライアントのすべてまたは特定のサブセットにメッセージを送信することに重点を置いています。

図 4-7 は、Azure SignalR が有効になっているクラウド ネイティブ アプリケーションに接続する HTTP クライアントのセットを示しています。

![Azure SignalR](./media/azure-signalr-service.png)

**図 4-7.** Azure SignalR

Azure SignalR サービスのもう 1 つの利点は、サーバーレス クラウド ネイティブ サービスの実装です。 コードは Azure 関数トリガーを使用してオンデマンドで実行される可能性があります。 コードはクライアントとの長い接続を維持しないため、このシナリオは難しい場合があります。 Azure SignalR サービスでは、サービスが既に接続を管理しているため、このような状況に対処できます。

Azure SignalR サービスは、Azure SQL データベース、サービス バス、Redis キャッシュなど、他の Azure サービスと密接に統合され、クラウド ネイティブ アプリケーションの多くの可能性が開かれます。

>[!div class="step-by-step"]
>[前へ](communication-patterns.md)
>[次へ](service-to-service-communication.md)
