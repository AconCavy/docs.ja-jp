---
title: gRPC
description: gRPC、クラウドネイティブアプリケーションにおけるその役割、および HTTP RESTful 通信との違いについて説明します。
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524209"
---
# <a name="grpc"></a><span data-ttu-id="ddc82-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="ddc82-103">gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="ddc82-104">ここまでの本では[、REST ベース](https://docs.microsoft.com/azure/architecture/best-practices/api-design)のコミュニケーションに焦点を当てていました。</span><span class="sxs-lookup"><span data-stu-id="ddc82-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="ddc82-105">REST は、エンティティ リソースに対する CRUD ベースの操作を定義する柔軟なアーキテクチャ スタイルであることを確認しました。</span><span class="sxs-lookup"><span data-stu-id="ddc82-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="ddc82-106">クライアントは、要求/応答通信モデルを使用して、HTTP 全体のリソースと対話します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="ddc82-107">REST は広く実装されていますが、新しい通信技術 gRPC はクラウドネイティブ コミュニティ全体で大きな勢いを増しています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="ddc82-108">gRPCとは何ですか?</span><span class="sxs-lookup"><span data-stu-id="ddc82-108">What is gRPC?</span></span>

<span data-ttu-id="ddc82-109">gRPC は、古い[リモート プロシージャ コール (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call)プロトコルを進化させる最新の高性能フレームワークです。</span><span class="sxs-lookup"><span data-stu-id="ddc82-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="ddc82-110">gRPC は、アプリケーション レベルでは、クライアントとバックエンド サービス間のメッセージングを合理化します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="ddc82-111">Googleから生まれたgRPCはオープンソースであり、[クラウドネイティブ製品のクラウドネイティブコンピューティング財団(CNCF)](https://www.cncf.io/)エコシステムの一部です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="ddc82-112">CNCF は gRPC を[インキュベート プロジェクトと見なします](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="ddc82-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="ddc82-113">インキュベートとは、エンドユーザーがプロダクションアプリケーションで技術を使用していることを意味し、プロジェクトには健全な貢献者が多数あります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="ddc82-114">一般的な gRPC クライアント アプリでは、ビジネス操作を実装するローカルのインプロセス関数が公開されます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="ddc82-115">そのローカル関数は、リモートマシン上の別の関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="ddc82-116">ローカル呼び出しと思われるものは、基本的にリモート サービスへの透過的なアウトプロセス呼び出しになります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="ddc82-117">RPC 配管は、コンピュータ間のポイント ツー ポイント ネットワーク通信、シリアル化、および実行を抽象化します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="ddc82-118">クラウド ネイティブ アプリケーションでは、開発者はプログラミング言語、フレームワーク、テクノロジ間で作業することがよくあります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="ddc82-119">この*相互運用性*により、メッセージ コントラクトと、クロスプラットフォーム通信に必要な機能が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="ddc82-120">gRPC は、これらの問題を抽象化する「均一水平層」を提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="ddc82-121">開発者は、ビジネス機能に焦点を当てたネイティブ プラットフォームでコードを記述し、gRPC は通信のプラミングを処理します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="ddc82-122">gRPC は、Java、JavaScript、C#、Go、Swift、NodeJS など、最も一般的な開発スタック全体で包括的なサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="ddc82-123">gRPC の利点</span><span class="sxs-lookup"><span data-stu-id="ddc82-123">gRPC Benefits</span></span>

<span data-ttu-id="ddc82-124">gRPC は、そのトランスポート プロトコルに HTTP/2 を使用します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="ddc82-125">HTTP 1.1 との互換性はありますが、HTTP/2 には多くの高度な機能があります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="ddc82-126">データ転送用のバイナリ プロトコル - データをクリア テキストとして送信する HTTP 1.1 とは異なり。</span><span class="sxs-lookup"><span data-stu-id="ddc82-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="ddc82-127">同じ接続で複数の並列要求を送信するための多重化サポート - HTTP 1.1 は、一度に 1 つの要求/応答メッセージに処理を制限します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="ddc82-128">クライアント要求とサーバー応答の両方を同時に送信するための双方向の全二重通信。</span><span class="sxs-lookup"><span data-stu-id="ddc82-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="ddc82-129">組み込みのストリーミングにより、大きなデータセットを非同期的にストリーミングする要求と応答を可能にします。</span><span class="sxs-lookup"><span data-stu-id="ddc82-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="ddc82-130">gRPCは軽量で高パフォーマンスです。</span><span class="sxs-lookup"><span data-stu-id="ddc82-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="ddc82-131">メッセージが 60 ~ 80% 小さい JSON シリアル化よりも最大 8 倍高速になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="ddc82-132">マイクロソフト[の Windows 通信財団 (WCF) では](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)、gRPC のパフォーマンスは、高度に最適化された[NetTCP バインディング](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)の速度と効率を超えています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="ddc82-133">NetTCP とは異なり、 マイクロソフトスタックを支持する、 gRPC はクロスプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="ddc82-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="ddc82-134">プロトコル バッファー</span><span class="sxs-lookup"><span data-stu-id="ddc82-134">Protocol Buffers</span></span>

<span data-ttu-id="ddc82-135">gRPC はプロトコル バッファと呼ばれるオープンソース技術[を採用しています](https://developers.google.com/protocol-buffers/docs/overview)。</span><span class="sxs-lookup"><span data-stu-id="ddc82-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="ddc82-136">サービスが相互に送信する構造化されたメッセージをシリアル化するための、効率性とプラットフォームに依存しないシリアル化形式を提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="ddc82-137">クロスプラットフォーム インターフェイス定義言語 (IDL) を使用して、開発者は各マイクロサービスのサービス コントラクトを定義します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="ddc82-138">テキスト ベース`.proto`のファイルとして実装されたコントラクトは、各サービスのメソッド、入力、および出力を記述します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="ddc82-139">同じコントラクト ファイルを、異なる開発プラットフォームで構築された gRPC クライアントとサービスに使用できます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="ddc82-140">Protobuf コンパイラは、proto ファイルを`protoc`使用して、ターゲット プラットフォームのクライアントコードとサービスコードの両方を生成します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="ddc82-141">コードには、次のコンポーネントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-141">The code includes the following components:</span></span>

- <span data-ttu-id="ddc82-142">クライアントとサービスによって共有される、メッセージのサービス操作とデータ要素を表す厳密に型指定されたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ddc82-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="ddc82-143">リモート gRPC サービスが継承および拡張できる、必要なネットワーク配管を持つ厳密に型指定された基本クラス。</span><span class="sxs-lookup"><span data-stu-id="ddc82-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="ddc82-144">リモート gRPC サービスを呼び出すために必要な配管を含むクライアント スタブ。</span><span class="sxs-lookup"><span data-stu-id="ddc82-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="ddc82-145">実行時に、各メッセージは標準の Protobuf 表現としてシリアル化され、クライアントとリモート サービスの間で交換されます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="ddc82-146">JSON や XML とは異なり、Protobuf メッセージはコンパイル済みバイナリ バイトとしてシリアル化されます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="ddc82-147">マイクロソフト アーキテクチャ サイトから入手できる[、WCF 開発者向けの gRPC](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)のマニュアルでは、gRPC とプロトコル バッファーの詳細な説明を提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="ddc82-148">NET での gRPC サポート</span><span class="sxs-lookup"><span data-stu-id="ddc82-148">gRPC support in .NET</span></span>

<span data-ttu-id="ddc82-149">gRPC は .NET Core 3.0 SDK 以降に統合されています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-149">gRPC is integrated into .NET Core 3.0 SDK or later.</span></span> <span data-ttu-id="ddc82-150">次のツールは、それをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-150">The following tools support it:</span></span>

- <span data-ttu-id="ddc82-151">Web 開発ワークロードがインストールされた Visual Studio 2019、バージョン 16.3 以降。</span><span class="sxs-lookup"><span data-stu-id="ddc82-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="ddc82-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="ddc82-152">Visual Studio Code</span></span>
- <span data-ttu-id="ddc82-153">ドットネット CLI</span><span class="sxs-lookup"><span data-stu-id="ddc82-153">the dotnet CLI</span></span>

<span data-ttu-id="ddc82-154">SDK には、エンドポイントルーティング、組み込み IoC、およびログ記録用のツールが含まれています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="ddc82-155">オープンソースの Kestrel Web サーバーは、HTTP/2 接続をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="ddc82-156">図 4-20 は、gRPC サービスのスケルトン プロジェクトをスキャフォールディングする Visual Studio 2019 テンプレートを示しています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="ddc82-157">NET Core が Windows、Linux、および macOS を完全にサポートしていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="ddc82-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![ビジュアル スタジオ 2019 での gRPC サポート](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="ddc82-159">**図 4-20**</span><span class="sxs-lookup"><span data-stu-id="ddc82-159">**Figure 4-20**.</span></span> <span data-ttu-id="ddc82-160">ビジュアル スタジオ 2019 での gRPC のサポート</span><span class="sxs-lookup"><span data-stu-id="ddc82-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="ddc82-161">図 4-21 は、組み込みのスキャフォールディングから生成されたスケルトン gRPC サービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![ビジュアル スタジオ 2019 で gRPC プロジェクト](./media/grpc-project.png  )

<span data-ttu-id="ddc82-163">**図 4-21**</span><span class="sxs-lookup"><span data-stu-id="ddc82-163">**Figure 4-21**.</span></span> <span data-ttu-id="ddc82-164">ビジュアル スタジオ 2019 で gRPC プロジェクト</span><span class="sxs-lookup"><span data-stu-id="ddc82-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="ddc82-165">前の図では、proto 記述ファイルとサービスコードをメモします。</span><span class="sxs-lookup"><span data-stu-id="ddc82-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="ddc82-166">すぐにわかるように、Visual Studio はスタートアップ クラスと基になるプロジェクト ファイルの両方で追加の構成を生成します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="ddc82-167">gRPC の使用</span><span class="sxs-lookup"><span data-stu-id="ddc82-167">gRPC usage</span></span>

<span data-ttu-id="ddc82-168">次のシナリオでは gRPC を優先します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="ddc82-169">処理を続行するために即時応答が必要な同期バックエンドマイクロサービス間の通信。</span><span class="sxs-lookup"><span data-stu-id="ddc82-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="ddc82-170">混合プログラミング プラットフォームをサポートする必要があるポリグロット環境。</span><span class="sxs-lookup"><span data-stu-id="ddc82-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="ddc82-171">パフォーマンスが重要な低遅延および高スループット通信。</span><span class="sxs-lookup"><span data-stu-id="ddc82-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="ddc82-172">ポイントツーポイントリアルタイム通信 - gRPCはポーリングなしでリアルタイムでメッセージをプッシュすることができ、双方向ストリーミングに優れたサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="ddc82-173">ネットワークに制約のある環境 – バイナリ gRPC メッセージは、常に同等のテキストベースの JSON メッセージよりも小さくなります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="ddc82-174">この時点で、gRPC は主にバックエンド サービスで使用されます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="ddc82-175">最近のブラウザでは、フロントエンド gRPC クライアントをサポートするために必要な HTTP/2 コントロールのレベルを提供できません。</span><span class="sxs-lookup"><span data-stu-id="ddc82-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="ddc82-176">しかし、JavaScriptまたはBlazor WebAssembly技術を使用して構築されたブラウザベースのアプリからのgRPC通信を可能にする[初期のイニシアチブ](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/)があります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="ddc82-177">[net 用 gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)を使用すると、ASP.NETコア gRPC アプリがブラウザー アプリで gRPC 機能をサポートできるようになります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="ddc82-178">厳密に型指定されたコード生成クライアント</span><span class="sxs-lookup"><span data-stu-id="ddc82-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="ddc82-179">コンパクトなプロトブーフメッセージ</span><span class="sxs-lookup"><span data-stu-id="ddc82-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="ddc82-180">サーバー ストリーミング</span><span class="sxs-lookup"><span data-stu-id="ddc82-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="ddc82-181">gRPC の実装</span><span class="sxs-lookup"><span data-stu-id="ddc82-181">gRPC implementation</span></span>

<span data-ttu-id="ddc82-182">マイクロソフトのマイクロサービス参照アーキテクチャ[であるコンテナーの eShop](https://github.com/dotnet-architecture/eShopOnContainers)は、.NET Core アプリケーションで gRPC サービスを実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="ddc82-183">図 4-22 に、バックエンド アーキテクチャを示します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-183">Figure 4-22 presents the back-end architecture.</span></span>

![コンテナ上の eShop のバックエンド アーキテクチャ](./media/eshop-with-aggregators.png)

<span data-ttu-id="ddc82-185">**図 4-22**</span><span class="sxs-lookup"><span data-stu-id="ddc82-185">**Figure 4-22**.</span></span> <span data-ttu-id="ddc82-186">コンテナ上の eShop のバックエンド アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="ddc82-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="ddc82-187">前の図では、複数の API ゲートウェイを公開することで、フロントエンド[パターン](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)(BFF) を eShop がどのように採用しているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="ddc82-188">この章では、BFF パターンについて前に説明しました。</span><span class="sxs-lookup"><span data-stu-id="ddc82-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="ddc82-189">Web ショッピング API ゲートウェイとバックエンド ショッピング マイクロサービスの間にあるアグリゲーター マイクロサービス (グレー) に細心の注意を払います。</span><span class="sxs-lookup"><span data-stu-id="ddc82-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="ddc82-190">Aggregator は、クライアントから 1 つの要求を受け取り、それをさまざまなマイクロサービスにディスパッチし、結果を集約して、要求元のクライアントに返送します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="ddc82-191">このような操作では、通常、即時応答を生成するために同期通信が必要です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="ddc82-192">eShop では、図 4-23 に示すように、アグリゲータからのバックエンド呼び出しは gRPC を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![コンテナ上の e ショップで gRPC](./media/grpc-implementation.png)

<span data-ttu-id="ddc82-194">**図 4-23**. </span><span class="sxs-lookup"><span data-stu-id="ddc82-194">**Figure 4-23**.</span></span> <span data-ttu-id="ddc82-195">コンテナ上の e ショップで gRPC</span><span class="sxs-lookup"><span data-stu-id="ddc82-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="ddc82-196">gRPC 通信には、クライアントコンポーネントとサーバーコンポーネントの両方が必要です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="ddc82-197">前の図では、ショッピング アグリゲータが gRPC クライアントを実装する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ddc82-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="ddc82-198">クライアントは、バックエンド マイクロサービスに対して同期 gRPC 呼び出し (赤色) を行い、それぞれが gRPC サーバーを実装します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="ddc82-199">クライアントとサーバーの両方が .NET Core 3.0 SDK の組み込みの gRPC の組み込みを利用します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core 3.0 SDK.</span></span> <span data-ttu-id="ddc82-200">クライアント側*スタブは、* リモート gRPC 呼び出しを呼び出すための配管を提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="ddc82-201">サーバー側コンポーネントは、カスタム サービス クラスが継承および使用できる gRPC 配管を提供します。</span><span class="sxs-lookup"><span data-stu-id="ddc82-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="ddc82-202">RESTful API と gRPC 通信の両方を公開するマイクロサービスでは、トラフィックを管理するために複数のエンドポイントが必要です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="ddc82-203">RESTful 呼び出しの HTTP トラフィックをリッスンするエンドポイントと、gRPC 呼び出し用のエンドポイントを開きます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="ddc82-204">gRPC エンドポイントは、gRPC 通信に必要な HTTP/2 プロトコル用に構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="ddc82-205">非同期通信パターンを使用してマイクロサービスを分離しようと努力していますが、一部の操作では直接呼び出しが必要です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="ddc82-206">マイクロサービス間の直接同期通信の主な選択肢は gRPC です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="ddc82-207">HTTP/2およびプロトコルバッファに基づく高性能通信プロトコルは、完璧な選択になります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="ddc82-208">将来を見据えて</span><span class="sxs-lookup"><span data-stu-id="ddc82-208">Looking ahead</span></span>

<span data-ttu-id="ddc82-209">今後も、gRPCはクラウドネイティブシステムの牽引力を獲得していきます。</span><span class="sxs-lookup"><span data-stu-id="ddc82-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="ddc82-210">パフォーマンス上の利点と開発の容易さは、非常に魅力的です。</span><span class="sxs-lookup"><span data-stu-id="ddc82-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="ddc82-211">ただし、REST は長い間使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ddc82-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="ddc82-212">公開されている API と下位互換性の理由で優れています。</span><span class="sxs-lookup"><span data-stu-id="ddc82-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ddc82-213">[前次](service-to-service-communication.md)
>[Next](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="ddc82-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
