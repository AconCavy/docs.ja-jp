---
title: クラウドネイティブ データ パターン
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |クラウドネイティブデータパターン
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841823"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="949a9-103">クラウドネイティブ データ パターン</span><span class="sxs-lookup"><span data-stu-id="949a9-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="949a9-104">一元化されたデータは、パフォーマンス、スケーラビリティ、およびコストの削減につながる可能性がありますが、多くの課題があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="949a9-105">マイクロサービス間でのデータのクエリは複雑です。</span><span class="sxs-lookup"><span data-stu-id="949a9-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="949a9-106">マイクロサービスにまたがるトランザクションは、クラウドネイティブアプリケーションではサポートされていない分散トランザクションとしてプログラムで管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="949a9-107">*一貫性*のある世界から*最終的な整合性*に移行します。</span><span class="sxs-lookup"><span data-stu-id="949a9-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="949a9-108">ここでは、これらの課題について説明します。</span><span class="sxs-lookup"><span data-stu-id="949a9-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="949a9-109">クロスサービスクエリ</span><span class="sxs-lookup"><span data-stu-id="949a9-109">Cross-service queries</span></span>

<span data-ttu-id="949a9-110">アプリケーションが多数の独立したマイクロサービスに分散しているデータを照会する方法</span><span class="sxs-lookup"><span data-stu-id="949a9-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="949a9-111">図5-4 はこのシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-111">Figure 5-4 shows this scenario.</span></span>

![マイクロサービス間でのクエリ](./media/cross-service-query.png)

<span data-ttu-id="949a9-113">**図 5-4**</span><span class="sxs-lookup"><span data-stu-id="949a9-113">**Figure 5-4**.</span></span> <span data-ttu-id="949a9-114">マイクロサービス間でのクエリ</span><span class="sxs-lookup"><span data-stu-id="949a9-114">Querying across microservices</span></span>

<span data-ttu-id="949a9-115">前の図では、ユーザーのショッピングカートに項目を追加する買い物かごマイクロサービスがあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="949a9-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="949a9-116">買い物かごのデータストアには、バスケットと lineItem テーブルが含まれていますが、製品と価格のマイクロサービスで見つかった製品や価格のデータは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="949a9-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="949a9-117">項目を追加するには、買い物かごマイクロサービスに製品データと価格データが必要です。</span><span class="sxs-lookup"><span data-stu-id="949a9-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="949a9-118">製品と価格データを取得するためのオプションは何ですか?</span><span class="sxs-lookup"><span data-stu-id="949a9-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="949a9-119">図5-5 は、製品カタログと価格マイクロサービスの両方に対して直接 HTTP 呼び出しを行う買い物かごマイクロサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![直接 http 通信](./media/direct-http-communication.png)

<span data-ttu-id="949a9-121">**図 5-5**</span><span class="sxs-lookup"><span data-stu-id="949a9-121">**Figure 5-5**.</span></span> <span data-ttu-id="949a9-122">直接 HTTP 通信</span><span class="sxs-lookup"><span data-stu-id="949a9-122">Direct HTTP communication</span></span>

<span data-ttu-id="949a9-123">を実装することは可能ですが、第4章では、マイクロサービス間での HTTP 呼び出しがシステムに対してどのように行われるかを説明しましたが、この方法は推奨されません。</span><span class="sxs-lookup"><span data-stu-id="949a9-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="949a9-124">図5-6 に示すアグリゲーターマイクロサービスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![アグリゲーターマイクロサービス](./media/aggregator-microservice.png)

<span data-ttu-id="949a9-126">**図 5-6**</span><span class="sxs-lookup"><span data-stu-id="949a9-126">**Figure 5-6.**</span></span> <span data-ttu-id="949a9-127">アグリゲーターマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="949a9-127">Aggregator microservice</span></span>

<span data-ttu-id="949a9-128">この方法では、個々のマイクロサービスでビジネス操作ワークフローがカプセル化されますが、複雑さが増し、引き続き直接 HTTP 呼び出しが発生します。</span><span class="sxs-lookup"><span data-stu-id="949a9-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="949a9-129">クロスサービスクエリを実行するための一般的な方法では、図5-7 に示すように、具体化された[ビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)を使用します。</span><span class="sxs-lookup"><span data-stu-id="949a9-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![具体化ビューパターン](./media/materialized-view-pattern.png)

<span data-ttu-id="949a9-131">**Figure5-7**。</span><span class="sxs-lookup"><span data-stu-id="949a9-131">**Figure5-7**.</span></span> <span data-ttu-id="949a9-132">具体化ビューパターン</span><span class="sxs-lookup"><span data-stu-id="949a9-132">Materialized View Pattern</span></span>

<span data-ttu-id="949a9-133">このパターンでは、(*読み取りモデル*と呼ばれる) ローカルテーブルを買い物かごサービスに直接配置します。このテーブルには、製品および料金マイクロサービスに必要なデータの非正規化されたコピーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="949a9-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="949a9-134">このデータをショッピングバスケットマイクロサービス内に配置することで、高価なクロスサービス呼び出しを呼び出す必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="949a9-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="949a9-135">データをサービスに対してローカルにすると、応答時間と信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="949a9-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="949a9-136">このアプローチを使用すると、システム内に重複するデータが存在することになります。</span><span class="sxs-lookup"><span data-stu-id="949a9-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="949a9-137">クラウドネイティブシステムでは、重複データは[アンチパターン](https://en.wikipedia.org/wiki/Anti-pattern)とは見なされず、クラウドネイティブシステムに実装されるのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="949a9-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="949a9-138">ただし、1つのシステムだけが任意のデータセットの所有者になることができます。また、基になるデータの変更が発生するたびに、関連するすべての読み取りモデルを更新するために、レコードのシステム用の同期メカニズムを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="949a9-139">トランザクションのサポート</span><span class="sxs-lookup"><span data-stu-id="949a9-139">Transactional support</span></span>

<span data-ttu-id="949a9-140">マイクロサービス間でのクエリは困難ですが、マイクロサービス間でのトランザクションの実装は複雑になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="949a9-141">異なるマイクロサービスに存在するデータソース間でデータの一貫性を維持するための固有の課題を袖口することはできません。</span><span class="sxs-lookup"><span data-stu-id="949a9-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="949a9-142">図5-8 は、この問題を示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-142">Figure 5-8 shows the problem.</span></span>

![Saga パターンでのトランザクション](./media/saga-transaction-operation.png)

<span data-ttu-id="949a9-144">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="949a9-144">**Figure 5-8**.</span></span> <span data-ttu-id="949a9-145">マイクロサービス間でのトランザクションの実装</span><span class="sxs-lookup"><span data-stu-id="949a9-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="949a9-146">前の図では、すべての独立したマイクロサービスが分散*作成注文*トランザクションに参加していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="949a9-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="949a9-147">ただし、5つの各マイクロサービスのトランザクションが成功する必要があります。それ以外の場合は、すべてのマイクロサービスが操作を中止してロールバックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="949a9-148">組み込みのトランザクションサポートは各マイクロサービス内で利用できますが、5つのサービスすべてにまたがる分散トランザクションはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="949a9-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="949a9-149">この操作では、各マイクロサービスでデータの一貫性を維持するためにトランザクションサポートが不可欠であるため、プログラムを使用して分散トランザクションを構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="949a9-150">トランザクションサポートをプログラムで追加するための一般的なパターンは、 [Saga パターン](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)です。</span><span class="sxs-lookup"><span data-stu-id="949a9-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="949a9-151">ローカルトランザクションをグループ化し、それぞれを順番に呼び出すことによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="949a9-152">ローカルトランザクションが失敗した場合、Saga は操作を中止し、[補正トランザクション](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)のセットを呼び出して、前のローカルトランザクションによって行われた変更を元に戻します。</span><span class="sxs-lookup"><span data-stu-id="949a9-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="949a9-153">図5-9 は、Saga パターンを使用した失敗したトランザクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Saga パターンでのロールバック](./media/saga-rollback-operation.png)

<span data-ttu-id="949a9-155">**図 5-9**</span><span class="sxs-lookup"><span data-stu-id="949a9-155">**Figure 5-9**.</span></span> <span data-ttu-id="949a9-156">トランザクションのロールバック</span><span class="sxs-lookup"><span data-stu-id="949a9-156">Rolling back a transaction</span></span>

<span data-ttu-id="949a9-157">前の図では、 *GenerateContent*操作が music マイクロサービスで失敗したことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="949a9-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="949a9-158">Saga は、補正トランザクション (赤) を呼び出して、コンテンツを削除し、支払いを取り消し、注文をキャンセルし、各マイクロサービスのデータを一貫性のある状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="949a9-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="949a9-159">Saga パターンは、通常、関連する一連のイベントとして、または関連する一連のコマンドとして調整されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="949a9-160">CQRS パターン</span><span class="sxs-lookup"><span data-stu-id="949a9-160">CQRS pattern</span></span>

<span data-ttu-id="949a9-161">CQRS ([コマンドクエリ責務分離](https://docs.microsoft.com/azure/architecture/patterns/cqrs)) は、データを書き込むデータを読み取る操作を分離するアーキテクチャパターンです。</span><span class="sxs-lookup"><span data-stu-id="949a9-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="949a9-162">このパターンは、パフォーマンス、スケーラビリティ、およびセキュリティを最大化するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="949a9-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="949a9-163">通常のデータアクセスのシナリオでは、データの読み取りと書き込み操作の*両方*を実行する単一のモデル (エンティティとリポジトリオブジェクト) を実装します。</span><span class="sxs-lookup"><span data-stu-id="949a9-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="949a9-164">ただし、より高度なデータアクセスのシナリオでは、読み取りと書き込みのために個別のモデルとデータテーブルを利用すると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="949a9-165">パフォーマンスを向上させるために、*クエリ*と呼ばれる読み取り操作は、負荷の高いテーブル結合を避けるために、データの非常に非正規化された表現に対してクエリを実行することがあります。</span><span class="sxs-lookup"><span data-stu-id="949a9-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="949a9-166">*書き込み*操作 (*コマンド*) は、完全に正規化されたデータの表現に対して更新される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="949a9-167">次に、両方の表現を同期させておくためのメカニズムを実装する必要があります。通常、書き込みテーブルが変更されるたびに、データ変更を読み取りテーブルにレプリケートするイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="949a9-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="949a9-168">図5-10 は、CQRS パターンの実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![CQRS の実装](./media/cqrs-implementation.png)

<span data-ttu-id="949a9-170">**図 5-10**</span><span class="sxs-lookup"><span data-stu-id="949a9-170">**Figure 5-10**.</span></span> <span data-ttu-id="949a9-171">CQRS の実装</span><span class="sxs-lookup"><span data-stu-id="949a9-171">CQRS implementation</span></span>

<span data-ttu-id="949a9-172">前の図では、コマンドモデルとクエリモデルが個別に実装されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="949a9-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="949a9-173">さらに、各データ書き込み操作は書き込みストアに保存され、読み取りストアに反映されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="949a9-174">最終的な[整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)の原則に基づいて伝達プロセスがどのように動作するかに注意してください。一方、読み取りモデルは最終的に書き込みモデルと同期しますが、プロセスに多少のずれが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="949a9-175">分離を実装することで、読み取りと書き込みを個別にスケーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="949a9-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="949a9-176">また、読み取りに関しては、書き込み操作に対してセキュリティを強化することもできます。</span><span class="sxs-lookup"><span data-stu-id="949a9-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="949a9-177">通常、CQRS パターンは、特定のニーズに基づいて、システムの限られたセクションに適用されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="949a9-178">リレーショナル vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="949a9-178">Relational vs NoSQL</span></span>

<span data-ttu-id="949a9-179">[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/)テクノロジの影響は、特に分散クラウドネイティブシステムでは数多くできません。</span><span class="sxs-lookup"><span data-stu-id="949a9-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="949a9-180">この領域に新しいデータテクノロジが急増すると、リレーショナルデータベースに排他的に依存するソリューションが中断されました。</span><span class="sxs-lookup"><span data-stu-id="949a9-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="949a9-181">一方で、リレーショナルデータベースは数十年にわたり、一般的なテクノロジでした。</span><span class="sxs-lookup"><span data-stu-id="949a9-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="949a9-182">成熟し、実証済みで、広く実装されています。</span><span class="sxs-lookup"><span data-stu-id="949a9-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="949a9-183">競合するデータベース製品、専門知識、ツール abounds。</span><span class="sxs-lookup"><span data-stu-id="949a9-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="949a9-184">リレーショナルデータベースは、関連するデータテーブルのストアを提供します。</span><span class="sxs-lookup"><span data-stu-id="949a9-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="949a9-185">これらのテーブルには固定スキーマがあり、SQL (構造化照会言語) を使用してデータを管理し、 [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (原子性、一貫性、分離性、持続性とも呼ばれます) を保証します。</span><span class="sxs-lookup"><span data-stu-id="949a9-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="949a9-186">一方、SQL データベースは、高パフォーマンスの非リレーショナルデータストアを参照します。</span><span class="sxs-lookup"><span data-stu-id="949a9-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="949a9-187">これらは、使いやすさ、スケーラビリティ、回復性、および可用性の特性を excel で実現しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="949a9-188">NoSQL は、正規化されたデータのテーブルを結合するのではなく、通常は JSON ドキュメントに自己記述型 (schemaless) データを格納します。</span><span class="sxs-lookup"><span data-stu-id="949a9-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="949a9-189">[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/)保証は提供されません。</span><span class="sxs-lookup"><span data-stu-id="949a9-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="949a9-190">これらの種類のデータベースの違いを理解する方法は、 [CAP 定理](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)にあります。これは、状態を格納する分散システムに適用できる一連の原則です。</span><span class="sxs-lookup"><span data-stu-id="949a9-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="949a9-191">図5-11 は、キャップ定理の3つのプロパティを示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![キャップ定理](./media/cap-theorem.png)

<span data-ttu-id="949a9-193">**図 5-11**</span><span class="sxs-lookup"><span data-stu-id="949a9-193">**Figure 5-11**.</span></span> <span data-ttu-id="949a9-194">CAP 定理</span><span class="sxs-lookup"><span data-stu-id="949a9-194">The CAP theorem</span></span>

<span data-ttu-id="949a9-195">定理は、すべての分散データシステムが整合性、可用性、およびパーティションの許容範囲の間にトレードオフを提供し、どのデータベースでも次の3つのプロパティのうち2つのみを保証できることを示しています。</span><span class="sxs-lookup"><span data-stu-id="949a9-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="949a9-196">*整合性*: クラスター内のすべてのノードは、すべてのレプリカが正しく更新されるまで要求をブロックする必要がある場合でも、最新のデータを使用して応答します。</span><span class="sxs-lookup"><span data-stu-id="949a9-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="949a9-197">*可用性*: すべてのノードは、応答が最新のデータではない場合でも、適切な時間内に応答を返します。</span><span class="sxs-lookup"><span data-stu-id="949a9-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="949a9-198">*パーティションの許容範囲*: ノードで障害が発生した場合、または別のノードとの接続が失われた場合に、システムが引き続き動作することを保証します。</span><span class="sxs-lookup"><span data-stu-id="949a9-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="949a9-199">リレーショナルデータベースは、整合性と可用性を備えていますが、パーティションの許容範囲ではありません。</span><span class="sxs-lookup"><span data-stu-id="949a9-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="949a9-200">リレーショナルデータベース (シャーディングなど) のパーティション分割は困難であり、パフォーマンスに影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="949a9-201">一方、NoSQL データベースでは、通常、パーティションの許容範囲 (水平方向のスケーラビリティと高可用性) が示されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="949a9-202">CAP 定理によって指定されているように、3つの原則はどちらも2つしかないため、整合性プロパティは失われます。</span><span class="sxs-lookup"><span data-stu-id="949a9-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="949a9-203">NoSQL データベースは分散され、一般に汎用サーバー間でスケールアウトされます。</span><span class="sxs-lookup"><span data-stu-id="949a9-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="949a9-204">そうすることで、地理的なリージョン内とリージョン間の両方で、コストを削減して優れた可用性を実現できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="949a9-205">これらのマシンまたはノード間でデータをパーティション分割してレプリケートし、冗長性とフォールトトレランスを提供できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="949a9-206">欠点は、整合性です。</span><span class="sxs-lookup"><span data-stu-id="949a9-206">The downside is consistency.</span></span> <span data-ttu-id="949a9-207">1つの NoSQL ノード上のデータに対する変更は、他のノードに反映されるまでに時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="949a9-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="949a9-208">通常、NoSQL データベースノードは、表示されているデータが古く、まだ更新されていない場合でも、クエリに直ちに応答します。</span><span class="sxs-lookup"><span data-stu-id="949a9-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="949a9-209">これは、ACID トランザクションがサポートされていない分散データシステムの特性である既知の[最終的な整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)です。</span><span class="sxs-lookup"><span data-stu-id="949a9-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="949a9-210">データ項目が更新されてから、その更新が各レプリカノードに反映されるまでにかかる時間が短くなります。</span><span class="sxs-lookup"><span data-stu-id="949a9-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="949a9-211">米国の NoSQL データベースの製品項目を更新しても、ヨーロッパのレプリカノードと同じデータ項目を同時に照会した場合は、ヨーロッパのノードが製品の変更で更新されるまで、以前の製品情報を取得することがあります。</span><span class="sxs-lookup"><span data-stu-id="949a9-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="949a9-212">トレードオフは、[強力な一貫性を確保](https://en.wikipedia.org/wiki/Strong_consistency)し、すべてのレプリカノードが更新されるのを待ってからクエリ結果を返すことによって、大規模なスケールとトラフィックのボリュームをサポートできますが、古いデータが表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="949a9-213">NoSQL データベースは、次の4つのモデルで分類できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="949a9-214">*ドキュメントストア*(MongoDB、CouchDB、Couchbase): データ (および対応するメタデータ) は、データベース内の非正規化された JSON ベースのドキュメントで、非 relationally に格納されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="949a9-215">*キー/値ストア*(Redis、riak、memcached): データは、ユーザーデータの値にマップされた一意のアクセスキーに対して実行されるシステム操作と共に、単純なキーと値のペアに格納されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="949a9-216">*ワイド列ストア*(HBase、Cassandra): 関連データは、複数のテーブルを結合しなくても、通常は1つの単位として取得されるデータを使用して、1つの列に入れ子になったキーと値のペアのセットとして列形式で格納されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="949a9-217">*グラフストア*(neo4j、titan): データは、ノード間のリレーションシップを指定するエッジと共に、ノード内にグラフィカルな表現として格納されます。</span><span class="sxs-lookup"><span data-stu-id="949a9-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="949a9-218">NoSQL データベースは、特にデータが比較的単純な場合に、大規模なデータを処理するように最適化できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="949a9-219">次の場合に NoSQL データベースを検討します。</span><span class="sxs-lookup"><span data-stu-id="949a9-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="949a9-220">ワークロードには大規模な同時実行性が必要です。</span><span class="sxs-lookup"><span data-stu-id="949a9-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="949a9-221">多数のユーザーがいます。</span><span class="sxs-lookup"><span data-stu-id="949a9-221">You have large numbers of users.</span></span>
- <span data-ttu-id="949a9-222">データは、リレーションシップなしでのみ表現できます。</span><span class="sxs-lookup"><span data-stu-id="949a9-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="949a9-223">データを地理的に分散する必要があります。</span><span class="sxs-lookup"><span data-stu-id="949a9-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="949a9-224">ACID の保証は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="949a9-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="949a9-225">は、汎用的ハードウェアにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="949a9-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="949a9-226">次に、次の場合にリレーショナルデータベースを検討します。</span><span class="sxs-lookup"><span data-stu-id="949a9-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="949a9-227">ワークロードには、中規模から大規模のスケールが必要です。</span><span class="sxs-lookup"><span data-stu-id="949a9-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="949a9-228">同時実行は大きな問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="949a9-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="949a9-229">ACID 保証が必要です。</span><span class="sxs-lookup"><span data-stu-id="949a9-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="949a9-230">データは relationally で表現することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="949a9-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="949a9-231">アプリケーションは、大規模なハイエンドハードウェアにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="949a9-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="949a9-232">次に、Azure クラウドのデータストレージについて見ていきます。</span><span class="sxs-lookup"><span data-stu-id="949a9-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="949a9-233">[前へ](distributed-data.md)
>[次へ](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="949a9-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
