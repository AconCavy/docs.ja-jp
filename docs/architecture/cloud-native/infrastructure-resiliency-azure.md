---
title: Azure platform の回復性
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |Azure を使用したクラウドインフラストラクチャの回復性
ms.date: 06/30/2019
ms.openlocfilehash: 02d661952c860da25442b0fa9fed0d5f93abe023
ms.sourcegitcommit: 4f4a32a5c16a75724920fa9627c59985c41e173c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/17/2019
ms.locfileid: "73841259"
---
# <a name="azure-platform-resiliency"></a><span data-ttu-id="60ea0-103">Azure platform の回復性</span><span class="sxs-lookup"><span data-stu-id="60ea0-103">Azure platform resiliency</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="60ea0-104">クラウドで信頼性の高いアプリケーションを構築することは、従来のオンプレミスアプリケーションの開発とは異なります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-104">Building a reliable application in the cloud is different from traditional on-premises application development.</span></span> <span data-ttu-id="60ea0-105">これまでは、スケールアウトするクラウド環境でハイエンドのハードウェアを購入しましたが、障害を防ぐのではなく、その影響を最小限に抑え、システムの安定性を維持することを目標としています。</span><span class="sxs-lookup"><span data-stu-id="60ea0-105">While historically you purchased higher-end hardware to scale up, in a cloud environment you scale out. Instead of trying to prevent failures, the goal is to minimize their effects and keep the system stable.</span></span>

<span data-ttu-id="60ea0-106">しかし、信頼性の高いクラウドアプリケーションでは、次のように異なる特性が表示されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-106">That said, reliable cloud applications display distinct characteristics:</span></span>

- <span data-ttu-id="60ea0-107">これらは回復力があり、問題から適切に回復し、引き続き機能します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-107">They're resilient, recover gracefully from problems, and continue to function.</span></span>
- <span data-ttu-id="60ea0-108">高可用性 (HA) で、非常に長いダウンタイムなしで正常な状態で設計されているように実行されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-108">They're highly available (HA) and run as designed in a healthy state with no significant downtime.</span></span>

<span data-ttu-id="60ea0-109">これらの特性がどのように連携するか、およびそれらがコストにどのように影響するかを理解することは、信頼性の高いクラウドネイティブアプリケーションを構築するために不可欠です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-109">Understanding how these characteristics work together - and how they affect cost - is essential to building a reliable cloud-native application.</span></span> <span data-ttu-id="60ea0-110">次に、Azure クラウドの機能を利用して、クラウドネイティブアプリケーションに回復性と可用性を構築する方法について見ていきます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-110">We'll next look at ways that you can build resiliency and availability into your cloud-native applications leveraging features from the Azure cloud.</span></span>

## <a name="design-with-redundancy"></a><span data-ttu-id="60ea0-111">冗長性を備えた設計</span><span class="sxs-lookup"><span data-stu-id="60ea0-111">Design with redundancy</span></span>

<span data-ttu-id="60ea0-112">障害は影響の範囲によって異なります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-112">Failures vary in scope of impact.</span></span> <span data-ttu-id="60ea0-113">障害が発生したディスクなどのハードウェア障害は、クラスター内の1つのノードに影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-113">A hardware failure, such as a failed disk, can affect a single node in a cluster.</span></span> <span data-ttu-id="60ea0-114">ネットワークスイッチの障害は、サーバーラック全体に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-114">A failed network switch could affect an entire server rack.</span></span> <span data-ttu-id="60ea0-115">電力の損失など、一般的ではない障害により、データセンター全体が混乱する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-115">Less common failures, such as loss of power, could disrupt a whole datacenter.</span></span> <span data-ttu-id="60ea0-116">ほとんどの場合、リージョン全体が使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-116">Rarely, an entire region becomes unavailable.</span></span>

<span data-ttu-id="60ea0-117">[冗長性](https://docs.microsoft.com/azure/architecture/guide/design-principles/redundancy)は、アプリケーションの回復力を提供する1つの方法です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-117">[Redundancy](https://docs.microsoft.com/azure/architecture/guide/design-principles/redundancy) is one way to provide application resilience.</span></span> <span data-ttu-id="60ea0-118">必要な冗長性の正確なレベルは、ビジネス要件によって異なり、システムのコストと複雑さの両方に影響します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-118">The exact level of redundancy needed depends on your business requirements and will affect both cost and complexity of your system.</span></span> <span data-ttu-id="60ea0-119">たとえば、複数リージョンのデプロイは、単一リージョンのデプロイよりもコストが高く、複雑になります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-119">For example, a multi-region deployment is more expensive and more complex to manage than a single-region deployment.</span></span> <span data-ttu-id="60ea0-120">フェールオーバーとフェールバックを管理するには、運用手順が必要です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-120">You'll need operational procedures to manage failover and failback.</span></span> <span data-ttu-id="60ea0-121">追加コストと複雑さは、ビジネスシナリオによっては正当化されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-121">The additional cost and complexity might be justified for some business scenarios and not others.</span></span>

<span data-ttu-id="60ea0-122">冗長性を設計するには、アプリケーションで重要なパスを特定し、パスの各ポイントに冗長性があるかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-122">To architect redundancy, you need to identify the critical paths in your application, and then determine if there's redundancy at each point in the path?</span></span> <span data-ttu-id="60ea0-123">サブシステムで障害が発生した場合、アプリケーションは何かにフェールオーバーしますか。</span><span class="sxs-lookup"><span data-stu-id="60ea0-123">If a subsystem should fail, will the application fail over to something else?</span></span> <span data-ttu-id="60ea0-124">最後に、冗長性の要件を満たすために利用できる、Azure クラウドプラットフォームに組み込まれている機能を明確に理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-124">Finally, you need a clear understanding of those features built into the Azure cloud platform that you can leverage to meet your redundancy requirements.</span></span> <span data-ttu-id="60ea0-125">冗長性を設計するための推奨事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-125">Here are recommendations for architecting redundancy:</span></span>

- <span data-ttu-id="60ea0-126">*サービスの複数のインスタンスをデプロイします。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-126">*Deploy multiple instances of services.*</span></span> <span data-ttu-id="60ea0-127">アプリケーションがサービスの1つのインスタンスに依存している場合は、単一障害点が発生します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-127">If your application depends on a single instance of a service, it creates a single point of failure.</span></span> <span data-ttu-id="60ea0-128">複数のインスタンスをプロビジョニングすると、回復性とスケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-128">Provisioning multiple instances improves both resiliency and scalability.</span></span> <span data-ttu-id="60ea0-129">Azure Kubernetes Service でホストする場合は、Kubernetes マニフェストファイル内の冗長インスタンス (レプリカセット) を宣言によって構成できます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-129">When hosting in Azure Kubernetes Service, you can declaratively configure redundant instances (replica sets) in the Kubernetes manifest file.</span></span> <span data-ttu-id="60ea0-130">レプリカ数の値は、プログラム、ポータル、または自動スケール機能を使用して管理できます。これについては後で説明します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-130">The replica count value can be managed programmatically, in the portal or through autoscaling features, which will be discussed later on.</span></span>

- <span data-ttu-id="60ea0-131">*ロードバランサーを活用する。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-131">*Leveraging a load balancer.*</span></span> <span data-ttu-id="60ea0-132">負荷分散は、アプリケーションの要求を正常なサービスインスタンスに分散し、異常なインスタンスをローテーションから自動的に削除します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-132">Load-balancing distributes your application's requests to healthy service instances and automatically removes unhealthy instances from rotation.</span></span> <span data-ttu-id="60ea0-133">Kubernetes にデプロイする場合は、[サービス] セクションの Kubernetes マニフェストファイルで負荷分散を指定できます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-133">When deploying to Kubernetes, load balancing can be specified in the Kubernetes manifest file in the Services section.</span></span>

- <span data-ttu-id="60ea0-134">*複数リージョンのデプロイを計画します。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-134">*Plan for multiregion deployment.*</span></span> <span data-ttu-id="60ea0-135">アプリケーションが1つのリージョンにデプロイされていて、そのリージョンが使用できなくなった場合は、アプリケーションも使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-135">If your application is deployed to a single region, and the region becomes unavailable, your application will also become unavailable.</span></span> <span data-ttu-id="60ea0-136">これは、アプリケーションのサービスレベルアグリーメントの条項によっては受け入れられない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-136">This may be unacceptable under the terms of your application's service level agreements.</span></span> <span data-ttu-id="60ea0-137">代わりに、アプリケーションとそのサービスを複数のリージョンにデプロイすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-137">Instead, consider deploying your application and its services across multiple regions.</span></span> <span data-ttu-id="60ea0-138">たとえば、Azure Kubernetes Service (AKS) クラスターは1つのリージョンにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-138">For example, an Azure Kubernetes Service (AKS) cluster is deployed to a single region.</span></span> <span data-ttu-id="60ea0-139">リージョン内の障害からシステムを保護するには、異なるリージョンの複数の AKS クラスターにアプリケーションをデプロイし、[ペアのリージョン](https://buildazure.com/2017/01/06/azure-region-pairs-explained/)機能を使用してプラットフォームの更新を調整し、復旧作業の優先順位を設定します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-139">To protect your system from a regional failure, you might deploy your application to multiple AKS clusters across different regions and use the [Paired Regions](https://buildazure.com/2017/01/06/azure-region-pairs-explained/) feature to coordinate platform updates and prioritize recovery efforts.</span></span>

- <span data-ttu-id="60ea0-140">*[Geo レプリケーション](https://docs.microsoft.com/azure/sql-database/sql-database-active-geo-replication)を有効にします。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-140">*Enable [geo-replication](https://docs.microsoft.com/azure/sql-database/sql-database-active-geo-replication).*</span></span> <span data-ttu-id="60ea0-141">Azure SQL Database や Cosmos DB などのサービスの Geo レプリケーションでは、複数のリージョンにわたってデータのセカンダリレプリカが作成されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-141">Geo-replication for services such as Azure SQL Database and Cosmos DB will create secondary replicas of your data across multiple regions.</span></span> <span data-ttu-id="60ea0-142">どちらのサービスも同じリージョン内のデータを自動的にレプリケートしますが、geo レプリケーションでは、セカンダリリージョンへのフェールオーバーを可能にすることで、リージョンの停止を防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-142">While both services will automatically replicate data within the same region, geo-replication protects you against a regional outage by enabling you to fail over to a secondary region.</span></span> <span data-ttu-id="60ea0-143">コンテナーイメージの格納に関するその他のベストプラクティスとして、geo レプリケーションを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="60ea0-143">Another best practice for geo-replication centers around storing container images.</span></span> <span data-ttu-id="60ea0-144">AKS でサービスをデプロイするには、リポジトリからイメージを格納してプルする必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-144">To deploy a service in AKS, you need to store and pull the image from a repository.</span></span> <span data-ttu-id="60ea0-145">Azure Container Registry は AKS と統合され、コンテナーイメージを安全に格納できます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-145">Azure Container Registry integrates with AKS and can securely store container images.</span></span> <span data-ttu-id="60ea0-146">パフォーマンスと可用性を向上させるには、AKS クラスターがある各リージョンのレジストリにイメージを geo レプリケートすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-146">To improve performance and availability, consider geo-replicating your images to a registry in each region where you have an AKS cluster.</span></span> <span data-ttu-id="60ea0-147">次に図6-6 に示すように、各 AKS クラスターは、そのリージョンのローカルコンテナーレジストリからコンテナーイメージをプルします。</span><span class="sxs-lookup"><span data-stu-id="60ea0-147">Each AKS cluster then pulls container images from the local container registry in its region as shown in Figure 6-6:</span></span>

![リージョン間でレプリケートされたリソース](./media/replicated-resources.png)

<span data-ttu-id="60ea0-149">**図 6-6**。</span><span class="sxs-lookup"><span data-stu-id="60ea0-149">**Figure 6-6**.</span></span> <span data-ttu-id="60ea0-150">リージョン間でレプリケートされたリソース</span><span class="sxs-lookup"><span data-stu-id="60ea0-150">Replicated resources across regions</span></span>

- <span data-ttu-id="60ea0-151">*DNS トラフィックのロードバランサーを実装します。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-151">*Implement a DNS traffic load balancer.*</span></span> <span data-ttu-id="60ea0-152">[Azure Traffic Manager](https://docs.microsoft.com/azure/traffic-manager/traffic-manager-overview)は、DNS レベルで負荷分散を行うことによって、重要なアプリケーションに高可用性を提供します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-152">[Azure Traffic Manager](https://docs.microsoft.com/azure/traffic-manager/traffic-manager-overview) provides high-availability for critical applications by load-balancing at the DNS level.</span></span> <span data-ttu-id="60ea0-153">地理的、クラスターの応答時間、さらにはアプリケーションエンドポイントの正常性に基づいて、異なるリージョンにトラフィックをルーティングすることができます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-153">It can route traffic to different regions based on geography, cluster response time, and even application endpoint health.</span></span> <span data-ttu-id="60ea0-154">たとえば、Azure Traffic Manager では、最も近い AKS クラスターとアプリケーションインスタンスに顧客を誘導できます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-154">For example, Azure Traffic Manager can direct customers to the closest AKS cluster and application instance.</span></span> <span data-ttu-id="60ea0-155">異なるリージョンに複数の AKS クラスターがある場合は、Traffic Manager を使用して、各クラスターで実行されるアプリケーションへのトラフィックフローを制御します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-155">If you have multiple AKS clusters in different regions, use Traffic Manager to control how traffic flows to the applications that run in each cluster.</span></span> <span data-ttu-id="60ea0-156">図6-7 はこのシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="60ea0-156">Figure 6-7 shows this scenario.</span></span>

![AKS と Azure Traffic Manager](./media/aks-traffic-manager.png)

<span data-ttu-id="60ea0-158">**図 6-7**。</span><span class="sxs-lookup"><span data-stu-id="60ea0-158">**Figure 6-7**.</span></span> <span data-ttu-id="60ea0-159">AKS と Azure Traffic Manager</span><span class="sxs-lookup"><span data-stu-id="60ea0-159">AKS and Azure Traffic Manager</span></span>

## <a name="design-for-scalability"></a><span data-ttu-id="60ea0-160">スケーラビリティのための設計</span><span class="sxs-lookup"><span data-stu-id="60ea0-160">Design for scalability</span></span>

<span data-ttu-id="60ea0-161">クラウドの thrives をスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="60ea0-161">The cloud thrives on scaling.</span></span> <span data-ttu-id="60ea0-162">システムの負荷の増加と減少に対処するために、システムリソースを増減する機能は、Azure クラウドの重要な理念です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-162">The ability to increase/decrease system resources to address increasing/decreasing system load is a key tenet of the Azure cloud.</span></span> <span data-ttu-id="60ea0-163">しかし、アプリケーションを効果的にスケーリングするには、アプリケーションに含める各 Azure サービスのスケーリング機能について理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-163">But, to effectively scale an application, you need an understanding of the scaling features of each Azure service that you include in your application.</span></span>  <span data-ttu-id="60ea0-164">ここでは、システムにスケーリングを効果的に実装するための推奨事項を示します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-164">Here are recommendations for effectively implementing scaling in your system.</span></span>

- <span data-ttu-id="60ea0-165">*スケーリングのための設計。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-165">*Design for scaling.*</span></span> <span data-ttu-id="60ea0-166">アプリケーションは、スケーリング用に設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-166">An application must be designed for scaling.</span></span> <span data-ttu-id="60ea0-167">開始するには、サービスがステートレスである必要があります。これにより、任意のインスタンスに要求をルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-167">To start, services should be stateless so that requests can be routed to any instance.</span></span> <span data-ttu-id="60ea0-168">また、ステートレスサービスを用意すると、インスタンスを追加または削除しても現在のユーザーに悪影響を及ぼすことはありません。</span><span class="sxs-lookup"><span data-stu-id="60ea0-168">Having stateless services also means that adding or removing an instance doesn't adversely impact current users.</span></span>

- <span data-ttu-id="60ea0-169">*ワークロードをパーティション分割*します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-169">*Partition workloads*.</span></span> <span data-ttu-id="60ea0-170">ドメインを独立した自己完結型マイクロサービスに分解することにより、各サービスを他のサービスとは無関係に拡張できます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-170">Decomposing domains into independent, self-contained microservices enable each service to scale independently of others.</span></span> <span data-ttu-id="60ea0-171">通常、サービスにはさまざまなスケーラビリティニーズと要件があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-171">Typically, services will have different scalability needs and requirements.</span></span> <span data-ttu-id="60ea0-172">パーティション分割を使用すると、アプリケーション全体のスケーリングに不要なコストをかけることなく、スケーリングする必要があるものだけをスケールできます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-172">Partitioning enables you to scale only what needs to be scaled without the unnecessary cost of scaling an entire application.</span></span>

- <span data-ttu-id="60ea0-173">*スケールアウトを優先します。* クラウドベースのアプリケーションでは、スケールアップではなく、リソースのスケールアウトが優先されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-173">*Favor scale-out.* Cloud-based applications favor scaling out resources as opposed to scaling up.</span></span> <span data-ttu-id="60ea0-174">スケールアウト (水平スケーリングとも呼ばれます) では、必要なレベルのパフォーマンスを満たして共有するために、既存のシステムにサービスリソースを追加します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-174">Scaling out (also known as horizontal scaling) involves adding more service resources to an existing system to meet and share a desired level of performance.</span></span> <span data-ttu-id="60ea0-175">スケールアップ (垂直スケーリングとも呼ばれます) では、既存のリソースをより強力なハードウェア (より多くのディスク、メモリ、および処理コア) に置き換える必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-175">Scaling up (also known as vertical scaling) involves replacing existing resources with more powerful hardware (more disk, memory, and processing cores).</span></span> <span data-ttu-id="60ea0-176">スケールアウトは、一部の Azure クラウドリソースで使用可能な自動スケール機能を使用して自動的に呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-176">Scaling out can be invoked automatically with the autoscaling features available in some Azure cloud resources.</span></span> <span data-ttu-id="60ea0-177">複数のリソースをスケールアウトすると、システム全体に冗長性も追加されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-177">Scaling out across multiple resources also adds redundancy to the overall system.</span></span> <span data-ttu-id="60ea0-178">最終的には、1つのリソースをスケールアップすることは、多くの小さなリソースに対してスケールアウトするよりもコストが高くなります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-178">Finally scaling up a single resource is typically more expensive than scaling out across many smaller resources.</span></span> <span data-ttu-id="60ea0-179">図6-8 は、次の2つの方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="60ea0-179">Figure 6-8 shows the two approaches:</span></span>

![スケールアップとスケールアウト](./media/scale-up-scale-out.png)

<span data-ttu-id="60ea0-181">**図 6-8.**</span><span class="sxs-lookup"><span data-stu-id="60ea0-181">**Figure 6-8.**</span></span> <span data-ttu-id="60ea0-182">スケールアップとスケールアウト</span><span class="sxs-lookup"><span data-stu-id="60ea0-182">Scale up versus scale out</span></span>

- <span data-ttu-id="60ea0-183">*比例してスケーリングします。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-183">*Scale proportionally.*</span></span> <span data-ttu-id="60ea0-184">サービスをスケーリングする場合は、*リソースセット*を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-184">When scaling a service, think in terms of *resource sets*.</span></span> <span data-ttu-id="60ea0-185">特定のサービスを劇的にスケールアウトする場合、バックエンドのデータストア、キャッシュ、および依存サービスに対する影響はどのようなものですか。</span><span class="sxs-lookup"><span data-stu-id="60ea0-185">If you were to dramatically scale out a specific service, what impact would that have on back-end data stores, caches and dependent services?</span></span> <span data-ttu-id="60ea0-186">Cosmos DB などの一部のリソースは、比例してスケールアウトできますが、他のリソースは使用できません。</span><span class="sxs-lookup"><span data-stu-id="60ea0-186">Some resources such as Cosmos DB can scale out proportionally, while many others can't.</span></span> <span data-ttu-id="60ea0-187">リソースをスケールアウトしないようにして、関連する他のリソースを消費しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-187">You want to ensure that you don't scale out a resource to a point where it will exhaust other associated resources.</span></span>

- <span data-ttu-id="60ea0-188">*アフィニティを回避します。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-188">*Avoid affinity.*</span></span> <span data-ttu-id="60ea0-189">ノードがローカルアフィニティを必要としないようにすることをお勧めします。これは、多くの場合、*固定セッション*と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-189">A best practice is to ensure a node doesn't require local affinity, often referred to as a *sticky session*.</span></span> <span data-ttu-id="60ea0-190">要求は、任意のインスタンスにルーティングできなければなりません。</span><span class="sxs-lookup"><span data-stu-id="60ea0-190">A request should be able to route to any instance.</span></span> <span data-ttu-id="60ea0-191">状態を永続化する必要がある場合は、 [Azure Redis cache](https://azure.microsoft.com/services/cache/)などの分散キャッシュに保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-191">If you need to persist state, it should be saved to a distributed cache, such as [Azure Redis cache](https://azure.microsoft.com/services/cache/).</span></span>

- <span data-ttu-id="60ea0-192">*プラットフォームの自動スケール機能を活用します。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-192">*Take advantage of platform autoscaling features.*</span></span> <span data-ttu-id="60ea0-193">組み込みの自動スケール機能は、カスタムまたはサードパーティのメカニズムではなく、可能な限り使用してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-193">Use built-in autoscaling features whenever possible, rather than custom or third-party mechanisms.</span></span> <span data-ttu-id="60ea0-194">可能であれば、スケジュールされたスケーリングルールを使用して、起動の遅延なしにリソースが使用可能であることを確認します。ただし、必要に応じて、予期しない変更が発生した場合に備えてルールにリアクティブな自動スケールを追加します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-194">Where possible, use scheduled scaling rules to ensure that resources are available without a startup delay, but add reactive autoscaling to the rules as appropriate, to cope with unexpected changes in demand.</span></span> <span data-ttu-id="60ea0-195">詳細については、「自動[スケールガイダンス](https://docs.microsoft.com/azure/architecture/best-practices/auto-scaling)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-195">For more information, see [Autoscaling guidance](https://docs.microsoft.com/azure/architecture/best-practices/auto-scaling).</span></span>

- <span data-ttu-id="60ea0-196">*積極的にスケールアウトします。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-196">*Scale-out aggressively.*</span></span> <span data-ttu-id="60ea0-197">最終的には、ビジネスを失うことなく迅速にトラフィックの急増に対応できるように、積極的にスケールアウトする必要があります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-197">A final practice would be to scale out aggressively so that you can quickly meet immediate spikes in traffic without losing business.</span></span> <span data-ttu-id="60ea0-198">また、システムを安定した状態に保つために、スケールイン (不要なインスタンスを削除する) 控えめします。</span><span class="sxs-lookup"><span data-stu-id="60ea0-198">And, then scale in (that is, remove unneeded instances) conservatively to keep the system stable.</span></span> <span data-ttu-id="60ea0-199">これを実装する簡単な方法は、クールダウン期間を設定することです。これは、スケーリング操作の間の待機時間であり、リソースを追加する場合は5分、インスタンスを削除する場合は最大15分です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-199">A simple way to implement this is to set the cool down period, which is the time to wait between scaling operations, to five minutes for adding resources and up to 15 minutes for removing instances.</span></span>

## <a name="built-in-retry-in-services"></a><span data-ttu-id="60ea0-200">サービスでの組み込みの再試行</span><span class="sxs-lookup"><span data-stu-id="60ea0-200">Built-in retry in services</span></span>

<span data-ttu-id="60ea0-201">前のセクションでは、プログラムによる再試行操作を実装することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="60ea0-201">We encouraged the best practice of implementing programmatic retry operations in an earlier section.</span></span> <span data-ttu-id="60ea0-202">多くの Azure サービスとそれに対応するクライアント Sdk には、再試行メカニズムも含まれることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="60ea0-202">Keep in mind that many Azure services and their corresponding client SDKs also include retry mechanisms.</span></span> <span data-ttu-id="60ea0-203">次の一覧は、このブックで説明されている多くの Azure サービスの再試行機能をまとめたものです。</span><span class="sxs-lookup"><span data-stu-id="60ea0-203">The following list summarizes retry features in the many of the Azure services that are discussed in this book:</span></span>

- <span data-ttu-id="60ea0-204">*Azure Cosmos DB。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-204">*Azure Cosmos DB.*</span></span> <span data-ttu-id="60ea0-205">クライアント API の <xref:Microsoft.Azure.Documents.Client.DocumentClient> クラスは、失敗した試行を自動的に廃止します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-205">The <xref:Microsoft.Azure.Documents.Client.DocumentClient> class from the client API automatically retires failed attempts.</span></span> <span data-ttu-id="60ea0-206">再試行回数と最大待機時間は構成可能です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-206">The number of retries and maximum wait time are configurable.</span></span> <span data-ttu-id="60ea0-207">クライアント API によってスローされる例外は、再試行ポリシーまたは一時的でないエラーを超える要求のいずれかです。</span><span class="sxs-lookup"><span data-stu-id="60ea0-207">Exceptions thrown by the client API are either requests that exceed the retry policy or non-transient errors.</span></span>

- <span data-ttu-id="60ea0-208">*Azure Redis Cache。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-208">*Azure Redis Cache.*</span></span> <span data-ttu-id="60ea0-209">Redis StackExchange クライアントは、失敗した試行に対する再試行を含む接続マネージャークラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-209">The Redis StackExchange client uses a connection manager class that includes retries on failed attempts.</span></span> <span data-ttu-id="60ea0-210">再試行回数、特定の再試行ポリシー、待機時間はすべて構成可能です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-210">The number of retries, specific retry policy and wait time are all configurable.</span></span>

- <span data-ttu-id="60ea0-211">*Azure Service Bus。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-211">*Azure Service Bus.*</span></span> <span data-ttu-id="60ea0-212">Service Bus クライアントは、バックオフ間隔、再試行回数、および <xref:Microsoft.ServiceBus.RetryExponential.TerminationTimeBuffer>で構成できる[RetryPolicy クラス](xref:Microsoft.ServiceBus.RetryPolicy)を公開します。このクラスは、操作が実行できる最大時間を指定します。</span><span class="sxs-lookup"><span data-stu-id="60ea0-212">The Service Bus client exposes a [RetryPolicy class](xref:Microsoft.ServiceBus.RetryPolicy) that can be configured with a back-off interval, retry count, and <xref:Microsoft.ServiceBus.RetryExponential.TerminationTimeBuffer>, which specifies the maximum time an operation can take.</span></span> <span data-ttu-id="60ea0-213">既定のポリシーは、30秒間のバックオフ期間による最大9回の再試行です。</span><span class="sxs-lookup"><span data-stu-id="60ea0-213">The default policy is nine maximum retry attempts with a 30-second backoff period between attempts.</span></span>

- <span data-ttu-id="60ea0-214">*Azure SQL Database。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-214">*Azure SQL Database.*</span></span> <span data-ttu-id="60ea0-215">[Entity Framework Core](https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency)ライブラリを使用する場合は、再試行のサポートが提供されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-215">Retry support is provided when using the [Entity Framework Core](https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency) library.</span></span>

- <span data-ttu-id="60ea0-216">*Azure Storage。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-216">*Azure Storage.*</span></span> <span data-ttu-id="60ea0-217">ストレージクライアントライブラリは再試行操作をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="60ea0-217">The storage client library support retry operations.</span></span> <span data-ttu-id="60ea0-218">戦略は、Azure storage のテーブル、blob、キューによって異なります。</span><span class="sxs-lookup"><span data-stu-id="60ea0-218">The strategies vary across Azure storage tables, blobs, and queues.</span></span> <span data-ttu-id="60ea0-219">さらに、geo 冗長機能が有効になっている場合は、プライマリストレージサービスとセカンダリストレージサービスの場所が交互に再試行されます。</span><span class="sxs-lookup"><span data-stu-id="60ea0-219">As well, alternate retries switch between primary and secondary storage services locations when the geo-redundancy feature is enabled.</span></span>

- <span data-ttu-id="60ea0-220">*Azure Event Hubs。*</span><span class="sxs-lookup"><span data-stu-id="60ea0-220">*Azure Event Hubs.*</span></span> <span data-ttu-id="60ea0-221">イベントハブクライアントライブラリは、構成可能な指数バックオフ機能を含む RetryPolicy プロパティを特徴としています。</span><span class="sxs-lookup"><span data-stu-id="60ea0-221">The Event Hub client library features a RetryPolicy property, which includes a configurable exponential backoff feature.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="60ea0-222">[前へ](application-resiliency-patterns.md)
>[次へ](resilient-communications.md)</span><span class="sxs-lookup"><span data-stu-id="60ea0-222">[Previous](application-resiliency-patterns.md)
[Next](resilient-communications.md)</span></span>
