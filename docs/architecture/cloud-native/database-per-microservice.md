---
title: マイクロサービスごとのデータベース
description: モノリシックアプリケーションとクラウドネイティブアプリケーションでのデータストレージのコントラストを実現します。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141446"
---
# <a name="database-per-microservice"></a><span data-ttu-id="dbeff-103">マイクロサービスごとのデータベース</span><span class="sxs-lookup"><span data-stu-id="dbeff-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="dbeff-104">このマニュアルで説明したように、クラウド ネイティブのアプローチによって、アプリケーションの設計、デプロイ、および管理方法が変わります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="dbeff-105">また、データの管理方法や保存方法も変更されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="dbeff-106">図 5-1 は、その違いを対比しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-106">Figure 5-1 contrasts the differences.</span></span>

![クラウドネイティブアプリケーションでのデータストレージ](./media/distributed-data.png)

<span data-ttu-id="dbeff-108">**図 5-1**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-108">**Figure 5-1**.</span></span> <span data-ttu-id="dbeff-109">クラウドネイティブアプリケーションでのデータ管理</span><span class="sxs-lookup"><span data-stu-id="dbeff-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="dbeff-110">経験豊富な開発者は、図 5-1 の左側にあるアーキテクチャを簡単に認識できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="dbeff-111">この*モノリシック アプリケーション*では、ビジネス サービス コンポーネントは共有サービス層にまとめて配置され、単一のリレーショナル データベースのデータを共有します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="dbeff-112">多くの点で、単一のデータベースはデータ管理をシンプルに保ちます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="dbeff-113">複数のテーブル間でデータをクエリするのは簡単です。</span><span class="sxs-lookup"><span data-stu-id="dbeff-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="dbeff-114">データ更新の変更をまとめて行うか、すべてロールバックします。</span><span class="sxs-lookup"><span data-stu-id="dbeff-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="dbeff-115">[ACID トランザクションは、強力で](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)即時の一貫性を保証します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="dbeff-116">クラウド ネイティブ向けの設計では、別のアプローチを採用しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="dbeff-117">図 5-1 の右側で、ビジネス機能が小規模で独立したマイクロサービスにどのように分離されているのかを確認します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="dbeff-118">各マイクロサービスは、特定のビジネス機能と独自のデータをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="dbeff-119">モノリシック データベースは、多数の小規模なデータベースを持つ分散データ モデルに分解され、それぞれがマイクロサービスに合わせて配置されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="dbeff-120">煙が晴れると、*マイクロサービスごとにデータベース*を公開するデザインが現れます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="dbeff-121">なぜですか?</span><span class="sxs-lookup"><span data-stu-id="dbeff-121">Why?</span></span>

<span data-ttu-id="dbeff-122">マイクロサービスごとにこのデータベースは、特に急速に進化し大規模な規模をサポートする必要があるシステムに多くの利点をもたらします。</span><span class="sxs-lookup"><span data-stu-id="dbeff-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="dbeff-123">このモデルで.</span><span class="sxs-lookup"><span data-stu-id="dbeff-123">With this model...</span></span>

- <span data-ttu-id="dbeff-124">ドメイン データはサービス内にカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="dbeff-125">データ スキーマは他のサービスに直接影響を与えることなく進化できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="dbeff-126">各データ ストアは個別に拡張可能</span><span class="sxs-lookup"><span data-stu-id="dbeff-126">Each data store can independently scale</span></span>
- <span data-ttu-id="dbeff-127">1 つのサービスでデータ ストアの障害が発生しても、他のサービスに直接影響を与えることはありません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="dbeff-128">データの分離により、各マイクロサービスは、ワークロード、ストレージのニーズ、および読み取り/書き込みパターンに最適なデータ ストアの種類を実装できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="dbeff-129">選択肢には、リレーショナル、ドキュメント、キー値、グラフベースのデータストアなどがあります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="dbeff-130">図 5-2 は、クラウドネイティブ システムにおけるポリグロットの持続性の原則を示しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![多項グロデータの永続性](./media/polyglot-data-persistence.png)

<span data-ttu-id="dbeff-132">**図 5-2**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-132">**Figure 5-2**.</span></span> <span data-ttu-id="dbeff-133">多項グロデータの永続性</span><span class="sxs-lookup"><span data-stu-id="dbeff-133">Polyglot data persistence</span></span>

<span data-ttu-id="dbeff-134">前の図では、各マイクロサービスが異なる種類のデータ ストアをサポートする方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbeff-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="dbeff-135">製品カタログ マイクロサービスは、基になるデータの豊富なリレーショナル構造に対応するためにリレーショナル データベースを使用します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="dbeff-136">ショッピング カート マイクロサービスは、シンプルなキー値データ ストアをサポートする分散キャッシュを使用します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="dbeff-137">注文マイクロサービスは、大量の読み取り操作に対応するために、書き込み操作に対して NoSql ドキュメント データベースと、高度に非正規化されたキー/値ストアの両方を使用します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="dbeff-138">リレーショナル データベースは複雑なデータを持つマイクロサービスに関連していますが、NoSQL データベースはかなりの人気を集めています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="dbeff-139">大規模な規模と高可用性を提供します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="dbeff-140">スキーマを持たない性質により、開発者は、変更にコストと時間がかかる型指定されたデータ クラスや ORM のアーキテクチャから離れて移動できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="dbeff-141">この章では、後ほど NoSQL データベースについて説明します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="dbeff-142">データを別々のマイクロサービスにカプセル化することで、俊敏性、パフォーマンス、およびスケーラビリティを向上させることができますが、多くの課題も伴います。</span><span class="sxs-lookup"><span data-stu-id="dbeff-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="dbeff-143">次のセクションでは、これらの課題と、それらを克服するためのパターンと実践について説明します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="dbeff-144">クロスサービス クエリ</span><span class="sxs-lookup"><span data-stu-id="dbeff-144">Cross-service queries</span></span>

<span data-ttu-id="dbeff-145">マイクロサービスは独立しており、在庫、出荷、発注などの特定の機能に重点を置いていますが、多くの場合、他のマイクロサービスとの統合が必要になります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="dbeff-146">多くの場合、統合には、あるマイクロサービスが別のマイクロサービス*にデータを照会する*必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="dbeff-147">図 5-3 にシナリオを示します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-147">Figure 5-3 shows the scenario.</span></span>

![マイクロサービス間でのクエリ](./media/cross-service-query.png)

<span data-ttu-id="dbeff-149">**図 5-3**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-149">**Figure 5-3**.</span></span> <span data-ttu-id="dbeff-150">マイクロサービス間でのクエリ</span><span class="sxs-lookup"><span data-stu-id="dbeff-150">Querying across microservices</span></span>

<span data-ttu-id="dbeff-151">前の図では、ユーザーの買い物かごにアイテムを追加するショッピング バスケット マイクロサービスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="dbeff-152">このマイクロサービスのデータ ストアにはバスケットと品目のデータが含まれていますが、商品データや価格データは保持されません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="dbeff-153">代わりに、これらのデータ項目はカタログと価格マイクロサービスによって所有されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="dbeff-154">これは問題を提示します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-154">This presents a problem.</span></span> <span data-ttu-id="dbeff-155">買い物かごマイクロサービスは、そのデータベースに製品や価格設定データがない場合、どのようにユーザーの買い物かごに製品を追加できますか?</span><span class="sxs-lookup"><span data-stu-id="dbeff-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="dbeff-156">第 4 章で説明したオプションの 1 つは、ショッピング カートからカタログおよび価格マイクロサービスへの[直接 HTTP 呼び出し](service-to-service-communication.md#queries)です。</span><span class="sxs-lookup"><span data-stu-id="dbeff-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="dbeff-157">しかし、第 4 章では、同期 HTTP 呼び出し*はマイクロサービスを結合*し、その自律性を低下させ、アーキテクチャ上の利点を減らすことを説明しました。</span><span class="sxs-lookup"><span data-stu-id="dbeff-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="dbeff-158">また、各サービスに対して、個別の受信キューと送信キューを持つ要求/応答パターンを実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="dbeff-159">ただし、このパターンは複雑であり、要求メッセージと応答メッセージを関連付けるために配管が必要です。</span><span class="sxs-lookup"><span data-stu-id="dbeff-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="dbeff-160">バックエンド マイクロサービス呼び出しの分離は行われますが、呼び出し元のサービスは、呼び出しが完了するまで同期的に待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="dbeff-161">ネットワークの輻輳、一時的な障害、または過負荷のマイクロサービスが発生し、長時間実行され、さらに失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="dbeff-162">その代わり、クロスサービスの依存関係を削除するための広く受け入れられているパターンは、図 5-4 に示す[マテリアライズビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。</span><span class="sxs-lookup"><span data-stu-id="dbeff-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![マテリアライズビューパターン](./media/materialized-view-pattern.png)

<span data-ttu-id="dbeff-164">**図 5-4**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-164">**Figure 5-4**.</span></span> <span data-ttu-id="dbeff-165">マテリアライズビューパターン</span><span class="sxs-lookup"><span data-stu-id="dbeff-165">Materialized View Pattern</span></span>

<span data-ttu-id="dbeff-166">このパターンでは、買い物バスケット サービスにローカル データ テーブル (*読み取りモデル*) を配置します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="dbeff-167">このテーブルには、製品および価格マイクロサービスから必要なデータの非正規化コピーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="dbeff-168">データをショッピング バスケット マイクロサービスに直接コピーすると、コストのかかるクロスサービス呼び出しが不要になります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="dbeff-169">サービスに対してローカルなデータを使用すると、サービスの応答時間と信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="dbeff-170">さらに、データの独自のコピーを持つことで、ショッピング バスケット サービスの弾力性が向上します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="dbeff-171">カタログ サービスが利用できなくなった場合、ショッピング バスケット サービスに直接影響を与えることはありません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="dbeff-172">買い物かごは、自分の店舗からのデータで操作を続けることができます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="dbeff-173">このアプローチのキャッチは、システム内に重複データが存在することです。</span><span class="sxs-lookup"><span data-stu-id="dbeff-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="dbeff-174">しかし、クラウドネイティブシステムでデータを*戦略的に*複製することは確立された慣行であり、アンチパターンや悪い習慣とは考えられません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="dbeff-175">*1 つのサービスだけが*データ・セットを所有し、そのデータ・セットに対する権限を持つことができることを覚えておいてください。</span><span class="sxs-lookup"><span data-stu-id="dbeff-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="dbeff-176">レコードのシステムが更新されたときに読み取りモデルを同期する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="dbeff-177">同期は、通常、[パブリッシュ/サブスクライブ パターン](service-to-service-communication.md#events)を使用した非同期メッセージングを介して実装されます (図 5.4 を参照)。</span><span class="sxs-lookup"><span data-stu-id="dbeff-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="dbeff-178">分散トランザクション</span><span class="sxs-lookup"><span data-stu-id="dbeff-178">Distributed transactions</span></span>

<span data-ttu-id="dbeff-179">マイクロサービス間でデータを照会するのは困難ですが、複数のマイクロサービス間でのトランザクションの実装はさらに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="dbeff-180">異なるマイクロサービス内の独立したデータ ソース間でデータの一貫性を維持するという固有の課題は、過小評価することはできません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="dbeff-181">クラウド ネイティブ アプリケーションで分散トランザクションが不足している場合は、分散トランザクションをプログラムで管理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="dbeff-182">*あなたは、即時の一貫性*の世界から*最終的な一貫性*の世界に移動します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="dbeff-183">図 5-5 に問題を示します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-183">Figure 5-5 shows the problem.</span></span>

![サガ パターンでのトランザクション](./media/saga-transaction-operation.png)

<span data-ttu-id="dbeff-185">**図 5-5**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-185">**Figure 5-5**.</span></span> <span data-ttu-id="dbeff-186">マイクロサービス間でのトランザクションの実装</span><span class="sxs-lookup"><span data-stu-id="dbeff-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="dbeff-187">前の図では、5 つの独立したマイクロサービスが、注文を作成する分散トランザクションに参加しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="dbeff-188">各マイクロサービスは、独自のデータ ストアを保持し、そのストアのローカル トランザクションを実装します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="dbeff-189">注文を作成するには、*個々*のマイクロサービスのローカル トランザクションが成功するか、*または操作をすべて*中止してロールバックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="dbeff-190">組み込みのトランザクション サポートは各マイクロサービス内で利用できますが、データの一貫性を維持するために 5 つのサービス全体にわたる分散トランザクションのサポートはありません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="dbeff-191">代わりに、この分散トランザクションを*プログラムで*構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="dbeff-192">分散トランザクションサポートを追加する一般的なパターンは、Sagaパターンです。</span><span class="sxs-lookup"><span data-stu-id="dbeff-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="dbeff-193">ローカル トランザクションをプログラムでグループ化し、各トランザクションを順次呼び出すことによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="dbeff-194">いずれかのローカル トランザクションが失敗した場合、Saga は操作を中止し、一連の[補正トランザクションを](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)呼び出します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="dbeff-195">補正トランザクションは、前のローカル トランザクションによって行われた変更を元に戻し、データの一貫性を復元します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="dbeff-196">図 5-6 は、Saga パターンを使用して失敗したトランザクションを示しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![サガパターンでロールバック](./media/saga-rollback-operation.png)

<span data-ttu-id="dbeff-198">**図 5-6**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-198">**Figure 5-6**.</span></span> <span data-ttu-id="dbeff-199">トランザクションのロールバック</span><span class="sxs-lookup"><span data-stu-id="dbeff-199">Rolling back a transaction</span></span>

<span data-ttu-id="dbeff-200">前の図では、*在庫の更新*操作は、インベントリ のマイクロサービスで失敗しました。</span><span class="sxs-lookup"><span data-stu-id="dbeff-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="dbeff-201">佐賀は、一連の補正トランザクション (赤色) を呼び出して、在庫数を調整し、支払と注文をキャンセルし、各マイクロサービスのデータを一貫した状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="dbeff-202">佐賀パターンは、通常、関連する一連のイベントとして振り付け、または関連するコマンドのセットとして調整されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="dbeff-203">第 4 章では、オーケストレーションサガ実装の基礎となるサービス アグリゲータ パターンについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="dbeff-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="dbeff-204">また、振り付けサガの実装の基礎となる Azure サービス バスと Azure イベント グリッドのトピックと共にイベントについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="dbeff-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="dbeff-205">大量データ</span><span class="sxs-lookup"><span data-stu-id="dbeff-205">High volume data</span></span>

<span data-ttu-id="dbeff-206">大規模なクラウド ネイティブ アプリケーションは、多くの場合、大量のデータ要件をサポートします。</span><span class="sxs-lookup"><span data-stu-id="dbeff-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="dbeff-207">このようなシナリオでは、従来のデータ ストレージ手法によってボトルネックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="dbeff-208">大規模に展開する複雑なシステムでは、コマンドとクエリ責任の分離 (CQRS) とイベント ソーシングの両方で、アプリケーションのパフォーマンスが向上する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="dbeff-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="dbeff-209">CQRS</span></span>

<span data-ttu-id="dbeff-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)は、パフォーマンス、スケーラビリティ、およびセキュリティを最大限に高めるアーキテクチャ パターンです。</span><span class="sxs-lookup"><span data-stu-id="dbeff-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="dbeff-211">このパターンは、データを読み取る操作と、データを書き込む操作を分離します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="dbeff-212">通常のシナリオでは、同じエンティティ モデルとデータ リポジトリ オブジェクトが読み取りと書き込みの*両方*の操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="dbeff-213">ただし、大量のデータ シナリオでは、読み取りと書き込みの個別のモデルとデータ テーブルの利点があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="dbeff-214">パフォーマンスを向上させるために、読み取り操作は、データの高度に非正規化された表現に対してクエリを実行し、負荷のかかる反復的なテーブル結合とテーブル ロックを回避できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="dbeff-215">*コマンド*と呼ばれる*書き込み*操作は、一貫性を保証する完全に正規化されたデータ表現に対して更新されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="dbeff-216">次に、両方の表現を同期するメカニズムを実装する必要があります。通常、書き込みテーブルは、変更が変更されるたびに、読み取りテーブルに変更をレプリケートするイベントを発行します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="dbeff-217">図 5-7 は、CQRS パターンの実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![コマンドとクエリの責任の分離](./media/cqrs-implementation.png)

<span data-ttu-id="dbeff-219">**図 5-7**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-219">**Figure 5-7**.</span></span> <span data-ttu-id="dbeff-220">CQRS の実装</span><span class="sxs-lookup"><span data-stu-id="dbeff-220">CQRS implementation</span></span>

<span data-ttu-id="dbeff-221">前の図では、個別のコマンド モデルとクエリ モデルが実装されています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="dbeff-222">各データ書き込み操作は書き込みストアに保存され、その後、読み取りストアに反映されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="dbeff-223">データ伝播プロセスが[最終的な一貫性](http://www.cloudcomputingpatterns.org/eventual_consistency/)の原則にどのように作用するかに細心の注意を払う。</span><span class="sxs-lookup"><span data-stu-id="dbeff-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="dbeff-224">読み取りモデルは最終的に書き込みモデルと同期しますが、プロセスに若干の遅れがある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="dbeff-225">最終的な一貫性については、次のセクションで説明します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="dbeff-226">この分離により、読み取りと書き込みを個別にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="dbeff-227">読み取り操作ではクエリ用に最適化されたスキーマが使用されますが、書き込みでは更新用に最適化されたスキーマが使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="dbeff-228">読み取りクエリは非正規化されたデータに対して行われますが、複雑なビジネス ロジックは書き込みモデルに適用できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="dbeff-229">また、読み取りを公開する場合よりも、書き込み操作に対して厳しいセキュリティを課す場合もあります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="dbeff-230">CQRS を実装すると、クラウド ネイティブ サービスのアプリケーション パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="dbeff-231">ただし、より複雑な設計になります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="dbeff-232">この原則は、クラウドネイティブアプリケーションのセクションに慎重かつ戦略的に適用します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="dbeff-233">CQRS の詳細については、 Microsoft の著書[「.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="dbeff-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="dbeff-234">イベントソーシング</span><span class="sxs-lookup"><span data-stu-id="dbeff-234">Event sourcing</span></span>

<span data-ttu-id="dbeff-235">大量のデータ シナリオを最適化するもう 1 つの方法として[は、イベント ソーシング](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)が含まれます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="dbeff-236">システムは通常、データ エンティティの現在の状態を格納します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="dbeff-237">たとえば、ユーザーが電話番号を変更すると、顧客レコードが新しい番号で更新されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="dbeff-238">データ エンティティの現在の状態は常にわかりますが、各更新プログラムは以前の状態を上書きします。</span><span class="sxs-lookup"><span data-stu-id="dbeff-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="dbeff-239">ほとんどの場合、このモデルは正常に動作します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-239">In most cases, this model works fine.</span></span> <span data-ttu-id="dbeff-240">ただし、大量のシステムでは、トランザクション ロックと頻繁な更新操作によるオーバーヘッドがデータベースのパフォーマンス、応答性、およびスケーラビリティの制限に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="dbeff-241">イベント ソーシングでは、データのキャプチャに異なるアプローチを採用しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="dbeff-242">データに影響を与える各操作は、イベント ストアに永続化されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="dbeff-243">データ レコードの状態を更新する代わりに、経理担当の元帳と同様に、各変更を過去のイベントの連続したリストに追加します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="dbeff-244">イベントストアは、データの記録のシステムになります。</span><span class="sxs-lookup"><span data-stu-id="dbeff-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="dbeff-245">マイクロサービスの境界コンテキスト内でさまざまなマテリアライズドビューを伝播するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="dbeff-246">図 5.8 にパターンを示します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-246">Figure 5.8 shows the pattern.</span></span>

![イベント ソーシング](./media/event-sourcing.png)

<span data-ttu-id="dbeff-248">**図 5-8**.</span><span class="sxs-lookup"><span data-stu-id="dbeff-248">**Figure 5-8**.</span></span> <span data-ttu-id="dbeff-249">イベント ソーシング</span><span class="sxs-lookup"><span data-stu-id="dbeff-249">Event Sourcing</span></span>

<span data-ttu-id="dbeff-250">前の図では、ユーザーのショッピング カートの各エントリ (青色) が基になるイベント ストアに追加される方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="dbeff-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="dbeff-251">隣接するマテリアライズドビューでは、各ショッピングカートに関連付けられたすべてのイベントを再生することによって、現在の状態が投影されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="dbeff-252">このビュー(読み取りモデル)は、UI に公開されます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="dbeff-253">イベントは、外部システムやアプリケーションと統合したり、エンティティの現在の状態を判断するためにクエリを実行したりすることもできます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="dbeff-254">このアプローチでは、履歴を保持します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-254">With this approach, you maintain history.</span></span> <span data-ttu-id="dbeff-255">エンティティの現在の状態だけでなく、この状態に到達した方法も知っています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="dbeff-256">機械的に言えば、イベント ソーシングは書き込みモデルを単純化します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="dbeff-257">更新または削除はありません。</span><span class="sxs-lookup"><span data-stu-id="dbeff-257">There are no updates or deletes.</span></span> <span data-ttu-id="dbeff-258">各データ エントリを変更できないイベントとして追加すると、リレーショナル データベースに関連する競合、ロック、および同時実行の競合を最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="dbeff-259">マテリアライズドビューパターンを使用して読み取りモデルを構築すると、書き込みモデルからビューを切り離し、最適なデータ ストアを選択してアプリケーション UI のニーズを最適化できます。</span><span class="sxs-lookup"><span data-stu-id="dbeff-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="dbeff-260">このパターンでは、イベント ソーシングを直接サポートするデータ ストアを検討してください。</span><span class="sxs-lookup"><span data-stu-id="dbeff-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="dbeff-261">Azure コスモス DB、モンゴデータベース、カサンドラ、カウチDB、および RavenDB が適しています。</span><span class="sxs-lookup"><span data-stu-id="dbeff-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="dbeff-262">すべてのパターンとテクノロジと同様に、戦略的に、必要に応じて実装します。</span><span class="sxs-lookup"><span data-stu-id="dbeff-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="dbeff-263">イベント ソーシングはパフォーマンスとスケーラビリティを向上させますが、複雑さと学習曲線を犠牲にします。</span><span class="sxs-lookup"><span data-stu-id="dbeff-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="dbeff-264">[前次](service-mesh-communication-infrastructure.md)
>[Next](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="dbeff-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
