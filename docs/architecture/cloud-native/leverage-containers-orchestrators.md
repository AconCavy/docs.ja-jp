---
title: コンテナーとコンテナー オーケストレーターの活用
description: Azure での Docker コンテナーと Kubernetes Orchestrators 活用
ms.date: 05/13/2020
ms.openlocfilehash: 5d0b7f41caecb3422a4416514de2fdd54e94539a
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/19/2020
ms.locfileid: "83613908"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="88114-103">コンテナーとコンテナー オーケストレーターの活用</span><span class="sxs-lookup"><span data-stu-id="88114-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="88114-104">コンテナーとオーケストレーター、モノリシックデプロイアプローチに共通する問題を解決するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="88114-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="88114-105">モノリシックデプロイに関する課題</span><span class="sxs-lookup"><span data-stu-id="88114-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="88114-106">従来、ほとんどのアプリケーションは1つのユニットとして展開されていました。</span><span class="sxs-lookup"><span data-stu-id="88114-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="88114-107">このようなアプリケーションは、モノリスと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="88114-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="88114-108">図3-1 に示すように、複数のモジュールまたはアセンブリで構成されている場合でも、アプリケーションを1つの単位としてデプロイする一般的な方法を次に示します。</span><span class="sxs-lookup"><span data-stu-id="88114-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![モノリシックアーキテクチャ。](./media/monolithic-design.png)

<span data-ttu-id="88114-110">**図 3-1**.</span><span class="sxs-lookup"><span data-stu-id="88114-110">**Figure 3-1**.</span></span> <span data-ttu-id="88114-111">モノリシックアーキテクチャ。</span><span class="sxs-lookup"><span data-stu-id="88114-111">Monolithic architecture.</span></span>

<span data-ttu-id="88114-112">単純化の利点はありますが、モノリシックアーキテクチャはいくつかの課題に直面します。</span><span class="sxs-lookup"><span data-stu-id="88114-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="88114-113">展開</span><span class="sxs-lookup"><span data-stu-id="88114-113">Deployment</span></span>

<span data-ttu-id="88114-114">モノリシックアプリケーションでは、わずかな変更しか加えられていない場合でも、アプリケーション全体を完全に展開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="88114-114">Monolithic applications require a full deployment of the entire application, even if only a small change has been made.</span></span> <span data-ttu-id="88114-115">完全な展開はコストが高く、エラーが発生しやすい場合があります。</span><span class="sxs-lookup"><span data-stu-id="88114-115">Full deployments can be expensive and error prone.</span></span> <span data-ttu-id="88114-116">また、アプリケーションを再起動する必要があり、一時的に使用不可に影響します。</span><span class="sxs-lookup"><span data-stu-id="88114-116">Additionally, they require a restart of the application, which temporarily impacts unavailability.</span></span>

### <a name="scaling"></a><span data-ttu-id="88114-117">Scaling</span><span class="sxs-lookup"><span data-stu-id="88114-117">Scaling</span></span>

<span data-ttu-id="88114-118">モノリシックアプリケーションは、1台のコンピューターインスタンスで完全にホストされ、多くの場合、高い機能を備えたハードウェアを必要とします。</span><span class="sxs-lookup"><span data-stu-id="88114-118">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="88114-119">モノリスのいずれかの部分にスケーリングが必要な場合は、アプリケーション全体の別のコピーを別のコンピューターに配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="88114-119">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="88114-120">モノリスを使用すると、アプリケーションコンポーネントを個別に拡張することはできません。</span><span class="sxs-lookup"><span data-stu-id="88114-120">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="88114-121">スケーリングを必要としないコンポーネントをスケーリングすると、効率が高く、コストがかかるリソースが使用されます。</span><span class="sxs-lookup"><span data-stu-id="88114-121">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="88114-122">環境</span><span class="sxs-lookup"><span data-stu-id="88114-122">Environment</span></span>

<span data-ttu-id="88114-123">モノリシックアプリケーションは、通常、インストール済みのオペレーティングシステム、ランタイム、およびライブラリの依存関係を備えたホスト環境に配置されます。</span><span class="sxs-lookup"><span data-stu-id="88114-123">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="88114-124">この環境は、アプリケーションを開発またはテストしたときと一致しない場合があります。</span><span class="sxs-lookup"><span data-stu-id="88114-124">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="88114-125">アプリケーション環境間での不整合は、モノリシック配置における一般的な問題の原因となります。</span><span class="sxs-lookup"><span data-stu-id="88114-125">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="88114-126">結合</span><span class="sxs-lookup"><span data-stu-id="88114-126">Coupling</span></span>

<span data-ttu-id="88114-127">モノリシックアプリケーションでは、その機能コンポーネント間で高い結合が発生する可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="88114-127">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="88114-128">ハードな境界がないと、システムの変更によって意図しないコストの高い副作用が生じることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="88114-128">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="88114-129">新機能と修正プログラムは、複雑になり、時間がかかり、実装にコストがかかります。</span><span class="sxs-lookup"><span data-stu-id="88114-129">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="88114-130">更新には広範なテストが必要です。</span><span class="sxs-lookup"><span data-stu-id="88114-130">Updates require extensive testing.</span></span> <span data-ttu-id="88114-131">また、結合を使用すると、別の実装でのコンポーネントのリファクタリングやスワップが困難になります。</span><span class="sxs-lookup"><span data-stu-id="88114-131">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="88114-132">問題の厳密な分離によって構築された場合でも、アーキテクチャ erosion はをモノリシックコードベース悪化として設定します。</span><span class="sxs-lookup"><span data-stu-id="88114-132">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="88114-133">プラットフォームのロックイン</span><span class="sxs-lookup"><span data-stu-id="88114-133">Platform lock-in</span></span>

<span data-ttu-id="88114-134">モノリシックアプリケーションは、1つのテクノロジスタックを使用して構築されます。</span><span class="sxs-lookup"><span data-stu-id="88114-134">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="88114-135">統一性を提供する一方で、このコミットメントはイノベーションの妨げになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="88114-135">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="88114-136">新しい機能とコンポーネントは、アプリケーションの現在のスタックを使用して構築されます。最新のテクノロジがより適している場合もあります。</span><span class="sxs-lookup"><span data-stu-id="88114-136">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="88114-137">長期的なリスクとしては、テクノロジスタックが古くなったり時代遅れになったりすることがあります。</span><span class="sxs-lookup"><span data-stu-id="88114-137">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="88114-138">アプリケーション全体を新しい最新のプラットフォームに再設計することは、最高のコストとリスクを伴います。</span><span class="sxs-lookup"><span data-stu-id="88114-138">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="88114-139">コンテナーと orchestrators はどのような利点がありますか。</span><span class="sxs-lookup"><span data-stu-id="88114-139">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="88114-140">第1章ではコンテナーを紹介しました。</span><span class="sxs-lookup"><span data-stu-id="88114-140">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="88114-141">Cloud native Computing Foundation (CNCF) の順位付けは、クラウドネイティブのコンテナー化[マップ](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)の最初の手順として、クラウドネイティブの旅を開始する企業向けのガイダンスとして強調されています。</span><span class="sxs-lookup"><span data-stu-id="88114-141">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="88114-142">このセクションでは、コンテナーの利点について説明します。</span><span class="sxs-lookup"><span data-stu-id="88114-142">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="88114-143">Docker は、最も一般的なコンテナー管理プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="88114-143">Docker is the most popular container management platform.</span></span> <span data-ttu-id="88114-144">Linux と Windows の両方でコンテナーと連携して動作します。</span><span class="sxs-lookup"><span data-stu-id="88114-144">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="88114-145">コンテナーは、任意のシステムで同じように動作する、再現可能な別のアプリケーション環境を提供します。</span><span class="sxs-lookup"><span data-stu-id="88114-145">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="88114-146">この側面により、クラウドネイティブサービスの開発とホスティングに最適なものになります。</span><span class="sxs-lookup"><span data-stu-id="88114-146">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="88114-147">コンテナーは相互に分離されています。</span><span class="sxs-lookup"><span data-stu-id="88114-147">Containers are isolated from one another.</span></span> <span data-ttu-id="88114-148">同じホストハードウェア上の2つのコンテナーは、競合を発生させることなく、異なるバージョンのソフトウェアを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="88114-148">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="88114-149">コンテナーは、プロジェクトの成果物になる単純なテキストベースのファイルによって定義され、ソース管理にチェックインされます。</span><span class="sxs-lookup"><span data-stu-id="88114-149">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="88114-150">完全なサーバーと仮想マシンは手動で更新する必要がありますが、コンテナーは簡単にバージョン管理できます。</span><span class="sxs-lookup"><span data-stu-id="88114-150">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="88114-151">コンテナーで実行するようにビルドされたアプリは、ビルドパイプラインの一部として自動化ツールを使用して開発、テスト、および配置できます。</span><span class="sxs-lookup"><span data-stu-id="88114-151">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="88114-152">コンテナーは変更できません。</span><span class="sxs-lookup"><span data-stu-id="88114-152">Containers are immutable.</span></span> <span data-ttu-id="88114-153">コンテナーを定義したら、それをまったく同じ方法で再作成し、実行することができます。</span><span class="sxs-lookup"><span data-stu-id="88114-153">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="88114-154">この不変性は、コンポーネントベースの設計に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="88114-154">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="88114-155">アプリケーションの一部が他の部分とは異なる方法で進化する場合、最も頻繁に変更される部分を展開するだけで、アプリ全体を再展開するのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="88114-155">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="88114-156">アプリのさまざまな機能と横断的な問題を別々の単位に分割できます。</span><span class="sxs-lookup"><span data-stu-id="88114-156">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="88114-157">図3-2 は、モノリシックアプリが特定の機能を委任することによってコンテナーとマイクロサービスを利用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="88114-157">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="88114-158">アプリ自体のその他の機能もコンテナー化されています。</span><span class="sxs-lookup"><span data-stu-id="88114-158">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="88114-159">コンテナーは変更できません。</span><span class="sxs-lookup"><span data-stu-id="88114-159">Containers are immutable.</span></span> <span data-ttu-id="88114-160">コンテナーを定義したら、それをまったく同じ方法で再作成し、実行することができます。</span><span class="sxs-lookup"><span data-stu-id="88114-160">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="88114-161">この不変性は、コンポーネントベースの設計に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="88114-161">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="88114-162">アプリケーションの一部が他の部分とは異なる方法で進化する場合、最も頻繁に変更される部分を展開するだけで、アプリ全体を再展開するのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="88114-162">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="88114-163">アプリのさまざまな機能と横断的な問題を別々の単位に分割できます。</span><span class="sxs-lookup"><span data-stu-id="88114-163">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="88114-164">図3-2 は、モノリシックアプリが特定の機能を委任することによってコンテナーとマイクロサービスを利用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="88114-164">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="88114-165">アプリ自体のその他の機能もコンテナー化されています。</span><span class="sxs-lookup"><span data-stu-id="88114-165">The remaining functionality in the app itself has also been containerized.</span></span>

![バックエンドでマイクロサービスを使用するようにモノリシックアプリを分割します。](./media/cloud-native-design.png)

<span data-ttu-id="88114-167">**図 3-2**.</span><span class="sxs-lookup"><span data-stu-id="88114-167">**Figure 3-2**.</span></span> <span data-ttu-id="88114-168">モノリシックアプリを分解してマイクロサービスを利用する。</span><span class="sxs-lookup"><span data-stu-id="88114-168">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="88114-169">各クラウドネイティブサービスは、個別のコンテナーにビルドおよび展開されます。</span><span class="sxs-lookup"><span data-stu-id="88114-169">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="88114-170">各は必要に応じて更新できます。</span><span class="sxs-lookup"><span data-stu-id="88114-170">Each can update as needed.</span></span> <span data-ttu-id="88114-171">個々のサービスは、各サービスに適切なリソースを持つノードでホストできます。</span><span class="sxs-lookup"><span data-stu-id="88114-171">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="88114-172">各サービスが実行されている環境は、開発環境、テスト環境、運用環境間で共有することも、簡単にバージョン管理することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-172">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="88114-173">アプリケーションのさまざまな領域間の結合は、モノリス内のコンパイル時の依存関係ではなく、サービス間の呼び出しまたはメッセージとして明示的に行われます。</span><span class="sxs-lookup"><span data-stu-id="88114-173">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="88114-174">また、アプリの他の部分に変更を加えることなく、特定の機能に最適なテクノロジを選択することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-174">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="88114-175">コンテナー化されたサービスには、自動管理が必要です。</span><span class="sxs-lookup"><span data-stu-id="88114-175">Containerized services require automated management.</span></span> <span data-ttu-id="88114-176">個別にデプロイされた多数のコンテナーを手動で管理することはできません。</span><span class="sxs-lookup"><span data-stu-id="88114-176">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="88114-177">たとえば、次のタスクについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="88114-177">For example, consider the following tasks:</span></span>

- <span data-ttu-id="88114-178">多くのコンピューターのクラスターに対してコンテナーインスタンスをプロビジョニングするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-178">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="88114-179">デプロイ後、コンテナーはどのようにして相互に検出され、相互に通信しますか。</span><span class="sxs-lookup"><span data-stu-id="88114-179">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="88114-180">コンテナーをオンデマンドでスケールインまたはスケールアウトするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-180">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="88114-181">各コンテナーの正常性を監視するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-181">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="88114-182">コンテナーをハードウェアおよびソフトウェアの障害から保護するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-182">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="88114-183">ダウンタイムなしでライブアプリケーションのコンテナーをアップグレードするにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="88114-183">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="88114-184">コンテナーオーケストレーター、これらの問題に対処して自動化します。</span><span class="sxs-lookup"><span data-stu-id="88114-184">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="88114-185">クラウドネイティブエコシステムでは、Kubernetes は事実上コンテナー orchestrator になりました。</span><span class="sxs-lookup"><span data-stu-id="88114-185">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="88114-186">これは、クラウドネイティブコンピューティングファンデーション (CNCF) によって管理されるオープンソースのプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="88114-186">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="88114-187">Kubernetes は、マシンクラスター全体のコンテナー化されたワークロードのデプロイ、スケーリング、および運用上の懸念事項を自動化します。</span><span class="sxs-lookup"><span data-stu-id="88114-187">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="88114-188">ただし、Kubernetes のインストールと管理は非常に複雑です。</span><span class="sxs-lookup"><span data-stu-id="88114-188">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="88114-189">クラウドベンダーの管理されたサービスとして Kubernetes を利用する方が、はるかに優れたアプローチです。</span><span class="sxs-lookup"><span data-stu-id="88114-189">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="88114-190">Azure クラウドは、完全に管理された[Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/)の Kubernetes プラットフォームを特徴としています。</span><span class="sxs-lookup"><span data-stu-id="88114-190">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="88114-191">AKS は、Kubernetes を管理する際の複雑さと運用上のオーバーヘッドを抽象化します。</span><span class="sxs-lookup"><span data-stu-id="88114-191">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="88114-192">クラウドサービスとして Kubernetes を使用します。Microsoft は、it を管理およびサポートする責任を担います。</span><span class="sxs-lookup"><span data-stu-id="88114-192">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="88114-193">また、AKS は、他の Azure サービスや開発ツールと緊密に統合されています。</span><span class="sxs-lookup"><span data-stu-id="88114-193">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="88114-194">AKS は、クラスターベースのテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="88114-194">AKS is a cluster-based technology.</span></span> <span data-ttu-id="88114-195">フェデレーション仮想マシン (ノード) のプールが Azure クラウドにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="88114-195">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="88114-196">これらの組み合わせにより、高可用性環境 (クラスター) が形成されます。</span><span class="sxs-lookup"><span data-stu-id="88114-196">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="88114-197">クラスターは、クラウドネイティブアプリケーションに対してシームレスな単一のエンティティとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="88114-197">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="88114-198">内部的には、AKS は、負荷を均等に分散する定義済みの方法に従って、これらのノード間でコンテナー化されたサービスをデプロイします。</span><span class="sxs-lookup"><span data-stu-id="88114-198">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

<span data-ttu-id="88114-199">コンテナー化されたサービスには、自動管理が必要です。</span><span class="sxs-lookup"><span data-stu-id="88114-199">Containerized services require automated management.</span></span> <span data-ttu-id="88114-200">個別にデプロイされた多数のコンテナーを手動で管理することはできません。</span><span class="sxs-lookup"><span data-stu-id="88114-200">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="88114-201">たとえば、次のタスクについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="88114-201">For example, consider the following tasks:</span></span>

- <span data-ttu-id="88114-202">多くのコンピューターのクラスターに対してコンテナーインスタンスをプロビジョニングするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-202">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="88114-203">デプロイ後、コンテナーはどのようにして相互に検出され、相互に通信しますか。</span><span class="sxs-lookup"><span data-stu-id="88114-203">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="88114-204">コンテナーをオンデマンドでスケールインまたはスケールアウトするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-204">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="88114-205">各コンテナーの正常性を監視するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-205">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="88114-206">コンテナーをハードウェアおよびソフトウェアの障害から保護するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="88114-206">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="88114-207">ダウンタイムなしでライブアプリケーションのコンテナーをアップグレードするにはどうすればよいですか?</span><span class="sxs-lookup"><span data-stu-id="88114-207">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="88114-208">コンテナーオーケストレーター、これらの問題に対処して自動化します。</span><span class="sxs-lookup"><span data-stu-id="88114-208">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="88114-209">クラウドネイティブエコシステムでは、Kubernetes は事実上コンテナー orchestrator になりました。</span><span class="sxs-lookup"><span data-stu-id="88114-209">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="88114-210">これは、クラウドネイティブコンピューティングファンデーション (CNCF) によって管理されるオープンソースのプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="88114-210">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="88114-211">Kubernetes は、マシンクラスター全体のコンテナー化されたワークロードのデプロイ、スケーリング、および運用上の懸念事項を自動化します。</span><span class="sxs-lookup"><span data-stu-id="88114-211">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="88114-212">ただし、Kubernetes のインストールと管理は非常に複雑です。</span><span class="sxs-lookup"><span data-stu-id="88114-212">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="88114-213">クラウドベンダーの管理されたサービスとして Kubernetes を利用する方が、はるかに優れたアプローチです。</span><span class="sxs-lookup"><span data-stu-id="88114-213">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="88114-214">Azure クラウドは、完全に管理された[Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/)の Kubernetes プラットフォームを特徴としています。</span><span class="sxs-lookup"><span data-stu-id="88114-214">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="88114-215">AKS は、Kubernetes を管理する際の複雑さと運用上のオーバーヘッドを抽象化します。</span><span class="sxs-lookup"><span data-stu-id="88114-215">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="88114-216">クラウドサービスとして Kubernetes を使用します。Microsoft は、it を管理およびサポートする責任を担います。</span><span class="sxs-lookup"><span data-stu-id="88114-216">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="88114-217">また、AKS は、他の Azure サービスや開発ツールと緊密に統合されています。</span><span class="sxs-lookup"><span data-stu-id="88114-217">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="88114-218">AKS は、クラスターベースのテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="88114-218">AKS is a cluster-based technology.</span></span> <span data-ttu-id="88114-219">フェデレーション仮想マシン (ノード) のプールが Azure クラウドにデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="88114-219">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="88114-220">これらの組み合わせにより、高可用性環境 (クラスター) が形成されます。</span><span class="sxs-lookup"><span data-stu-id="88114-220">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="88114-221">クラスターは、クラウドネイティブアプリケーションに対してシームレスな単一のエンティティとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="88114-221">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="88114-222">内部的には、AKS は、負荷を均等に分散する定義済みの方法に従って、これらのノード間でコンテナー化されたサービスをデプロイします。</span><span class="sxs-lookup"><span data-stu-id="88114-222">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="88114-223">スケーリングにはどのような利点がありますか。</span><span class="sxs-lookup"><span data-stu-id="88114-223">What are the scaling benefits?</span></span>

<span data-ttu-id="88114-224">コンテナー上に構築されたサービスは、Kubernetes などのオーケストレーションツールによって提供されるスケーリングの利点を活用できます。</span><span class="sxs-lookup"><span data-stu-id="88114-224">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="88114-225">設計コンテナーによって認識されるのは、それ自体だけです。</span><span class="sxs-lookup"><span data-stu-id="88114-225">By design containers only know about themselves.</span></span> <span data-ttu-id="88114-226">複数のコンテナーを連携させる必要がある場合は、より高いレベルでそれらを整理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="88114-226">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="88114-227">多数のコンテナーとその共有依存関係 (ネットワーク構成など) を整理すると、その日を節約するためにオーケストレーションツールが提供されます。</span><span class="sxs-lookup"><span data-stu-id="88114-227">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="88114-228">Kubernetes は、コンテナーのグループに対して抽象化レイヤーを作成し、*ポッド*に整理します。</span><span class="sxs-lookup"><span data-stu-id="88114-228">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="88114-229">ポッドは、*ノード*と呼ばれるワーカーマシン上で実行されます。</span><span class="sxs-lookup"><span data-stu-id="88114-229">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="88114-230">この体系化された構造は*クラスター*と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="88114-230">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="88114-231">図3-3 は、Kubernetes クラスターのさまざまなコンポーネントを示しています。</span><span class="sxs-lookup"><span data-stu-id="88114-231">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="88114-232">![クラスターコンポーネントを Kubernetes します。 ](./media/kubernetes-cluster-components.png)
**図 3-3**.</span><span class="sxs-lookup"><span data-stu-id="88114-232">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="88114-233">クラスターコンポーネントを Kubernetes します。</span><span class="sxs-lookup"><span data-stu-id="88114-233">Kubernetes cluster components.</span></span>

<span data-ttu-id="88114-234">コンテナー化されたワークロードのスケーリングは、コンテナー orchestrators 主要な機能です。</span><span class="sxs-lookup"><span data-stu-id="88114-234">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="88114-235">AKS は、コンテナーインスタンスとコンピューティングノードの2つのディメンション間の自動スケーリングをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="88114-235">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="88114-236">AKS を利用することで、需要の急増に迅速かつ効率的に応答し、リソースを追加することができます。</span><span class="sxs-lookup"><span data-stu-id="88114-236">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="88114-237">AKS でのスケーリングについては、この章で後ほど説明します。</span><span class="sxs-lookup"><span data-stu-id="88114-237">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="88114-238">宣言型と命令型</span><span class="sxs-lookup"><span data-stu-id="88114-238">Declarative versus imperative</span></span>

<span data-ttu-id="88114-239">Kubernetes は、宣言型と命令型の両方の構成をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="88114-239">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="88114-240">命令型のアプローチには、各手順の実行方法を Kubernetes に指示するさまざまなコマンドを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="88114-240">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="88114-241">このイメージを実行します。</span><span class="sxs-lookup"><span data-stu-id="88114-241">Run this image.</span></span> <span data-ttu-id="88114-242">このポッドを削除します。</span><span class="sxs-lookup"><span data-stu-id="88114-242">Delete this pod.</span></span> <span data-ttu-id="88114-243">このポートを公開します。</span><span class="sxs-lookup"><span data-stu-id="88114-243">Expose this port.</span></span> <span data-ttu-id="88114-244">宣言型の方法では、マニフェストと呼ばれる構成ファイルを作成して、何を行うかではなく、目的の内容を記述します。</span><span class="sxs-lookup"><span data-stu-id="88114-244">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="88114-245">Kubernetes はマニフェストを読み取り、目的の終了状態を実際の終了状態に変換します。</span><span class="sxs-lookup"><span data-stu-id="88114-245">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="88114-246">命令型コマンドは、学習や対話型の実験に適しています。</span><span class="sxs-lookup"><span data-stu-id="88114-246">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="88114-247">ただし、信頼性が高く反復可能なデプロイを実現するために、コードのアプローチとしてインフラストラクチャを採用するために、Kubernetes マニフェストファイルを宣言によって作成することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="88114-247">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="88114-248">マニフェストファイルはプロジェクトアーティファクトになり、Kubernetes デプロイを自動化するために CI/CD パイプラインで使用されます。</span><span class="sxs-lookup"><span data-stu-id="88114-248">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="88114-249">命令型コマンドを使用して既にクラスターを構成している場合は、を使用して宣言型マニフェストをエクスポートでき `kubectl get svc SERVICENAME -o yaml > service.yaml` ます。</span><span class="sxs-lookup"><span data-stu-id="88114-249">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="88114-250">このコマンドを実行すると、次のようなマニフェストが生成されます。</span><span class="sxs-lookup"><span data-stu-id="88114-250">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="88114-251">宣言型の構成を使用する場合は、構成ファイルが配置されているフォルダーに対してを使用してコミットする前に、変更をプレビューでき `kubectl diff -f FOLDERNAME` ます。</span><span class="sxs-lookup"><span data-stu-id="88114-251">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="88114-252">変更を適用することを確認したら、を実行 `kubectl apply -f FOLDERNAME` します。</span><span class="sxs-lookup"><span data-stu-id="88114-252">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="88114-253">`-R`フォルダー階層を再帰的に処理するには、を追加します。</span><span class="sxs-lookup"><span data-stu-id="88114-253">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="88114-254">宣言型の構成を他の Kubernetes 機能と共に使用することもできます。そのうちの1つは配置です。</span><span class="sxs-lookup"><span data-stu-id="88114-254">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="88114-255">宣言型の配置は、リリース、更新、およびスケーリングを管理するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="88114-255">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="88114-256">新しい変更をデプロイする方法、負荷をスケールアウトする方法、または以前のリビジョンにロールバックする方法について、Kubernetes deployment controller に指示します。</span><span class="sxs-lookup"><span data-stu-id="88114-256">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="88114-257">クラスターが不安定な場合、宣言型のデプロイはクラスターを自動的に適切な状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="88114-257">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="88114-258">たとえば、ノードがクラッシュした場合、デプロイメカニズムによって、目的の状態を実現するために置き換えが再デプロイされます。</span><span class="sxs-lookup"><span data-stu-id="88114-258">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="88114-259">宣言型の構成を使用すると、アプリケーションコードと共にチェックインおよびバージョン管理できるコードとして、インフラストラクチャを表すことができます。</span><span class="sxs-lookup"><span data-stu-id="88114-259">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="88114-260">改良された変更管理と、ビルドおよびデプロイパイプラインを使用した継続的なデプロイのサポートが向上します。</span><span class="sxs-lookup"><span data-stu-id="88114-260">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="88114-261">コンテナーと orchestrators 最適なシナリオ</span><span class="sxs-lookup"><span data-stu-id="88114-261">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="88114-262">次のシナリオは、コンテナーと orchestrators 使用する場合に最適です。</span><span class="sxs-lookup"><span data-stu-id="88114-262">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="88114-263">高いアップタイムとスケーラビリティを必要とするアプリケーション</span><span class="sxs-lookup"><span data-stu-id="88114-263">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="88114-264">アップタイムとスケーラビリティの要件が高い個々のアプリケーションは、マイクロサービス、コンテナー、および orchestrators 使用したクラウドネイティブアーキテクチャに最適です。</span><span class="sxs-lookup"><span data-stu-id="88114-264">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="88114-265">これらは、コンテナーで開発し、バージョン管理された環境でテストし、ダウンタイムなしで運用環境にデプロイすることができます。</span><span class="sxs-lookup"><span data-stu-id="88114-265">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="88114-266">Kubernetes クラスターを使用することにより、このようなアプリはオンデマンドでスケールしたり、ノードの障害から自動的に回復したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="88114-266">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="88114-267">多数のアプリケーション</span><span class="sxs-lookup"><span data-stu-id="88114-267">Large numbers of applications</span></span>

<span data-ttu-id="88114-268">多数のアプリケーションを展開して管理する組織は、コンテナーと orchestrators 利用できます。</span><span class="sxs-lookup"><span data-stu-id="88114-268">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="88114-269">コンテナー化された環境と Kubernetes クラスターを設定する前の作業は、主に固定コストです。</span><span class="sxs-lookup"><span data-stu-id="88114-269">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="88114-270">個々のアプリケーションの配置、保守、および更新には、アプリケーションの数に応じてコストがかかります。</span><span class="sxs-lookup"><span data-stu-id="88114-270">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="88114-271">アプリケーションの数が少ない場合、カスタムアプリケーションを手動で管理することの複雑さは、コンテナーと orchestrators 使用したソリューションの実装コストを上回ることになります。</span><span class="sxs-lookup"><span data-stu-id="88114-271">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="88114-272">コンテナーと orchestrators 使用する必要があるのはどのような場合ですか。</span><span class="sxs-lookup"><span data-stu-id="88114-272">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="88114-273">12要素アプリの原則に従ってアプリケーションをビルドできない場合は、コンテナーと orchestrators 避けることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="88114-273">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="88114-274">このような場合は、VM ベースのホスティングプラットフォームや、場合によっては一部のハイブリッドシステムを検討してください。</span><span class="sxs-lookup"><span data-stu-id="88114-274">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="88114-275">この機能を使用すると、特定の機能をいつでも個別のコンテナーやサーバーレス機能に分解できます。</span><span class="sxs-lookup"><span data-stu-id="88114-275">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="88114-276">開発リソース</span><span class="sxs-lookup"><span data-stu-id="88114-276">Development resources</span></span>

<span data-ttu-id="88114-277">このセクションでは、次のアプリケーションでコンテナーとオーケストレーター使用を開始する際に役立つ、開発リソースの簡単な一覧を示します。</span><span class="sxs-lookup"><span data-stu-id="88114-277">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="88114-278">クラウドネイティブマイクロサービスアーキテクチャアプリを設計する方法に関するガイダンスについては、「 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="88114-278">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="88114-279">ローカル Kubernetes の開発</span><span class="sxs-lookup"><span data-stu-id="88114-279">Local Kubernetes Development</span></span>

<span data-ttu-id="88114-280">Kubernetes のデプロイは、運用環境での優れた価値を提供しますが、開発用コンピューターでローカルに実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-280">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="88114-281">個々のマイクロサービスを独立して作業することもありますが、運用環境にデプロイしたときに実行するのと同じように、ローカルでシステム全体を実行することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="88114-281">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="88114-282">Minikube と Docker Desktop に役立つツールがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="88114-282">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="88114-283">Visual Studio には、Docker 開発用のツールも用意されています。</span><span class="sxs-lookup"><span data-stu-id="88114-283">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="88114-284">Minikube</span><span class="sxs-lookup"><span data-stu-id="88114-284">Minikube</span></span>

<span data-ttu-id="88114-285">Minikube とは</span><span class="sxs-lookup"><span data-stu-id="88114-285">What is Minikube?</span></span> <span data-ttu-id="88114-286">Minikube プロジェクトでは、"Minikube は macOS、Linux、および Windows でローカルの Kubernetes クラスターを実装しています" と表示されます。</span><span class="sxs-lookup"><span data-stu-id="88114-286">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="88114-287">主な目的は、"ローカル Kubernetes アプリケーションの開発に最適なツールであり、Kubernetes のすべての機能をサポートすることです。" ということです。</span><span class="sxs-lookup"><span data-stu-id="88114-287">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="88114-288">Minikube のインストールは Docker とは分離されていますが、Minikube は Docker デスクトップでサポートされるのとは異なるハイパーバイザーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="88114-288">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="88114-289">現在、Minikube では次の Kubernetes 機能がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="88114-289">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="88114-290">DNS</span><span class="sxs-lookup"><span data-stu-id="88114-290">DNS</span></span>
- <span data-ttu-id="88114-291">NodePorts</span><span class="sxs-lookup"><span data-stu-id="88114-291">NodePorts</span></span>
- <span data-ttu-id="88114-292">ConfigMaps とシークレット</span><span class="sxs-lookup"><span data-stu-id="88114-292">ConfigMaps and secrets</span></span>
- <span data-ttu-id="88114-293">ダッシュボード</span><span class="sxs-lookup"><span data-stu-id="88114-293">Dashboards</span></span>
- <span data-ttu-id="88114-294">コンテナーランタイム: Docker、rkt、CRI、および格納されている</span><span class="sxs-lookup"><span data-stu-id="88114-294">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="88114-295">コンテナーネットワークインターフェイスを有効にする (CNI)</span><span class="sxs-lookup"><span data-stu-id="88114-295">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="88114-296">イングレス</span><span class="sxs-lookup"><span data-stu-id="88114-296">Ingress</span></span>

<span data-ttu-id="88114-297">Minikube をインストールしたら、 `minikube start` イメージをダウンロードしてローカルの Kubernetes クラスターを起動するコマンドを実行して、すぐに使用を開始できます。</span><span class="sxs-lookup"><span data-stu-id="88114-297">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="88114-298">クラスターを起動したら、標準の Kubernetes コマンドを使用して操作し `kubectl` ます。</span><span class="sxs-lookup"><span data-stu-id="88114-298">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="88114-299">Docker Desktop</span><span class="sxs-lookup"><span data-stu-id="88114-299">Docker Desktop</span></span>

<span data-ttu-id="88114-300">Windows の Docker デスクトップから直接 Kubernetes を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-300">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="88114-301">Windows コンテナーを使用している場合の唯一のオプションであり、Windows 以外のコンテナーにも適しています。</span><span class="sxs-lookup"><span data-stu-id="88114-301">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="88114-302">図3-4 は、Docker Desktop の実行時にローカル Kubernetes のサポートを有効にする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="88114-302">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop での Kubernetes の構成](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="88114-304">**図 3-4**.</span><span class="sxs-lookup"><span data-stu-id="88114-304">**Figure 3-4**.</span></span> <span data-ttu-id="88114-305">Docker Desktop で Kubernetes を構成しています。</span><span class="sxs-lookup"><span data-stu-id="88114-305">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="88114-306">Docker Desktop は、コンテナー化されたアプリをローカルで構成して実行するための最も一般的なツールです。</span><span class="sxs-lookup"><span data-stu-id="88114-306">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="88114-307">Docker Desktop を使用する場合は、実稼働環境にデプロイする Docker コンテナーイメージのまったく同じセットに対してローカルで開発できます。</span><span class="sxs-lookup"><span data-stu-id="88114-307">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="88114-308">Docker Desktop は、コンテナー化されたアプリをローカルで "ビルド、テスト、および出荷" するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="88114-308">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="88114-309">Linux と Windows の両方のコンテナーをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="88114-309">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="88114-310">Azure Container Registry や Docker Hub などのイメージレジストリにイメージをプッシュすると、AKS はそれらをプルして運用環境にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="88114-310">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="88114-311">Visual Studio Docker ツール</span><span class="sxs-lookup"><span data-stu-id="88114-311">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="88114-312">Visual Studio では、web ベースアプリケーションの Docker 開発をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="88114-312">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="88114-313">新しい ASP.NET Core アプリケーションを作成するときに、図3-5 に示すように、Docker サポートを使用して構成することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-313">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio による Docker サポートの有効化](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="88114-315">**図 3-5**.</span><span class="sxs-lookup"><span data-stu-id="88114-315">**Figure 3-5**.</span></span> <span data-ttu-id="88114-316">Visual Studio による Docker サポートの有効化</span><span class="sxs-lookup"><span data-stu-id="88114-316">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="88114-317">このオプションを選択すると、プロジェクトはというルートに作成され、 `Dockerfile` Docker コンテナーでアプリをビルドしてホストするために使用できます。</span><span class="sxs-lookup"><span data-stu-id="88114-317">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="88114-318">図 3-6 に Dockerfile の例を示します。</span><span class="sxs-lookup"><span data-stu-id="88114-318">An example Dockerfile is shown in Figure 3-6.git</span></span>

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="88114-319">**図 3-6**.</span><span class="sxs-lookup"><span data-stu-id="88114-319">**Figure 3-6**.</span></span> <span data-ttu-id="88114-320">Visual Studio によって生成された Dockerfile</span><span class="sxs-lookup"><span data-stu-id="88114-320">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="88114-321">アプリを実行するときの既定の動作は、Docker も使用するように構成されます。</span><span class="sxs-lookup"><span data-stu-id="88114-321">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="88114-322">図3-7 は、Docker サポートを追加して作成された新しい ASP.NET Core プロジェクトで使用できるさまざまな実行オプションを示しています。</span><span class="sxs-lookup"><span data-stu-id="88114-322">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker の実行オプション](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="88114-324">**図 3-7**.</span><span class="sxs-lookup"><span data-stu-id="88114-324">**Figure 3-7**.</span></span> <span data-ttu-id="88114-325">Visual Studio Docker の実行オプション</span><span class="sxs-lookup"><span data-stu-id="88114-325">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="88114-326">[Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/)には、ローカル開発に加えて、複数の開発者が Azure 内で独自の Kubernetes 構成を操作するための便利な方法が用意されています。</span><span class="sxs-lookup"><span data-stu-id="88114-326">In addition to local development, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="88114-327">図3-7 に示すように、Azure Dev Spaces でアプリケーションを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-327">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="88114-328">また、いつでも既存の ASP.NET Core アプリケーションに Docker サポートを追加できます。</span><span class="sxs-lookup"><span data-stu-id="88114-328">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="88114-329">図3-8 に示すように、Visual Studio ソリューションエクスプローラーからプロジェクト**Add**を右クリックし、  >  **Docker サポート**を追加します。</span><span class="sxs-lookup"><span data-stu-id="88114-329">From the Visual Studio Solution Explorer, right click on the project and **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio による Docker サポートの追加](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="88114-331">**図 3-8**.</span><span class="sxs-lookup"><span data-stu-id="88114-331">**Figure 3-8**.</span></span> <span data-ttu-id="88114-332">Visual Studio への Docker サポートの追加</span><span class="sxs-lookup"><span data-stu-id="88114-332">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="88114-333">また、図3-8 に示すように、コンテナーオーケストレーションのサポートを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-333">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="88114-334">既定では、orchestrator は Kubernetes とヘルムを使用します。</span><span class="sxs-lookup"><span data-stu-id="88114-334">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="88114-335">Orchestrator を選択する `azds.yaml` と、ファイルがプロジェクトのルートに追加され、 `charts` アプリケーションを構成して Kubernetes に配置するために使用されるヘルムグラフを含むフォルダーが追加されます。</span><span class="sxs-lookup"><span data-stu-id="88114-335">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="88114-336">図3-9 に、新しいプロジェクトで生成されるファイルを示します。</span><span class="sxs-lookup"><span data-stu-id="88114-336">Figure 3-9 shows the resulting files in a new project.</span></span>

<span data-ttu-id="88114-337">また、図3-8 に示すように、コンテナーオーケストレーションのサポートを追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="88114-337">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="88114-338">既定では、orchestrator は Kubernetes とヘルムを使用します。</span><span class="sxs-lookup"><span data-stu-id="88114-338">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="88114-339">Orchestrator を選択する `azds.yaml` と、ファイルがプロジェクトのルートに追加され、 `charts` アプリケーションを構成して Kubernetes に配置するために使用されるヘルムグラフを含むフォルダーが追加されます。</span><span class="sxs-lookup"><span data-stu-id="88114-339">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="88114-340">図3-9 に、新しいプロジェクトで生成されるファイルを示します。</span><span class="sxs-lookup"><span data-stu-id="88114-340">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio の Orchestrator サポートの追加](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="88114-342">**図 3-9**.</span><span class="sxs-lookup"><span data-stu-id="88114-342">**Figure 3-9**.</span></span> <span data-ttu-id="88114-343">Visual Studio へのオーケストレーションサポートの追加</span><span class="sxs-lookup"><span data-stu-id="88114-343">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="88114-344">Docker ツールの Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="88114-344">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="88114-345">Docker 開発をサポートする Visual Studio Code には、いくつかの拡張機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="88114-345">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="88114-346">Microsoft では、 [Docker for Visual Studio Code 拡張機能](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)を提供しています。</span><span class="sxs-lookup"><span data-stu-id="88114-346">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="88114-347">この拡張機能により、アプリケーションにコンテナーサポートを追加するプロセスが簡略化されます。</span><span class="sxs-lookup"><span data-stu-id="88114-347">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="88114-348">スキャフォールディングは、必要なファイルを作成し、Docker イメージをビルドして、コンテナー内でアプリをデバッグできるようにします。</span><span class="sxs-lookup"><span data-stu-id="88114-348">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="88114-349">拡張機能は、開始、停止、検査、削除などのコンテナーとイメージに対して簡単にアクションを実行できるようにする visual explorer を特徴としています。</span><span class="sxs-lookup"><span data-stu-id="88114-349">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="88114-350">また、この拡張機能では、複数の実行中のコンテナーを1つの単位として管理できる Docker Compose もサポートされています。</span><span class="sxs-lookup"><span data-stu-id="88114-350">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="88114-351">[前へ](scale-applications.md)
>[次へ](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="88114-351">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
