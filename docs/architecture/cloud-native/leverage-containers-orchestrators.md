---
title: コンテナーとコンテナー オーケストレーターの活用
description: Azure でのドッカー コンテナーと Kubernetes オーケストレーターの活用
ms.date: 06/30/2019
ms.openlocfilehash: 44b2fff8c9c88717d83e41a421b9817e2cc68135
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989039"
---
# <a name="leveraging-containers-and-orchestrators"></a>コンテナーとコンテナー オーケストレーターの活用

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

コンテナーとオーケストレーターは、モノリシック配置アプローチに共通する問題を解決するように設計されています。

## <a name="challenges-with-monolithic-deployments"></a>モノリシック展開の課題

従来、ほとんどのアプリケーションは単一のユニットとしてデプロイされてきました。 このようなアプリケーションは、モノリスと呼ばれます。 複数のモジュールまたはアセンブリで構成されているアプリケーションを単一ユニットとして配置するこの一般的なアプローチは、図 3-1 に示すようにモノリシック アーキテクチャと呼ばれます。

![モノリシックアーキテクチャ。](./media/monolithic-architecture.png)

**図 3-1**. モノリシックアーキテクチャ。

シンプルさの利点はありますが、モノリシック アーキテクチャは次のような課題に直面しています。

### <a name="deployments"></a>デプロイメント

モノリシック アプリケーションにデプロイするには、通常、1 つの小さなモジュールだけを交換する場合でも、アプリケーション全体を再起動する必要があります。 アプリケーションをホストするコンピューターの数によっては、デプロイメント中にダウンタイムが発生する可能性があります。

### <a name="hosting"></a>Hosting

モノリシック アプリケーションは、完全に単一のコンピューター インスタンスでホストされます。 この場合、分散アプリケーションのどのモジュールよりも高機能なハードウェアが必要になる場合があります。 また、アプリの一部がボトルネックになった場合は、スケール アウトするために、アプリケーション全体を追加のコンピューター ノードにデプロイする必要があります。

### <a name="environment"></a>環境

モノリシック アプリケーションは、通常、既存のホスティング環境 (オペレーティング システム、インストールされているフレームワークなど) にデプロイされます。 この環境は、アプリケーションが開発またはテストされた環境と一致しない場合があります。 アプリケーションの環境の不整合は、モノリシックな展開の問題の一般的な原因です。

### <a name="coupling"></a>結合

モノリシック アプリケーションは、アプリケーションのさまざまな部分間、およびアプリケーションとその環境の間で多大な結合を持つ可能性があります。 これにより、スケーラビリティを向上させるため、または代替実装でスワップするために、特定のサービスや懸念事項を後で考慮することが困難になる可能性があります。 このカップリングは、システムの変更に対する潜在的な影響を大幅に大きくし、大規模なアプリケーションでの広範なテストを必要とします。

### <a name="technology-choice"></a>技術の選択

モノリシック アプリケーションは、1 つの単位として構築および展開されます。 これは、シンプルさと均一性を提供しますが、イノベーションの障壁になる可能性があります。 システムの新しい機能やモジュールは、より最新のプラットフォームやフレームワークに適しているかもしれませんが、一貫性と開発と展開の容易さのために、アプリケーションの現在のアプローチを使用して構築される可能性があります。

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a>コンテナやオーケストレーターのメリットは何ですか?

Docker は、最も一般的なコンテナー管理およびイメージング プラットフォームであり、Linux および Windows 上のコンテナーをすぐに操作できます。 コンテナーは、どのシステムでも同じように実行される、別々の再現可能なアプリケーション環境を提供します。 これにより、クラウド ネイティブ アプリケーションでアプリケーションやアプリ コンポーネントを開発およびホストするのに最適です。 コンテナーは互いに分離されるため、同じホスト ハードウェア上の 2 つのコンテナーに異なるバージョンのソフトウェアをインストールし、依存関係が競合を引き起こすことなくオペレーティング システムをインストールすることもできます。

さらに、コンテナーは、ソース管理にチェックインできる単純なファイルによって定義されます。 フル サーバーとは異なり、更新プログラムの適用や追加サービスのインストールに手動作業を必要とする仮想マシンでも、コンテナー インフラストラクチャは簡単にバージョン管理できます。 したがって、コンテナーで実行するように構築されたアプリは、ビルド パイプラインの一部として自動化ツールを使用して開発、テスト、およびデプロイできます。

コンテナーは変更不可能です。 コンテナーの定義が完了すると、そのコンテナーを再作成でき、まったく同じ方法で実行されます。 この不変性は、コンポーネントベースの設計に適しています。 アプリケーションの一部が他の部分ほど頻繁に変更されない場合は、最も頻繁に変更される部分を展開できるだけで、アプリ全体を再デプロイする理由は何でしょうか。 アプリのさまざまな機能と横断的な懸念は、別々のユニットに分割することができます。 図 3-2 は、モノリシック アプリが特定の機能を委任することによってコンテナーとマイクロサービスを利用する方法を示しています。 アプリ自体の残りの機能もコンテナー化されています。

![バック エンドでマイクロサービスを使用するためにモノリシック アプリを分割します。](./media/breaking-up-monolith-with-backend-microservices.png)
**図 3-2**. バック エンドでマイクロサービスを使用するためにモノリシック アプリを分割します。

個別のコンテナーを使用して構築されたクラウドネイティブ アプリは、必要に応じてアプリケーションをできるだけまたは少なくデプロイする機能を利用できます。 個々のサービスは、各サービスに適したリソースを持つノードでホストできます。 各サービスが実行される環境は不変であり、開発、テスト、および実稼働環境で共有でき、簡単にバージョン管理できます。 アプリケーションの異なる領域間の結合は、モノリス内のコンパイル時の依存関係ではなく、サービス間の呼び出しまたはメッセージとして明示的に行われます。 また、アプリ全体の任意の部分は、アプリの残りの部分に変更を加えることなく、その機能や機能に最も適したテクノロジを選択できます。

## <a name="what-are-the-scaling-benefits"></a>スケーリングの利点は何ですか?

コンテナー上に構築されたサービスは、Kubernetes などのオーケストレーション ツールによって提供されるスケーリングの利点を活用できます。 設計によってコンテナは自分自身についてしか知りません。 一緒に動作する必要がある複数のコンテナーを作成し始めると、より高いレベルでそれらを整理する価値があります。 多数のコンテナーとその共有依存関係 (ネットワーク構成など) を整理することは、オーケストレーション ツールが 1 日を節約するために入ってくる場所です。 Kubernetes は、コンテナー化されたアプリケーションのデプロイ、スケーリング、および管理を自動化するために設計されたコンテナー オーケストレーション プラットフォームです。 コンテナのグループの上に抽象化レイヤーを作成し、*それらをポッド*に整理します。 ポッドは、*ノード*と呼ばれるワーカー マシンで実行されます。 組織化されたグループ全体を *、クラスタ*と呼びます。 図 3-3 は、Kubernetes クラスターの各種コンポーネントを示しています。

![Kubernetes クラスター コンポーネント。](./media/kubernetes-cluster-components.png)
**図 3-3**. Kubernetes クラスター コンポーネント。

Kubernetes は、需要を満たすためにクラスターをスケーリングするための組み込みサポートを備えています。 コンテナー化されたマイクロサービスと組み合わせることで、クラウドネイティブアプリケーションは、必要なときに必要な場所で追加のリソースを使用して、需要の急増に迅速かつ効率的に対応できます。

### <a name="declarative-versus-imperative"></a>宣言型と命令型

Kubernetes は、宣言型オブジェクトと強制オブジェクト構成の両方をサポートします。 命令的なアプローチでは、Kubernetesに道の各ステップを何をすべきかを伝えるさまざまなコマンドを実行することが含まれます。 このイメージを*実行*します。 このポッドを*削除*します。 このポート*を公開*します。 宣言型の方法では、何をするかではなく *、必要な操作*を記述した構成ファイル*を*使用し、Kubernetes は目的の終了状態を実現するために何をすべきかを示します。 強制コマンドを使用してクラスターを既に構成している場合は、 を使用`kubectl get svc SERVICENAME -o yaml > service.yaml`して宣言マニフェストをエクスポートできます。 これにより、次のようなマニフェスト ファイルが生成されます。

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

宣言構成を使用する場合は、構成ファイルが配置されているフォルダーに対してを使用`kubectl diff -f FOLDERNAME`して、コミットする前に行われる変更をプレビューできます。 変更を適用することを確認したら、 を実行`kubectl apply -f FOLDERNAME`します。 フォルダー`-R`階層を再帰的に処理する追加。

サービスに加えて、展開などの他の Kubernetes 機能に対して宣言型構成*を*使用できます。 宣言型の展開は、クラスター リソースを更新するために配置コントローラーによって使用されます。 デプロイは、新しい変更をロールアウトしたり、より多くの負荷をサポートするようにスケールアップしたり、以前のリビジョンにロールバックしたりするために使用されます。 クラスターが不安定な場合、宣言型の展開は、クラスターを希望の状態に自動的に戻すメカニズムを提供します。

宣言型構成を使用すると、インフラストラクチャをアプリケーション コードと共にチェックインおよびバージョン管理できるコードとして表すことができます。 これにより、ソース管理の変更に関連付けられたビルドとデプロイのパイプラインを使用して、変更制御が強化され、継続的な配置のサポートが向上します。

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a>コンテナーやオーケストレーターに最適なシナリオは何ですか。

次のシナリオは、コンテナーとオーケストレーターを使用するのに適しています。

### <a name="applications-requiring-high-uptime-and-scalability"></a>高い稼働時間と拡張性を必要とするアプリケーション

高い稼働時間とスケーラビリティの要件を持つ個々のアプリケーションは、マイクロサービス、コンテナー、オーケストレーターを使用するクラウド ネイティブ アーキテクチャの理想的な候補です。 これらのアプリケーションは、バージョン管理された環境を使用してコンテナ内で開発することができ、本番環境に行く前に広範囲にテストすることができ、ダウンタイムをゼロにして本番環境に展開できます。 Kubernetes クラスターを使用すると、このようなアプリは、オンデマンドで拡張し、ノードの障害から自動的に回復できます。

### <a name="large-numbers-of-applications"></a>多数のアプリケーション

多数のアプリケーションを展開し、その後も維持する必要がある組織は、コンテナーとオーケストレーターの恩恵を受けることができます。 コンテナ化環境と Kubernetes クラスターのセットアップに関する先行作業は、主に固定コストです。 個々のアプリケーションの展開、保守、および更新には、保守する必要があるアプリケーションの数によって異なるコストがかかります。 一定の数のアプリケーションを超えて、カスタム アプリケーションを手動で維持する複雑さは、コンテナーとオーケストレーターを使用してソリューションを実装するコストを超えています。

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a>コンテナーとオーケストレーターの使用を避ける必要がある場合

12 要素アプリの原則に従ってアプリケーションを作成したくない場合や、ビルドできない場合は、コンテナーやオーケストレーターを避けた方が良いでしょう。 このような場合は、VM ベースのホスティング プラットフォーム、または特定の機能を個別のコンテナーまたはサーバーレス機能に分割できるハイブリッド システムを使用して、次の手順を進めるのが最善の方法です。

## <a name="development-resources"></a>開発リソース

このセクションでは、次のアプリケーションでコンテナーとオーケストレーターを使用する際に役立つ開発リソースの簡単な一覧を示します。 クラウド ネイティブ マイクロサービス アーキテクチャ アプリを設計する方法に関するガイダンスをお探しの場合は、このマニュアルの付属の[「.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャ](https://aka.ms/microservicesebook)」を参照してください。

### <a name="local-kubernetes-development"></a>地元のクベルネテス開発

Kubernetes の導入は、運用環境で大きな価値を提供しますが、ローカルで実行することもできます。 多くの場合、個々のアプリやマイクロサービスを個別に操作できることは良いことですが、運用環境に展開する場合と同じように、システム全体をローカルで実行できることがあります。 これを達成するにはいくつかの方法があり、そのうちの2つはMinikubeとDockerデスクトップです。 また、ドッカー開発用のツールも提供されます。

### <a name="minikube"></a>Minikube

ミニクベとは何ですか? Minikubeプロジェクトは、「MinikubeはmacOS、Linux、およびWindows上でローカルKubernetesクラスタを実装しています」と述べています。 その主な目標は、「地元のKubernetesアプリケーション開発のための最良のツールであり、適合するすべてのKubernetes機能をサポートすることです。 Minikubeのインストールは、Dockerとは別ですが、Minikubeは、Dockerデスクトップがサポートするのとは異なるハイパーバイザーをサポートしています。 現在、Minikubeでは以下の Kubernetes 機能がサポートされています。

- DNS
- ノードポート
- 構成マップとシークレット
- ダッシュボード
- コンテナー ランタイム: ドッカー、rkt、CRI-O、およびコンテナー化
- コンテナネットワークインタフェース(CNI)の有効化
- イングレス

Minikubeをインストールした後、イメージをダウンロードしてローカル Kubernetes クラスターを起動する`minikube start`コマンドを実行することで、すぐに使用を開始できます。 クラスターが起動したら、標準の Kubernetes`kubectl`コマンドを使用してクラスターと対話します。

### <a name="docker-desktop"></a>Docker Desktop

また、WindowsのDockerデスクトップから直接Kubernetesを使用して作業することができます。 Windows コンテナーを使用している場合は、これが唯一のオプションであり、Windows 以外のコンテナーにも最適です。 標準の Docker デスクトップ構成アプリは、Docker デスクトップから実行されている Kubernetes を構成するために使用されます。

![Docker デスクトップでの Kubernetes の構成](./media/docker-desktop-kubernetes.png)

**図 3-4**. Docker デスクトップでの Kubernetes の構成。

Docker Desktop は、コンテナー化されたアプリをローカルで構成および実行するための最も一般的なツールです。 Docker Desktop を使用する場合、運用環境にデプロイする Docker コンテナー イメージのセットとまったく同じセットに対して、ローカルで開発できます。 Docker Desktop は、コンテナー化されたアプリをローカルに "ビルド、テスト、および出荷" するように設計されています。 イメージが Azure コンテナー レジストリや Docker Hub などのイメージ レジストリに出荷されると、Azure Kubernetes サービス (AKS) などのサービスは、運用環境でアプリケーションを管理します。

### <a name="visual-studio-docker-tooling"></a>ビジュアルスタジオドッカーツーリング

Visual Studio は、Web アプリケーションの Docker 開発をサポートしています。 新しい ASP.NET Core アプリケーションを作成する場合、プロジェクト作成プロセスの一環として Docker サポートを使用して構成するオプションが表示されます (図 3-5 を参照)。

![ドッカーサポートを有効にする](./media/visual-studio-enable-docker-support.png)

**図 3-5**. ドッカーサポートを有効にする

このオプションを選択すると、プロジェクトは、そのルートに`Dockerfile`作成され、Docker コンテナーでアプリをビルドおよびホストするために使用できます。 図 3-6 に Dockerfile の例を示します。

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

**図 3-6**. 生成されたドッカーファイル

アプリの実行時の既定の動作は、Docker を使用するように構成されています。 図 3-7 は、Docker サポートを追加して作成された新しいASP.NETコア プロジェクトから利用できるさまざまな実行オプションを示しています。

![ビジュアル スタジオ ドッカー実行オプション](./media/visual-studio-docker-run-options.png)

**図 3-7**. ビジュアル スタジオ ドッカー実行オプション

[Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/)は、ローカル開発に加えて、複数の開発者が Azure 内で独自の Kubernetes 構成を操作するための便利な方法を提供します。 図 3-7 に示すように、Azure Dev Spaces でアプリケーションを実行することもできます。

作成時に ASP.NET Core アプリケーションに Docker サポートを追加しない場合は、後でいつでも追加できます。 図 3-8 に示すように、Visual Studio ソリューション エクスプローラーでプロジェクトを右クリックし **、[Docker サポート**の**追加** > ] を選択します。

![ビジュアル スタジオ追加ドッカー サポート](./media/visual-studio-add-docker-support.png)

**図 3-8**. ビジュアル スタジオ追加ドッカー サポート

Docker サポートに加えて、図 3-8 に示すように、コンテナー オーケストレーション サポートを追加することもできます。 既定では、オーケストレーターは、Kubernetes と Helm を使用します。 オーケストレーターを選択すると、`azds.yaml`プロジェクトルートにファイルが追加され、アプリケーションを`charts`Kubernetes に構成およびデプロイするために使用される Helm チャートを含むフォルダーが追加されます。 図 3-9 は、新しいプロジェクトで作成されたファイルを示しています。

![ビジュアル スタジオ 追加オーケストレーターのサポート](./media/visual-studio-add-orchestrator-support.png)

**図 3-9**. ビジュアル スタジオ 追加オーケストレーターのサポート

## <a name="references"></a>References

- [Kubernetes とは](https://blog.newrelic.com/engineering/what-is-kubernetes/)
- [ミニクベでのKubernetesのインストール](https://kubernetes.io/docs/setup/learning-environment/minikube/)
- [ミニクベ対ドッカーデスクトップ](https://medium.com/containers-101/local-kubernetes-for-windows-minikube-vs-docker-desktop-25a1c6d3b766)
- [Visual Studio Tools for Docker](https://docs.microsoft.com/dotnet/standard/containerized-lifecycle-architecture/design-develop-containerized-apps/visual-studio-tools-for-docker)

>[!div class="step-by-step"]
>[前へ](scale-applications.md)
>[次へ](leverage-serverless-functions.md)
