---
title: サービス間通信
description: バックエンド クラウドネイティブ マイクロサービスが他のバックエンド マイクロサービスと通信する方法について説明します。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401761"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="ecb28-103">サービス間通信</span><span class="sxs-lookup"><span data-stu-id="ecb28-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="ecb28-104">フロントエンド クライアントから移行し、バックエンド マイクロサービスが相互に通信する方法に対処するようになりました。</span><span class="sxs-lookup"><span data-stu-id="ecb28-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="ecb28-105">クラウド ネイティブ アプリケーションを構築する場合は、バックエンド サービスが相互に通信する方法に注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="ecb28-106">理想的には、サービス間通信が少ないほど、より良い方法です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="ecb28-107">ただし、バックエンド サービスは、多くの場合、操作を完了するために互いに依存しているので、回避は常に可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="ecb28-108">クロスサービス通信を実装するには、いくつかの広く受け入れられているアプローチがあります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="ecb28-109">*コミュニケーションの相互作用のタイプ*は、多くの場合、最良のアプローチを決定します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="ecb28-110">次の相互作用の種類を検討してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="ecb28-111">*クエリ*– 呼び出し元のマイクロサービスが、"ねえ、特定の顧客 ID の購入者情報を与える" など、呼び出しマイクロサービスからの応答を必要とする場合。</span><span class="sxs-lookup"><span data-stu-id="ecb28-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="ecb28-112">*Command* – 呼び出し元のマイクロサービスがアクションを実行するために別のマイクロサービスを必要としているが、応答を必要としない場合は、「ねえ、この注文を出荷するだけです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="ecb28-113">*イベント*– パブリッシャと呼ばれるマイクロサービスが、状態が変更されたか、アクションが発生したイベントを発生させるとします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="ecb28-114">関心のあるサブスクライバーと呼ばれる他のマイクロサービスは、イベントに適切に対応できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="ecb28-115">パブリッシャーとサブスクライバーは、相互に認識していません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="ecb28-116">マイクロサービス システムは、通常、サービス間の対話を必要とする操作を実行するときに、これらの相互作用の種類の組み合わせを使用します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="ecb28-117">それぞれと実装方法を詳しく見ていきましょう。</span><span class="sxs-lookup"><span data-stu-id="ecb28-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="ecb28-118">クエリ</span><span class="sxs-lookup"><span data-stu-id="ecb28-118">Queries</span></span>

<span data-ttu-id="ecb28-119">多くの場合、あるマイクロサービスは別のマイクロサービスに*対してクエリ*を実行する必要があり、操作を完了するために即時の応答が必要になります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="ecb28-120">買い物かごのマイクロサービスは、商品情報と商品をバスケットに追加するための価格を必要とする場合があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="ecb28-121">クエリ操作を実装するための方法は多数あります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="ecb28-122">要求/応答メッセージング</span><span class="sxs-lookup"><span data-stu-id="ecb28-122">Request/Response Messaging</span></span>

<span data-ttu-id="ecb28-123">このシナリオを実装する 1 つのオプションは、呼び出し側のバックエンド マイクロサービスが、クエリを実行する必要があるマイクロサービスに直接 HTTP 要求を作成することです (図 4-8 参照)。</span><span class="sxs-lookup"><span data-stu-id="ecb28-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通信](./media/direct-http-communication.png)

<span data-ttu-id="ecb28-125">**図 4-8**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-125">**Figure 4-8**.</span></span> <span data-ttu-id="ecb28-126">直接 HTTP 通信</span><span class="sxs-lookup"><span data-stu-id="ecb28-126">Direct HTTP communication</span></span>

<span data-ttu-id="ecb28-127">マイクロサービス間の直接 HTTP 呼び出しは比較的簡単に実装できますが、この方法を最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="ecb28-128">開始するには、これらの呼び出しは常に*同期*的であり、結果が返されるか、要求がタイムアウトになるまで操作をブロックします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="ecb28-129">かつては自己完結型の独立したサービスで、独立して進化し、頻繁に展開することができ、今では互いに結びついています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="ecb28-130">マイクロサービス間の結合が増加すると、アーキテクチャ上の利点は減少します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="ecb28-131">一部のシステムでは、別のマイクロサービスに対して単一の直接 HTTP 呼び出しを行う頻度の低い要求を実行することが可能です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="ecb28-132">ただし、複数のマイクロサービスに対して直接 HTTP 呼び出しを呼び出す大量呼び出しは推奨されません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="ecb28-133">遅延が長くなり、システムのパフォーマンス、スケーラビリティ、および可用性に悪影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="ecb28-134">さらに悪いことに、一連の直接的な HTTP 通信が長いと、同期マイクロサービス呼び出しの深く複雑なチェーンが生じる可能性があります (図 4-9 を参照)。</span><span class="sxs-lookup"><span data-stu-id="ecb28-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP クエリのチェーン](./media/chaining-http-queries.png)

<span data-ttu-id="ecb28-136">**図 4-9**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-136">**Figure 4-9**.</span></span> <span data-ttu-id="ecb28-137">HTTP クエリのチェーン</span><span class="sxs-lookup"><span data-stu-id="ecb28-137">Chaining HTTP queries</span></span>

<span data-ttu-id="ecb28-138">前の図に示したデザインのリスクは、確かに想像できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="ecb28-139">ステップ\#3 が失敗した場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="ecb28-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="ecb28-140">または、\#ステップ8が失敗しますか?</span><span class="sxs-lookup"><span data-stu-id="ecb28-140">Or Step \#8 fails?</span></span> <span data-ttu-id="ecb28-141">どのように回復しますか?</span><span class="sxs-lookup"><span data-stu-id="ecb28-141">How do you recover?</span></span> <span data-ttu-id="ecb28-142">基になるサービス\#がビジー状態であるために手順 6 が遅い場合はどうでしょうか。</span><span class="sxs-lookup"><span data-stu-id="ecb28-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="ecb28-143">どのように続けますか?</span><span class="sxs-lookup"><span data-stu-id="ecb28-143">How do you continue?</span></span> <span data-ttu-id="ecb28-144">すべての操作が正しく機能する場合でも、この呼び出しが発生する待機時間 (各ステップの待機時間の合計) を考えてください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="ecb28-145">前の画像の結合度が大きい場合、サービスが最適にモデル化されていなかったことを示唆しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="ecb28-146">彼らのデザインを再検討するのはチームを後押しするだろう。</span><span class="sxs-lookup"><span data-stu-id="ecb28-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="ecb28-147">具体化されたビュー パターン</span><span class="sxs-lookup"><span data-stu-id="ecb28-147">Materialized View pattern</span></span>

<span data-ttu-id="ecb28-148">マイクロサービスカップリングを削除する一般的なオプションは、[マテリアライズビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="ecb28-149">このパターンでは、マイクロサービスは、他のサービスが所有するデータの独自のローカルで非正規化されたコピーを格納します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="ecb28-150">ショッピング バスケット マイクロサービスが製品カタログおよび価格のマイクロサービスを照会する代わりに、そのデータの独自のローカル コピーを保持します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="ecb28-151">このパターンは不要なカップリングを除去し、信頼性および応答時間を改善する。</span><span class="sxs-lookup"><span data-stu-id="ecb28-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="ecb28-152">操作全体が 1 つのプロセス内で実行されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="ecb28-153">第5章では、このパターンとその他のデータに関する問題について説明します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="ecb28-154">サービス アグリゲータ パターン</span><span class="sxs-lookup"><span data-stu-id="ecb28-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="ecb28-155">マイクロサービスとマイクロサービスの結合をなくすもう 1 つのオプションは、図 4-10 に紫色で示す[アグリゲータ マイクロサービス](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![アグリゲーターサービス](./media/aggregator-service.png)

<span data-ttu-id="ecb28-157">**図 4-10**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-157">**Figure 4-10**.</span></span> <span data-ttu-id="ecb28-158">アグリゲーターマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="ecb28-158">Aggregator microservice</span></span>

<span data-ttu-id="ecb28-159">このパターンは、複数のバックエンド マイクロサービスを呼び出す操作を分離し、そのロジックを特殊なマイクロサービスに集中させます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="ecb28-160">前の図の紫色のチェックアウト アグリゲータ マイクロサービスは、チェックアウト操作のワークフローを調整します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="ecb28-161">これには、シーケンス順で複数のバックエンド マイクロサービスへの呼び出しが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="ecb28-162">ワークフローのデータが集約され、呼び出し元に返されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="ecb28-163">直接 HTTP 呼び出しを実装する間も、アグリゲーター マイクロサービスはバックエンド マイクロサービス間の直接的な依存関係を減らします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="ecb28-164">要求/応答パターン</span><span class="sxs-lookup"><span data-stu-id="ecb28-164">Request/Reply Pattern</span></span>

<span data-ttu-id="ecb28-165">同期 HTTP メッセージを分離するもう 1 つの方法は、キューイング通信を使用する[要求応答パターン](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="ecb28-166">キューを使用した通信は常に一方向のチャネルであり、プロデューサがメッセージを送信し、コンシューマがそれを受信します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="ecb28-167">このパターンでは、図 4-11 に示すように、要求キューと応答キューの両方が実装されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![要求/応答パターン](./media/request-reply-pattern.png)

<span data-ttu-id="ecb28-169">**図 4-11**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-169">**Figure 4-11**.</span></span> <span data-ttu-id="ecb28-170">要求/応答パターン</span><span class="sxs-lookup"><span data-stu-id="ecb28-170">Request-reply pattern</span></span>

<span data-ttu-id="ecb28-171">ここでは、メッセージ プロデューサーは、一意の相関 ID を含むクエリ ベースのメッセージを作成し、要求キューに配置します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="ecb28-172">使用サービスは、メッセージをキューから取り出し、処理し、応答を同じ相関 ID を持つ応答キューに入れます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="ecb28-173">プロデューサ サービスは、メッセージをキューから取り出し、相関 ID と照合して処理を続行します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="ecb28-174">キューについては、次のセクションで詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="ecb28-175">コマンド</span><span class="sxs-lookup"><span data-stu-id="ecb28-175">Commands</span></span>

<span data-ttu-id="ecb28-176">もう 1 つの通信の種類は *、 コマンド*です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="ecb28-177">マイクロサービスでは、アクションを実行するために別のマイクロサービスが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="ecb28-178">注文マイクロサービスでは、承認された注文の出荷を作成するために出荷マイクロサービスが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="ecb28-179">図 4-12 では、プロデューサーと呼ばれる 1 つのマイクロサービスが、別のマイクロサービスである Consumer にメッセージを送信し、何かを実行するように命令します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![キューとのコマンド操作](./media/command-interaction-with-queue.png)

<span data-ttu-id="ecb28-181">**図 4-12**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-181">**Figure 4-12**.</span></span> <span data-ttu-id="ecb28-182">キューとのコマンド操作</span><span class="sxs-lookup"><span data-stu-id="ecb28-182">Command interaction with a queue</span></span>

<span data-ttu-id="ecb28-183">ほとんどの場合、プロデューサーは応答を必要とせず、メッセージを*起動して忘*れることができます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="ecb28-184">応答が必要な場合、コンシューマーは別のチャネルのプロデューサーに別のメッセージを送り返します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="ecb28-185">コマンド メッセージは、メッセージ キューと共に非同期的に送信するのが最適です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="ecb28-186">軽量のメッセージ ブローカーでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="ecb28-187">前の図では、キューが両方のサービスを分離および切り離す方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="ecb28-188">メッセージ キューは、プロデューサとコンシューマがメッセージを渡す仲介構造です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="ecb28-189">キューは、非同期のポイント ツー ポイント メッセージング パターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="ecb28-190">プロデューサーは、コマンドの送信先を知り、適切にルーティングします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="ecb28-191">キューは、チャネルから読み取るコンシューマー インスタンスの 1 つだけによってメッセージが処理されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="ecb28-192">このシナリオでは、プロデューサ またはコンシューマー サービスは、他のサービスに影響を与えずにスケール アウトできます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="ecb28-193">また、テクノロジはそれぞれの側面で異なる場合があるため[、Golang](https://golang.org)マイクロサービスを呼び出す Java マイクロサービスが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="ecb28-194">第1章では、*バッキングサービス*について話しました。</span><span class="sxs-lookup"><span data-stu-id="ecb28-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="ecb28-195">バッキング サービスは、クラウド ネイティブ システムが依存する補助的なリソースです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="ecb28-196">メッセージ キューは、サービスをバッキングしています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-196">Message queues are backing services.</span></span> <span data-ttu-id="ecb28-197">Azure クラウドでは、コマンド メッセージングを実装するためにクラウド ネイティブ システムが使用できる 2 種類のメッセージ キュー (Azure Storage キューと Azure Service Bus キュー) がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="ecb28-198">Azure Storage キュー</span><span class="sxs-lookup"><span data-stu-id="ecb28-198">Azure Storage Queues</span></span>

<span data-ttu-id="ecb28-199">Azure ストレージ キューは、Azure ストレージ アカウントによって、高速で手頃な価格で、バックアップされたシンプルなキューイング インフラストラクチャを提供します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="ecb28-200">[Azure Storage キューには、](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)信頼性の高い永続的なメッセージングを備えた REST ベースのキューイング メカニズムが備えられています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="ecb28-201">最小限の機能セットを提供しますが、安価で、数百万のメッセージを保存します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="ecb28-202">容量は最大500 TBです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="ecb28-203">1 つのメッセージのサイズは最大 64 KB です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="ecb28-204">HTTP または HTTPS を使用して、認証された呼び出しを介して世界中のどこからでもメッセージにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="ecb28-205">ストレージ キューは、トラフィックの急増に対処するために、多数の同時クライアントにスケール アウトできます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="ecb28-206">つまり、サービスには次の制限があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="ecb28-207">メッセージの順序は保証されません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="ecb28-208">メッセージは、自動的に削除されるまで 7 日間のみ保持できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="ecb28-209">状態管理、重複データ検出、またはトランザクションのサポートは利用できません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="ecb28-210">図 4-13 は、Azure ストレージ キューの階層を示しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![ストレージ キュー階層](./media/storage-queue-hierarchy.png)

<span data-ttu-id="ecb28-212">**図 4-13**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-212">**Figure 4-13**.</span></span> <span data-ttu-id="ecb28-213">ストレージ キュー階層</span><span class="sxs-lookup"><span data-stu-id="ecb28-213">Storage queue hierarchy</span></span>

<span data-ttu-id="ecb28-214">前の図では、ストレージ キューが基になる Azure ストレージ アカウントにメッセージを格納する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="ecb28-215">開発者向けに、Microsoft はストレージ キュー処理用にクライアントおよびサーバー側のライブラリを複数提供しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="ecb28-216">ほとんどの主要なプラットフォームは、.NET、Java、JavaScript、ルビー、Python、および囲碁を含むサポートされています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="ecb28-217">開発者は、これらのライブラリと直接通信しないでください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="ecb28-218">これを行うと、マイクロサービス コードが Azure Storage キュー サービスに緊密に結合されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="ecb28-219">API の実装の詳細を絶縁する方が良い方法です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="ecb28-220">一般的な操作を公開し、具象ライブラリをカプセル化する仲介レイヤー (中間 API) を導入します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="ecb28-221">この疎結合により、メインライン・サービス・コードを変更することなく、あるキューイング・サービスを別のキューイング・サービスとスワップアウトできます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="ecb28-222">Azure Storage キューは、クラウド ネイティブ アプリケーションにコマンド メッセージングを実装するための経済的なオプションです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="ecb28-223">キュー サイズが 80 GB を超える場合、または単純な機能セットが許容される場合は特に問題ありません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="ecb28-224">メッセージの保存に対してのみ支払う必要があります。固定時間料金はありません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="ecb28-225">Azure Service Bus キュー</span><span class="sxs-lookup"><span data-stu-id="ecb28-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="ecb28-226">より複雑なメッセージング要件については、Azure サービス バス のキューを検討してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="ecb28-227">堅牢なメッセージ インフラストラクチャの上に置き[、Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)は*仲介メッセージング モデルを*サポートしています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="ecb28-228">メッセージは、コンシューマが受信するまで、ブローカー (キュー) に確実に格納されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="ecb28-229">キューは、メッセージがキューに追加された順序を考慮して、先入れ先出し (FIFO) メッセージの配信を保証します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="ecb28-230">メッセージのサイズは、最大 256 KB まで、はるかに大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="ecb28-231">メッセージは、キューに無制限に保持されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="ecb28-232">Service Bus は HTTP ベースの呼び出しだけでなく[、AMPQ プロトコル](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)の完全なサポートも提供します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="ecb28-233">AMPQ は、バイナリ プロトコルと高い信頼性をサポートするベンダー間のオープンスタンダードです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="ecb28-234">Service Bus には、[トランザクション サポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)や[重複データ検出機能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)など、豊富な機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="ecb28-235">キューは、メッセージごとに 「1 回の配信」を保証します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="ecb28-236">既に送信されたメッセージは自動的に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="ecb28-237">プロデューサが疑わしい場合は、同じメッセージを再送信することができ、Service Bus は 1 つのコピーのみが処理されることを保証します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="ecb28-238">重複データ検出により、追加のインフラストラクチャ配管を構築する必要が少ないです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="ecb28-239">さらに 2 つのエンタープライズ機能は、パーティション分割とセッションです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="ecb28-240">従来の Service Bus キューは、単一のメッセージ ブローカーによって処理され、単一のメッセージ ストアに格納されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="ecb28-241">ただし[、Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)は、複数のメッセージ ブローカーとメッセージ ストアにキューを分散します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="ecb28-242">単一のメッセージ ブローカーまたはメッセージング ストアのパフォーマンスによって、全体的なスループットが制限されなくなりました。</span><span class="sxs-lookup"><span data-stu-id="ecb28-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="ecb28-243">メッセージング ストアの一時的な停止では、パーティション分割されたキューが使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="ecb28-244">[サービス バス セッションは](https://codingcanvas.com/azure-service-bus-sessions/)、グループ関連のメッセージを提供します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="ecb28-245">メッセージを一緒に処理し、最後に操作を完了するワークフロー シナリオを想像してみてください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="ecb28-246">利点を活かすには、キューに対してセッションを明示的に有効にし、関連する各メッセージに同じセッション ID を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="ecb28-247">ただし、サービス バスキューのサイズは 80 GB に制限されており、ストア キューから入手できるサイズよりもはるかに小さい点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="ecb28-248">さらに、Service Bus キューには、運用ごとに基本コストと料金が発生します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="ecb28-249">図 4-14 は、Service Bus キューの高レベル アーキテクチャの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus キュー](./media/service-bus-queue.png)

<span data-ttu-id="ecb28-251">**図 4-14**. </span><span class="sxs-lookup"><span data-stu-id="ecb28-251">**Figure 4-14**.</span></span> <span data-ttu-id="ecb28-252">Service Bus キュー</span><span class="sxs-lookup"><span data-stu-id="ecb28-252">Service Bus queue</span></span>

<span data-ttu-id="ecb28-253">前の図では、ポイントツーポイントの関係に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="ecb28-254">同じプロバイダーの 2 つのインスタンスが、メッセージを 1 つの Service Bus キューにキューイングしています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="ecb28-255">各メッセージは、右側の 3 つのコンシューマー インスタンスのうち 1 つだけによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="ecb28-256">次に、異なるコンシューマが同じメッセージに関心を持つメッセージングを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="ecb28-257">events</span><span class="sxs-lookup"><span data-stu-id="ecb28-257">Events</span></span>

<span data-ttu-id="ecb28-258">メッセージ キューイングは、プロデューサがコンシューマにメッセージを非同期的に送信できる通信を実装する効果的な方法です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="ecb28-259">しかし、*多くの異なる消費者*が同じメッセージに興味を持っている場合はどうなりますか?</span><span class="sxs-lookup"><span data-stu-id="ecb28-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="ecb28-260">各コンシューマーの専用メッセージ キューは、適切にスケーリングされず、管理が困難になります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="ecb28-261">このシナリオに対処するために、3 番目の種類のメッセージ対話に移*ります*。</span><span class="sxs-lookup"><span data-stu-id="ecb28-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="ecb28-262">あるマイクロサービスは、アクションが発生したことをアナウンスします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="ecb28-263">他のマイクロサービスは、関心がある場合は、アクションまたはイベントに反応します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="ecb28-264">イベント処理は 2 段階のプロセスです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-264">Eventing is a two-step process.</span></span> <span data-ttu-id="ecb28-265">特定の状態変更に関して、マイクロサービスはイベントをメッセージ ブローカーに発行し、他の関心のあるマイクロサービスで利用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="ecb28-266">関心のあるマイクロサービスは、メッセージ ブローカーでイベントをサブスクライブすることによって通知されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="ecb28-267">[パブリッシュ/サブスクライブ](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)パターンを使用して[、イベントベースの通信](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)を実装します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="ecb28-268">図 4-15 は、他の 2 つのマイクロサービスがサブスクライブしているイベントを公開するショッピング バスケット マイクロサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![イベント駆動型メッセージング](./media/event-driven-messaging.png)

<span data-ttu-id="ecb28-270">**図 4-15**. </span><span class="sxs-lookup"><span data-stu-id="ecb28-270">**Figure 4-15**.</span></span> <span data-ttu-id="ecb28-271">イベント駆動型メッセージング</span><span class="sxs-lookup"><span data-stu-id="ecb28-271">Event-Driven messaging</span></span>

<span data-ttu-id="ecb28-272">通信チャネルの中央に位置する*イベント バス*コンポーネントに注目してください。</span><span class="sxs-lookup"><span data-stu-id="ecb28-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="ecb28-273">これは、メッセージ ブローカーをカプセル化し、基になるアプリケーションから切り離すカスタム クラスです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="ecb28-274">注文と在庫のマイクロサービスは、互いの知識もショッピング バスケット マイクロサービスも知らずに、独立してイベントを操作します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="ecb28-275">登録されたイベントがイベント バスに発行されると、イベント バスに対して動作します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="ecb28-276">イベント処理では、キューイング技術から*トピック*に移行します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="ecb28-277">[トピック](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)はキューに似ていますが、一対多のメッセージング パターンをサポートします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="ecb28-278">1 つのマイクロサービスがメッセージをパブリッシュします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-278">One microservice publishes a message.</span></span> <span data-ttu-id="ecb28-279">複数のサブスクライブ マイクロサービスは、そのメッセージを受信して処理することを選択できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="ecb28-280">図 4-16 にトピック アーキテクチャを示します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-280">Figure 4-16 shows a topic architecture.</span></span>

![トピックアーキテクチャ](./media/topic-architecture.png)

<span data-ttu-id="ecb28-282">**図 4-16**. </span><span class="sxs-lookup"><span data-stu-id="ecb28-282">**Figure 4-16**.</span></span> <span data-ttu-id="ecb28-283">トピックアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="ecb28-283">Topic architecture</span></span>

<span data-ttu-id="ecb28-284">前の図では、パブリッシャーはトピックにメッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="ecb28-285">最後に、サブスクライバーはサブスクリプションからメッセージを受信します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="ecb28-286">中央では、トピックは、濃い青色のボックスに表示される一連の*ルール*に基づいて、サブスクリプションにメッセージを転送します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="ecb28-287">ルールは、特定のメッセージをサブスクリプションに転送するフィルターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="ecb28-288">ここでは、サブスクリプション 1 とサブスクリプション\#\#3 に "CreateOrder" イベントが送信されますが\#、サブスクリプション 2 には送信されません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="ecb28-289">"OrderCompleted" イベントは、サブスクリプション 2\#とサブスクリプション\#3 に送信されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="ecb28-290">Azure クラウドでは、2 つの異なるトピック サービスがサポートされています: Azure サービス バス トピックと Azure イベント グリッド。</span><span class="sxs-lookup"><span data-stu-id="ecb28-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="ecb28-291">Azure Service Bus トピック</span><span class="sxs-lookup"><span data-stu-id="ecb28-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="ecb28-292">Azure サービス バス キューの同じ堅牢な仲介メッセージ モデルの上に座って[Azure サービス バスのトピックです](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="ecb28-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="ecb28-293">トピックは、複数の独立したパブリッシャーからのメッセージを受信し、最大 2,000 人のサブスクライバーにメッセージを送信できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="ecb28-294">サブスクリプションは、システムを停止したりトピックを再作成したりすることなく、実行時に動的に追加または削除できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="ecb28-295">Azure Service Bus キューの多くの高度な機能は、[重複データ検出](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)や[トランザクション サポート](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)などのトピックでも利用できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="ecb28-296">既定では、Service Bus のトピックは単一のメッセージ ブローカーによって処理され、単一のメッセージ ストアに格納されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="ecb28-297">ただし[、Service Bus パーティション分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)では、トピックを多数のメッセージ ブローカーとメッセージ ストアに分散してスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="ecb28-298">[スケジュールされたメッセージ配信](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)は、メッセージに特定の時間を処理するタグを付けます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="ecb28-299">その時間より前にメッセージがトピックに表示されません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="ecb28-300">[メッセージ遅延](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)により、後でメッセージの取得を延期できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="ecb28-301">どちらの操作も、特定の順序で処理されるワークフロー処理シナリオで一般的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="ecb28-302">受信したメッセージの処理は、前の作業が完了するまで延期できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="ecb28-303">Service Bus のトピックは、クラウド ネイティブ システムでパブリッシュ/サブスクライブ通信を可能にする、堅牢で実証済みのテクノロジです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="ecb28-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="ecb28-304">Azure Event Grid</span></span>

<span data-ttu-id="ecb28-305">Azure Service Bus は、エンタープライズ機能の完全なセットを備えた戦闘テスト済みのメッセージング ブローカーですが[、Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview)はブロックの新しい子供です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="ecb28-306">一見すると、Event Grid は、トピックベースのメッセージング システムのように見えるかもしれません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="ecb28-307">しかし、それは多くの点で異なります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-307">However, it's different in many ways.</span></span> <span data-ttu-id="ecb28-308">イベント駆動型のワークロードに焦点を当て、リアルタイムのイベント処理、Azure の深い統合、オープン プラットフォーム (すべてサーバーレス インフラストラクチャ) を実現します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="ecb28-309">現代的なクラウドネイティブアプリケーションとサーバーレスアプリケーション向けに設計されています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="ecb28-310">イベント グリッドは、イベント*バックプレーン*(パイプ) の集中型として、Azure リソース内および独自のサービスからのイベントに対応します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="ecb28-311">イベント通知はイベント グリッド トピックに発行され、各イベントはサブスクリプションにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="ecb28-312">サブスクライバーはサブスクリプションにマップされ、イベントを消費します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="ecb28-313">Service Bus と同様に、Event Grid は、サブスクリプションが受信するイベントのルールを設定する*フィルター処理されたサブスクライバー モデル*をサポートします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="ecb28-314">Event Grid は、Azure Service Bus が生成できるものよりもはるかに多く、1 秒あたり 1,000 万イベントを保証することで高速スループットを実現します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="ecb28-315">Event Grid の優れたスポットは、Azure インフラストラクチャのファブリックへの深い統合です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="ecb28-316">Cosmos DB などの Azure リソースは、カスタム コードを必要とせずに、関連する他の Azure リソースに直接組み込みイベントを発行できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="ecb28-317">Event Grid では、Azure サブスクリプション、リソース グループ、またはサービスからイベントを発行できるため、開発者はクラウド リソースのライフサイクルを細かく制御できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="ecb28-318">ただし、イベント グリッドは Azure に限定されません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="ecb28-319">アプリケーションまたはサードパーティサービスから公開されたカスタム HTTP イベントを使用して、外部のサブスクライバーにイベントをルーティングできるオープンプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="ecb28-320">Azure リソースからネイティブ イベントを発行してサブスクライブする場合、コーディングは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="ecb28-321">簡単な構成では、トピックとサブスクリプションの組み込みの組み込み配管を使用して、Azure リソース間のイベントを統合できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="ecb28-322">図 4-17 に、イベント グリッドの解剖学を示します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![イベントグリッドの解剖学](./media/event-grid-anatomy.png)

<span data-ttu-id="ecb28-324">**図 4-17**. </span><span class="sxs-lookup"><span data-stu-id="ecb28-324">**Figure 4-17**.</span></span> <span data-ttu-id="ecb28-325">イベントグリッドの解剖学</span><span class="sxs-lookup"><span data-stu-id="ecb28-325">Event Grid anatomy</span></span>

<span data-ttu-id="ecb28-326">EventGrid とサービス バスの主な違いは、基になる*メッセージ交換パターン*です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="ecb28-327">Service Bus は、下位のサブスクライバがトピック サブスクリプションをアクティブにポーリングして新しいメッセージを受け取る、古いスタイルの*プル モデル*を実装します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="ecb28-328">逆に、このアプローチは、サブスクライバーがメッセージを処理するペースを完全に制御できるようにします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="ecb28-329">特定の時点で処理するメッセージの数とタイミングを制御します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="ecb28-330">未読メッセージは、処理されるまでサブスクリプションに残ります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="ecb28-331">重大な欠点は、イベントが生成されてから、そのメッセージを処理のためにサブスクライバーにプルするポーリング操作との間の待機時間です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="ecb28-332">また、次のイベントの一定のポーリングのオーバーヘッドは、リソースとお金を消費します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="ecb28-333">しかし、イベントグリッドは異なります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-333">EventGrid, however, is different.</span></span> <span data-ttu-id="ecb28-334">イベントが受信されると EventHandlers に送信され、ほぼリアルタイムのイベント配信を提供する*プッシュ モデル*を実装します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="ecb28-335">また、ポーリングのようにイベントを消費する必要がある場合にのみサービスがトリガーされるため、コストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="ecb28-336">つまり、イベント ハンドラーは、着信負荷を処理し、自分自身が圧倒されないように、調整メカニズムを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="ecb28-337">Azure 関数やロジック アプリなど、これらのイベントを使用する多くの Azure サービスは、増加した負荷を処理するための自動自動スケール機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="ecb28-338">Event Grid は、サーバーレスクラウドサービスを完全に管理しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="ecb28-339">トラフィックに基づいて動的にスケーリングされ、購入済みの容量ではなく、実際の使用量に対してのみ課金されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="ecb28-340">毎月の最初の 100,000 回の操作は無料で、イベント入力 (受信イベント通知)、サブスクリプションの配信試行、管理呼び出し、件名によるフィルタリングとして定義される操作です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="ecb28-341">EventGrid は、99.99% の可用性を備えたイベントの配信を 24 時間以内に保証し、配信に失敗した場合に組み込みの再試行機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="ecb28-342">配信不能メッセージは、解決のために "配信不能" キューに移動できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="ecb28-343">Azure Service Bus とは異なり、Event Grid は高速なパフォーマンスを実現するように調整されており、順序付けられたメッセージング、トランザクション、セッションなどの機能はサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="ecb28-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="ecb28-344">Azure クラウドでのメッセージのストリーミング</span><span class="sxs-lookup"><span data-stu-id="ecb28-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="ecb28-345">Azure Service Bus および Event Grid は、新しいドキュメントが Cosmos DB に挿入されたような 1 つの個別のイベントを公開するアプリケーションをサポートします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="ecb28-346">しかし、クラウドネイティブシステムが*関連イベントのストリーム*を処理する必要がある場合はどうでしょうか?</span><span class="sxs-lookup"><span data-stu-id="ecb28-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="ecb28-347">[イベント ストリーム](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)はより複雑です。</span><span class="sxs-lookup"><span data-stu-id="ecb28-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="ecb28-348">通常、それらは時間順で相互に関連しており、グループとして処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="ecb28-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/)は、イベントを収集、変換、および格納するデータ ストリーミング プラットフォームおよびイベント インジェスト サービスです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="ecb28-350">テレメトリ コンテキストから生成された継続的なイベント通知など、ストリーミング データをキャプチャするように微調整されています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="ecb28-351">このサービスは拡張性が高く、[毎秒数百万のイベントを](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)保存して処理できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="ecb28-352">図 4-18 に示すように、多くの場合、このガイドは、イベント パイプラインのフロント ドアであり、取り込みストリームとイベント消費の分離を行います。</span><span class="sxs-lookup"><span data-stu-id="ecb28-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure Event Hub](./media/azure-event-hub.png)

<span data-ttu-id="ecb28-354">**図 4-18**.</span><span class="sxs-lookup"><span data-stu-id="ecb28-354">**Figure 4-18**.</span></span> <span data-ttu-id="ecb28-355">Azure Event Hub</span><span class="sxs-lookup"><span data-stu-id="ecb28-355">Azure Event Hub</span></span>

<span data-ttu-id="ecb28-356">Event Hub は、低待機時間と構成可能な時間の保持をサポートします。</span><span class="sxs-lookup"><span data-stu-id="ecb28-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="ecb28-357">Event Hubs は、キューやトピックとは異なり、コンシューマーが読み取った後もイベント データを保持します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="ecb28-358">この機能により、内部と外部の両方の他のデータ分析サービスが、さらに分析するためにデータを再生できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="ecb28-359">イベント ハブに格納されたイベントは、保持期間が満了した時点でのみ削除されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="ecb28-360">イベント ハブは、HTTPS や AMQP などの一般的なイベント発行プロトコルをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="ecb28-361">また、カフカ 1.0 もサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="ecb28-362">[既存の Kafka アプリケーションは、Kafka](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)プロトコルを使用してイベント ハブと通信でき、大規模な Kafka クラスタを管理する代わりに使用できます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="ecb28-363">多くのオープンソースのクラウドネイティブシステムは、Kafkaを採用しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="ecb28-364">Event Hubs は、各コンシューマーがメッセージ ストリームの特定のサブセット (パーティション) のみを読み取る[、パーティション化されたコンシューマー モデル](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)を通じてメッセージ ストリーミングを実装します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="ecb28-365">このパターンでは、イベント処理の横の倍率を大きくすることができ、キューおよびトピックで使用できないその他のストリームに重点を置いた機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="ecb28-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="ecb28-366">パーティションは、イベント ハブで保持される順序付けされた一連のイベントです。</span><span class="sxs-lookup"><span data-stu-id="ecb28-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="ecb28-367">新しいイベントが到着すると、このシーケンスの末尾に追加されます。</span><span class="sxs-lookup"><span data-stu-id="ecb28-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="ecb28-368">図 4-19 は、イベント ハブでのパーティショニングを示しています。</span><span class="sxs-lookup"><span data-stu-id="ecb28-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![イベント ハブのパーティション分割](./media/event-hub-partitioning.png)

<span data-ttu-id="ecb28-370">**図 4-19**</span><span class="sxs-lookup"><span data-stu-id="ecb28-370">**Figure 4-19**.</span></span> <span data-ttu-id="ecb28-371">イベント ハブのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="ecb28-371">Event Hub partitioning</span></span>

<span data-ttu-id="ecb28-372">各コンシューマー グループは、同じリソースから読み取るのではなく、メッセージ ストリームのサブセット (パーティション) を通して読み取ります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="ecb28-373">大量のイベントをストリーミングする必要があるクラウド ネイティブ アプリケーションの場合、Azure Event Hub は堅牢で手頃な価格のソリューションになります。</span><span class="sxs-lookup"><span data-stu-id="ecb28-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ecb28-374">[前次](front-end-communication.md)
>[Next](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="ecb28-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
