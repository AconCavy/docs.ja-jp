---
title: アプリケーションの回復性パターン
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |アプリケーションの回復性パターン
ms.date: 06/30/2019
ms.openlocfilehash: 13811efaa88e0bd2824add1c8712b78b18d46375
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841889"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="7b275-103">アプリケーションの回復性パターン</span><span class="sxs-lookup"><span data-stu-id="7b275-103">Application resiliency patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="7b275-104">最初の防御ラインは、ソフトウェア対応アプリケーションの回復性です。</span><span class="sxs-lookup"><span data-stu-id="7b275-104">The first line of defense is software-enabled application resiliency.</span></span>

<span data-ttu-id="7b275-105">独自の回復性フレームワークの作成にかなりの時間を費やすことができますが、このような製品は既に存在しています。</span><span class="sxs-lookup"><span data-stu-id="7b275-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="7b275-106">たとえば、 [polly](http://www.thepollyproject.org/) 、開発者が fluent とスレッドセーフの方法で回復性ポリシーを表すことができる、包括的な .net 復元性と一時的な障害処理ライブラリです。</span><span class="sxs-lookup"><span data-stu-id="7b275-106">For example, [Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="7b275-107">コアは、完全な .NET Framework または .NET Core でビルドされたアプリケーションを対象としています。</span><span class="sxs-lookup"><span data-stu-id="7b275-107">Polly targets applications built with either the full .NET Framework or .NET Core.</span></span> <span data-ttu-id="7b275-108">図6-2 に、ポリシーによって提供される回復性ポリシー (つまり、機能) を示します。</span><span class="sxs-lookup"><span data-stu-id="7b275-108">Figure 6-2 shows the resiliency policies (that is, functionality) available from the Polly Library.</span></span> <span data-ttu-id="7b275-109">これらのポリシーは、個別に適用することも、組み合わせて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="7b275-109">These policies can be applied individually or combined together.</span></span>

![Polly](./media/polly-resiliency-framework.png)

<span data-ttu-id="7b275-111">**図 6-2**。</span><span class="sxs-lookup"><span data-stu-id="7b275-111">**Figure 6-2**.</span></span> <span data-ttu-id="7b275-112">正常性の回復性フレームワークの機能</span><span class="sxs-lookup"><span data-stu-id="7b275-112">Polly resiliency framework features</span></span>

<span data-ttu-id="7b275-113">前の図では、外部クライアントまたは別のバックエンドサービスからの要求メッセージに対して、回復性ポリシーが適用されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7b275-113">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or another back-end service.</span></span> <span data-ttu-id="7b275-114">目標は、一時的に使用できなくなる可能性があるサービスの要求を補正することです。</span><span class="sxs-lookup"><span data-stu-id="7b275-114">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="7b275-115">これらの短い中断は通常、図6-3 に示す HTTP ステータスコードを使用しています。</span><span class="sxs-lookup"><span data-stu-id="7b275-115">These short interruptions typically manifest themselves with the HTTP status codes shown in Figure 6-3.</span></span>

![再試行する HTTP 状態コード](./media/http-status-codes.png)

<span data-ttu-id="7b275-117">**図 6-3**。</span><span class="sxs-lookup"><span data-stu-id="7b275-117">**Figure 6-3**.</span></span> <span data-ttu-id="7b275-118">再試行する HTTP 状態コード</span><span class="sxs-lookup"><span data-stu-id="7b275-118">HTTP status codes to retry</span></span>

<span data-ttu-id="7b275-119">質問: HTTP 状態コード 403-許可されていないことを再試行しますか?</span><span class="sxs-lookup"><span data-stu-id="7b275-119">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="7b275-120">No:</span><span class="sxs-lookup"><span data-stu-id="7b275-120">No.</span></span> <span data-ttu-id="7b275-121">ここでは、システムは正常に機能していますが、要求された操作を実行する権限がないことを呼び出し元に通知しています。</span><span class="sxs-lookup"><span data-stu-id="7b275-121">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="7b275-122">障害によって発生した操作のみを再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7b275-122">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="7b275-123">第1章で推奨されているように、クラウドネイティブアプリケーションを構築する Microsoft 開発者は .NET Core をターゲットにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="7b275-123">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target .NET Core.</span></span> <span data-ttu-id="7b275-124">バージョン2.1 では、URL ベースのリソースと対話するための HTTP クライアントインスタンスを作成するための[HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore)ライブラリが導入されました。</span><span class="sxs-lookup"><span data-stu-id="7b275-124">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="7b275-125">ファクトリクラスは、元の HTTPClient クラスを置き換えることで、多くの強化された機能をサポートしています。その1つは、厳密な回復性ライブラリとの[緊密な統合](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md)です。</span><span class="sxs-lookup"><span data-stu-id="7b275-125">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="7b275-126">これを使用すると、アプリケーションのスタートアップクラスで復元ポリシーを簡単に定義して、部分的なエラーと接続の問題を処理することができます。</span><span class="sxs-lookup"><span data-stu-id="7b275-126">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="7b275-127">次に、再試行とサーキットブレーカーパターンについて説明します。</span><span class="sxs-lookup"><span data-stu-id="7b275-127">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="7b275-128">再試行パターン</span><span class="sxs-lookup"><span data-stu-id="7b275-128">Retry pattern</span></span>

<span data-ttu-id="7b275-129">分散型クラウドネイティブ環境では、一時的な (有効期間が短い) エラーによって、サービスとクラウドリソースへの呼び出しが失敗することがあります。これは、通常、短時間の経過後に自動的に修正されます。</span><span class="sxs-lookup"><span data-stu-id="7b275-129">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="7b275-130">再試行戦略を実装すると、クラウドネイティブサービスがこれらのシナリオを処理するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="7b275-130">Implementing a retry strategy helps a cloud-native service handle these scenarios.</span></span>

<span data-ttu-id="7b275-131">[再試行パターン](https://docs.microsoft.com/azure/architecture/patterns/retry)を使用すると、サービスは失敗した要求操作を (構成可能な) 回数指数関数的に増加する待機時間で再試行できます。</span><span class="sxs-lookup"><span data-stu-id="7b275-131">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="7b275-132">図6-4 は、アクションの再試行を示しています。</span><span class="sxs-lookup"><span data-stu-id="7b275-132">Figure 6-4 shows a retry in action.</span></span>

![再試行パターンのアクション](./media/retry-pattern.png)

<span data-ttu-id="7b275-134">**図 6-4**。</span><span class="sxs-lookup"><span data-stu-id="7b275-134">**Figure 6-4**.</span></span> <span data-ttu-id="7b275-135">再試行パターンのアクション</span><span class="sxs-lookup"><span data-stu-id="7b275-135">Retry pattern in action</span></span>

<span data-ttu-id="7b275-136">前の図では、要求操作に対して再試行パターンが実装されています。</span><span class="sxs-lookup"><span data-stu-id="7b275-136">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="7b275-137">2秒間に最大で4回の再試行を許可するように構成されています。これは、後続の試行ごとに指数関数的に倍倍になります。</span><span class="sxs-lookup"><span data-stu-id="7b275-137">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="7b275-138">最初の呼び出しは失敗し、HTTP 状態コード500が返されます。</span><span class="sxs-lookup"><span data-stu-id="7b275-138">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="7b275-139">アプリケーションは2秒間待機し、呼び出しを再試行します。</span><span class="sxs-lookup"><span data-stu-id="7b275-139">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="7b275-140">2番目の呼び出しも失敗し、HTTP 状態コード500が返されます。</span><span class="sxs-lookup"><span data-stu-id="7b275-140">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="7b275-141">これで、アプリケーションは、バックオフ間隔を4秒に2倍にし、呼び出しを再試行します。</span><span class="sxs-lookup"><span data-stu-id="7b275-141">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="7b275-142">最後に、3番目の呼び出しが成功します。</span><span class="sxs-lookup"><span data-stu-id="7b275-142">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="7b275-143">このシナリオでは、再試行操作で最大4回の再試行が試行され、呼び出しが失敗する前にバックオフ期間が2倍になりました。</span><span class="sxs-lookup"><span data-stu-id="7b275-143">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>

<span data-ttu-id="7b275-144">サービス時間が自己修正されるように、呼び出しを再試行する前にバックオフ期間を長くすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="7b275-144">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="7b275-145">最適な修正時間を実現するには、指数関数的に増加するバックオフを実装することをお勧めします (再試行ごとに期間を2倍にします)。</span><span class="sxs-lookup"><span data-stu-id="7b275-145">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="7b275-146">サーキットブレーカーパターン</span><span class="sxs-lookup"><span data-stu-id="7b275-146">Circuit breaker pattern</span></span>

<span data-ttu-id="7b275-147">再試行パターンを使用すると、部分的な障害で要求を減らすことができますが、予期しないイベントが原因でエラーが発生する可能性があります。これは、解決に長時間かかることがあります。</span><span class="sxs-lookup"><span data-stu-id="7b275-147">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="7b275-148">このような障害の重大度は、部分的な接続の損失からサービスの完全な不具合まで多岐にわたります。</span><span class="sxs-lookup"><span data-stu-id="7b275-148">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="7b275-149">このような状況では、アプリケーションが成功する可能性の低い操作を継続的に再試行することは無意味です。</span><span class="sxs-lookup"><span data-stu-id="7b275-149">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="7b275-150">問題を悪化させるために、応答しないサービスに対して連続した再試行操作を実行することで、セルフサービスのサービス拒否シナリオに移行することができます。このシナリオでは、メモリ、スレッド、データベースなどの継続的な呼び出しによってサービスが大量に消費されます。接続により、同じリソースを使用するシステムの関連部分でエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="7b275-150">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="7b275-151">このような状況では、操作が直ちに失敗し、成功する可能性がある場合にのみサービスの呼び出しを試行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="7b275-151">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="7b275-152">[サーキットブレーカーパターン](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker)を使用すると、失敗する可能性のある操作をアプリケーションが繰り返し試行するのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="7b275-152">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="7b275-153">また、アプリケーションを定期的に評価して、エラーが解決されたかどうかを判断するための呼び出しを監視します。</span><span class="sxs-lookup"><span data-stu-id="7b275-153">It also monitors the application with a periodic trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="7b275-154">図6-5 は、動作中のサーキットブレーカーパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="7b275-154">Figure 6-5 shows the Circuit Breaker pattern in action.</span></span>

![サーキットブレーカーパターンの動作](./media/circuit-breaker-pattern.png)

<span data-ttu-id="7b275-156">**図 6-5**。</span><span class="sxs-lookup"><span data-stu-id="7b275-156">**Figure 6-5**.</span></span> <span data-ttu-id="7b275-157">サーキットブレーカーパターンの動作</span><span class="sxs-lookup"><span data-stu-id="7b275-157">Circuit breaker pattern in action</span></span>

<span data-ttu-id="7b275-158">前の図では、サーキットブレーカーパターンが元の再試行パターンに追加されています。</span><span class="sxs-lookup"><span data-stu-id="7b275-158">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="7b275-159">失敗した要求が10回失敗すると、サーキットブレーカーが開き、サービスの呼び出しが許可されなくなることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7b275-159">Note how after 10 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="7b275-160">[CheckCircuit] の値は30秒で設定され、ライブラリが1つの要求をサービスに継続することを許可する頻度を指定します。</span><span class="sxs-lookup"><span data-stu-id="7b275-160">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="7b275-161">その呼び出しが成功すると、回線が閉じられ、サービスはトラフィックに再び使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="7b275-161">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="7b275-162">サーキットブレーカーパターンの目的は、再試行パターンとは*異なる*ことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7b275-162">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="7b275-163">再試行パターンを使用すると、アプリケーションは成功すると想定して操作を再試行できます。</span><span class="sxs-lookup"><span data-stu-id="7b275-163">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="7b275-164">サーキットブレーカーパターンは、アプリケーションが失敗する可能性のある操作を実行できないようにします。</span><span class="sxs-lookup"><span data-stu-id="7b275-164">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="7b275-165">多くの場合、アプリケーションは、サーキットブレーカーを介して操作を呼び出すために再試行パターンを使用して、これら2つのパターンを*結合*します。</span><span class="sxs-lookup"><span data-stu-id="7b275-165">Often, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span> <span data-ttu-id="7b275-166">ただし、再試行ロジックは、サーキットブレーカーによって返される例外に依存し、障害が一時的でないことをサーキットブレーカーが示す場合は再試行を破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7b275-166">However, the retry logic should be sensitive to any exceptions returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault isn't transient.</span></span>

<span data-ttu-id="7b275-167">アプリケーションの回復性は、要求された問題のある操作を処理するためのものです。</span><span class="sxs-lookup"><span data-stu-id="7b275-167">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="7b275-168">しかし、これはストーリーの半分にすぎません。</span><span class="sxs-lookup"><span data-stu-id="7b275-168">But, it's only half of the story.</span></span> <span data-ttu-id="7b275-169">次に、Azure クラウドで使用できる回復機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="7b275-169">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7b275-170">[前へ](resiliency.md)
>[次へ](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="7b275-170">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
