---
title: クラウド ネイティブ アプリの Azure セキュリティ
description: Azure 用クラウド ネイティブ .NET アプリの設計 |クラウド ネイティブ アプリの Azure セキュリティ
ms.date: 06/30/2019
ms.openlocfilehash: 13b5ad7a883a83014913fa0a6a020610c28c524f
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989143"
---
# <a name="azure-security-for-cloud-native-apps"></a>クラウド ネイティブ アプリの Azure セキュリティ

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

クラウド ネイティブ アプリケーションは、従来のアプリケーションよりも簡単で、セキュリティで保護するのが難しい場合があります。 欠点としては、より小さなアプリケーションを保護し、セキュリティ インフラストラクチャを構築するためにより多くのエネルギーを費やす必要があります。 また、ほとんどのサービス展開におけるプログラミング言語とスタイルの異種性は、多くの異なるプロバイダからのセキュリティ情報にもっと注意を払う必要があるということでもあります。

逆に、小規模なサービスは、それぞれ独自のデータ ストアを持ち、攻撃の範囲を制限します。 攻撃者が 1 つのシステムを侵害した場合、攻撃者が別のシステムにジャンプするのは、モノリシック アプリケーションよりも難しい可能性があります。 プロセス境界は、強力な境界です。 また、データベースのバックアップがリークした場合、そのデータベースにはデータのサブセットしか含まれておらず、個人データが含まれる可能性が低いため、損害はより限定されます。

## <a name="threat-modeling"></a>脅威モデリング

クラウド ネイティブ アプリケーションの欠点を上回る利点が、同じ全体的なセキュリティの考え方に従う必要があります。 セキュリティと安全な思考は、開発と運用のストーリーのあらゆるステップの一部でなければなりません。 アプリケーションを計画する際には、次のような質問をします。

- このデータが失われた場合の影響は何でしょうか。
- このサービスに差し込まれる不良データによる被害を抑えるにはどうすればよいでしょうか。
- このデータにアクセスできるユーザー
- 開発およびリリース プロセスの周りに監査ポリシーが設定されていますか。

これらの質問はすべて、[脅威モデリング](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)と呼ばれるプロセスの一部です。 このプロセスは、システムに対する脅威、脅威の可能性、およびそれらによる潜在的な損害の問題に答えようとします。

脅威のリストが確立されたら、脅威を軽減する価値があるかどうかを判断する必要があります。 時には、脅威は計画する可能性が非常に低く、高価であり、それにエネルギーを費やす価値はありません。 たとえば、状態レベルのアクターによっては、何百万ものデバイスで使用されるプロセスの設計に変更を挿入できます。 リング[3](https://en.wikipedia.org/wiki/Protection_ring)で特定のコードを実行する代わりに、そのコードは Ring 0 で実行されます。 これにより、ハイパーバイザーをバイパスしてベア メタル マシンで攻撃コードを実行できるエクスプロイトが可能になり、そのハードウェアで実行されているすべての仮想マシンに対する攻撃が可能になります。

変更されたプロセッサは、顕微鏡なしで検出することは困難であり、そのプロセッサのシリコン設計に関する高度な知識。 このシナリオは発生する可能性は低く、軽減コストがかかるため、脅威モデルは悪用保護を構築することを推奨しません。

アクセス制御の破損など、`Id`攻撃の増加 (URL`Id=2``Id=3`で置換) や SQL インジェクションを許可する脅威の可能性が高く、保護を構築する方が魅力的です。 これらの脅威の軽減策は、会社の評判を傷つける恥ずかしいセキュリティホールを構築し、防ぐのに非常に合理的です。

## <a name="principle-of-least-privilege"></a>最小限の特権の原則

コンピュータセキュリティの建国のアイデアの1つは、最小特権の原則(POLP)です。 デジタルでも物理的でも、ほとんどの形式のセキュリティでは、実際には基本的なアイデアです。 つまり、ユーザーまたはプロセスは、タスクを実行できる権限の数を最小限に抑える必要があります。

例として、銀行の窓口担当者を考えてみましょう:金庫にアクセスすることは珍しい活動です。 だから、平均的な窓口は自分で金庫を開けることができません。 アクセスを得るためには、追加のセキュリティ チェックを実行する銀行の管理者を通じて要求をエスカレートする必要があります。

コンピュータ システムでは、データベースに接続するユーザーの権限がすばらしい例です。 多くの場合、データベース構造の構築とアプリケーションの実行の両方に使用される単一のユーザー アカウントがあります。 極端な場合を除き、アプリケーションを実行しているアカウントはスキーマ情報を更新する機能を必要としません。 異なるレベルの特権を提供するアカウントが複数存在する必要があります。 アプリケーションでは、テーブル内のデータに対する読み取りおよび書き込みアクセスを許可するアクセス許可レベルのみを使用する必要があります。 この種の保護は、データベース テーブルを削除したり、悪意のあるトリガーを導入することを目的とした攻撃を排除します。

クラウド ネイティブ アプリケーションの構築のほぼすべての部分は、最小限の特権の原則を覚えておくとメリットがあります。 ファイアウォール、ネットワーク セキュリティ グループ、ロール、およびスコープを設定する際に、ロール ベースのアクセス制御 (RBAC) でこの機能を確認できます。

## <a name="penetration-testing"></a>侵入テスト

アプリケーションが複雑になるにつれて、攻撃ベクトルの数は驚くべき速度で増加します。 脅威のモデル化には、システムを構築する同じユーザーによって実行される傾向があるという点で欠陥があります。 多くの開発者がユーザーの操作を想定して使用できないユーザー インターフェイスを構築するのと同じように、ほとんどの開発者は攻撃の方法を見るのが困難です。 また、システムを構築する開発者が攻撃方法論に精通しておらず、重要な何かを見逃している可能性もあります。

侵入テストまたは「ペンテスト」は、システムを攻撃しようとする外部アクターを持ち込むことを含みます。 これらの攻撃者は、外部のコンサルティング会社や、ビジネスの他の部分からの優れたセキュリティ知識を持つ他の開発者である可能性があります。 彼らはシステムを破壊しようとするカルトブランシュを与えられています。 多くの場合、パッチを適用する必要がある広範なセキュリティ ホールが見つかります。 攻撃のベクトルは、CEO に対するフィッシング攻撃を悪用するような、まったく予想外の攻撃の場合があります。

Azure 自体は常に[マイクロソフト内のハッカーのチーム](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)からの攻撃を受けています。 長年にわたり、彼らは潜在的に壊滅的な攻撃ベクトルの数十を発見し、外部から悪用される前にそれらを閉じる最初の人でした。 ターゲットを魅力的にするほど、永遠のアクターがそれを悪用しようとする可能性が高くなり、世界にはAzureよりも魅力的なターゲットがいくつかあります。

## <a name="monitoring"></a>監視

攻撃者がアプリケーションに侵入しようとした場合は、その警告が表示されるはずです。 多くの場合、サービスのログを調べることで攻撃を見つけることができます。 攻撃は、成功する前に発見できる物語の兆候を残します。 たとえば、パスワードを推測しようとする攻撃者は、ログイン システムに対して多くの要求を行います。 ログイン システムの監視では、一般的なアクセス パターンと一致しない奇妙なパターンを検出できます。 この監視は、操作担当者に何らかの対策を有効にするよう警告するアラートに変えることができます。 高度に成熟した監視システムは、これらの偏差に基づいてアクションを実行し、リクエストをブロックしたり応答を調整したりするためのルールを積極的に追加することもあります。

## <a name="securing-the-build"></a>ビルドのセキュリティ保護

セキュリティが見落とされがちな場所の 1 つは、ビルド プロセスの周りにあります。 安全でないコードやチェックインされた資格情報のスキャンなど、ビルドでセキュリティ チェックを実行するだけでなく、ビルド自体もセキュリティで保護する必要があります。 ビルド サーバーが侵害された場合は、任意のコードを製品に導入するためのすばらしいベクトルを提供します。

攻撃者が Web アプリケーションにサインインするユーザーのパスワードを盗もうとしているとします。 また、チェックアウトしたコードを変更して、ログイン要求を別のサーバーにミラーリングするビルド ステップを導入する可能性があります。 次にコードがビルドを通過すると、自動的に更新されます。 ソース コードの脆弱性スキャンでは、ビルドの前に実行されるこの問題は検出されません。 同様に、ビルド ステップはビルド サーバー上に行われるため、コード レビューではそれをキャッチするユーザーはいません。 悪用されたコードは、パスワードを収集できる実稼働環境に移動します。 ビルド プロセスの変更の監査ログがないか、少なくとも監査を監視するユーザーがいない可能性があります。

これは、システムに侵入するために使用できる一見低い値のターゲットの完璧な例です。 攻撃者がシステムの境界を侵害すると、アクセス許可を好きな場所に本当の害を引き起こす可能性があるポイントまで昇格する方法を見つけ始めることができます。

## <a name="building-secure-code"></a>安全なコードの構築

.NET Framework は、既に非常に安全なフレームワークです。 配列の終端を離れるなど、アンマネージ コードの落とし穴を回避します。 セキュリティ ホールが発見された場合、セキュリティ ホールを修正する作業が積極的に行われます。 研究者にフレームワーク内の問題を見つけて報告するのではなく、それらを悪用するのではなく報告する[バグバウンティプログラム](https://www.microsoft.com/msrc/bounty)もあります。

.NET コードをより安全にする方法は多数あります。 [「.NET のセキュリティで保護されたコーディング ガイドライン](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines)」などのガイドラインに従うことは、コードを一から保護するために実行する合理的な手順です。 [OWASP トップ 10](https://owasp.org/www-project-top-ten/)は、安全なコードを構築するための貴重なガイドです。

ビルド プロセスは、ソース コードの問題を実稼働にする前に検出するスキャン ツールを配置するのに適しています。 ほとんどのプロジェクトは、他のパッケージに依存しています。 古いパッケージをスキャンできるツールは、夜間のビルドで問題をキャッチします。 Docker イメージを構築する場合でも、ベース イメージに既知の脆弱性が存在しないことを確認して確認すると便利です。 もう 1 つ確認する必要があるのは、だれも誤って資格情報をチェックインしていないということです。

## <a name="built-in-security"></a>組み込みのセキュリティ

Azure は、ユーザーの大半のユーザーの使いやすさとセキュリティのバランスを取るように設計されています。 ユーザーごとに異なるセキュリティ要件が必要になるため、クラウド セキュリティへのアプローチを微調整する必要があります。 マイクロソフトは、セキュリティ[センター](https://azure.microsoft.com/support/trust-center/)に多くのセキュリティ情報を公開しています。 このリソースは、組み込みの攻撃軽減テクノロジがどのように機能するかを理解することに関心を持つ専門家にとって最初のストップとなります。

Azure ポータル内では[、Azure Advisor](https://azure.microsoft.com/services/advisor/)は常に環境をスキャンし、推奨事項を作成するシステムです。 これらの推奨事項の中には、ユーザーのコストを節約するためのものがありますが、仮想ネットワークによって保護されていないストレージ コンテナーを持つなど、潜在的に安全でない構成を識別するように設計されているものもあります。

## <a name="azure-network-infrastructure"></a>Azure ネットワーク インフラストラクチャ

オンプレミスの展開環境では、ネットワークのセットアップに多大なエネルギーが注力されています。 ルーターやスイッチなどを設定するのは複雑な作業です。 ネットワークを使用すると、特定のリソースが他のリソースと通信し、場合によってはアクセスを防ぐことができます。 ネットワークルールの中には、開発中のコードが少しずつ実行され、データを削除する可能性が低いという、開発環境からの運用環境へのアクセスを制限することが頻繁に行われます。

ほとんどの PaaS Azure リソースには、最も基本的で寛容なネットワーク設定しかありません。 たとえば、インターネット上の誰でもアプリ サービスにアクセスできます。 通常、新しい SQL Server インスタンスは制限されるため、外部パーティはアクセスできませんが、Azure 自体が使用する IP アドレス範囲は許可されます。 したがって、SQL サーバーは外部からの脅威から保護されていますが、攻撃者は Azure 上のすべての SQL インスタンスに対する攻撃を開始できる場所から Azure ブリッジヘッドを設定するだけで済みます。

さいわい、ほとんどの Azure リソースは、細かいアクセス制御を可能にする Azure 仮想ネットワークに配置できます。 オンプレミス ネットワークが、より広い世界から保護されているプライベート ネットワークを確立する方法と同様に、仮想ネットワークは、Azure ネットワーク内に配置されているプライベート IP アドレスの島です。

![図 10-1 Azure](./media/virtual-network.png)
図**10-1**の仮想ネットワーク 。 Azure の仮想ネットワーク。

オンプレミス ネットワークがネットワークへのアクセスを制御するファイアウォールを持っているのと同じように、仮想ネットワークの境界に同様のファイアウォールを確立できます。 既定では、仮想ネットワーク上のすべてのリソースは、インターネットと通信できます。 何らかの形で明示的なファイアウォール例外が必要なのは、着信接続だけです。

ネットワークが確立されると、ストレージ アカウントなどの内部リソースを、仮想ネットワーク上のリソースからのアクセスのみを許可するように設定できます。 このファイアウォールは、そのストレージ アカウントのキーが漏洩した場合、攻撃者は、漏洩したキーを悪用するために、それに接続することはできません、セキュリティの追加のレベルを提供します。 これは、最小特権の原則のもう 1 つの例です。

Azure Kubernetes クラスター内のノードは、Azure に対してネイティブな他のリソースと同様に、仮想ネットワークに参加できます。 この機能は[、Azure コンテナー ネットワーク インターフェイス と呼ばれます](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)。 実際には、仮想マシンとコンテナー イメージが割り当てられる仮想ネットワーク内のサブネットを割り当てます。

仮想ネットワーク内のすべてのリソースが他のすべてのリソースと通信する必要があるわけではありませんが、最小限の特権の原則を説明するパスを続けます。 たとえば、ストレージ アカウントと SQL データベースを介して Web API を提供するアプリケーションでは、データベースとストレージ アカウントが互いに話し合う必要はほとんどありません。 それらの間でデータを共有する場合は、Web アプリケーションを経由します。 したがって、[ネットワーク セキュリティ グループ (NSG) を](https://docs.microsoft.com/azure/virtual-network/security-overview)使用して、2 つのサービス間のトラフィックを拒否できます。

リソース間の通信を拒否するポリシーは、特にトラフィック制限なしで Azure を使用する背景から、実装するのが面倒です。 他のクラウドでは、ネットワーク セキュリティ グループの概念が非常に普及しています。 たとえば、AWS のデフォルトポリシーでは、NSG のルールによって有効にされるまで、リソースはリソース間で通信できません。 この問題を開発する速度は遅くなりますが、より制限の厳しい環境では、より安全な既定値が提供されます。 適切な DevOps プラクティスを使用すると、特に[Azure リソース マネージャーまたは Terraform](infrastructure-as-code.md)を使用してアクセス許可を管理することで、ルールの制御が容易になります。

仮想ネットワークは、オンプレミスリソースとクラウドリソース間の通信を設定する場合にも役立ちます。 仮想プライベート ネットワークを使用すると、2 つのネットワークをシームレスに接続できます。 これにより、すべてのユーザーがオンサイトのシナリオに対して、ゲートウェイのない仮想ネットワークを実行できます。 このネットワークを確立するために使用できるテクノロジは多数あります。 最も簡単な方法は、多くのルーターと Azure の間で確立できるサイト間[VPN を](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti)使用することです。 トラフィックは、他のトラフィックと同じバイトあたりのコストで、インターネット上で暗号化およびトンネリングされます。 帯域幅の多い場合やセキュリティを強化することが望ましいシナリオでは、Azure は、オンプレミス ネットワークと Azure の間のプライベート回線を使用する[Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute)というサービスを提供します。 確立はコストが高く、確立が難しくなりますが、安全性も高くなります。

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a>Azure リソースへのアクセスを制限するためのロール ベースのアクセス制御

RBAC は、Azure で実行されているアプリケーションに ID を提供するシステムです。 アプリケーションは、キーやパスワードの代わりに、またはキーやパスワードを使用する代わりに、この ID を使用してリソースにアクセスできます。

## <a name="security-principals"></a>セキュリティ プリンシパル

RBAC の最初のコンポーネントは、セキュリティ プリンシパルです。 セキュリティ プリンシパルには、ユーザー、グループ、サービス プリンシパル、またはマネージド ID を指定できます。

![図 10-2 さまざまな種類のセキュリティ](./media/rbac-security-principal.png)
プリンシパル**図 10-2** セキュリティ プリンシパルの種類が異なります。

- ユーザー - Azure アクティブ ディレクトリにアカウントを持つすべてのユーザーはユーザーです。
- グループ - Azure アクティブ ディレクトリからユーザーのコレクション。 グループのメンバーとして、ユーザーは、グループの役割に加えて、グループの役割を担当します。
- サービス プリンシパル - サービスまたはアプリケーションが実行されるセキュリティ ID。
- マネージド ID - Azure によって管理される Azure アクティブ ディレクトリ ID。 マネージド ID は、通常、Azure サービスを認証するための資格情報を管理するクラウド アプリケーションを開発するときに使用されます。

セキュリティ プリンシパルは、ほとんどのリソースに適用できます。 つまり、Azure Kubernetes 内で実行されているコンテナーにセキュリティ プリンシパルを割り当て、Key Vault に格納されているシークレットにアクセスできます。 Azure 関数は、呼び出し元のユーザーの JWT を検証するために、Active Directory インスタンスとの間でのアクセス許可を取得できます。 サービス プリンシパルでサービスを有効にすると、ロールとスコープを使用して、そのアクセス許可を細かく管理できます。

## <a name="roles"></a>ロール

セキュリティ プリンシパルは、多くの役割を担うか、よりサルトリアルなたとえを使用して、多くの帽子を着用することができます。 各ロールは、"Azure Service Bus エンドポイントからのメッセージの読み取り" などの一連のアクセス許可を定義します。 セキュリティ プリンシパルの有効なアクセス許可セットは、セキュリティ プリンシパルが持つすべてのロールに割り当てられたすべてのアクセス許可の組み合わせです。 Azure には多数の組み込みロールがあり、ユーザーは独自のロールを定義できます。

![図 10-3 RBAC](./media/rbac-role-definition.png)
ロールの定義**図 10-3**. RBAC ロールの定義。

Azure に組み込まれているのは、所有者、共同作成者、閲覧者、ユーザー アカウント管理者など、多くの高レベルのロールでもあります。 所有者ロールを使用すると、セキュリティ プリンシパルはすべてのリソースにアクセスし、他のリソースにアクセス許可を割り当てることができます。 投稿者はすべてのリソースに対して同じレベルのアクセス権を持っていますが、アクセス許可を割り当てることはできません。 閲覧者は既存の Azure リソースのみを表示でき、ユーザー アカウント管理者は Azure リソースへのアクセスを管理できます。

[DNS ゾーン共同作成者](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor)などのより細分化された組み込みの役割には、単一のサービスに限定された権限があります。 セキュリティ プリンシパルは、任意の数のロールを使用できます。

## <a name="scopes"></a>スコープ

ロールは、Azure 内の制限された一連のリソースに適用できます。 たとえば、Service Bus キューからの読み取りの前の例にスコープを適用すると、アクセス許可を単一のキューに`blah.servicebus.windows.net/queue1`絞り込むことができます。

スコープは、単一のリソースと同じくらい狭くすることも、リソース グループ全体、サブスクリプション、または管理グループに適用することもできます。

セキュリティ プリンシパルに特定のアクセス許可があるかどうかをテストする場合は、ロールとスコープの組み合わせが考慮されます。 この組み合わせにより、強力な承認メカニズムが提供されます。

## <a name="deny"></a>拒否

以前は、RBAC に対して許可されたルールは許可されていました。 この動作により、いくつかのスコープの構築が複雑になりました。 たとえば、潜在的に無限のストレージ アカウントの一覧に明示的なアクセス許可を与える必要がある 1 つを除くすべてのストレージ アカウントへのセキュリティ プリンシパル アクセスを許可します。 新しいストレージ アカウントを作成するたびに、このアカウントの一覧に追加する必要があります。 この追加管理オーバーヘッドは、確かに望ましくないものでした。

拒否ルールは許可ルールよりも優先されます。 同じ 「1 つを除くすべての許可」 スコープを表す場合は、"すべて許可" と "この 1 つの特定のルールを拒否" の 2 つのルールとして表すことができる。 拒否ルールは、管理を容易にするだけでなく、すべてのユーザーへのアクセスを拒否することで、セキュリティが強化されたリソースを許可します。

## <a name="checking-access"></a>アクセスの確認

ご想像のとおり、多数のロールとスコープを持つことは、サービス プリンシパルの有効なアクセス許可を見つけ出すのが非常に困難になる可能性があります。 その上に拒否ルールを積み重ねることは、複雑さを増すだけの役割を果たします。 幸いにも、任意のサービス プリンシパルに有効なアクセス許可を表示できるアクセス許可計算ツールがあります。 通常、図 10-3 に示すように、ポータルの [IAM] タブにあります。

![図 10-4 アプリ サービス](./media/check-rbac.png)
のアクセス許可計算ツール図**10-4**. アプリ サービスのアクセス許可計算ツール。

## <a name="securing-secrets"></a>秘密の保護

パスワードと証明書は、攻撃者にとって一般的な攻撃方法です。 パスワードクラッキングハードウェアは、ブルートフォース攻撃を行い、毎秒数十億のパスワードを推測しようとします。 そのため、リソースへのアクセスに使用されるパスワードは、さまざまな文字を使用して強力に使用することが重要です。 これらのパスワードは、覚えきが不可能に近いパスワードです。 幸いなことに、Azure のパスワードは、実際には人間が知っている必要はありません。

多くのセキュリティ専門家は、パスワードマネージャを使用して自分のパスワードを保持することが最善の方法であると[示唆](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/)しています。 パスワードを 1 か所に集中させる一方で、複雑なパスワードを使用して、アカウントごとに一意であることを確認することもできます。 同じシステムが Azure 内に存在します: シークレットの中央ストア。

## <a name="azure-key-vault"></a>Azure Key Vault

Azure Key Vault は、データベース、API キー、証明書などのパスワードを格納する一元的な場所を提供します。 いったん Vault にシークレットが入力されると、そのシークレットは二度と表示されず、抽出して表示するコマンドは意図的に複雑になります。 金庫内の情報は、ソフトウェア暗号化または FIPS 140-2 レベル 2 の検証済みハードウェア セキュリティ モジュールを使用して保護されます。

キー コンテナーへのアクセスは、RBAC を通じて提供されるため、ユーザーがボールト内の情報にアクセスできるわけではありません。 Web アプリケーションが Azure Key Vault に格納されているデータベース接続文字列にアクセスしたいとします。 アクセスするには、アプリケーションはサービス プリンシパルを使用して実行する必要があります。 この引き受け役割の下で、彼らは金庫から秘密を読み取ることができます。 アプリケーションがコンテナーに対して持っているアクセスをさらに制限できるさまざまなセキュリティ設定があり、シークレットを更新することはなく、読み取り専用です。

キー コンテナーへのアクセスを監視して、必要なアプリケーションだけがコンテナーにアクセスしていることを確認できます。 ログを Azure Monitor に統合し直すと、予期しない状況が発生したときにアラートを設定する機能を解除できます。

## <a name="kubernetes"></a>Kubernetes

Kubernetes内には、機密情報の小片を維持するための同様のサービスがあります。 Kubernetes シークレットは、典型的な`kubectl`実行可能ファイルを使用して設定できます。

シークレットの作成は、格納する値の base64 バージョンを見つけるのと同じくらい簡単です。

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

次に、次の例のような名前`secret.yml`のシークレット ファイルに追加します。

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

最後に、次のコマンドを実行して、このファイルを Kubernetes にロードできます。

```console
kubectl apply -f ./secret.yaml
```

これらのシークレットは、ボリュームにマウントしたり、環境変数を通じてコンテナプロセスに公開したりできます。 アプリケーションを構築するための[12 要素アプリ](https://12factor.net/)のアプローチでは、最も低い共通分母を使用して設定をアプリケーションに送信することをお勧めします。 環境変数は、オペレーティング システムやアプリケーションに関係なくサポートされるため、最も低い共通分母です。

ビルトイン Kubernetes シークレットを使用する代わりに、Kubernetes 内から Azure Key Vault のシークレットにアクセスする方法があります。 最も簡単な方法は、シークレットを読み込むコンテナに RBAC ロールを割り当てることです。 アプリケーションは、Azure Key Vault API を使用してシークレットにアクセスできます。 ただし、この方法ではコードを変更する必要があり、環境変数を使用するパターンに従いません。 代わりに[、Azure Key Vault インジェクタ](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)を使用してコンテナーに値を挿入できます。 このアプローチは、実際には Kubernetes シークレットを直接使用するよりも安全です。

## <a name="encryption-in-transit-and-at-rest"></a>転送中および保存時の暗号化

データをディスク上に置く場合でも、さまざまなサービス間を移動する場合でも、データを安全に保つことが重要です。 データが漏洩しないようにする最も効果的な方法は、他のユーザーが簡単に読み取ることができない形式に暗号化することです。 Azure では、幅広い暗号化オプションがサポートされています。

### <a name="in-transit"></a>転送中のデータ

Azure のネットワーク上のトラフィックを暗号化するには、いくつかの方法があります。 Azure サービスへのアクセスは、通常、トランスポート層セキュリティ (TLS) を使用する接続を介して行われます。 たとえば、Azure API へのすべての接続には TLS 接続が必要です。 同様に、Azure ストレージ内のエンドポイントへの接続は、TLS 暗号化接続でのみ動作するように制限できます。

TLS は複雑なプロトコルであり、単に接続が TLS を使用していることを知っているだけでは、セキュリティを確保するのに十分ではありません。 たとえば、TLS 1.0 は慢性的に安全で、TLS 1.1 はあまり良くありません。 TLS のバージョン内でも、接続の暗号化を簡単にするさまざまな設定があります。 最善の対処方法は、サーバー接続が最新のプロトコルを使用しているかどうかを確認することです。

このチェックは、SSL ラボの SSL サーバー テストなどの外部サービスで行うことができます。 一般的な Azure エンドポイント (この場合はサービス バス エンドポイント) に対するテスト実行では、ほぼ完全なスコア A が得られます。

Azure SQL データベースのようなサービスでも、データを非表示に保つために TLS 暗号化が使用されます。 TLS を使用して転送中のデータを暗号化する興味深い点は、TLS を実行しているコンピューター間の接続をリッスンすることは、マイクロソフトであっても不可能です。 これにより、マイクロソフトの適切な、または標準の攻撃者よりも多くのリソースを持つ状態アクターからデータが危険にさらされる可能性があることを懸念する企業に快適さを提供する必要があります。

![図 10-5 サービス バス エンドポイントのスコア A を示す SSL ラボ レポート](./media/ssl-report.png)
**図 10-5**. サービス バス エンドポイントのスコア A を示す SSL ラボ レポート。

このレベルの暗号化は常に十分ではありませんが、Azure TLS 接続が非常に安全であるという確信を促す必要があります。 Azure は、暗号化が向上するにつれて、セキュリティ標準を継続的に進化させます。 誰かがセキュリティ標準を見て、Azure を改善するにつれて更新していることを知ってうれしいです。

### <a name="at-rest"></a>保存中

どのアプリケーションでも、データがディスク上に置かれている場所は多数あります。 アプリケーション コード自体は、いくつかのストレージ 機構から読み込まれます。 また、ほとんどのアプリケーションでは、SQL Server、Cosmos DB、あるいは驚くほど価格効率の高いテーブルストレージなどのデータベースを使用しています。 これらのデータベースはすべて、暗号化の多いストレージを使用して、適切な権限を持つアプリケーション以外の誰もデータを読み取ることができないようにします。 システムオペレータも、暗号化されたデータを読み取ることができません。 したがって、顧客は秘密情報が秘密のままであると確信できます。

### <a name="storage"></a>ストレージ

Azure の大部分の基になっているのは、Azure ストレージ エンジンです。 仮想マシン ディスクは、Azure ストレージの上にマウントされます。 Azure Kubernetes サービスは、それ自体が Azure ストレージでホストされている仮想マシン上で実行されます。 Azure 関数アプリや Azure コンテナー インスタンスなどのサーバーレス テクノロジでも、Azure ストレージの一部であるディスクが不足しています。

Azure Storage が適切に暗号化されている場合は、他のほとんどすべても暗号化するための基盤が提供されます。 Azure ストレージは[FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140)準拠[の 256 ビット AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)で[暗号化されます](https://docs.microsoft.com/azure/storage/common/storage-service-encryption)。 これは、過去20年ほどの間に広範な学術的精査の対象となってきた、評価の高い暗号化技術です。 現時点では、キーを知らない人がAESによって暗号化されたデータを読み取ることを可能にする実用的な攻撃は知られていません。

既定では、Azure ストレージの暗号化に使用されるキーは、マイクロソフトによって管理されます。 これらのキーへの悪意のあるアクセスを防ぐため、広範な保護が実施されています。 ただし、特定の暗号化要件を持つユーザーは、Azure Key Vault で管理される[独自のストレージ キーを提供](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell)することもできます。 これらのキーはいつでも取り消すことができるため、ストレージ アカウントのコンテンツは事実上アクセス不能になります。

仮想マシンは暗号化されたストレージを使用しますが、Windows の BitLocker や Linux の DM-Crypt などのテクノロジを使用して、別の暗号化層を提供することができます。 これらの技術は、ディスクイメージがストレージから漏洩しても、読み取ることは不可能に近いままであることを意味します。

### <a name="azure-sql"></a>Azure SQL

Azure SQL でホストされるデータベースでは、[透過的なデータ暗号化 (TDE)](/sql/relational-databases/security/encryption/transparent-data-encryption)と呼ばれるテクノロジを使用して、データが暗号化された状態を維持します。 新しく作成されたすべての SQL データベースで既定で有効になっていますが、従来のデータベースでは手動で有効にする必要があります。 TDE は、データベースだけでなく、バックアップとトランザクション ログの暗号化と復号化をリアルタイムで実行します。

暗号化パラメータはデータベースに`master`格納され、起動時に残りの操作のためにメモリに読み込まれます。 つまり、データベースは`master`暗号化されていない状態にする必要があります。 実際のキーはマイクロソフトによって管理されます。 ただし、厳密なセキュリティ要件を持つユーザーは、Azure Storage で行うのとほぼ同じ方法で Key Vault で独自のキーを提供できます。 Key Vault は、キーのローテーションや失効などのサービスを提供します。

TDS の「透過」部分は、暗号化されたデータベースを使用するために必要なクライアントの変更がないという事実から来ています。 この方法ではセキュリティが強化されますが、データベース パスワードの漏洩は、ユーザーがデータを復号化できる十分です。 データベース内の個々の列またはテーブルを暗号化する別の方法があります。 [常に暗号化は](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault)、暗号化されたデータがデータベース内のプレーン テキストで表示されることを保証します。

暗号化のこの層を設定するには、SQL Server 管理スタジオのウィザードを使用して、暗号化の種類を選択し、関連付けられたキーを格納する Key Vault での場所を選択する必要があります。

![図 10-6 常に暗号化する](./media/always-encrypted.png)
**図 10-6**を使用して、暗号化するテーブル内の列を選択する [常に暗号化] を使用して、暗号化するテーブル内の列を選択します。

これらの暗号化された列から情報を読み取るクライアント アプリケーションは、暗号化されたデータを読み取るために特別な許可を与える必要があります。 接続文字列を更新する必要`Column Encryption Setting=Enabled`があり、クライアント資格情報を Key Vault から取得する必要があります。 SQL Server クライアントは、列暗号化キーを使用して準備する必要があります。 これが完了すると、残りのアクションは SQL クライアントへの標準インターフェースを使用します。 つまり、SQL クライアントの上に構築された Dapper や Entity Framework などのツールは、変更なしで引き続き動作します。 すべての言語ですべての SQL Server ドライバで使用できる状態になっていません。

TDE と Always Encrypted の組み合わせにより、クライアント固有のキーと共に使用できるため、最も厳密な暗号化要件もサポートされます。

### <a name="cosmos-db"></a>Cosmos DB

Cosmos DB は、Azure でマイクロソフトが提供する最新のデータベースです。 セキュリティと暗号化を念頭に置いて、最初から構築されています。 AES-256 ビット暗号化はすべての Cosmos DB データベースに対して標準であり、無効にすることはできません。 通信に対する TLS 1.2 要件と組み合わせることで、ストレージ ソリューション全体が暗号化されます。

![図 10-7 Cosmos DB](./media/cosmos-encryption.png)
図**10-7**内のデータ暗号化の流れ。 Cosmos DB 内のデータ暗号化のフロー。

Cosmos DB は顧客の暗号化キーを提供していませんが、チームは、それがなくても PCI-DSS に準拠し続けるために、多大な作業を行ってきました。 Cosmos DB では、Azure SQL の常に暗号化されているのと同様の単一列の暗号化もサポートされていません。

## <a name="keeping-secure"></a>安全を確保

Azure には、安全性の高い製品をリリースするために必要なすべてのツールがあります。 しかし、チェーンは最も弱いリンクと同じくらい強いです。 Azure の上にデプロイされたアプリケーションが、適切なセキュリティの考え方と優れたセキュリティ監査を使用して開発されていない場合、チェーン内の脆弱なリンクになります。 Azure にインストールされたソフトウェアが Azure 自体と同じくらい安全であることを保証するために使用できる優れた静的分析ツール、暗号化ライブラリ、およびセキュリティプラクティスは数多くあります。 たとえば、[静的分析ツール](https://www.whitesourcesoftware.com/)、[暗号化ライブラリ](https://www.libressl.org/)、セキュリティ[対策](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)などがあります。

>[!div class="step-by-step"]
>[前へ](security.md)
>[次へ](devops.md)
