---
title: クラウド ネイティブの定義
description: クラウドネイティブシステムの基盤となる基礎的な柱について学ぶ
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 756a2565bd77fcef19a5f15579987836ff0e75a4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989091"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="f8d15-103">クラウド ネイティブの定義</span><span class="sxs-lookup"><span data-stu-id="f8d15-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="f8d15-104">あなたがやっていることを止め、同僚の10人にテキストを送ってください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="f8d15-105">「クラウドネイティブ」という用語を定義するように依頼します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="f8d15-106">あなたは8つの異なる答えを得る可能性が高いです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-106">Good chance you'll get eight different answers.</span></span>

<span data-ttu-id="f8d15-107">クラウドネイティブは、重要なビジネスシステムの構築に対する考え方を変える方法です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-107">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="f8d15-108">クラウドネイティブシステムは、急速な変化、大規模、および回復力を採用するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="f8d15-109">クラウドネイティブコンピューティング財団は[、公式の定義](https://github.com/cncf/foundation/blob/master/charter.md)を提供します:</span><span class="sxs-lookup"><span data-stu-id="f8d15-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="f8d15-110">*クラウドネイティブテクノロジにより、組織は、パブリック クラウド、プライベート クラウド、ハイブリッド クラウドなどの最新の動的環境でスケーラブルなアプリケーションを構築し、実行できます。コンテナー、サービス メッシュ、マイクロサービス、不変インフラストラクチャ、および宣言型 API は、このアプローチを例示しています。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="f8d15-111">*これらの手法により、弾力性、管理性、観察性を備えた疎結合システムが実現します。堅牢な自動化と組み合わせることで、エンジニアは最小限の苦労で頻繁かつ予測可能に影響の大きな変更を行うことを可能にします。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="f8d15-112">アプリケーションは、ますます多くのユーザーを要求して複雑になっています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="f8d15-113">ユーザーは、迅速な応答性、革新的な機能、およびダウンタイムをゼロに期待します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="f8d15-114">パフォーマンスの問題、繰り返し発生するエラー、および高速に移動できない場合は、もはや許容されません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="f8d15-115">彼らは簡単にあなたの競争相手に移動します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="f8d15-116">クラウドネイティブは、*スピード*と*敏捷性*について多くのです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-116">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="f8d15-117">ビジネスシステムは、ビジネス能力の実現から戦略的変革の武器まで進化し、ビジネスのスピードと成長を加速しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-117">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="f8d15-118">アイデアをすぐに市場に投入することが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="f8d15-119">これらの技術を実装した企業をいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="f8d15-120">達成したスピード、俊敏性、拡張性について考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="f8d15-121">[会社]</span><span class="sxs-lookup"><span data-stu-id="f8d15-121">Company</span></span> | <span data-ttu-id="f8d15-122">エクスペリエンス</span><span class="sxs-lookup"><span data-stu-id="f8d15-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="f8d15-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="f8d15-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="f8d15-124">生産に600以上のサービスを持っています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-124">Has 600+ services in production.</span></span> <span data-ttu-id="f8d15-125">1 日に 100 回展開します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-125">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="f8d15-126">ユーバー</span><span class="sxs-lookup"><span data-stu-id="f8d15-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="f8d15-127">1,000以上のサービスが本番環境に保存されています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-127">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="f8d15-128">毎週数千のビルドを展開します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-128">Deploys several thousand builds each week.</span></span> |
| [<span data-ttu-id="f8d15-129">WeChat</span><span class="sxs-lookup"><span data-stu-id="f8d15-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="f8d15-130">生産に300以上のサービスを持っています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-130">Has 300+ services in production.</span></span> <span data-ttu-id="f8d15-131">1 日あたり約 1,000 の変更を行います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-131">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="f8d15-132">ご覧のとおり、Netflix、Uber、WeChat は、何百もの独立したマイクロサービスで構成されるシステムを公開しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="f8d15-133">この建築様式は市場の状況に迅速に対応することを可能にする。</span><span class="sxs-lookup"><span data-stu-id="f8d15-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="f8d15-134">ライブの複雑なアプリケーションの小さな領域を瞬時に更新し、必要に応じて個別に拡張できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="f8d15-135">クラウドネイティブのスピードと俊敏性は、多くの要因から生じます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="f8d15-136">最も重要なのはクラウド インフラストラクチャです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="f8d15-137">図 1-3 に示す 5 つの追加の基礎柱は、クラウド ネイティブ システムの基盤も提供します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![クラウドネイティブ基礎柱](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="f8d15-139">**図 1-3**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-139">**Figure 1-3**.</span></span> <span data-ttu-id="f8d15-140">クラウドネイティブ基礎柱</span><span class="sxs-lookup"><span data-stu-id="f8d15-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="f8d15-141">各柱の重要性を理解するために少し時間を取りましょう。</span><span class="sxs-lookup"><span data-stu-id="f8d15-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="f8d15-142">クラウド.</span><span class="sxs-lookup"><span data-stu-id="f8d15-142">The cloud…</span></span>

<span data-ttu-id="f8d15-143">クラウド ネイティブ システムは、クラウド サービス モデルを最大限に活用します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="f8d15-144">動的な仮想化クラウド環境での繁栄を目的として設計されたこれらのシステムは、[プラットフォームをサービスとして(PaaS)](https://azure.microsoft.com/overview/what-is-paas/)コンピューティングインフラストラクチャとマネージドサービスを幅広く利用しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="f8d15-145">基盤となるインフラストラクチャは、数分でプロビジョニングされ、オートメーションによってサイズ変更、拡大縮小、移動、または破棄される *、使い捨て*として扱われます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="f8d15-146">[ペット対牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)の広く受け入れられているDevOpsの概念を考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="f8d15-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="f8d15-147">従来のデータセンターでは、サーバーは*Pets*として扱われます: 物理マシン、意味のある名前を与えられ、世話をします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="f8d15-148">同じマシンにリソースを追加してスケールアップします (スケールアップ)。</span><span class="sxs-lookup"><span data-stu-id="f8d15-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="f8d15-149">サーバーが病気になった場合は、健康に戻って看護します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="f8d15-150">サーバーが使用できなくなった場合、全員が通知します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="f8d15-151">*牛*のサービスモデルは異なります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="f8d15-152">各インスタンスを仮想マシンまたはコンテナーとしてプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="f8d15-153">これらは同じで、Service-01、Service-02 などのシステム識別子が割り当てられています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="f8d15-154">スケールするには、その他のサイズを作成します (スケール アウト)。</span><span class="sxs-lookup"><span data-stu-id="f8d15-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="f8d15-155">1つが利用できなくなったら、誰も気付かない。</span><span class="sxs-lookup"><span data-stu-id="f8d15-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="f8d15-156">牛モデルは*不変のインフラを*受け入れています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="f8d15-157">サーバーは修復も変更もされません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="f8d15-158">1 つが失敗した場合、または更新が必要な場合は、破棄され、新しいものがプロビジョニングされます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="f8d15-159">クラウドネイティブシステムは、牛サービスモデルを採用しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="f8d15-160">インフラストラクチャは、実行しているマシンに関係なく、スケールインまたはスケールアウトに応じて実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="f8d15-161">Azure クラウド プラットフォームは、自動スケーリング、自己修復、および監視機能を備えた、この種の高弾性インフラストラクチャをサポートします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="f8d15-162">モダン デザイン</span><span class="sxs-lookup"><span data-stu-id="f8d15-162">Modern design</span></span>

<span data-ttu-id="f8d15-163">クラウドネイティブアプリをどのように設計しますか?</span><span class="sxs-lookup"><span data-stu-id="f8d15-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="f8d15-164">アーキテクチャはどのようなものでしょうか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-164">What would your architecture look like?</span></span> <span data-ttu-id="f8d15-165">どのような原則、パターン、およびベスト プラクティスを遵守しますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="f8d15-166">どのようなインフラストラクチャと運用上の懸念が重要でしょうか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="f8d15-167">12要素アプリケーション</span><span class="sxs-lookup"><span data-stu-id="f8d15-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="f8d15-168">クラウドベースのアプリケーションを構築するための広く受け入れられている方法論は[、12要素アプリケーションです](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="f8d15-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="f8d15-169">開発者が最新のクラウド環境向けに最適化されたアプリケーションを構築するために従う一連の原則と実践について説明します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="f8d15-170">環境間の移植性と宣言型オートメーションには特に注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="f8d15-171">Web ベースのアプリケーションに適用できる一方で、多くの実務者はクラウドネイティブアプリを構築するための強固な基盤と考えています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-171">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="f8d15-172">これらの原則に基づいて構築されたシステムは、迅速に展開および拡張し、市場の変化に迅速に対応する機能を追加できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="f8d15-173">次の表は、12 要素の方法論を示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="f8d15-174">要素</span><span class="sxs-lookup"><span data-stu-id="f8d15-174">Factor</span></span> | <span data-ttu-id="f8d15-175">説明</span><span class="sxs-lookup"><span data-stu-id="f8d15-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="f8d15-176">1</span><span class="sxs-lookup"><span data-stu-id="f8d15-176">1</span></span> | <span data-ttu-id="f8d15-177">コードベース</span><span class="sxs-lookup"><span data-stu-id="f8d15-177">Code Base</span></span> | <span data-ttu-id="f8d15-178">マイクロサービスごとに 1 つのコード ベースを独自のリポジトリに格納します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="f8d15-179">バージョン管理で追跡され、複数の環境(QA、ステージング、本番)に展開できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="f8d15-180">2</span><span class="sxs-lookup"><span data-stu-id="f8d15-180">2</span></span> | <span data-ttu-id="f8d15-181">依存関係</span><span class="sxs-lookup"><span data-stu-id="f8d15-181">Dependencies</span></span> | <span data-ttu-id="f8d15-182">各マイクロサービスは、システム全体に影響を与えることなく変更を受け入れ、独自の依存関係を分離してパッケージ化します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="f8d15-183">3</span><span class="sxs-lookup"><span data-stu-id="f8d15-183">3</span></span> | <span data-ttu-id="f8d15-184">構成</span><span class="sxs-lookup"><span data-stu-id="f8d15-184">Configurations</span></span>  | <span data-ttu-id="f8d15-185">構成情報は、マイクロサービスから移動され、コードの外部にある構成管理ツールを通じて外部化されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="f8d15-186">正しい構成が適用された環境に同じ配置を適用できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="f8d15-187">4</span><span class="sxs-lookup"><span data-stu-id="f8d15-187">4</span></span> | <span data-ttu-id="f8d15-188">バッキングサービス</span><span class="sxs-lookup"><span data-stu-id="f8d15-188">Backing Services</span></span> | <span data-ttu-id="f8d15-189">補助リソース (データ ストア、キャッシュ、メッセージ ブローカー) は、アドレス指定可能な URL を介して公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="f8d15-190">これにより、アプリケーションからリソースが切り離され、交換可能になります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="f8d15-191">5</span><span class="sxs-lookup"><span data-stu-id="f8d15-191">5</span></span> | <span data-ttu-id="f8d15-192">ビルド、リリース、実行</span><span class="sxs-lookup"><span data-stu-id="f8d15-192">Build, Release, Run</span></span> | <span data-ttu-id="f8d15-193">各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を強制する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="f8d15-194">それぞれが一意の ID でタグ付けされ、ロールバックする機能をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="f8d15-195">最新のCI/CDシステムは、この原則を達成するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="f8d15-196">6</span><span class="sxs-lookup"><span data-stu-id="f8d15-196">6</span></span> | <span data-ttu-id="f8d15-197">処理</span><span class="sxs-lookup"><span data-stu-id="f8d15-197">Processes</span></span> | <span data-ttu-id="f8d15-198">各マイクロサービスは、他の実行中のサービスから分離された独自のプロセスで実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="f8d15-199">分散キャッシュやデータ ストアなどのバッキング サービスに必要な状態を外部化します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="f8d15-200">7</span><span class="sxs-lookup"><span data-stu-id="f8d15-200">7</span></span> | <span data-ttu-id="f8d15-201">[ポートのバインド]</span><span class="sxs-lookup"><span data-stu-id="f8d15-201">Port Binding</span></span> | <span data-ttu-id="f8d15-202">各マイクロサービスは、独自のポートで公開されるインターフェイスと機能を持つ自己完結型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="f8d15-203">これにより、他のマイクロサービスから分離できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="f8d15-204">8</span><span class="sxs-lookup"><span data-stu-id="f8d15-204">8</span></span> | <span data-ttu-id="f8d15-205">コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="f8d15-205">Concurrency</span></span> | <span data-ttu-id="f8d15-206">サービスは、利用可能な最も強力なマシン上の単一の大規模なインスタンスをスケールアップするのではなく、多数の小さな同一プロセス (コピー) にまたがってスケールアウトします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="f8d15-207">9</span><span class="sxs-lookup"><span data-stu-id="f8d15-207">9</span></span> | <span data-ttu-id="f8d15-208">ディスポスタビリティ</span><span class="sxs-lookup"><span data-stu-id="f8d15-208">Disposability</span></span> | <span data-ttu-id="f8d15-209">サービス インスタンスは、システムを正しい状態にする場合は、高速スタートアップを優先してスケーラビリティの機会を増やし、適切なシャットダウンを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="f8d15-210">Docker コンテナーとオーケストレーターは、本質的にこの要件を満たします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="f8d15-211">10</span><span class="sxs-lookup"><span data-stu-id="f8d15-211">10</span></span> | <span data-ttu-id="f8d15-212">開発/プロッド パリティ</span><span class="sxs-lookup"><span data-stu-id="f8d15-212">Dev/Prod Parity</span></span> | <span data-ttu-id="f8d15-213">アプリケーションのライフサイクル全体にわたって環境を可能な限り同じに保ち、コストのかかるショートカットを回避します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="f8d15-214">ここでは、同じ実行環境を推進することで、コンテナの採用に大きく貢献できる。</span><span class="sxs-lookup"><span data-stu-id="f8d15-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="f8d15-215">11</span><span class="sxs-lookup"><span data-stu-id="f8d15-215">11</span></span> | <span data-ttu-id="f8d15-216">ログ記録</span><span class="sxs-lookup"><span data-stu-id="f8d15-216">Logging</span></span> | <span data-ttu-id="f8d15-217">マイクロサービスによって生成されたログをイベント ストリームとして扱います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="f8d15-218">イベント アグリゲータを使用して処理し、データを Azure Monitor や Splunk などのデータ マイニング/ログ管理ツールに反映し、最終的には長期的なアーカイブを行います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="f8d15-219">12</span><span class="sxs-lookup"><span data-stu-id="f8d15-219">12</span></span> | <span data-ttu-id="f8d15-220">管理プロセス</span><span class="sxs-lookup"><span data-stu-id="f8d15-220">Admin Processes</span></span> | <span data-ttu-id="f8d15-221">管理/管理タスクを一時処理として実行します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="f8d15-222">タスクには、レポートのデータクリーンアップとプル分析を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="f8d15-223">これらのタスクを実行するツールは、アプリケーションとは別に、運用環境から呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="f8d15-224">本の中で、 [十二因子アプリを超えて](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), 著者ケビン・ホフマンは、元の12の要因のそれぞれを詳述します (2011年に書かれました).</span><span class="sxs-lookup"><span data-stu-id="f8d15-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="f8d15-225">さらに、この書籍には、今日の最新のクラウド アプリケーションの設計を反映する 3 つの追加要素が示されています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-225">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="f8d15-226">新しい要因</span><span class="sxs-lookup"><span data-stu-id="f8d15-226">New Factor</span></span> | <span data-ttu-id="f8d15-227">説明</span><span class="sxs-lookup"><span data-stu-id="f8d15-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="f8d15-228">13</span><span class="sxs-lookup"><span data-stu-id="f8d15-228">13</span></span> | <span data-ttu-id="f8d15-229">API ファースト</span><span class="sxs-lookup"><span data-stu-id="f8d15-229">API First</span></span> | <span data-ttu-id="f8d15-230">すべてをサービスにします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-230">Make everything a service.</span></span> <span data-ttu-id="f8d15-231">コードがフロントエンド クライアント、ゲートウェイ、または別のサービスによって使用されると仮定します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="f8d15-232">14</span><span class="sxs-lookup"><span data-stu-id="f8d15-232">14</span></span> | <span data-ttu-id="f8d15-233">製品利用統計情報</span><span class="sxs-lookup"><span data-stu-id="f8d15-233">Telemetry</span></span> | <span data-ttu-id="f8d15-234">ワークステーションでは、アプリケーションとその動作を詳細に把握できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="f8d15-235">クラウドでは、あなたはしません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-235">In the cloud, you don't.</span></span> <span data-ttu-id="f8d15-236">監視、ドメイン固有、および正常性/システム データの収集が設計に含まれていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="f8d15-237">15</span><span class="sxs-lookup"><span data-stu-id="f8d15-237">15</span></span> | <span data-ttu-id="f8d15-238">認証/承認</span><span class="sxs-lookup"><span data-stu-id="f8d15-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="f8d15-239">最初から ID を実装します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-239">Implement identity from the start.</span></span> <span data-ttu-id="f8d15-240">パブリック クラウドで利用できる[RBAC (ロールベースのアクセス制御)](https://docs.microsoft.com/azure/role-based-access-control/overview)機能を検討してください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-240">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="f8d15-241">この章と本の中の12以上の要因の多くを参照します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="f8d15-242">設計上の重要な考慮事項</span><span class="sxs-lookup"><span data-stu-id="f8d15-242">Critical Design Considerations</span></span>

<span data-ttu-id="f8d15-243">12 要素の方法論から提供されるガイダンスを超えて、分散システムを構築する際に行う必要があるいくつかの重要な設計上の決定があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="f8d15-244">*通信*</span><span class="sxs-lookup"><span data-stu-id="f8d15-244">*Communication*</span></span>

<span data-ttu-id="f8d15-245">フロントエンド クライアント アプリケーションは、バックエンドのコア サービスとどのように通信しますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="f8d15-246">直接コミュニケーションを許可しますか?</span><span class="sxs-lookup"><span data-stu-id="f8d15-246">Will you allow direct communication?</span></span> <span data-ttu-id="f8d15-247">または、柔軟性、制御、およびセキュリティを提供するゲートウェイ ファサードを使用してバックエンド サービスを抽象化する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="f8d15-248">バックエンドコアサービスは、どのように相互に通信しますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="f8d15-249">直接的な HTTP 呼び出しを許可して、パフォーマンスと俊敏性に影響を与える可能性がありますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="f8d15-250">または、キューとトピックのテクノロジを使用して、メッセージングを分離することを検討する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="f8d15-251">コミュニケーションの詳細については、第 4 章*クラウド ネイティブの通信パターンを説明*します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="f8d15-252">*回復性*</span><span class="sxs-lookup"><span data-stu-id="f8d15-252">*Resiliency*</span></span>

<span data-ttu-id="f8d15-253">マイクロサービス アーキテクチャは、システムをインプロセスからネットワーク通信に移行します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-253">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="f8d15-254">分散環境では、サービス B がサービス A からの呼び出しに応答しない場合は、どのような操作を行いますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-254">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="f8d15-255">サービス C が一時的に利用できなくなり、サービス C を呼び出す他のサービスがスタックし、システムのパフォーマンスが低下した場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-255">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="f8d15-256">復元力については、6 章クラウド*ネイティブの復元力*について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="f8d15-257">*分散データ*</span><span class="sxs-lookup"><span data-stu-id="f8d15-257">*Distributed Data*</span></span>

<span data-ttu-id="f8d15-258">仕様上、各マイクロサービスは独自のデータをカプセル化し、パブリック インターフェイスを介して操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="f8d15-259">その場合、データをクエリしたり、複数のサービス間でトランザクションを実装したりする方法はありますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="f8d15-260">分散データについては、第 5 章*クラウド ネイティブ データ パターン*で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="f8d15-261">*ID*</span><span class="sxs-lookup"><span data-stu-id="f8d15-261">*Identity*</span></span>

<span data-ttu-id="f8d15-262">サービスは、アクセスするユーザーと、そのサービスにアクセスできるアクセス許可をどのように識別しますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="f8d15-263">アイデンティティについては、第8章 の*アイデンティティについて詳しく説明*しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="f8d15-264">マイクロサービス</span><span class="sxs-lookup"><span data-stu-id="f8d15-264">Microservices</span></span>

<span data-ttu-id="f8d15-265">クラウド ネイティブ システムは、最新のアプリケーションを構築するための一般的なアーキテクチャ スタイルであるマイクロサービスを採用しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="f8d15-266">共有ファブリックを介して対話する小規模で独立したサービスの分散セットとして構築されたマイクロサービスは、次の特性を共有します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="f8d15-267">各ユーザーは、より大きなドメイン コンテキスト内で特定のビジネス機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="f8d15-268">それぞれが自律的に開発され、独立して展開することができます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="f8d15-269">それぞれが独自のデータストレージ技術(SQL、NoSQL)とプログラミングプラットフォームをカプセル化しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="f8d15-270">それぞれが独自のプロセスで実行され、HTTP/HTTPS、WebSockets、AMQPなどの標準通信プロトコルを使用して他[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)のユーザーと通信します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="f8d15-271">それらは、アプリケーションを形成するために一緒に構成します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-271">They compose together to form an application.</span></span>

<span data-ttu-id="f8d15-272">図 1-4 は、マイクロサービス アプローチとモノリシック アプリケーション アプローチを対比したものです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="f8d15-273">モノリスが、単一のプロセスで実行される階層化アーキテクチャで構成されている方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="f8d15-274">通常、リレーショナル データベースを使用します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-274">It typically consumes a relational database.</span></span> <span data-ttu-id="f8d15-275">ただし、マイクロサービスのアプローチでは、機能がロジックとデータを含む独立したサービスに分離されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="f8d15-276">各マイクロサービスは、独自のデータストアをホストします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-276">Each microservice hosts its own datastore.</span></span>

![モノリシック展開とマイクロサービス](./media/monolithic-vs-microservices.png)

<span data-ttu-id="f8d15-278">**図1-4。**</span><span class="sxs-lookup"><span data-stu-id="f8d15-278">**Figure 1-4.**</span></span> <span data-ttu-id="f8d15-279">モノリシック展開とマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="f8d15-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="f8d15-280">マイクロサービスが、この章で前に説明した[12 要素アプリケーション](https://12factor.net/)から「1 つのコードベース、1 つのアプリケーション」の原則をどのように推進しているかを確認します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="f8d15-281">*演算\#項目 1 は、"マイクロサービスごとに 1 つのコードベースを指定し、独自のリポジトリに格納します。バージョン管理で追跡することで、複数の環境に展開できます。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="f8d15-282">マイクロサービスについて</span><span class="sxs-lookup"><span data-stu-id="f8d15-282">Why microservices?</span></span>

<span data-ttu-id="f8d15-283">マイクロサービスは機敏性を提供します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-283">Microservices provide agility.</span></span>

<span data-ttu-id="f8d15-284">この章の前半では、モノリスとして構築された e コマース アプリケーションをマイクロサービスと比較しました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="f8d15-285">この例では、明確な利点を示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="f8d15-286">各マイクロサービスには自律的なライフサイクルがあり、独立して進化し、頻繁にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="f8d15-287">新しい機能や更新プログラムを展開するために、四半期ごとのリリースを待つ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="f8d15-288">複雑なアプリケーションの小さな領域を更新し、システム全体を混乱させるリスクを軽減できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="f8d15-289">各マイクロサービスは、個別にスケールできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-289">Each microservice can scale independently.</span></span> <span data-ttu-id="f8d15-290">アプリケーション全体を単一のユニットとして拡張するのではなく、処理能力やネットワーク帯域幅を必要とするサービスのみをスケールアウトします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="f8d15-291">このきめ細かなスケーリングアプローチにより、システムの制御性が向上し、すべてではなくシステムの一部をスケールする際に全体的なコストを削減できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="f8d15-292">マイクロサービスを理解するための優れたリファレンス ガイドは[、.NET マイクロサービス: コンテナー化された .NET アプリケーションのアーキテクチャです](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。</span><span class="sxs-lookup"><span data-stu-id="f8d15-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="f8d15-293">本書では、マイクロサービスの設計とアーキテクチャについて詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="f8d15-294">これは、Microsoft から無料でダウンロードできる[フルスタック マイクロサービスリファレンス アーキテクチャ](https://github.com/dotnet-architecture/eShopOnContainers)のコンパニオンです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="f8d15-295">マイクロサービスの開発</span><span class="sxs-lookup"><span data-stu-id="f8d15-295">Developing microservices</span></span>

<span data-ttu-id="f8d15-296">マイクロサービスは、あらゆる最新の開発プラットフォームで作成できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="f8d15-297">Net コア プラットフォームは優れた選択肢です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="f8d15-298">無料でオープンソースで、マイクロサービス開発を簡素化する多くの組み込み機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="f8d15-299">.NET Core はクロスプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="f8d15-300">アプリケーションは、Windows、macOS、および Linux のほとんどのフレーバーで構築および実行できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="f8d15-301">.NET Core はパフォーマンスが高く、Node.js やその他の競合プラットフォームと比較して優れたスコアを獲得しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="f8d15-302">興味深いことに[、TechEmpower](https://www.techempower.com/)は、多くの Web アプリケーション プラットフォームとフレームワークにわたって、広範な[パフォーマンス ベンチマーク](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)を実施しました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="f8d15-303">.NET Core はトップ 10 に入った - Node.js と他の競合するプラットフォームをはるかに上回っています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="f8d15-304">.NET Core は、マイクロソフトと GitHub の .NET コミュニティによって管理されています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="f8d15-305">Containers</span><span class="sxs-lookup"><span data-stu-id="f8d15-305">Containers</span></span>

<span data-ttu-id="f8d15-306">今日では、*クラウドネイティブ*に関する会話で言及された*コンテナ*という用語を聞くのは当然です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="f8d15-307">著者のコーネリア・デイビスは、「コンテナはクラウド[ネイティブ](https://www.manning.com/books/cloud-native-patterns)ソフトウェアの偉大なイネーブラーです」と述べています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="f8d15-308">クラウド ネイティブ コンピューティングファウンデーションでは、[クラウド ネイティブ のトレイル マップ](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)の最初のステップとしてマイクロサービスのコンテナー化を行います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="f8d15-309">マイクロサービスのコンテナー化は簡単で簡単です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="f8d15-310">コード、その依存関係、およびランタイムは、[コンテナー イメージ](https://docs.docker.com/glossary/?term=image)と呼ばれるバイナリにパッケージ化されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="f8d15-311">イメージは[、イメージ](https://caylent.com/container-registries/)のリポジトリまたはライブラリとして機能するコンテナー レジストリに格納されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="f8d15-312">レジストリは、開発用コンピューター、データセンター、またはパブリック クラウドに配置できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="f8d15-313">Docker 自体は[、Docker Hub](https://hub.docker.com/)経由でパブリック レジストリを維持します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="f8d15-314">Azure クラウドには、[コンテナー](https://azure.microsoft.com/services/container-registry/)イメージを実行するクラウド アプリケーションの近くに格納するためのコンテナー レジストリが備わっています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="f8d15-315">必要に応じて、イメージを実行中のコンテナインスタンスに変換します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="f8d15-316">インスタンスは[、コンテナー ランタイム](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)エンジンがインストールされているコンピューターで実行されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="f8d15-317">コンテナー化されたサービスのインスタンスは、必要に応じていくつでも持つことができます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="f8d15-318">図 1-5 は、それぞれが 1 つのホストで実行されている、それぞれ独自のコンテナー内の 3 つの異なるマイクロサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![コンテナー ホストで実行されている複数のコンテナー](./media/hosting-mulitple-containers.png)

<span data-ttu-id="f8d15-320">**図 1-5**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-320">**Figure 1-5**.</span></span> <span data-ttu-id="f8d15-321">コンテナー ホストで実行されている複数のコンテナー</span><span class="sxs-lookup"><span data-stu-id="f8d15-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="f8d15-322">各コンテナーが独自の依存関係とランタイムのセットを維持する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="f8d15-323">ここでは、同じホストで実行されている製品マイクロサービスの異なるバージョンが表示されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="f8d15-324">各コンテナーは、基になるホスト オペレーティング システム、メモリ、およびプロセッサのスライスを共有しますが、互いに分離されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="f8d15-325">コンテナモデルが[十二要素アプリケーション](https://12factor.net/)の「依存関係」原理をどの程度受け入れるかに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="f8d15-326">*演算\#項目 2 は、「各マイクロサービスは、システム全体に影響を与えずに変更を受け入れ、独自の依存関係を分離してパッケージ化する」と指定しています。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="f8d15-327">コンテナーは、Linux ワークロードと Windows ワークロードの両方をサポートします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="f8d15-328">Azure クラウドは、両方を公然と受け入れています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="f8d15-329">興味深いことに、Azure で最も人気のあるオペレーティング システムとなっているのは、Windows サーバーではなく Linux です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="f8d15-330">いくつかのコンテナベンダーが存在する一方で、Dockerは市場のライオンのシェアを獲得しました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="f8d15-331">同社はソフトウェアコンテナの動きを推進してきました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="f8d15-332">クラウド ネイティブ アプリケーションのパッケージ化、デプロイ、実行の事実上の標準となっています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="f8d15-333">なぜコンテナ?</span><span class="sxs-lookup"><span data-stu-id="f8d15-333">Why containers?</span></span>

<span data-ttu-id="f8d15-334">コンテナは、移植性を提供し、環境間で一貫性を保証します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="f8d15-335">すべてを 1 つのパッケージにカプセル化することで、マイクロサービスとその依存関係を基盤となるインフラストラクチャから*分離*できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="f8d15-336">Docker ランタイム エンジンを持つ環境では、同じコンテナーをデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="f8d15-337">コンテナー化されたワークロードでは、フレームワーク、ソフトウェア ライブラリ、およびランタイム エンジンを使用して各環境を事前に構成するコストも削減できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="f8d15-338">基になるオペレーティング システムとホスト リソースを共有することで、コンテナーのフットプリントは、完全な仮想マシンよりもはるかに小さくなります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="f8d15-339">サイズが小さいほど、特定のホストが一度に実行できる *、マイクロ*サービスの密度 (数) が増加します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="f8d15-340">コンテナーのオーケストレーション</span><span class="sxs-lookup"><span data-stu-id="f8d15-340">Container orchestration</span></span>

<span data-ttu-id="f8d15-341">Docker などのツールはイメージを作成し、コンテナーを実行しますが、それらを管理するためのツールも必要です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="f8d15-342">コンテナ管理は、コンテナオーケストレーターと呼ばれる特別なソフトウェアプログラムで行います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="f8d15-343">規模で動作する場合、コンテナー オーケストレーションは不可欠です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="f8d15-344">図 1-6 に、コンテナー オーケストレーターが提供する管理タスクを示します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![コンテナオーケストレーターが行うこと](./media/what-container-orchestrators-do.png)

<span data-ttu-id="f8d15-346">**図 1-6**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-346">**Figure 1-6**.</span></span> <span data-ttu-id="f8d15-347">コンテナオーケストレーターが行うこと</span><span class="sxs-lookup"><span data-stu-id="f8d15-347">What container orchestrators do</span></span>

<span data-ttu-id="f8d15-348">次の表は、一般的なオーケストレーション タスクを示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="f8d15-349">タスク</span><span class="sxs-lookup"><span data-stu-id="f8d15-349">Tasks</span></span> | <span data-ttu-id="f8d15-350">説明</span><span class="sxs-lookup"><span data-stu-id="f8d15-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="f8d15-351">スケジュール設定</span><span class="sxs-lookup"><span data-stu-id="f8d15-351">Scheduling</span></span> | <span data-ttu-id="f8d15-352">コンテナインスタンスを自動的にプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="f8d15-353">アフィニティ/アンチアフィニティー</span><span class="sxs-lookup"><span data-stu-id="f8d15-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="f8d15-354">コンテナーを近くまたは離れた状態でプロビジョニングし、可用性とパフォーマンスを向上させます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="f8d15-355">正常性の監視</span><span class="sxs-lookup"><span data-stu-id="f8d15-355">Health monitoring</span></span> | <span data-ttu-id="f8d15-356">障害を自動的に検出して修正します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="f8d15-357">[フェールオーバー]</span><span class="sxs-lookup"><span data-stu-id="f8d15-357">Failover</span></span> | <span data-ttu-id="f8d15-358">正常なマシンに障害が発生したインスタンスを自動的に再プロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="f8d15-359">Scaling</span><span class="sxs-lookup"><span data-stu-id="f8d15-359">Scaling</span></span> | <span data-ttu-id="f8d15-360">要求に合わせて、コンテナー インスタンスを自動的に追加または削除します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="f8d15-361">ネットワーク</span><span class="sxs-lookup"><span data-stu-id="f8d15-361">Networking</span></span> | <span data-ttu-id="f8d15-362">コンテナ通信用のネットワーク オーバーレイを管理する。</span><span class="sxs-lookup"><span data-stu-id="f8d15-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="f8d15-363">サービス探索</span><span class="sxs-lookup"><span data-stu-id="f8d15-363">Service Discovery</span></span> | <span data-ttu-id="f8d15-364">コンテナが互いを見つけ合えるようにします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="f8d15-365">ローリングアップグレード</span><span class="sxs-lookup"><span data-stu-id="f8d15-365">Rolling Upgrades</span></span> | <span data-ttu-id="f8d15-366">ダウンタイムゼロの展開で増分アップグレードを調整します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="f8d15-367">問題のある変更を自動的にロールバックします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="f8d15-368">オーケストレーターが、この章で前に説明した[12 要素アプリケーション](https://12factor.net/)のディスポジビリティと同時実行性の原則をどのように受け入れるかについて注意してください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="f8d15-369">*演算\#項目 9 は、「サービス インスタンスは使い捨て可能で、高速スタートアップを優先してスケーラビリティの機会を増やし、システムを正しい状態にするグレースフル シャットダウンを優先する必要があります。Docker コンテナーとオーケストレーターは、本質的にこの要件を満たしています。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="f8d15-370">*第\#8 段階では、「サービスは、利用可能な最も強力なマシン上の単一の大きなインスタンスをスケールアップするのではなく、多数の小さな同一プロセス (コピー) にスケールアウトします。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="f8d15-371">いくつかのコンテナオーケストレーターが存在する一方で[、Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)はクラウドネイティブの世界の事実上の標準となっています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="f8d15-372">コンテナ化されたワークロードを管理するための、移植可能で拡張性のあるオープンソースプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="f8d15-373">Kubernetes の独自のインスタンスをホストすることもできますが、その後、リソースのプロビジョニングと管理を担当する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="f8d15-374">Azure クラウドは、管理されたサービスである[Azure Kubernetes サービス (AKS) として Kubernetes を](https://azure.microsoft.com/services/kubernetes-service/)備えています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="f8d15-375">マネージド サービスを使用すると、その機能を完全に活用でき、インストールと保守を行う必要がありません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="f8d15-376">Azure Kubernetes サービスについては、詳細について説明します 2 章 クラウド*ネイティブ アプリケーションのスケーリング*.</span><span class="sxs-lookup"><span data-stu-id="f8d15-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="f8d15-377">バッキングサービス</span><span class="sxs-lookup"><span data-stu-id="f8d15-377">Backing services</span></span>

<span data-ttu-id="f8d15-378">クラウド ネイティブ システムは、データ ストア、メッセージ ブローカー、監視、ID サービスなど、さまざまな補助リソースに依存します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="f8d15-379">これらのサービスは、[バッキング サービス](https://12factor.net/backing-services)と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="f8d15-380">図 1-7 は、クラウド ネイティブ システムが使用する多くの一般的なバッキング サービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![共通のバッキングサービス](./media/common-backing-services.png)

<span data-ttu-id="f8d15-382">**図 1-7**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-382">**Figure 1-7**.</span></span> <span data-ttu-id="f8d15-383">共通のバッキングサービス</span><span class="sxs-lookup"><span data-stu-id="f8d15-383">Common backing services</span></span>

<span data-ttu-id="f8d15-384">支援サービスは、この章の前半で説明した[12要素アプリケーション](https://12factor.net/)から「無国籍」原則を推進しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="f8d15-385">*演算\#項目 6*では、「各マイクロサービスは、他の実行中のサービスから分離された独自のプロセスで実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="f8d15-386">分散キャッシュやデータ ストアなどのバッキング サービスに必要な状態を外部化します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="f8d15-387">独自のバッキング サービスをホストすることもできますが、その後、これらのリソースのライセンス付与、プロビジョニング、管理を担当します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="f8d15-388">クラウド プロバイダーは、*豊富な種類の管理されたバッキング サービスを提供します。*</span><span class="sxs-lookup"><span data-stu-id="f8d15-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="f8d15-389">サービスを所有する代わりに、単にそれを消費します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="f8d15-390">プロバイダは、大規模なリソースを運用し、パフォーマンス、セキュリティ、および保守に責任を負います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="f8d15-391">監視、冗長性、可用性はサービスに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="f8d15-392">プロバイダはマネージドサービスを完全にサポートしています - チケットを開くと、問題が解決されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="f8d15-393">クラウドネイティブシステムは、クラウドベンダーの管理バッキングサービスを優先します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="f8d15-394">時間と労力の節約は大きい。</span><span class="sxs-lookup"><span data-stu-id="f8d15-394">The savings in time and labor are great.</span></span> <span data-ttu-id="f8d15-395">あなた自身をホストし、トラブルを経験する運用上のリスクは、高速で高価になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="f8d15-396">ベスト プラクティスは、外部構成に格納された情報 (URL と資格情報) を含むマイクロサービスに動的にバインドされた、*アタッチされたリソース*としてバッキング サービスを扱います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="f8d15-397">このガイダンスは、この章の前半で説明した[12 要素アプリケーション](https://12factor.net/)で説明されています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="f8d15-398">*演算\#項目 4*は、バッキング サービスをアドレス指定可能な URL を介して公開することを指定します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="f8d15-399">これにより、アプリケーションからリソースが切り離され、交換可能になります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="f8d15-400">*演算\#項目 3*は、「構成情報はマイクロサービスから移動され、コードの外部の構成管理ツールを通じて外部化される」と指定します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="f8d15-401">このパターンでは、コードを変更せずにバッキング サービスをアタッチおよびデタッチできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="f8d15-402">マイクロサービスを QA からステージング環境に昇格させる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="f8d15-403">マイクロサービス構成を更新してステージングのバッキング サービスをポイントし、環境変数を使用してコンテナーに設定を挿入します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="f8d15-404">クラウド ベンダーは、独自のバッキング サービスと通信するための API を提供します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="f8d15-405">これらのライブラリは、配管と複雑さをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="f8d15-406">これらの API と直接通信すると、コードがバッキング サービスに密接に結合されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="f8d15-407">ベンダー API の実装の詳細を絶縁する方が良い方法です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="f8d15-408">仲介レイヤー (中間 API) を導入し、サービス コードに汎用操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="f8d15-409">この疎結合により、1 つのバッキング サービスを別のバッキング サービスに交換したり、メインライン サービス コードを変更することなくコードを別のパブリック クラウドに移動したりできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="f8d15-410">バッキング サービスについては、第 5 章、*クラウド ネイティブ データ パターン*、および第 4 章*のクラウド ネイティブ通信パターン*について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="f8d15-411">オートメーション</span><span class="sxs-lookup"><span data-stu-id="f8d15-411">Automation</span></span>

<span data-ttu-id="f8d15-412">ご覧のとおり、クラウド ネイティブ システムにはマイクロサービス、コンテナー、モダン システム設計が採用されており、スピードと俊敏性を実現できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="f8d15-413">しかし、それは物語の一部に過ぎません。</span><span class="sxs-lookup"><span data-stu-id="f8d15-413">But, that's only part of the story.</span></span> <span data-ttu-id="f8d15-414">これらのシステムを実行するクラウド環境をどのようにプロビジョニングしますか。</span><span class="sxs-lookup"><span data-stu-id="f8d15-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="f8d15-415">アプリの機能と更新プログラムを迅速に展開する方法</span><span class="sxs-lookup"><span data-stu-id="f8d15-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="f8d15-416">どのように全体像を丸めるのですか?</span><span class="sxs-lookup"><span data-stu-id="f8d15-416">How do you round out the full picture?</span></span>

<span data-ttu-id="f8d15-417">広く受け入れられているインフラストラクチャのプラクティスをコード 、または IaC[として](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)入力します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-417">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="f8d15-418">IaC を使用すると、プラットフォームのプロビジョニングとアプリケーションの展開を自動化できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="f8d15-419">基本的には、テストやバージョン管理などのソフトウェア エンジニアリングプラクティスを DevOps プラクティスに適用します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="f8d15-420">インフラストラクチャと展開は自動化され、一貫性があり、繰り返し可能です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="f8d15-421">インフラストラクチャの自動化</span><span class="sxs-lookup"><span data-stu-id="f8d15-421">Automating infrastructure</span></span>

<span data-ttu-id="f8d15-422">Azure[リソース マネージャー](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform、および[Azure CLI](https://docs.microsoft.com/cli/azure/)などのツールを使用すると、必要なクラウド インフラストラクチャを宣言的にスクリプト化できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-422">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="f8d15-423">リソース名、場所、容量、およびシークレットはパラメーター化され、動的です。</span><span class="sxs-lookup"><span data-stu-id="f8d15-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="f8d15-424">スクリプトはバージョン管理され、プロジェクトの成果物としてソース管理にチェックインされます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="f8d15-425">QA、ステージング、本番などのシステム環境全体で一貫性のある繰り返し可能なインフラストラクチャをプロビジョニングするには、スクリプトを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="f8d15-426">このフードの下では、IaCはべき等であり、副作用を伴わずに同じスクリプトを何度も実行できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="f8d15-427">チームが変更を加える必要がある場合は、スクリプトを編集して再実行します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="f8d15-428">更新されたリソースのみが影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="f8d15-429">記事では、[コードとしてのインフラストラクチャとは何か](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)、著者サム・グッケンハイマーは、「IaCを実装するチームは、迅速かつ大規模に安定した環境を提供することができます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-429">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="f8d15-430">チームは、手動で環境を構成することを回避し、コードを使用して環境の目的の状態を表すことによって整合性を強制します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="f8d15-431">IaC を使用したインフラストラクチャの展開は繰り返し可能であり、構成のドリフトや依存関係の欠落によって発生するランタイムの問題を防ぎます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="f8d15-432">DevOpsチームは、統一された一連のプラクティスとツールと連携して、アプリケーションとそのサポートインフラストラクチャを迅速かつ確実に、かつ大規模に提供できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="f8d15-433">展開の自動化</span><span class="sxs-lookup"><span data-stu-id="f8d15-433">Automating deployments</span></span>

<span data-ttu-id="f8d15-434">[前述の 12 要素アプリケーション](https://12factor.net/)では、完成したコードを実行中のアプリケーションに変換する場合に、個別の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="f8d15-435">*演算\#項目 5*は、「各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を強制する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="f8d15-436">それぞれが一意の ID でタグ付けされ、ロールバックする機能をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="f8d15-437">最新のCI/CDシステムは、この原則を達成するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="f8d15-438">これらは、個別の展開手順を提供し、ユーザーがすぐに利用できる一貫性のある高品質のコードを確保するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="f8d15-439">図 1-8 は、展開プロセス全体の分離を示しています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD パイプラインの展開手順](./media/build-release-run-pipeline.png)

<span data-ttu-id="f8d15-441">**図 1-8**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-441">**Figure 1-8**.</span></span> <span data-ttu-id="f8d15-442">CI/CD パイプラインでの展開手順</span><span class="sxs-lookup"><span data-stu-id="f8d15-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="f8d15-443">前の図では、タスクの分離に特に注意を払ってください。</span><span class="sxs-lookup"><span data-stu-id="f8d15-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="f8d15-444">開発者は、開発環境で、コードの "内部ループ" と呼ばれるものを反復処理し、実行し、デバッグする機能を構築します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="f8d15-445">完了すると、コードは GitHub、Azure DevOps、BitBucket などのコード リポジトリに*プッシュされます*。</span><span class="sxs-lookup"><span data-stu-id="f8d15-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="f8d15-446">このプッシュは、コードをバイナリアーティファクトに変換するビルドステージをトリガーします。</span><span class="sxs-lookup"><span data-stu-id="f8d15-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="f8d15-447">この作業は[、継続的インテグレーション (CI)](https://martinfowler.com/articles/continuousIntegration.html)パイプラインを使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="f8d15-448">アプリケーションのビルド、テスト、およびパッケージが自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="f8d15-449">リリース・ステージは、バイナリ成果物を取り出し、外部アプリケーションおよび環境構成情報を適用し、不変リリースを生成します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="f8d15-450">リリースは指定された環境にデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="f8d15-451">この作業は[、継続的デリバリー (CD)](https://martinfowler.com/bliki/ContinuousDelivery.html)パイプラインで実装されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="f8d15-452">各リリースは識別可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-452">Each release should be identifiable.</span></span> <span data-ttu-id="f8d15-453">"この展開は、アプリケーションのリリース 2.1.1 を実行しています" と言うことができます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="f8d15-454">最後に、リリースされた機能は、ターゲットの実行環境で実行されます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="f8d15-455">リリースは変更が不変であることを意味し、変更によって新しいリリースが作成される必要があります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="f8d15-456">これらのプラクティスを適用することで、組織はソフトウェアの出荷方法を根本的に進化させてきました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="f8d15-457">多くは四半期ごとのリリースからオンデマンド更新に移行しました。</span><span class="sxs-lookup"><span data-stu-id="f8d15-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="f8d15-458">目標は、問題を修正するコストが低い場合に、開発サイクルの早い段階で問題をキャッチすることです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="f8d15-459">統合の間の期間が長いほど、問題の解決にコストがかかります。</span><span class="sxs-lookup"><span data-stu-id="f8d15-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="f8d15-460">統合プロセスの一貫性により、チームはコード変更をより頻繁にコミットできるため、コラボレーションとソフトウェアの品質が向上します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="f8d15-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="f8d15-461">Azure Pipelines</span></span>

<span data-ttu-id="f8d15-462">Azure クラウドには、図 1-9 に示す[Azure DevOps](https://azure.microsoft.com/services/devops/)の提供の一部である Azure[パイプライン](https://azure.microsoft.com/services/devops/pipelines/)という新しい CI/CD サービスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![Azure パイプライン (DevOps)](./media/devops-components.png)

<span data-ttu-id="f8d15-464">**図 1-9**.</span><span class="sxs-lookup"><span data-stu-id="f8d15-464">**Figure 1-9**.</span></span> <span data-ttu-id="f8d15-465">Azure DevOps 製品</span><span class="sxs-lookup"><span data-stu-id="f8d15-465">Azure DevOps offerings</span></span>

<span data-ttu-id="f8d15-466">Azure パイプラインは、継続的インテグレーション (CI) と継続的デリバリー (CD) を組み合わせたクラウド サービスです。</span><span class="sxs-lookup"><span data-stu-id="f8d15-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="f8d15-467">コードを自動的にテスト、ビルド、および任意のターゲットに送信できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="f8d15-468">アプリの残りのコードと共に、YAML ファイル内のコードでパイプラインを定義します。</span><span class="sxs-lookup"><span data-stu-id="f8d15-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="f8d15-469">パイプラインはコードでバージョン管理され、同じ分岐構造に従います。</span><span class="sxs-lookup"><span data-stu-id="f8d15-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="f8d15-470">プル要求と分岐ビルド ポリシーのコード レビューを通じて、変更の検証を受けます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="f8d15-471">使用するすべてのブランチは、azure-pipelines.yml ファイルを変更することでビルドポリシーをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="f8d15-472">パイプライン ファイルはバージョン管理にチェックインされ、問題が発生した場合に調査できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="f8d15-473">Azure Pipelines サービスは、ほとんどの Git プロバイダーをサポートし、Linux、macOS、または Windows プラットフォームで記述されたアプリケーションのデプロイ パイプラインを生成できます。</span><span class="sxs-lookup"><span data-stu-id="f8d15-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="f8d15-474">これには、Java、.NET、JavaScript、Python、PHP、囲碁、XCode、およびC++のサポートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="f8d15-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f8d15-475">[前へ](introduction.md)
>[次へ](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="f8d15-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
