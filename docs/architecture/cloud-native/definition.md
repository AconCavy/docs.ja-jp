---
title: クラウド ネイティブの定義
description: クラウドネイティブシステムの基盤を提供する基本的な柱について説明します。
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 27191a67b2964ac2e1636a4d7dc55d5314b78439
ms.sourcegitcommit: 515469828d0f040e01bde01df6b8e4eb43630b06
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78675119"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="d110d-103">クラウドネイティブの定義</span><span class="sxs-lookup"><span data-stu-id="d110d-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="d110d-104">自分が行っていることと、同僚のテキスト10を停止します。</span><span class="sxs-lookup"><span data-stu-id="d110d-104">Stop what you’re doing and text 10 of your colleagues.</span></span> <span data-ttu-id="d110d-105">「クラウドネイティブ」という用語を定義するように依頼してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-105">Ask them to define the term “Cloud Native.”</span></span> <span data-ttu-id="d110d-106">これで、8つの異なる回答が得られる可能性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="d110d-106">Good chance you’ll get eight different answers.</span></span> <span data-ttu-id="d110d-107">興味深いことに、クラウドネイティブのテクノロジとプラクティスが進化するにつれて6か月後に、その定義が行われます。</span><span class="sxs-lookup"><span data-stu-id="d110d-107">Interestingly, six months from now, as cloud-native technologies and practices evolve, so will their definition.</span></span>

<span data-ttu-id="d110d-108">クラウドネイティブは、重要なビジネスシステムの構築について考える方法を変更することです。</span><span class="sxs-lookup"><span data-stu-id="d110d-108">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="d110d-109">クラウドネイティブシステムは、迅速な変更、大規模、および回復力を採用するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-109">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="d110d-110">クラウドネイティブコンピューティングファンデーションは、[公式の定義](https://github.com/cncf/foundation/blob/master/charter.md)を提供します。</span><span class="sxs-lookup"><span data-stu-id="d110d-110">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="d110d-111">*クラウドネイティブテクノロジを利用すると、パブリック、プライベート、ハイブリッドクラウドなどの最新の動的環境でスケーラブルなアプリケーションを構築し、実行することができます。コンテナー、サービスメッシュ、マイクロサービス、不変のインフラストラクチャ、および宣言型 Api は、この方法を知性します。*</span><span class="sxs-lookup"><span data-stu-id="d110d-111">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="d110d-112">*これらの手法は、回復性、管理性、監視可能な疎結合システムを実現します。堅牢な自動化と組み合わせることにより、エンジニアは働いを最小限に抑えながら、大きな影響を与える変化を頻繁に行うことができます。*</span><span class="sxs-lookup"><span data-stu-id="d110d-112">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="d110d-113">アプリケーションがますます複雑になり、ユーザーはさらに多くの要求を行うようになりました。</span><span class="sxs-lookup"><span data-stu-id="d110d-113">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="d110d-114">ユーザーは、迅速な応答性と革新的な機能を期待し、ダウンタイムをゼロにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-114">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="d110d-115">パフォーマンスの問題、繰り返し発生するエラー、および高速に移行できないことが許容されなくなりました。</span><span class="sxs-lookup"><span data-stu-id="d110d-115">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="d110d-116">これらのユーザーは、競合他社に簡単に移行できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-116">They'll easily move to your competitor.</span></span>

<span data-ttu-id="d110d-117">クラウドネイティブでは、*速度*と*機敏性*が大幅に向上しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-117">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="d110d-118">ビジネスシステムは、ビジネス機能を可能にして戦略的変革を実現し、ビジネスの速度と成長を加速させることに発展しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-118">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="d110d-119">市場でアイデアをすぐに得ることが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="d110d-119">It’s imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="d110d-120">ここでは、これらの手法を実装した企業をいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="d110d-120">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="d110d-121">実現したスピード、機敏性、およびスケーラビリティについて考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="d110d-121">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="d110d-122">[会社]</span><span class="sxs-lookup"><span data-stu-id="d110d-122">Company</span></span> | <span data-ttu-id="d110d-123">エクスペリエンス</span><span class="sxs-lookup"><span data-stu-id="d110d-123">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="d110d-124">Netflix</span><span class="sxs-lookup"><span data-stu-id="d110d-124">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="d110d-125">実稼働環境で600以上のサービスをご用意しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-125">Has 600+ services in production.</span></span> <span data-ttu-id="d110d-126">1日に100回デプロイします。</span><span class="sxs-lookup"><span data-stu-id="d110d-126">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="d110d-127">Uber</span><span class="sxs-lookup"><span data-stu-id="d110d-127">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="d110d-128">運用環境に1,000 を超えるサービスが格納されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-128">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="d110d-129">では、週ごとに数千のビルドがデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="d110d-129">Deploys several thousand builds each week.</span></span> |
| [<span data-ttu-id="d110d-130">WeChat</span><span class="sxs-lookup"><span data-stu-id="d110d-130">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="d110d-131">運用環境には300を超えるサービスがあります。</span><span class="sxs-lookup"><span data-stu-id="d110d-131">Has 300+ services in production.</span></span> <span data-ttu-id="d110d-132">1日に約1000の変更を行います。</span><span class="sxs-lookup"><span data-stu-id="d110d-132">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="d110d-133">ご覧のように、Netflix、Uber、w は、数百の独立したマイクロサービスで構成されるシステムを公開しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-133">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="d110d-134">このアーキテクチャスタイルを使用すると、市場の状況に迅速に対応できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-134">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="d110d-135">ライブで複雑なアプリケーションの小さな領域を瞬時に更新し、必要に応じてそれらの領域を個別にスケールできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-135">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="d110d-136">クラウドネイティブの速度と機敏性は、さまざまな要因によって発生します。</span><span class="sxs-lookup"><span data-stu-id="d110d-136">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="d110d-137">最も重要なのはクラウドインフラストラクチャです。</span><span class="sxs-lookup"><span data-stu-id="d110d-137">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="d110d-138">図1-3 に示す5つの追加の基本柱も、クラウドネイティブシステムの基盤を提供します。</span><span class="sxs-lookup"><span data-stu-id="d110d-138">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![クラウドネイティブの基本柱](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="d110d-140">**図 1-3**.</span><span class="sxs-lookup"><span data-stu-id="d110d-140">**Figure 1-3**.</span></span> <span data-ttu-id="d110d-141">クラウドネイティブの基本柱</span><span class="sxs-lookup"><span data-stu-id="d110d-141">Cloud-native foundational pillars</span></span>

<span data-ttu-id="d110d-142">各柱の有意性をさらに理解するために、少し時間を取ってみましょう。</span><span class="sxs-lookup"><span data-stu-id="d110d-142">Let’s take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="d110d-143">クラウド...</span><span class="sxs-lookup"><span data-stu-id="d110d-143">The cloud…</span></span>

<span data-ttu-id="d110d-144">クラウドネイティブシステムは、クラウドサービスモデルを最大限に活用します。</span><span class="sxs-lookup"><span data-stu-id="d110d-144">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="d110d-145">動的な仮想化されたクラウド環境で実現するように設計されたこれらのシステムでは、[サービスとしてのプラットフォーム (PaaS)](https://azure.microsoft.com/overview/what-is-paas/)コンピューティングインフラストラクチャと管理対象サービスが広く使用されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-145">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="d110d-146">基になるインフラストラクチャは、数分で*破棄*可能なプロビジョニング済みとして扱われ、オンデマンドでサイズ変更、拡大縮小、移動、または破棄されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-146">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="d110d-147">[ペットと家畜](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)の間で広く受け入れられている DevOps の概念を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-147">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="d110d-148">従来のデータセンターでは、サーバーは*ペット*として扱われます。物理マシンには、意味のある名前が与えられ、には紛れがあります。</span><span class="sxs-lookup"><span data-stu-id="d110d-148">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="d110d-149">同じコンピューター (スケールアップ) にリソースを追加することによって、スケーリングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-149">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="d110d-150">サーバーが病気になった場合、そのサーバーは正常性に戻ります。</span><span class="sxs-lookup"><span data-stu-id="d110d-150">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="d110d-151">サーバーが使用できなくなった場合、すべてのユーザーに通知されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-151">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="d110d-152">*家畜*サービスモデルは異なります。</span><span class="sxs-lookup"><span data-stu-id="d110d-152">The *Cattle* service model is different.</span></span> <span data-ttu-id="d110d-153">各インスタンスは、仮想マシンまたはコンテナーとしてプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-153">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="d110d-154">これらは同一であり、Service 01、Service 02 などのシステム識別子が割り当てられています。</span><span class="sxs-lookup"><span data-stu-id="d110d-154">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="d110d-155">さらに多くのもの (スケールアウト) を作成することによってスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-155">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="d110d-156">1つが使用できなくなった場合は、だれも通知しません。</span><span class="sxs-lookup"><span data-stu-id="d110d-156">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="d110d-157">家畜モデルは、*不変のインフラストラクチャ*を採用しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-157">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="d110d-158">サーバーが修復または変更されていません。</span><span class="sxs-lookup"><span data-stu-id="d110d-158">Servers aren't repaired or modified.</span></span> <span data-ttu-id="d110d-159">失敗した場合、または更新が必要な場合は、破棄され、新しいものがプロビジョニングされます (すべてのオートメーションを通じて実行されます)。</span><span class="sxs-lookup"><span data-stu-id="d110d-159">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="d110d-160">クラウドネイティブシステムは、家畜サービスモデルを採用しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-160">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="d110d-161">インフラストラクチャが実行されているコンピューターに関係なく、インフラストラクチャのスケールインまたはスケールアウトを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="d110d-161">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="d110d-162">Azure クラウドプラットフォームでは、自動スケーリング、自己復旧、および監視機能を備えた、この種類の高度なエラスティックインフラストラクチャがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="d110d-162">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="d110d-163">モダンデザイン</span><span class="sxs-lookup"><span data-stu-id="d110d-163">Modern design</span></span>

<span data-ttu-id="d110d-164">クラウドネイティブアプリを設計するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="d110d-164">How would you design a cloud-native app?</span></span> <span data-ttu-id="d110d-165">アーキテクチャはどのようなものでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d110d-165">What would your architecture look like?</span></span> <span data-ttu-id="d110d-166">どのような原則、パターン、およびベストプラクティスを遵守しますか。</span><span class="sxs-lookup"><span data-stu-id="d110d-166">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="d110d-167">インフラストラクチャと運用上の懸念事項はどのようなものですか。</span><span class="sxs-lookup"><span data-stu-id="d110d-167">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="d110d-168">12要素アプリケーション</span><span class="sxs-lookup"><span data-stu-id="d110d-168">The Twelve-Factor Application</span></span>

<span data-ttu-id="d110d-169">クラウドベースのアプリケーションを構築するための広く受け入れられた方法は、 [12 要素アプリケーション](https://12factor.net/)です。</span><span class="sxs-lookup"><span data-stu-id="d110d-169">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="d110d-170">ここでは、最新のクラウド環境向けに最適化されたアプリケーションを構築するために開発者が従う一連の原則と方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="d110d-170">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="d110d-171">環境間の移植性と宣言型の自動化には、特に注意が払われています。</span><span class="sxs-lookup"><span data-stu-id="d110d-171">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="d110d-172">Web ベースのアプリケーションにも該当しますが、多くの専門家は、クラウドネイティブアプリを構築するための堅固な基盤として考えています。</span><span class="sxs-lookup"><span data-stu-id="d110d-172">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="d110d-173">これらの原則に基づいて構築されたシステムでは、迅速にデプロイしてスケーリングし、市場の変化に迅速に対応する機能を追加できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-173">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="d110d-174">次の表は、12要素の手法を示しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-174">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="d110d-175">要素</span><span class="sxs-lookup"><span data-stu-id="d110d-175">Factor</span></span> | <span data-ttu-id="d110d-176">説明</span><span class="sxs-lookup"><span data-stu-id="d110d-176">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="d110d-177">1</span><span class="sxs-lookup"><span data-stu-id="d110d-177">1</span></span> | <span data-ttu-id="d110d-178">コードベース</span><span class="sxs-lookup"><span data-stu-id="d110d-178">Code Base</span></span> | <span data-ttu-id="d110d-179">各マイクロサービスの1つのコードベースが、独自のリポジトリに格納されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-179">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="d110d-180">バージョン管理で追跡され、複数の環境 (QA、ステージング、運用環境) にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-180">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="d110d-181">2</span><span class="sxs-lookup"><span data-stu-id="d110d-181">2</span></span> | <span data-ttu-id="d110d-182">依存関係</span><span class="sxs-lookup"><span data-stu-id="d110d-182">Dependencies</span></span> | <span data-ttu-id="d110d-183">各マイクロサービスは、独自の依存関係を分離およびパッケージ化し、システム全体に影響を与えることなく変更を行います。</span><span class="sxs-lookup"><span data-stu-id="d110d-183">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="d110d-184">3</span><span class="sxs-lookup"><span data-stu-id="d110d-184">3</span></span> | <span data-ttu-id="d110d-185">構成</span><span class="sxs-lookup"><span data-stu-id="d110d-185">Configurations</span></span>  | <span data-ttu-id="d110d-186">構成情報は、コードの外部にある構成管理ツールを使用して、マイクロサービスから外部化に移動されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-186">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="d110d-187">同じデプロイは、適切な構成が適用された環境間で伝達できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-187">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="d110d-188">4</span><span class="sxs-lookup"><span data-stu-id="d110d-188">4</span></span> | <span data-ttu-id="d110d-189">サービスのバックアップ</span><span class="sxs-lookup"><span data-stu-id="d110d-189">Backing Services</span></span> | <span data-ttu-id="d110d-190">補助リソース (データストア、キャッシュ、メッセージブローカー) は、アドレス指定可能な URL を介して公開する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-190">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="d110d-191">これにより、アプリケーションからリソースが分離され、それを交換可能にすることができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-191">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="d110d-192">5</span><span class="sxs-lookup"><span data-stu-id="d110d-192">5</span></span> | <span data-ttu-id="d110d-193">ビルド、リリース、実行</span><span class="sxs-lookup"><span data-stu-id="d110d-193">Build, Release, Run</span></span> | <span data-ttu-id="d110d-194">各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-194">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="d110d-195">各には一意の ID をタグ付けし、ロールバックの機能をサポートしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-195">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="d110d-196">最新の CI/CD システムは、この原則を満たすのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="d110d-196">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="d110d-197">6</span><span class="sxs-lookup"><span data-stu-id="d110d-197">6</span></span> | <span data-ttu-id="d110d-198">プロセス</span><span class="sxs-lookup"><span data-stu-id="d110d-198">Processes</span></span> | <span data-ttu-id="d110d-199">各マイクロサービスは、実行中の他のサービスから分離された独自のプロセスで実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-199">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="d110d-200">外部化は、分散キャッシュやデータストアなどのバッキングサービスに必要な状態を提供します。</span><span class="sxs-lookup"><span data-stu-id="d110d-200">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="d110d-201">7</span><span class="sxs-lookup"><span data-stu-id="d110d-201">7</span></span> | <span data-ttu-id="d110d-202">[ポートのバインド]</span><span class="sxs-lookup"><span data-stu-id="d110d-202">Port Binding</span></span> | <span data-ttu-id="d110d-203">各マイクロサービスは、独自のポートで公開されているインターフェイスと機能と共に自己完結している必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-203">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="d110d-204">これにより、他のマイクロサービスから分離されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-204">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="d110d-205">8</span><span class="sxs-lookup"><span data-stu-id="d110d-205">8</span></span> | <span data-ttu-id="d110d-206">コンカレンシー</span><span class="sxs-lookup"><span data-stu-id="d110d-206">Concurrency</span></span> | <span data-ttu-id="d110d-207">サービスは、最も強力なコンピューター上で1つの大きなインスタンスをスケールアップするのではなく、多数の小さな同一のプロセス (コピー) を使用してスケールアウトします。</span><span class="sxs-lookup"><span data-stu-id="d110d-207">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="d110d-208">9</span><span class="sxs-lookup"><span data-stu-id="d110d-208">9</span></span> | <span data-ttu-id="d110d-209">Disposability</span><span class="sxs-lookup"><span data-stu-id="d110d-209">Disposability</span></span> | <span data-ttu-id="d110d-210">サービスインスタンスは、システムを適切な状態に保つために、スケーラビリティの機会と正常なシャットダウンを向上させるために、優先 fast スタートアップにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-210">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="d110d-211">Docker コンテナーと orchestrator は、本質的にこの要件を満たしています。</span><span class="sxs-lookup"><span data-stu-id="d110d-211">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="d110d-212">10</span><span class="sxs-lookup"><span data-stu-id="d110d-212">10</span></span> | <span data-ttu-id="d110d-213">開発/運用のパリティ</span><span class="sxs-lookup"><span data-stu-id="d110d-213">Dev/Prod Parity</span></span> | <span data-ttu-id="d110d-214">アプリケーションライフサイクル全体の環境を可能な限り維持し、コストのかかるショートカットを回避します。</span><span class="sxs-lookup"><span data-stu-id="d110d-214">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="d110d-215">ここでは、同じ実行環境を昇格することで、コンテナーの導入が非常に困難になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-215">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="d110d-216">11</span><span class="sxs-lookup"><span data-stu-id="d110d-216">11</span></span> | <span data-ttu-id="d110d-217">ログ記録</span><span class="sxs-lookup"><span data-stu-id="d110d-217">Logging</span></span> | <span data-ttu-id="d110d-218">マイクロサービスによって生成されたログをイベントストリームとして扱います。</span><span class="sxs-lookup"><span data-stu-id="d110d-218">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="d110d-219">イベントアグリゲーターを使用して処理し、データをデータマイニング/ログ管理ツールに伝達します。これには Azure Monitor や、最終的には長期間のアーカイブが含まれます。</span><span class="sxs-lookup"><span data-stu-id="d110d-219">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="d110d-220">12</span><span class="sxs-lookup"><span data-stu-id="d110d-220">12</span></span> | <span data-ttu-id="d110d-221">管理プロセス</span><span class="sxs-lookup"><span data-stu-id="d110d-221">Admin Processes</span></span> | <span data-ttu-id="d110d-222">管理タスクと管理タスクを1回限りのプロセスとして実行します。</span><span class="sxs-lookup"><span data-stu-id="d110d-222">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="d110d-223">タスクには、レポートのデータクリーンアップとプル分析を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-223">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="d110d-224">これらのタスクを実行するツールは、運用環境から、アプリケーションとは別に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-224">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="d110d-225">この書籍では、 [12 要素アプリ以外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)に、2011で記述された元の12個の要素のそれぞれについて説明しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-225">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="d110d-226">さらに、今日の最新のクラウドアプリケーション設計を反映する3つの追加要素も提供されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-226">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="d110d-227">新しい係数</span><span class="sxs-lookup"><span data-stu-id="d110d-227">New Factor</span></span> | <span data-ttu-id="d110d-228">説明</span><span class="sxs-lookup"><span data-stu-id="d110d-228">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="d110d-229">13</span><span class="sxs-lookup"><span data-stu-id="d110d-229">13</span></span> | <span data-ttu-id="d110d-230">API 優先</span><span class="sxs-lookup"><span data-stu-id="d110d-230">API First</span></span> | <span data-ttu-id="d110d-231">すべてのサービスを作成します。</span><span class="sxs-lookup"><span data-stu-id="d110d-231">Make everything a service.</span></span> <span data-ttu-id="d110d-232">コードがフロントエンドクライアント、ゲートウェイ、または別のサービスによって使用されるとします。</span><span class="sxs-lookup"><span data-stu-id="d110d-232">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="d110d-233">14</span><span class="sxs-lookup"><span data-stu-id="d110d-233">14</span></span> | <span data-ttu-id="d110d-234">製品利用統計情報</span><span class="sxs-lookup"><span data-stu-id="d110d-234">Telemetry</span></span> | <span data-ttu-id="d110d-235">ワークステーションには、アプリケーションとその動作の詳細が表示されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-235">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="d110d-236">クラウドでは、そうではありません。</span><span class="sxs-lookup"><span data-stu-id="d110d-236">In the cloud, you don't.</span></span> <span data-ttu-id="d110d-237">監視、ドメイン固有、およびシステムデータのコレクションが設計に含まれていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="d110d-237">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="d110d-238">15</span><span class="sxs-lookup"><span data-stu-id="d110d-238">15</span></span> | <span data-ttu-id="d110d-239">認証/承認</span><span class="sxs-lookup"><span data-stu-id="d110d-239">Authentication/ Authorization</span></span>  | <span data-ttu-id="d110d-240">Start から id を実装します。</span><span class="sxs-lookup"><span data-stu-id="d110d-240">Implement identity from the start.</span></span> <span data-ttu-id="d110d-241">パブリッククラウドで利用できる[RBAC (ロールベースのアクセス制御)](https://docs.microsoft.com/azure/role-based-access-control/overview)機能を検討してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-241">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="d110d-242">この章では、12以上の要素の多くを紹介します。</span><span class="sxs-lookup"><span data-stu-id="d110d-242">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="d110d-243">重要な設計上の考慮事項</span><span class="sxs-lookup"><span data-stu-id="d110d-243">Critical Design Considerations</span></span>

<span data-ttu-id="d110d-244">12要素手法から提供されるガイダンス以外にも、分散システムを構築する際には、いくつかの重要な設計上の決定を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-244">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="d110d-245">*Communication*</span><span class="sxs-lookup"><span data-stu-id="d110d-245">*Communication*</span></span>

<span data-ttu-id="d110d-246">フロントエンドクライアントアプリケーションは、どのようにして、バックエンドのコアサービスと通信しますか。</span><span class="sxs-lookup"><span data-stu-id="d110d-246">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="d110d-247">直接通信を許可しますか?</span><span class="sxs-lookup"><span data-stu-id="d110d-247">Will you allow direct communication?</span></span> <span data-ttu-id="d110d-248">または、柔軟性、制御、およびセキュリティを提供するゲートウェイファサードを使用してバックエンドサービスを抽象化する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="d110d-248">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="d110d-249">バックエンドコアサービスが相互に通信する方法</span><span class="sxs-lookup"><span data-stu-id="d110d-249">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="d110d-250">結合につながる直接の HTTP 呼び出しを許可し、パフォーマンスと機敏性に影響を与えますか。</span><span class="sxs-lookup"><span data-stu-id="d110d-250">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="d110d-251">また、キューとトピックテクノロジを使用してメッセージングを分離することも考えられます。</span><span class="sxs-lookup"><span data-stu-id="d110d-251">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="d110d-252">通信の詳細については、「*クラウドネイティブの通信パターン*4」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-252">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="d110d-253">*回復性*</span><span class="sxs-lookup"><span data-stu-id="d110d-253">*Resiliency*</span></span>

<span data-ttu-id="d110d-254">マイクロサービスアーキテクチャは、システムをプロセス内からネットワーク通信に移動します。</span><span class="sxs-lookup"><span data-stu-id="d110d-254">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="d110d-255">分散環境では、サービス B がサービス A からの呼び出しに応答しない場合はどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d110d-255">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="d110d-256">サービス C が一時的に使用できなくなり、その他のサービスがスタックを呼び出し、システムパフォーマンスが低下した場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="d110d-256">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="d110d-257">回復性については、第6章「*クラウドネイティブの回復性*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-257">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="d110d-258">*分散データ*</span><span class="sxs-lookup"><span data-stu-id="d110d-258">*Distributed Data*</span></span>

<span data-ttu-id="d110d-259">仕様により、各マイクロサービスは独自のデータをカプセル化し、パブリックインターフェイスを介して操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="d110d-259">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="d110d-260">その場合、データを照会したり、複数のサービスにわたってトランザクションを実装したりするにはどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d110d-260">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="d110d-261">分散データの詳細については、「*クラウドネイティブデータパターン*5」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-261">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="d110d-262">*[ID]*</span><span class="sxs-lookup"><span data-stu-id="d110d-262">*Identity*</span></span>

<span data-ttu-id="d110d-263">サービスがアクセスしているユーザーとそのアクセス許可はどのように識別されますか。</span><span class="sxs-lookup"><span data-stu-id="d110d-263">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="d110d-264">Id の詳細については、「8. *id*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-264">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="d110d-265">マイクロサービス</span><span class="sxs-lookup"><span data-stu-id="d110d-265">Microservices</span></span>

<span data-ttu-id="d110d-266">クラウドネイティブシステムは、最新のアプリケーションを構築するための一般的なアーキテクチャスタイルであるマイクロサービスを採用しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-266">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="d110d-267">共有ファブリックを介してやり取りする小規模で独立したサービスの分散セットとして構築されたマイクロサービスは、次の特性を共有します。</span><span class="sxs-lookup"><span data-stu-id="d110d-267">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="d110d-268">各は、より大きなドメインコンテキスト内で特定のビジネス機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="d110d-268">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="d110d-269">各は自律的に開発され、個別にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-269">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="d110d-270">それぞれのデータストレージテクノロジ (SQL、NoSQL) およびプログラミングプラットフォームは自己完結型でカプセル化されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-270">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="d110d-271">それぞれが独自のプロセスで実行され、HTTP/HTTPS、Websocket、 [Amqp](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)などの標準的な通信プロトコルを使用して他のユーザーと通信します。</span><span class="sxs-lookup"><span data-stu-id="d110d-271">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="d110d-272">これらは、アプリケーションを形成するためにまとめられています。</span><span class="sxs-lookup"><span data-stu-id="d110d-272">They compose together to form an application.</span></span>

<span data-ttu-id="d110d-273">図1-4 は、モノリシックアプリケーションアプローチとマイクロサービスアプローチの違いを比較したものです。</span><span class="sxs-lookup"><span data-stu-id="d110d-273">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="d110d-274">モノリスは、1つのプロセスで実行される多層アーキテクチャで構成されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-274">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="d110d-275">通常、リレーショナルデータベースを消費します。</span><span class="sxs-lookup"><span data-stu-id="d110d-275">It typically consumes a relational database.</span></span> <span data-ttu-id="d110d-276">ただし、マイクロサービスアプローチは、ロジックとデータを含む独立したサービスに分離機能を備えています。</span><span class="sxs-lookup"><span data-stu-id="d110d-276">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="d110d-277">各マイクロサービスは、独自のデータストアをホストします。</span><span class="sxs-lookup"><span data-stu-id="d110d-277">Each microservice hosts its own datastore.</span></span>

![モノリシックデプロイとマイクロサービス](./media/monolithic-vs-microservices.png)

<span data-ttu-id="d110d-279">**図 1-4.**</span><span class="sxs-lookup"><span data-stu-id="d110d-279">**Figure 1-4.**</span></span> <span data-ttu-id="d110d-280">モノリシックデプロイとマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="d110d-280">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="d110d-281">「」で前述したように、マイクロサービスが[12 要素アプリケーション](https://12factor.net/)から "1 つのコードベース (1 つのアプリケーション)" プリンシパルを昇格する方法に注意してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-281">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="d110d-282">*係数 \#1 は、各マイクロサービスに対して1つのコードベースを指定し、そのリポジトリに格納します。バージョン管理を使用して追跡され、複数の環境に配置できます。 "*</span><span class="sxs-lookup"><span data-stu-id="d110d-282">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="d110d-283">マイクロサービスについて</span><span class="sxs-lookup"><span data-stu-id="d110d-283">Why microservices?</span></span>

<span data-ttu-id="d110d-284">マイクロサービスは機敏性を提供します。</span><span class="sxs-lookup"><span data-stu-id="d110d-284">Microservices provide agility.</span></span>

<span data-ttu-id="d110d-285">前の章では、マイクロサービスを使用したモノリスとして構築された電子商取引アプリケーションを比較しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-285">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="d110d-286">この例では、いくつかの明確な利点があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-286">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="d110d-287">各マイクロサービスには自律したライフサイクルがあり、個別に進化して頻繁に展開することができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-287">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="d110d-288">四半期ごとのリリースが新しい機能をデプロイしたり更新したりするまで待つ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="d110d-288">You don’t have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="d110d-289">システム全体を中断するリスクを軽減することで、複雑なアプリケーションの小さな領域を更新することができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-289">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="d110d-290">各マイクロサービスは個別にスケーリングできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-290">Each microservice can scale independently.</span></span> <span data-ttu-id="d110d-291">アプリケーション全体を1つのユニットとしてスケールアウトするのではなく、より多くの処理能力やネットワーク帯域幅を必要とするサービスのみをスケールアウトします。</span><span class="sxs-lookup"><span data-stu-id="d110d-291">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="d110d-292">このように細分化されたスケーリングのアプローチによって、システムをより細かく制御し、システム全体ではなく、システムの一部をスケールするときに全体的なコストを削減することができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-292">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="d110d-293">マイクロサービスを理解するための優れたリファレンスガイドは、 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)です。</span><span class="sxs-lookup"><span data-stu-id="d110d-293">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="d110d-294">この書籍は、マイクロサービスの設計とアーキテクチャに深くダイブしています。</span><span class="sxs-lookup"><span data-stu-id="d110d-294">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="d110d-295">これは、Microsoft から無料でダウンロードできる[フルスタックマイクロサービス参照アーキテクチャ](https://github.com/dotnet-architecture/eShopOnContainers)のコンパニオンです。</span><span class="sxs-lookup"><span data-stu-id="d110d-295">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="d110d-296">マイクロサービスの開発</span><span class="sxs-lookup"><span data-stu-id="d110d-296">Developing microservices</span></span>

<span data-ttu-id="d110d-297">マイクロサービスは、最新の開発プラットフォームを使用して作成できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-297">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="d110d-298">Microsoft .NET コアプラットフォームが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="d110d-298">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="d110d-299">無料のオープンソースとして、マイクロサービスの開発を簡略化する組み込みの機能が多数用意されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-299">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="d110d-300">.NET Core はクロスプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="d110d-300">.NET Core is cross-platform.</span></span> <span data-ttu-id="d110d-301">アプリケーションは、Windows、macOS、およびほとんどの Linux でビルドして実行できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-301">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="d110d-302">.NET Core は高いパフォーマンスを発揮し、node.js とその他の競合するプラットフォームとの比較においても十分に評価されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-302">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="d110d-303">興味深いこと[に、多くの web](https://www.techempower.com/)アプリケーションプラットフォームとフレームワークで、豊富な[パフォーマンスベンチマーク](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)が実行されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-303">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="d110d-304">.NET Core は、node.js などの競合しているプラットフォーム上の上位10件でスコア付けされています。</span><span class="sxs-lookup"><span data-stu-id="d110d-304">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="d110d-305">.NET Core は、GitHub の Microsoft および .NET コミュニティによって管理されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-305">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="d110d-306">コンテナー</span><span class="sxs-lookup"><span data-stu-id="d110d-306">Containers</span></span>

<span data-ttu-id="d110d-307">今日では、*クラウドのネイティブ*に関するメッセージ交換で言及されている用語*コンテナー*を聞いています。</span><span class="sxs-lookup"><span data-stu-id="d110d-307">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="d110d-308">この本の[クラウドネイティブパターン](https://www.manning.com/books/cloud-native-patterns)では、"コンテナーはクラウドネイティブソフトウェアの優れた Cornelia" です。</span><span class="sxs-lookup"><span data-stu-id="d110d-308">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="d110d-309">クラウドネイティブコンピューティングファンデーションは、クラウドネイティブの[トレイル地図](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)の最初の手順として、マイクロサービスコンテナー化を配置します。企業がクラウドネイティブの体験を開始するガイダンスです。</span><span class="sxs-lookup"><span data-stu-id="d110d-309">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="d110d-310">マイクロサービスのコンテナー化はシンプルで簡単です。</span><span class="sxs-lookup"><span data-stu-id="d110d-310">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="d110d-311">コード、その依存関係、およびランタイムは、[コンテナーイメージ](https://docs.docker.com/glossary/?term=image)と呼ばれるバイナリにパッケージ化されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-311">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="d110d-312">イメージは、イメージのリポジトリまたはライブラリとして機能する[コンテナーレジストリ](https://caylent.com/container-registries/)に格納されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-312">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="d110d-313">レジストリは、開発用コンピューター、データセンター、またはパブリッククラウドに配置できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-313">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="d110d-314">Docker 自体は、 [Docker Hub](https://hub.docker.com/)を使用してパブリックレジストリを管理します。</span><span class="sxs-lookup"><span data-stu-id="d110d-314">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="d110d-315">Azure クラウドでは、コンテナー[レジストリ](https://azure.microsoft.com/services/container-registry/)が機能し、コンテナーイメージを実行するクラウドアプリケーションの近くに格納されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-315">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="d110d-316">必要に応じて、イメージを実行中のコンテナーインスタンスに変換します。</span><span class="sxs-lookup"><span data-stu-id="d110d-316">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="d110d-317">インスタンスは、[コンテナーランタイム](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)エンジンがインストールされている任意のコンピューター上で実行されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-317">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="d110d-318">コンテナー化されたサービスのインスタンスは、必要に応じていくつでも作成できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-318">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="d110d-319">図1-5 は、それぞれが1つのホストで実行される3つの異なるマイクロサービスをそれぞれのコンテナーに示しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-319">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![コンテナー ホストで実行されている複数のコンテナー](./media/hosting-mulitple-containers.png)

<span data-ttu-id="d110d-321">**図 1-5**.</span><span class="sxs-lookup"><span data-stu-id="d110d-321">**Figure 1-5**.</span></span> <span data-ttu-id="d110d-322">コンテナー ホストで実行されている複数のコンテナー</span><span class="sxs-lookup"><span data-stu-id="d110d-322">Multiple containers running on a container host</span></span>

<span data-ttu-id="d110d-323">各コンテナーが独自の依存関係とランタイムのセットを保持していることに注意してください。異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-323">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="d110d-324">ここでは、同じホストで実行されている異なるバージョンの製品マイクロサービスを示します。</span><span class="sxs-lookup"><span data-stu-id="d110d-324">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="d110d-325">各コンテナーは、基礎となるホストオペレーティングシステム、メモリ、およびプロセッサのスライスを共有しますが、互いに分離されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-325">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="d110d-326">コンテナーモデルが、 [12 要素アプリケーション](https://12factor.net/)からの "依存関係" の原則をどの程度採用しているかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-326">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="d110d-327">*係数 \#2 は、"各マイクロサービスが独自の依存関係を分離およびパッケージ化し、システム全体に影響を与えることなく変更を行うことを指定します。"*</span><span class="sxs-lookup"><span data-stu-id="d110d-327">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="d110d-328">コンテナーは、Linux と Windows の両方のワークロードをサポートします。</span><span class="sxs-lookup"><span data-stu-id="d110d-328">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="d110d-329">Azure クラウドは、両方をオープンにしています。</span><span class="sxs-lookup"><span data-stu-id="d110d-329">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="d110d-330">興味深いことに、Azure で最も一般的なオペレーティングシステムになっている Windows Server ではなく Linux です。</span><span class="sxs-lookup"><span data-stu-id="d110d-330">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="d110d-331">複数のコンテナーベンダーが存在していても、Docker はライオンの市場シェアを獲得しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-331">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="d110d-332">会社はソフトウェアコンテナーの移動を推進しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-332">The company has been driving the software container movement.</span></span> <span data-ttu-id="d110d-333">クラウドネイティブアプリケーションのパッケージ化、デプロイ、実行のための事実上の標準になっています。</span><span class="sxs-lookup"><span data-stu-id="d110d-333">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="d110d-334">コンテナーを選ぶ理由</span><span class="sxs-lookup"><span data-stu-id="d110d-334">Why containers?</span></span>

<span data-ttu-id="d110d-335">コンテナーは、環境間での移植性と整合性を保証します。</span><span class="sxs-lookup"><span data-stu-id="d110d-335">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="d110d-336">すべてを1つのパッケージにカプセル化することで、マイクロサービスとその依存関係を基になるインフラストラクチャから*分離*します。</span><span class="sxs-lookup"><span data-stu-id="d110d-336">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="d110d-337">Docker ランタイムエンジンを持つ任意の環境に同じコンテナーを配置できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-337">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="d110d-338">コンテナー化されたワークロードでは、フレームワーク、ソフトウェアライブラリ、およびランタイムエンジンを使用して各環境を事前に構成する費用も不要になります。</span><span class="sxs-lookup"><span data-stu-id="d110d-338">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="d110d-339">基盤となるオペレーティングシステムとホストリソースを共有することで、コンテナーのフットプリントは、完全な仮想マシンよりもかなり小さくなります。</span><span class="sxs-lookup"><span data-stu-id="d110d-339">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="d110d-340">サイズを小さくすると、特定のホストが一度に実行できる*密度*(マイクロサービスの数) が増加します。</span><span class="sxs-lookup"><span data-stu-id="d110d-340">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="d110d-341">コンテナーのオーケストレーション</span><span class="sxs-lookup"><span data-stu-id="d110d-341">Container orchestration</span></span>

<span data-ttu-id="d110d-342">Docker、イメージの作成、コンテナーの実行などのツールでは、それらを管理するためのツールも必要です。</span><span class="sxs-lookup"><span data-stu-id="d110d-342">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="d110d-343">コンテナー管理は、コンテナー orchestrator と呼ばれる特別なソフトウェアプログラムを使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="d110d-343">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="d110d-344">大規模に運用する場合は、コンテナーオーケストレーションが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="d110d-344">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="d110d-345">図1-6 は、コンテナーオーケストレーター提供する管理タスクを示しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-345">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![コンテナーオーケストレーター行うこと](./media/what-container-orchestrators-do.png)

<span data-ttu-id="d110d-347">**図 1-6**.</span><span class="sxs-lookup"><span data-stu-id="d110d-347">**Figure 1-6**.</span></span> <span data-ttu-id="d110d-348">コンテナーオーケストレーター行うこと</span><span class="sxs-lookup"><span data-stu-id="d110d-348">What container orchestrators do</span></span>

<span data-ttu-id="d110d-349">次の表では、一般的なオーケストレーションタスクについて説明します。</span><span class="sxs-lookup"><span data-stu-id="d110d-349">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="d110d-350">タスク</span><span class="sxs-lookup"><span data-stu-id="d110d-350">Tasks</span></span> | <span data-ttu-id="d110d-351">説明</span><span class="sxs-lookup"><span data-stu-id="d110d-351">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="d110d-352">スケジュール設定</span><span class="sxs-lookup"><span data-stu-id="d110d-352">Scheduling</span></span> | <span data-ttu-id="d110d-353">コンテナーインスタンスを自動的にプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-353">Automatically provision container instances.</span></span>|
| <span data-ttu-id="d110d-354">アフィニティ/アンチアフィニティ</span><span class="sxs-lookup"><span data-stu-id="d110d-354">Affinity/anti-affinity</span></span> | <span data-ttu-id="d110d-355">隣接しているコンテナーまたは遠く離れたコンテナーを相互にプロビジョニングし、可用性とパフォーマンスを高めます。</span><span class="sxs-lookup"><span data-stu-id="d110d-355">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="d110d-356">ヘルスの監視</span><span class="sxs-lookup"><span data-stu-id="d110d-356">Health monitoring</span></span> | <span data-ttu-id="d110d-357">エラーを自動的に検出して修正します。</span><span class="sxs-lookup"><span data-stu-id="d110d-357">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="d110d-358">フェールオーバー</span><span class="sxs-lookup"><span data-stu-id="d110d-358">Failover</span></span> | <span data-ttu-id="d110d-359">失敗したインスタンスを正常なコンピューターに自動的に再プロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-359">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="d110d-360">Scaling</span><span class="sxs-lookup"><span data-stu-id="d110d-360">Scaling</span></span> | <span data-ttu-id="d110d-361">必要に応じて、コンテナーインスタンスを自動的に追加または削除します。</span><span class="sxs-lookup"><span data-stu-id="d110d-361">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="d110d-362">ネットワーク</span><span class="sxs-lookup"><span data-stu-id="d110d-362">Networking</span></span> | <span data-ttu-id="d110d-363">コンテナー通信のネットワークオーバーレイを管理します。</span><span class="sxs-lookup"><span data-stu-id="d110d-363">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="d110d-364">サービス検出</span><span class="sxs-lookup"><span data-stu-id="d110d-364">Service Discovery</span></span> | <span data-ttu-id="d110d-365">コンテナーが相互に配置されるようにします。</span><span class="sxs-lookup"><span data-stu-id="d110d-365">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="d110d-366">ローリングアップグレード</span><span class="sxs-lookup"><span data-stu-id="d110d-366">Rolling Upgrades</span></span> | <span data-ttu-id="d110d-367">ダウンタイムをゼロに配置して増分アップグレードを調整します。</span><span class="sxs-lookup"><span data-stu-id="d110d-367">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="d110d-368">問題のある変更を自動的にロールバックします。</span><span class="sxs-lookup"><span data-stu-id="d110d-368">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="d110d-369">この章で既に説明したように、オーケストレーター [12 要素アプリケーション](https://12factor.net/)から disposability と同時実行の原則を採用していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-369">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="d110d-370">*係数 \#9 は、"サービスインスタンスを破棄可能にする必要があることを指定します。優先 fast スタートアップを使用して、スケーラビリティの機会を増やし、正常なシャットダウンを行い、システムを適切な状態にします。Docker コンテナーと orchestrator は、本質的にこの要件を満たしています。 "*</span><span class="sxs-lookup"><span data-stu-id="d110d-370">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="d110d-371">*係数 \#8 は、使用可能な最も強力なコンピューター上で1つの大きなインスタンスをスケールアップするのではなく、多数の小さい同一のプロセス (コピー) でサービスをスケールアウトすることを指定します。*</span><span class="sxs-lookup"><span data-stu-id="d110d-371">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="d110d-372">複数のコンテナーオーケストレーター存在していても、 [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)はクラウドネイティブ環境では事実上標準になりました。</span><span class="sxs-lookup"><span data-stu-id="d110d-372">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="d110d-373">コンテナー化されたワークロードを管理するための、移植可能で拡張可能なオープンソースのプラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="d110d-373">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="d110d-374">Kubernetes の独自のインスタンスをホストすることもできますが、リソースのプロビジョニングと管理は複雑になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-374">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="d110d-375">Azure クラウドの機能 Kubernetes は、管理されたサービスである[Azure Kubernetes service (AKS)](https://azure.microsoft.com/services/kubernetes-service/)として機能します。</span><span class="sxs-lookup"><span data-stu-id="d110d-375">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="d110d-376">管理されたサービスを使用すると、その機能をインストールして保守しなくても、機能を完全に活用できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-376">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="d110d-377">Azure Kubernetes Services の詳細については、「*クラウドネイティブアプリケーションのスケーリング*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-377">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="d110d-378">サービスのバックアップ</span><span class="sxs-lookup"><span data-stu-id="d110d-378">Backing services</span></span>

<span data-ttu-id="d110d-379">クラウドネイティブシステムは、データストア、メッセージブローカー、監視、id サービスなど、さまざまな補助リソースに依存しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-379">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="d110d-380">これらのサービスは、[バッキングサービス](https://12factor.net/backing-services)と呼ばれています。</span><span class="sxs-lookup"><span data-stu-id="d110d-380">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="d110d-381">図1-7 は、クラウドネイティブシステムが使用する多くの一般的なバッキングサービスを示しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-381">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![一般的なバッキングサービス](./media/common-backing-services.png)

<span data-ttu-id="d110d-383">**図 1-7**.</span><span class="sxs-lookup"><span data-stu-id="d110d-383">**Figure 1-7**.</span></span> <span data-ttu-id="d110d-384">一般的なバッキングサービス</span><span class="sxs-lookup"><span data-stu-id="d110d-384">Common backing services</span></span>

<span data-ttu-id="d110d-385">バッキングサービスは、前の章で説明した[12 要素アプリケーション](https://12factor.net/)からの "状態" 原則を昇格させます。</span><span class="sxs-lookup"><span data-stu-id="d110d-385">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="d110d-386">*係数 \#6*は、"各マイクロサービスを、実行中の他のサービスから分離された独自のプロセスで実行する必要があることを指定します。</span><span class="sxs-lookup"><span data-stu-id="d110d-386">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="d110d-387">分散キャッシュやデータストアなどのバッキングサービスに必要な状態を外部化。 "</span><span class="sxs-lookup"><span data-stu-id="d110d-387">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="d110d-388">独自のバッキングサービスをホストすることもできますが、その場合は、これらのリソースのライセンス、プロビジョニング、および管理を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-388">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="d110d-389">クラウドプロバイダーは、さまざまな*マネージドバッキングサービスを提供しています。*</span><span class="sxs-lookup"><span data-stu-id="d110d-389">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="d110d-390">サービスを所有するのではなく、単に使用します。</span><span class="sxs-lookup"><span data-stu-id="d110d-390">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="d110d-391">プロバイダーは、大規模なリソースを操作し、パフォーマンス、セキュリティ、およびメンテナンスの責任を担います。</span><span class="sxs-lookup"><span data-stu-id="d110d-391">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="d110d-392">サービスには、監視、冗長性、可用性が組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="d110d-392">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="d110d-393">プロバイダーは、管理されたサービスを完全にサポートしています。チケットを開いて問題を解決します。</span><span class="sxs-lookup"><span data-stu-id="d110d-393">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="d110d-394">クラウドネイティブシステムは、クラウドベンダーのマネージドバッキングサービスを優先します。</span><span class="sxs-lookup"><span data-stu-id="d110d-394">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="d110d-395">時間と労力が節約されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-395">The savings in time and labor are great.</span></span> <span data-ttu-id="d110d-396">独自にホストし、問題が発生した場合の運用上のリスクは、コストがかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="d110d-396">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="d110d-397">ベストプラクティスとして、バッキングサービスを接続されたリソースとして扱い、外部構成に格納されて*いる*情報 (URL と資格情報) を使用してマイクロサービスに動的にバインドすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d110d-397">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="d110d-398">このガイダンスは、前の章で説明した[12 要素のアプリケーション](https://12factor.net/)でスペルが示されています。</span><span class="sxs-lookup"><span data-stu-id="d110d-398">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="d110d-399">*Factor \#4*では、アドレス指定可能な URL を使用してバッキングサービスを公開する必要があることを指定します。</span><span class="sxs-lookup"><span data-stu-id="d110d-399">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="d110d-400">これにより、アプリケーションからリソースが分離され、そのリソースを交換可能にすることができます。 "</span><span class="sxs-lookup"><span data-stu-id="d110d-400">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="d110d-401">*係数 \#3*は、"構成情報がマイクロサービスから移動され、構成管理ツールを使用してコード外に外部化" ことを指定します。</span><span class="sxs-lookup"><span data-stu-id="d110d-401">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="d110d-402">このパターンでは、コードを変更せずに、バッキングサービスをアタッチおよびデタッチできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-402">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="d110d-403">マイクロサービスを QA からステージング環境に昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-403">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="d110d-404">マイクロサービス構成を更新して、ステージング環境のバッキングサービスをポイントし、環境変数を使用して設定をコンテナーに挿入します。</span><span class="sxs-lookup"><span data-stu-id="d110d-404">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="d110d-405">クラウドベンダーは、独自のバッキングサービスと通信するための Api を提供しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-405">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="d110d-406">これらのライブラリは、プラミングと複雑さをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="d110d-406">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="d110d-407">これらの Api と直接通信することにより、コードをバッキングサービスに密に結合できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-407">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="d110d-408">ベンダ API の実装の詳細を分離することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d110d-408">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="d110d-409">Intermediation 層 (中間 API) を導入して、サービスコードに汎用的な操作を公開します。</span><span class="sxs-lookup"><span data-stu-id="d110d-409">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="d110d-410">この疎結合により、1つのバッキングサービスを別のサービスにスワップアウトしたり、メインのサービスコードを変更しなくても、別のパブリッククラウドにコードを移動したりできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-410">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="d110d-411">バッキングサービスの詳細については、「5章、*クラウドネイティブのデータパターン*」、および「*クラウドネイティブの通信パターン*」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="d110d-411">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="d110d-412">[オートメーション]</span><span class="sxs-lookup"><span data-stu-id="d110d-412">Automation</span></span>

<span data-ttu-id="d110d-413">既に説明したように、クラウドネイティブシステムは、高速で機敏性を実現するために、マイクロサービス、コンテナー、および最新のシステム設計を採用しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-413">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="d110d-414">しかし、これはストーリーの一部にすぎません。</span><span class="sxs-lookup"><span data-stu-id="d110d-414">But, that's only part of the story.</span></span> <span data-ttu-id="d110d-415">これらのシステムを実行するクラウド環境をプロビジョニングするにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="d110d-415">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="d110d-416">アプリの機能と更新プログラムを迅速に展開するにはどうすればよいですか。</span><span class="sxs-lookup"><span data-stu-id="d110d-416">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="d110d-417">全体像を丸めるにはどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="d110d-417">How do you round out the full picture?</span></span>

<span data-ttu-id="d110d-418">インフラストラクチャに関して広く受け入れられているプラクティスをコードまたは IaC[と](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)して入力します。</span><span class="sxs-lookup"><span data-stu-id="d110d-418">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="d110d-419">IaC を使用すると、プラットフォームのプロビジョニングとアプリケーションの展開を自動化できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-419">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="d110d-420">基本的に、テストやバージョン管理などのソフトウェアエンジニアリングプラクティスを DevOps プラクティスに適用します。</span><span class="sxs-lookup"><span data-stu-id="d110d-420">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="d110d-421">インフラストラクチャとデプロイは、自動化され、一貫性があり、反復可能です。</span><span class="sxs-lookup"><span data-stu-id="d110d-421">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="d110d-422">インフラストラクチャの自動化</span><span class="sxs-lookup"><span data-stu-id="d110d-422">Automating infrastructure</span></span>

<span data-ttu-id="d110d-423">[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、terraform、 [Azure CLI](https://docs.microsoft.com/cli/azure/)などのツールを使用すると、必要なクラウドインフラストラクチャを宣言によってスクリプト化することができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-423">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="d110d-424">リソース名、場所、容量、およびシークレットは、パラメーター化され、動的になります。</span><span class="sxs-lookup"><span data-stu-id="d110d-424">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="d110d-425">スクリプトがバージョン管理され、プロジェクトの成果物としてソース管理にチェックインされます。</span><span class="sxs-lookup"><span data-stu-id="d110d-425">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="d110d-426">スクリプトを呼び出して、QA、ステージング、運用などのシステム環境全体で、一貫性のある反復可能なインフラストラクチャをプロビジョニングします。</span><span class="sxs-lookup"><span data-stu-id="d110d-426">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="d110d-427">内部的には、IaC はべき等であり、副作用なしで同じスクリプトを何度も実行できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d110d-427">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="d110d-428">チームが変更を加える必要がある場合は、スクリプトを編集して再実行します。</span><span class="sxs-lookup"><span data-stu-id="d110d-428">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="d110d-429">更新されたリソースのみが影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="d110d-429">Only the updated resources are affected.</span></span>

<span data-ttu-id="d110d-430">「[コードとしてのインフラストラクチャとは](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)」の記事では、作成者 Sam Guckenheimer は、"IaC を実装するチームは、安定した環境を迅速かつ大規模に提供する方法を説明しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-430">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="d110d-431">チームは環境の手動構成を回避し、コードを使用して環境の望ましい状態を表すことによって一貫性を適用します。</span><span class="sxs-lookup"><span data-stu-id="d110d-431">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="d110d-432">IaC を使用したインフラストラクチャのデプロイは反復可能であり、構成のずれや依存関係の不足によって発生するランタイムの問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-432">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="d110d-433">DevOps チームは、統合された一連のプラクティスとツールを一緒に使用して、アプリケーションとそのサポートインフラストラクチャを迅速かつ確実に、かつ大規模に配信できます。 "</span><span class="sxs-lookup"><span data-stu-id="d110d-433">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="d110d-434">デプロイの自動化</span><span class="sxs-lookup"><span data-stu-id="d110d-434">Automating deployments</span></span>

<span data-ttu-id="d110d-435">前に説明した[12 要素アプリケーション](https://12factor.net/)は、完成したコードを実行中のアプリケーションに変換するときに個別の手順を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d110d-435">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="d110d-436">*係数 \#5*では、"各リリースで、ビルド、リリース、および実行の各段階で厳密な分離を強制する必要があることを指定します。</span><span class="sxs-lookup"><span data-stu-id="d110d-436">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="d110d-437">各には一意の ID をタグ付けし、ロールバックの機能をサポートする必要があります。 "</span><span class="sxs-lookup"><span data-stu-id="d110d-437">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="d110d-438">最新の CI/CD システムは、この原則を満たすのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="d110d-438">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="d110d-439">個別のデプロイ手順を提供し、ユーザーがすぐに利用できる一貫性のある品質のコードを保証します。</span><span class="sxs-lookup"><span data-stu-id="d110d-439">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="d110d-440">図1-8 は、デプロイプロセス間の分離を示しています。</span><span class="sxs-lookup"><span data-stu-id="d110d-440">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD パイプラインでのデプロイの手順](./media/build-release-run-pipeline.png)

<span data-ttu-id="d110d-442">**図 1-8**.</span><span class="sxs-lookup"><span data-stu-id="d110d-442">**Figure 1-8**.</span></span> <span data-ttu-id="d110d-443">CI/CD パイプラインでのデプロイ手順</span><span class="sxs-lookup"><span data-stu-id="d110d-443">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="d110d-444">前の図では、タスクの分離に特に注意を払っています。</span><span class="sxs-lookup"><span data-stu-id="d110d-444">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="d110d-445">開発者は、コード、実行、デバッグの "内側のループ" と呼ばれるものを反復処理して、開発環境で機能を構築します。</span><span class="sxs-lookup"><span data-stu-id="d110d-445">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="d110d-446">完了すると、そのコードは GitHub、Azure DevOps、BitBucket などのコードリポジトリに*プッシュ*されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-446">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="d110d-447">プッシュは、コードをバイナリの成果物に変換するビルドステージをトリガーします。</span><span class="sxs-lookup"><span data-stu-id="d110d-447">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="d110d-448">この作業は、[継続的インテグレーション (CI)](https://martinfowler.com/articles/continuousIntegration.html)パイプラインを使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-448">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="d110d-449">アプリケーションのビルド、テスト、およびパッケージ化が自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="d110d-449">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="d110d-450">リリース段階では、バイナリアーティファクトが取得され、外部のアプリケーションと環境の構成情報が適用され、変更できないリリースが生成されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-450">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="d110d-451">リリースは、指定された環境に配置されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-451">The release is deployed to a specified environment.</span></span> <span data-ttu-id="d110d-452">この作業は、[継続的デリバリー (CD)](https://martinfowler.com/bliki/ContinuousDelivery.html)パイプラインを使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-452">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="d110d-453">各リリースは識別可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="d110d-453">Each release should be identifiable.</span></span> <span data-ttu-id="d110d-454">「この配置では、アプリケーションのリリース2.1.1 を実行しています。」と言うことができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-454">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="d110d-455">最後に、リリースされた機能はターゲットの実行環境で実行されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-455">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="d110d-456">リリースは不変であり、すべての変更で新しいリリースを作成する必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="d110d-456">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="d110d-457">これらのプラクティスを適用することで、組織はソフトウェアの発送方法を大幅に進化させることができました。</span><span class="sxs-lookup"><span data-stu-id="d110d-457">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="d110d-458">多くの場合、四半期ごとのリリースからオンデマンド更新に移行されました。</span><span class="sxs-lookup"><span data-stu-id="d110d-458">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="d110d-459">目標は、開発サイクルの早い段階で問題を発見して、修正するのが低コストになることです。</span><span class="sxs-lookup"><span data-stu-id="d110d-459">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="d110d-460">統合間の時間が長くなるほど、コストのかかる問題が解決されます。</span><span class="sxs-lookup"><span data-stu-id="d110d-460">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="d110d-461">統合プロセスの一貫性を確保することで、チームはコードの変更をより頻繁にコミットし、コラボレーションとソフトウェアの品質を向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-461">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="d110d-462">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="d110d-462">Azure Pipelines</span></span>

<span data-ttu-id="d110d-463">Azure クラウドには、 [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)という新しい CI/CD サービスが含まれています。これは、図1-9 に示す[Azure DevOps](https://azure.microsoft.com/services/devops/)オファリングに含まれています。</span><span class="sxs-lookup"><span data-stu-id="d110d-463">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![DevOps の Azure Pipelines](./media/devops-components.png)

<span data-ttu-id="d110d-465">**図 1-9**.</span><span class="sxs-lookup"><span data-stu-id="d110d-465">**Figure 1-9**.</span></span> <span data-ttu-id="d110d-466">Azure DevOps のオファリング</span><span class="sxs-lookup"><span data-stu-id="d110d-466">Azure DevOps offerings</span></span>

<span data-ttu-id="d110d-467">Azure Pipelines は、継続的インテグレーション (CI) と継続的デリバリー (CD) を組み合わせたクラウドサービスです。</span><span class="sxs-lookup"><span data-stu-id="d110d-467">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="d110d-468">コードは、任意のターゲットに対して自動的にテスト、ビルド、および配布できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-468">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="d110d-469">アプリケーションのコードの残りの部分と共に、YAML ファイルのコードでパイプラインを定義します。</span><span class="sxs-lookup"><span data-stu-id="d110d-469">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="d110d-470">パイプラインは、コードを使用してバージョン管理され、同じ分岐構造に従います。</span><span class="sxs-lookup"><span data-stu-id="d110d-470">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="d110d-471">プル要求と分岐ビルドポリシーでコードレビューを使用して、変更の検証を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="d110d-471">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="d110d-472">使用するすべてのブランチで、azure-pipelines .yml ファイルを変更することによって、ビルドポリシーをカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="d110d-472">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="d110d-473">パイプラインファイルはバージョン管理にチェックインされ、問題がある場合は調査できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-473">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="d110d-474">Azure Pipelines サービスでは、ほとんどの Git プロバイダーがサポートされており、Linux、macOS、または Windows プラットフォームで作成されたアプリケーションのデプロイパイプラインを生成できます。</span><span class="sxs-lookup"><span data-stu-id="d110d-474">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="d110d-475">Java、.NET、JavaScript、Python、PHP、XCode、およびC++のサポートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d110d-475">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d110d-476">[前へ](introduction.md)
>[次へ](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="d110d-476">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
