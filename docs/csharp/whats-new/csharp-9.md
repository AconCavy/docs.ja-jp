---
title: C# 9.0 の新機能 - C# ガイド
description: C# 9.0 で使用できる新しい機能の概要を説明します。
ms.date: 09/04/2020
ms.openlocfilehash: a863e544c0fcc8682994f49a464acccafc5ce92f
ms.sourcegitcommit: cbacb5d2cebbf044547f6af6e74a9de866800985
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/05/2020
ms.locfileid: "89495775"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="13bde-103">C# 9.0 の新機能</span><span class="sxs-lookup"><span data-stu-id="13bde-103">What's new in C# 9.0</span></span>

<span data-ttu-id="13bde-104">C# 9.0 によって、C# 言語に次の機能と機能強化が追加されています。</span><span class="sxs-lookup"><span data-stu-id="13bde-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- <span data-ttu-id="13bde-105">レコード</span><span class="sxs-lookup"><span data-stu-id="13bde-105">Records</span></span>
- <span data-ttu-id="13bde-106">init 専用セッター</span><span class="sxs-lookup"><span data-stu-id="13bde-106">Init only setters</span></span>
- <span data-ttu-id="13bde-107">最上位レベルのステートメント</span><span class="sxs-lookup"><span data-stu-id="13bde-107">Top-level statements</span></span>
- <span data-ttu-id="13bde-108">パターン マッチングの拡張機能</span><span class="sxs-lookup"><span data-stu-id="13bde-108">Pattern matching enhancements</span></span>
- <span data-ttu-id="13bde-109">ネイティブ サイズの整数</span><span class="sxs-lookup"><span data-stu-id="13bde-109">Native sized integers</span></span>
- <span data-ttu-id="13bde-110">関数ポインター</span><span class="sxs-lookup"><span data-stu-id="13bde-110">Function pointers</span></span>
- <span data-ttu-id="13bde-111">localsinit フラグの出力を抑制する</span><span class="sxs-lookup"><span data-stu-id="13bde-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="13bde-112">ターゲット型の新しい式</span><span class="sxs-lookup"><span data-stu-id="13bde-112">Target-typed new expressions</span></span>
- <span data-ttu-id="13bde-113">静的な匿名関数</span><span class="sxs-lookup"><span data-stu-id="13bde-113">static anonymous functions</span></span>
- <span data-ttu-id="13bde-114">ターゲットにより型指定された条件式</span><span class="sxs-lookup"><span data-stu-id="13bde-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="13bde-115">共変の戻り値の型</span><span class="sxs-lookup"><span data-stu-id="13bde-115">Covariant return types</span></span>
- <span data-ttu-id="13bde-116">ラムダ ディスカード パラメーター</span><span class="sxs-lookup"><span data-stu-id="13bde-116">Lambda discard parameters</span></span>
- <span data-ttu-id="13bde-117">ローカル関数の属性</span><span class="sxs-lookup"><span data-stu-id="13bde-117">Attributes on local functions</span></span>
- <span data-ttu-id="13bde-118">モジュールの初期化子</span><span class="sxs-lookup"><span data-stu-id="13bde-118">Module initializers</span></span>
- <span data-ttu-id="13bde-119">部分メソッドの新機能</span><span class="sxs-lookup"><span data-stu-id="13bde-119">New features for partial methods</span></span>

<span data-ttu-id="13bde-120">C# 9.0 は **.NET 5** でサポートされています。</span><span class="sxs-lookup"><span data-stu-id="13bde-120">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="13bde-121">詳細については、「[C# 言語のバージョン管理](../language-reference/configure-language-version.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="13bde-121">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

## <a name="record-types"></a><span data-ttu-id="13bde-122">レコードの種類</span><span class="sxs-lookup"><span data-stu-id="13bde-122">Record types</span></span>

<span data-ttu-id="13bde-123">C# 9.0 には "***レコード型***" が導入されています。これは、等価性の値のセマンティクスを提供するための合成されたメソッドを提供する参照型です。</span><span class="sxs-lookup"><span data-stu-id="13bde-123">C# 9.0 introduces ***record types***, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="13bde-124">既定では、レコードは変更できません。</span><span class="sxs-lookup"><span data-stu-id="13bde-124">Records are immutable by default.</span></span>

<span data-ttu-id="13bde-125">レコード型を使用すると、変更できない参照型を .NET で簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-125">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="13bde-126">従来、.NET 型は、参照型 (クラス型と匿名型を含む) と値型 (構造体とタプルを含む) に大別されています。</span><span class="sxs-lookup"><span data-stu-id="13bde-126">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="13bde-127">変更できない値型が推奨されますが、変更可能な値型でエラーが頻繁に発生するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="13bde-127">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="13bde-128">値型の変数には値が保持され、値型がメソッドに渡されるときは、元のデータのコピーが変更されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-128">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="13bde-129">変更できない参照型にも多くの利点があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-129">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="13bde-130">これらの利点は、共有データを使用する同時実行プログラムで、より顕著になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-130">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="13bde-131">残念ながら、C# で変更できない参照型を作成するには、余分なコードをかなり記述する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="13bde-131">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="13bde-132">レコードにより、等価性の値のセマンティクスを使用する、変更できない参照型の型宣言が提供されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-132">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="13bde-133">等価コードとハッシュ コードの合成メソッドでは、プロパティがすべて等しい場合、2 つのレコードは等しいと見なされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-133">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="13bde-134">次の定義を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="13bde-134">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="13bde-135">レコード定義によって、`FirstName` と `LastName` の 2 つの読み取り専用プロパティを含む `Person` 型が作成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-135">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="13bde-136">`Person` 型は参照型です。</span><span class="sxs-lookup"><span data-stu-id="13bde-136">The `Person` type is a reference type.</span></span> <span data-ttu-id="13bde-137">IL を見た場合は、それはクラスです。</span><span class="sxs-lookup"><span data-stu-id="13bde-137">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="13bde-138">どのプロパティも作成後に変更できないので、それは変更できません。</span><span class="sxs-lookup"><span data-stu-id="13bde-138">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="13bde-139">レコード型を定義すると、コンパイラによって他のいくつかのメソッドが自動的に合成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-139">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="13bde-140">値ベースの等価比較のためのメソッド</span><span class="sxs-lookup"><span data-stu-id="13bde-140">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="13bde-141"><xref:System.Object.GetHashCode> のオーバーライド</span><span class="sxs-lookup"><span data-stu-id="13bde-141">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="13bde-142">コピー メンバーとクローン メンバー</span><span class="sxs-lookup"><span data-stu-id="13bde-142">Copy and Clone members</span></span>
- <span data-ttu-id="13bde-143">`PrintMembers` および <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="13bde-143">`PrintMembers` and <xref:System.Object.ToString></span></span>
- <span data-ttu-id="13bde-144">`Deconstruct` メソッド</span><span class="sxs-lookup"><span data-stu-id="13bde-144">`Deconstruct` method</span></span>

<span data-ttu-id="13bde-145">レコードによって、継承がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-145">Records support inheritance.</span></span> <span data-ttu-id="13bde-146">次のようにして、`Person` の新しい派生レコードを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-146">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="13bde-147">また、レコードをシールして、さらに派生させることもできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-147">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="13bde-148">コンパイラにより、上記のメソッドの異なるバージョンが合成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-148">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="13bde-149">メソッドのシグネチャは、レコード型がシールされているかどうか、および直接基底クラスがオブジェクトであるかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="13bde-149">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="13bde-150">レコードには次の機能が必要です。</span><span class="sxs-lookup"><span data-stu-id="13bde-150">Records should have the following capabilities:</span></span>

- <span data-ttu-id="13bde-151">等価性は値に基づいており、型が一致するかどうかのチェックが含まれます。</span><span class="sxs-lookup"><span data-stu-id="13bde-151">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="13bde-152">たとえば、2 つのレコードが同じ名前を共有している場合でも、`Student` を `Person` と同じにすることはできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-152">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="13bde-153">レコードには、自動的に生成される一貫した文字列表現があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-153">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="13bde-154">レコードによって、コピーの構築がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-154">Records support copy construction.</span></span> <span data-ttu-id="13bde-155">正しいコピーの構築には、継承階層と、開発者によって追加されたプロパティが含まれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-155">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="13bde-156">レコードは、変更してコピーできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-156">Records can be copied with modification.</span></span> <span data-ttu-id="13bde-157">これらのコピー操作と変更操作では、非破壊的な変異がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-157">These copy and modify operations supports non-destructive mutation.</span></span>
- <span data-ttu-id="13bde-158">すべてのレコードによって、分解がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-158">All records support deconstruction.</span></span>

<span data-ttu-id="13bde-159">使い慣れた `Equals` オーバーロード、`operator ==`、`operator !=` に加えて、コンパイラによって新しい `EqualityContract` プロパティが合成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="13bde-160">プロパティからは、レコードの型に一致する `Type` オブジェクトが返されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="13bde-161">基本データ型が `object` の場合、プロパティは `virtual` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="13bde-162">基本データ型が別のレコード型である場合、プロパティは `override` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="13bde-163">レコード型が `sealed` の場合、プロパティは `sealed` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="13bde-164">合成された `GetHashCode` によって、基本データ型とレコード型で宣言されているすべてのプロパティとフィールドの `GetHashCode` が使用されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="13bde-165">これらの合成メソッドにより、継承階層全体で値ベースの等価性が適用されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="13bde-166">つまり、`Student` は、同じ名前の `Person` と等しいとは見なされません。</span><span class="sxs-lookup"><span data-stu-id="13bde-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="13bde-167">2 つのレコードの型が一致し、さらにレコード型の間で共有されているすべてのプロパティが等しい必要があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="13bde-168">レコードには、合成されたコンストラクターと、コピーを作成するための "clone" メソッドもあります。</span><span class="sxs-lookup"><span data-stu-id="13bde-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="13bde-169">合成コンストラクターは、レコード型の引数を 1 つ持ちます。</span><span class="sxs-lookup"><span data-stu-id="13bde-169">The synthesized constructor has one argument of the record type.</span></span> <span data-ttu-id="13bde-170">これにより、レコードのすべてのプロパティの値が同じ新しいレコードが生成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="13bde-171">レコードがシールされている場合、このコンストラクターは private です。それ以外の場合は、protected です。</span><span class="sxs-lookup"><span data-stu-id="13bde-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="13bde-172">合成された "clone" メソッドによって、レコード階層のコピーの構築がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="13bde-173">"clone" という用語が引用符で囲まれているのは、実際の名前はコンパイラによって生成されるためです。</span><span class="sxs-lookup"><span data-stu-id="13bde-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="13bde-174">レコード型で `Clone` という名前のメソッドを作成することはできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="13bde-175">合成された "clone" メソッドによって、仮想ディスパッチを使用してコピーされるレコードの型が返されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="13bde-176">コンパイラにより、`record` のアクセス修飾子に応じて、異なる修飾子が "clone" メソッドに追加されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="13bde-177">レコード型が `abstract` の場合は、"clone" メソッドも `abstract` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="13bde-178">基本データ型が `object` でない場合は、メソッドも `override` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="13bde-179">基本データ型が `object` であるときの、`abstract` ではないレコード型の場合:</span><span class="sxs-lookup"><span data-stu-id="13bde-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="13bde-180">レコードが `sealed` の場合、追加の修飾子は "clone" メソッドに追加されません (つまり、`virtual` ではありません)。</span><span class="sxs-lookup"><span data-stu-id="13bde-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="13bde-181">レコードが `sealed` ではない場合、"clone" メソッドは `virtual` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="13bde-182">基本データ型が `object` ではないときの、`abstract` ではないレコード型の場合:</span><span class="sxs-lookup"><span data-stu-id="13bde-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="13bde-183">レコードが `sealed` の場合は、"clone" メソッドも `sealed` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="13bde-184">レコードが `sealed` ではない場合、"clone" メソッドは `override` になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="13bde-185">これらすべてのルールの結果として、レコード型のすべての階層で等価性が一貫して実装されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="13bde-186">次の例で示すように、プロパティが等しく、型が同じである場合、2 つのレコードは互いに等しくなります。</span><span class="sxs-lookup"><span data-stu-id="13bde-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="13bde-187">コンパイラにより、印刷出力をサポートする 2 つのメソッド <xref:System.Object.ToString> のオーバーライドと `PrintMembers` が合成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="13bde-188">`PrintMembers` は、引数として <xref:System.Text.StringBuilder?displayProperty=nameWithType> を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="13bde-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="13bde-189">レコード型のすべてのプロパティに対し、プロパティ名と値のコンマ区切りリストが追加されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="13bde-190">`PrintMembers` によって、他のレコードからのすべての派生レコードに対する基本実装が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="13bde-191"><xref:System.Object.ToString> のオーバーライドでは、`PrintMembers` によって生成され、`{` と `}` で囲まれた文字列が返されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="13bde-192">たとえば、`Student` に対する <xref:System.Object.ToString> メソッドでは、次のコードのような `string` が返されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="13bde-193">これまでに示した例では、従来の構文を使用してプロパティが宣言されています。</span><span class="sxs-lookup"><span data-stu-id="13bde-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="13bde-194">"***位置指定レコード***" と呼ばれる簡潔な形式があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-194">There's a more concise form called ***positional records***.</span></span>  <span data-ttu-id="13bde-195">次に示すのは、前に位置指定レコードとして定義されている 3 つのレコード型です。</span><span class="sxs-lookup"><span data-stu-id="13bde-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="13bde-196">これらの宣言によって、以前のバージョンと同じ機能が作成されます (次のセクションで説明する追加の機能がいくつかあります)。</span><span class="sxs-lookup"><span data-stu-id="13bde-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="13bde-197">これらのレコードには新しいメソッドが追加されていないため、これらの宣言は角かっこではなくセミコロンで終わっています。</span><span class="sxs-lookup"><span data-stu-id="13bde-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="13bde-198">本体を追加し、追加のメソッドを含めることもできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="13bde-199">コンパイラによって、位置指定レコードに対して `Deconstruct` メソッドが生成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="13bde-200">`Deconstruct` メソッドには、レコード型のすべてのパブリック プロパティの名前と一致するパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="13bde-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="13bde-201">`Deconstruct` メソッドを使用して、レコードをコンポーネント プロパティに分解できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="13bde-202">最後に、レコードによって "***with 式***" がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="13bde-202">Finally, records support ***with-expressions***.</span></span> <span data-ttu-id="13bde-203">"***with 式***" では、レコードのコピーを、*with* で指定したプロパティを変更して作成するように、コンパイラに指示されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-203">A ***with-expression*** instructs the compiler to create a copy of a record, but *with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="13bde-204">上の行では、`LastName` プロパティは `person` のコピーで、`FirstName` が "Paul" である、新しい `Person` レコードが作成されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-204">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is "Paul".</span></span> <span data-ttu-id="13bde-205">with 式では、任意の数のプロパティを設定できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-205">You can set any number of properties in a with-expression.</span></span>  <span data-ttu-id="13bde-206">"clone" メソッド以外のすべての合成メンバーは、開発者が自分で記述できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-206">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="13bde-207">レコード型に、いずれかの合成メソッドのシグネチャと一致するメソッドがある場合、コンパイラでそのメソッドは合成されません。</span><span class="sxs-lookup"><span data-stu-id="13bde-207">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="13bde-208">前の `Dog` レコードの例には、手作業でコーディングされた <xref:System.String.ToString> メソッドが例として含まれます。</span><span class="sxs-lookup"><span data-stu-id="13bde-208">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="13bde-209">init 専用セッター</span><span class="sxs-lookup"><span data-stu-id="13bde-209">Init only setters</span></span>

<span data-ttu-id="13bde-210">"***init 専用セッター***" によって、オブジェクトのメンバーを初期化するための一貫した構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-210">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="13bde-211">プロパティ初期化子を使用すると、どの値によってどのプロパティが設定されているかが明確にされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-211">Property initializers provide make it clear which value is setting which property.</span></span> <span data-ttu-id="13bde-212">欠点は、それらのプロパティが設定可能である必要があることです。</span><span class="sxs-lookup"><span data-stu-id="13bde-212">The downside is that those properties must be settable.</span></span> <span data-ttu-id="13bde-213">C# 9.0 以降では、プロパティとインデクサーに対して `set` アクセサーの代わりに `init` アクセサーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-213">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="13bde-214">呼び出し元により、プロパティ初期化子構文を使用して作成式でこれらの値を設定することができますが、構築が完了するとそれらのプロパティは読み取り専用になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-214">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="13bde-215">init 専用セッターによって、状態を変更するためのウィンドウが提供されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-215">Init only setters provide a window to change state.</span></span> <span data-ttu-id="13bde-216">構築フェーズが終了すると、そのウィンドウは閉じます。</span><span class="sxs-lookup"><span data-stu-id="13bde-216">That window closes when the construction phase ends.</span></span> <span data-ttu-id="13bde-217">プロパティ初期化子と with 式の完了を含め、すべての初期化の後で、構築フェーズは実質的に終了します。</span><span class="sxs-lookup"><span data-stu-id="13bde-217">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="13bde-218">位置指定レコードに関する前の例では、init 専用セッターを使用して、with 式を使用するプロパティを設定する方法が示されています。</span><span class="sxs-lookup"><span data-stu-id="13bde-218">The preceding example for positional records demonstrates using an init-only setter to set a property using a with expression.</span></span> <span data-ttu-id="13bde-219">init 専用セッターは、記述する任意の型で宣言できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-219">You can declare init only setters in any type you write.</span></span> <span data-ttu-id="13bde-220">たとえば、次の構造体では、気象監視構造体が定義されています。</span><span class="sxs-lookup"><span data-stu-id="13bde-220">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="13bde-221">呼び出し元は、プロパティ初期化子構文を使用して値を設定できますが、それでも不変性は維持されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-221">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="13bde-222">ただし、初期化後に監視を変更することは、初期化の外側で init 専用プロパティに代入することによるエラーになります。</span><span class="sxs-lookup"><span data-stu-id="13bde-222">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TempetureInCelsius = 18;
```

<span data-ttu-id="13bde-223">init 専用セッターは、派生クラスから基底クラスのプロパティを設定する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="13bde-223">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="13bde-224">また、基底クラスのヘルパーを使用して派生プロパティを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-224">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="13bde-225">位置指定レコードによって、init 専用セッターを使用してプロパティが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-225">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="13bde-226">これらのセッターは、with 式で使用されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-226">Those setters are used in with-expressions.</span></span> <span data-ttu-id="13bde-227">定義する任意の `class` または `struct` に対して、init 専用セッターを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-227">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="13bde-228">最上位レベルのステートメント</span><span class="sxs-lookup"><span data-stu-id="13bde-228">Top-level statements</span></span>

<span data-ttu-id="13bde-229">"***最上位レベル ステートメント***" により、多くのアプリケーションから不要な手続きが削除されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-229">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="13bde-230">正規の "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="13bde-230">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="13bde-231">プログラムについて考えます。</span><span class="sxs-lookup"><span data-stu-id="13bde-231">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="13bde-232">何かを行うコード行は 1 つだけです。</span><span class="sxs-lookup"><span data-stu-id="13bde-232">There’s only one line of code that does anything.</span></span> <span data-ttu-id="13bde-233">最上位レベル ステートメントを使用すると、そのすべての定型句を、`using` ステートメントと処理を行う 1 行に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-233">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="13bde-234">1 行だけのプログラムが必要な場合は、`using` ディレクティブを削除し、完全修飾型名を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-234">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="13bde-235">最上位レベル ステートメントを使用できるのは、アプリケーション内の 1 つのファイルだけです。</span><span class="sxs-lookup"><span data-stu-id="13bde-235">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="13bde-236">コンパイラにより、複数のソース ファイルで最上位レベル ステートメントが検出されると、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="13bde-236">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="13bde-237">また、最上位レベル ステートメントを、宣言されたプログラム エントリ ポイント メソッド (通常は `Main` メソッド) と組み合わせても、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="13bde-237">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="13bde-238">ある程度まで、その 1 つのファイルに、通常は `Program` クラスの `Main` メソッドに含まれるステートメントが含まれているものと考えることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-238">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="13bde-239">この機能の最も一般的な用途の 1 つは、教材の作成です。</span><span class="sxs-lookup"><span data-stu-id="13bde-239">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="13bde-240">C# の開発初心者は、正規の "Hello World!" を</span><span class="sxs-lookup"><span data-stu-id="13bde-240">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="13bde-241">1 行または 2 行のコードで作成できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-241">in one or two lines of code.</span></span> <span data-ttu-id="13bde-242">余分な手続きは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="13bde-242">None of the extra ceremony is needed.</span></span> <span data-ttu-id="13bde-243">一方、経験豊富な開発者は、この機能の多くの用途を見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-243">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="13bde-244">最上位レベル ステートメントを使用すると、Jupyter Notebook で提供されるものと同様の実験用にスクリプトに似たエクスペリエンスを有効にできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-244">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="13bde-245">最上位レベル ステートメントは、小規模なコンソール プログラムとユーティリティに最適です。</span><span class="sxs-lookup"><span data-stu-id="13bde-245">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="13bde-246">Azure 関数は、最上位レベル ステートメントに最適なユース ケースです。</span><span class="sxs-lookup"><span data-stu-id="13bde-246">Azure functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="13bde-247">最も重要なのは、最上位レベル ステートメントでアプリケーションのスコープや複雑さが制限されないことです。</span><span class="sxs-lookup"><span data-stu-id="13bde-247">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="13bde-248">それらのステートメントでは、任意の .NET クラスにアクセスしたり、使用したりできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-248">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="13bde-249">また、コマンド ライン引数や戻り値の使用も制限されません。</span><span class="sxs-lookup"><span data-stu-id="13bde-249">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="13bde-250">最上位レベル ステートメントでは、args という名前の文字列の配列にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="13bde-250">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="13bde-251">最上位レベル ステートメントで整数値が返される場合、その値は、合成された `Main` メソッドからの整数のリターン コードになります。</span><span class="sxs-lookup"><span data-stu-id="13bde-251">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="13bde-252">最上位レベル ステートメントには、非同期式を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-252">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="13bde-253">その場合、合成されたエントリ ポイントからは `Task` または `Task<int>` が返されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-253">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="13bde-254">パターン マッチングの拡張機能</span><span class="sxs-lookup"><span data-stu-id="13bde-254">Pattern matching enhancements</span></span>

<span data-ttu-id="13bde-255">C# 9 には、新しいパターン マッチングの機能強化が含まれています。</span><span class="sxs-lookup"><span data-stu-id="13bde-255">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="13bde-256">"***型パターン***" は、変数が型である場合に一致します</span><span class="sxs-lookup"><span data-stu-id="13bde-256">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="13bde-257">"***かっこで囲まれたパターン***" では、パターンの組み合わせの優先順位が適用または強調されます</span><span class="sxs-lookup"><span data-stu-id="13bde-257">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="13bde-258">"***接続的 `and` パターン***" では、両方のパターンが一致することが要求されます</span><span class="sxs-lookup"><span data-stu-id="13bde-258">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="13bde-259">"***離接的 `or` パターン***" では、どちらかのパターンが一致することが要求されます</span><span class="sxs-lookup"><span data-stu-id="13bde-259">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="13bde-260">"***否定的 `not` パターン***" では、パターンが一致しないことが要求されます</span><span class="sxs-lookup"><span data-stu-id="13bde-260">***Negated `not` patterns*** require that a pattern doesn’t match</span></span>
- <span data-ttu-id="13bde-261">"***関係パターン***" では、入力が定数より小さい、より大きい、以下、または以上であることが要求されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-261">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="13bde-262">これらのパターンにより、パターンの構文が豊富になります。</span><span class="sxs-lookup"><span data-stu-id="13bde-262">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="13bde-263">次のような例を考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="13bde-263">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="13bde-264">または、省略可能なかっこを使用して、`and` が `or` より優先順位が高いことを明確にします。</span><span class="sxs-lookup"><span data-stu-id="13bde-264">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="13bde-265">最も一般的な使用方法の 1 つは、null チェックの新しい構文です。</span><span class="sxs-lookup"><span data-stu-id="13bde-265">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="13bde-266">これらのパターンのいずれも、パターンが許可される任意のコンテキスト (`is` パターン式、`switch` 式、入れ子になったパターン、`switch` ステートメントの `case` ラベルのパターン) で使用できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-266">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="13bde-267">パフォーマンスと相互運用</span><span class="sxs-lookup"><span data-stu-id="13bde-267">Performance and interop</span></span>

<span data-ttu-id="13bde-268">3 つの新機能により、高パフォーマンスを必要とするネイティブ相互運用および低レベル ライブラリのサポートが向上します (ネイティブ サイズの整数、関数ポインター、`localsinit` フラグの省略)。</span><span class="sxs-lookup"><span data-stu-id="13bde-268">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="13bde-269">ネイティブ サイズの整数 `nint` と `nuint` は整数型です。</span><span class="sxs-lookup"><span data-stu-id="13bde-269">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="13bde-270">これらは、基になる型 <xref:System.IntPtr?displayProperty=nameWithType> および <xref:System.UIntPtr?displayProperty=nameWithType> によって表されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-270">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13bde-271">コンパイラによって、これらの型に対する追加の変換と操作がネイティブ int として公開されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-271">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="13bde-272">ネイティブ サイズの整数には、`MaxValue` または `MinValue` の定数はありません。ただし、`0` の `MinValue` を持つ `nuint.MinValue` は除きます。</span><span class="sxs-lookup"><span data-stu-id="13bde-272">Native sized ints don't have constants for `MaxValue` or `MinValue`, except for `nuint.MinValue`, which has a `MinValue` of `0`.</span></span> <span data-ttu-id="13bde-273">他の値は、ターゲット コンピューターでの整数のネイティブ サイズに依存するため、定数として表すことはできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-273">Other values can't be expressed as constants because it depends on the native size of an integer on the target machine.</span></span> <span data-ttu-id="13bde-274">`nint` に対する定数値は、[`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="13bde-274">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="13bde-275">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="13bde-275">`int.MaxValue`].</span></span> <span data-ttu-id="13bde-276">`nuint` に対する定数値は、[`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="13bde-276">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="13bde-277">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="13bde-277">`uint.MaxValue`].</span></span> <span data-ttu-id="13bde-278">コンパイラによって、<xref:System.Int32?displayProperty=nameWithType> 型と <xref:System.UInt32?displayProperty=nameWithType> 型を使用するすべての単項演算子と二項演算子に対して、定数の折りたたみが実行されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-278">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="13bde-279">結果が 32 ビットに収まらない場合、演算は実行時に実行され、定数とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="13bde-279">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="13bde-280">ネイティブ サイズの整数を使用すると、整数演算が広く使用されており、最速のパフォーマンスを実現する必要があるシナリオで、パフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-280">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="13bde-281">関数ポインターでは、IL オペコード `ldftn` および `calli` にアクセスするための簡単な構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-281">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="13bde-282">関数ポインターは、新しい `delegate*` 構文を使用して宣言できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-282">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="13bde-283">`delegate*` 型はポインター型です。</span><span class="sxs-lookup"><span data-stu-id="13bde-283">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="13bde-284">`Invoke()` メソッドで `callvirt` が使用されるデリゲートとは異なり、`delegate*` 型の呼び出しでは `calli` が使用されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-284">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="13bde-285">構文的には、呼び出しは同じです。</span><span class="sxs-lookup"><span data-stu-id="13bde-285">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="13bde-286">関数ポインターの呼び出しでは、`managed` の呼び出し規約が使用されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-286">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="13bde-287">`unmanaged` の呼び出し規約が必要であることを宣言するには、`delegate*` 構文の後に `unmanaged` キーワードを追加します。</span><span class="sxs-lookup"><span data-stu-id="13bde-287">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="13bde-288">その他の呼び出し規約は、`delegate*` 宣言の属性を使用して指定できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-288">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="13bde-289">最後に、<xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> を追加することで、`localsinit` フラグを生成しないようコンパイラに指示することができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-289">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="13bde-290">このフラグは、すべてのローカル変数をゼロで初期化するように CLR に指示します。</span><span class="sxs-lookup"><span data-stu-id="13bde-290">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="13bde-291">1\.0 から、`localsinit` フラグが C# に対する既定の動作でした。</span><span class="sxs-lookup"><span data-stu-id="13bde-291">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="13bde-292">しかし、一部のシナリオでは、ゼロによる初期化を追加すると、パフォーマンスに大きく影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-292">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="13bde-293">特に、`stackalloc` を使用する場合です。</span><span class="sxs-lookup"><span data-stu-id="13bde-293">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="13bde-294">そのような場合は、<xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> を追加できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-294">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="13bde-295">1 つのメソッドまたはプロパティに、または `class`、`struct`、`interface` に、さらにはモジュールに対してさえも、それを追加できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-295">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="13bde-296">この属性は `abstract` メソッドに影響しません。実装用に生成されたコードに影響します。</span><span class="sxs-lookup"><span data-stu-id="13bde-296">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="13bde-297">これらの機能により、一部のシナリオでパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-297">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="13bde-298">導入前と導入後の両方で慎重にベンチマークを行った後でのみ、使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-298">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="13bde-299">ネイティブ サイズの整数に関するコードは、複数のターゲット プラットフォームで、異なる整数サイズを使用して、テストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="13bde-299">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="13bde-300">その他の機能には、アンセーフ コードが必要です。</span><span class="sxs-lookup"><span data-stu-id="13bde-300">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="13bde-301">適合性と完成度の機能</span><span class="sxs-lookup"><span data-stu-id="13bde-301">Fit and finish features</span></span>

<span data-ttu-id="13bde-302">他の多くの機能は、コードをより効率的に記述するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="13bde-302">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="13bde-303">C# 9.0 では、作成されたオブジェクトの型が既にわかっている場合、新しい式で型を省略できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-303">In C# 9.0, you can omit the type in a new expression when the created object's type is already known.</span></span> <span data-ttu-id="13bde-304">最も一般的な使用方法は、フィールドの宣言です。</span><span class="sxs-lookup"><span data-stu-id="13bde-304">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="13bde-305">ターゲット型 new は、メソッドにパラメーターとして渡す新しいオブジェクトを作成する必要がある場合にも使用できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-305">Target type new can also be used when you need to create a new object to pass as a parameter to a method.</span></span> <span data-ttu-id="13bde-306">次のようなシグネチャを持つ `ForecastFor()` メソッドについて考えます。</span><span class="sxs-lookup"><span data-stu-id="13bde-306">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="13bde-307">これを、次のように呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-307">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="13bde-308">この機能のもう 1 つの便利な用途は、init 専用プロパティと組み合わせて、新しいオブジェクトを初期化する場合です。</span><span class="sxs-lookup"><span data-stu-id="13bde-308">Another nice use for this feature is to combine it with init only properties to initialize a new object.</span></span> <span data-ttu-id="13bde-309">`new` のかっこは省略可能です。</span><span class="sxs-lookup"><span data-stu-id="13bde-309">The parentheses on `new` are optional:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="13bde-310">`return new();` 式を使用することで、既定のコンストラクターによって作成されたインスタンスを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-310">You can return an instance created by the default constructor using a `return new();` expression.</span></span>

<span data-ttu-id="13bde-311">同様の機能により、条件式の対象となる型の解決が向上します。</span><span class="sxs-lookup"><span data-stu-id="13bde-311">A similar feature improves the target type resolution of conditional expressions.</span></span> <span data-ttu-id="13bde-312">この変更により、2 つの式の間で暗黙的な変換を行う必要はありませんが、どちらも共通型への暗黙的な変換を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-312">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a common type.</span></span> <span data-ttu-id="13bde-313">多くの場合、この変更に気付くことはありません。</span><span class="sxs-lookup"><span data-stu-id="13bde-313">You likely won’t notice this change.</span></span> <span data-ttu-id="13bde-314">気付くとすれば、以前はキャストを必要としたり、コンパイルされなかったりした一部の条件式が、機能するようになることです。</span><span class="sxs-lookup"><span data-stu-id="13bde-314">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="13bde-315">C# 9.0 以降では、`static` 修飾子をラムダ式または匿名メソッドに追加できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-315">Starting in C# 9.0, you can add the `static` modifier to lambda expressions or anonymous methods.</span></span> <span data-ttu-id="13bde-316">静的なラムダ式は、`static` ローカル関数に似ています。静的ラムダ関数または匿名関数では、ローカル変数またはインスタンスの状態をキャプチャできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-316">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous function can't capture local variables or instance state.</span></span> <span data-ttu-id="13bde-317">`static` 修飾子により、誤って他の変数がキャプチャされることがなくなります。</span><span class="sxs-lookup"><span data-stu-id="13bde-317">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="13bde-318">共変の戻り値の型を使用すると、オーバーライドされた関数の戻り値の型を柔軟に指定できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-318">Covariant return types provide flexibility for the return types of overridden functions.</span></span> <span data-ttu-id="13bde-319">オーバーライドされた仮想関数では、基底クラスのメソッドで宣言されている戻り値の型から派生した型を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-319">An overridden virtual function can return a type derived from the return type declared in the base class method.</span></span> <span data-ttu-id="13bde-320">これは、レコードや、仮想クローンまたはファクトリ メソッドをサポートするその他の型に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="13bde-320">This can be useful for Records, and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="13bde-321">次に、ラムダ式に対するパラメーターとして破棄を使用できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-321">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="13bde-322">このようにすると、引数の名前付けを避けることができ、コンパイラではその使用を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="13bde-322">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="13bde-323">任意の引数に対して `_` を使用します。</span><span class="sxs-lookup"><span data-stu-id="13bde-323">You use the `_` for any argument.</span></span>

<span data-ttu-id="13bde-324">最後に、ローカル関数に属性を適用できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="13bde-324">Finally, you can now apply attributes to local functions.</span></span> <span data-ttu-id="13bde-325">たとえば、null 許容属性の注釈をローカル関数に適用できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-325">For example, you can apply nullable attribute annotations to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="13bde-326">コード ジェネレーターのサポート</span><span class="sxs-lookup"><span data-stu-id="13bde-326">Support for code generators</span></span>

<span data-ttu-id="13bde-327">2 つの最終機能では、C# コード ジェネレーターがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="13bde-327">Two final features support C# code generators.</span></span> <span data-ttu-id="13bde-328">C# コード ジェネレーターは、roslyn アナライザーまたはコード修正と同じように記述できるコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="13bde-328">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="13bde-329">違いは、コード ジェネレーターでは、コードが分析され、コンパイル プロセスの一環として新しいソース コード ファイルが記述されることです。</span><span class="sxs-lookup"><span data-stu-id="13bde-329">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="13bde-330">一般的なコード ジェネレーターでは、属性またはその他の規則がコードで検索されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-330">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="13bde-331">コード ジェネレーターでは、Roslyn 分析 API を使用して属性または他のコード要素が読み取られます。</span><span class="sxs-lookup"><span data-stu-id="13bde-331">A code generator read attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="13bde-332">その情報を基にして、コンパイルに新しいコードが追加されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-332">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="13bde-333">ソース ジェネレーターではコードが追加されるだけで、コンパイル中の既存のコードの変更は許可されていません。</span><span class="sxs-lookup"><span data-stu-id="13bde-333">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="13bde-334">コード ジェネレーターに対して追加された 2 つの機能は、"***部分メソッド構文***" の拡張機能と、"***モジュール初期化子***" です。</span><span class="sxs-lookup"><span data-stu-id="13bde-334">The two features added for code generators are extensions to ***partial method syntax***, and ***module initializers***.</span></span> <span data-ttu-id="13bde-335">1 つ目は、部分メソッドに対する変更です。</span><span class="sxs-lookup"><span data-stu-id="13bde-335">First, the changes to partial methods.</span></span> <span data-ttu-id="13bde-336">C# 9.0 より前の部分メソッドは `private` ですが、アクセス修飾子を指定することはできず、戻り値は `void` で、`out` パラメーターを持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-336">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="13bde-337">これらの制限は、メソッドの実装を提供しないと、コンパイラによって部分メソッドのすべての呼び出しが削除されることを意味しました。</span><span class="sxs-lookup"><span data-stu-id="13bde-337">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="13bde-338">C# 9.0 ではこれらの制限はなくなりましたが、部分メソッドの宣言には実装が必要です。</span><span class="sxs-lookup"><span data-stu-id="13bde-338">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="13bde-339">コード ジェネレーターで、その実装を提供できます。</span><span class="sxs-lookup"><span data-stu-id="13bde-339">Code generators can provide that implementation.</span></span> <span data-ttu-id="13bde-340">破壊的変更が発生しないよう、コンパイラでは、アクセス修飾子を持たないすべての部分メソッドは、古い規則に従うものと見なされます。</span><span class="sxs-lookup"><span data-stu-id="13bde-340">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="13bde-341">部分メソッドに `private` アクセス修飾子が含まれている場合、その部分メソッドは新しい規則によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-341">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="13bde-342">コード ジェネレーターの 2 つ目の新機能は、"***モジュール初期化子***" です。</span><span class="sxs-lookup"><span data-stu-id="13bde-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="13bde-343">モジュール初期化子は、<xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 属性が関連付けられているメソッドです。</span><span class="sxs-lookup"><span data-stu-id="13bde-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="13bde-344">これらのメソッドは、アセンブリが読み込まれるときに、ランタイムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="13bde-344">These methods will be called by the runtime when the assembly loads.</span></span> <span data-ttu-id="13bde-345">モジュール初期化子メソッドは次のようなものです。</span><span class="sxs-lookup"><span data-stu-id="13bde-345">A module initializer method:</span></span>

- <span data-ttu-id="13bde-346">静的でなければなりません</span><span class="sxs-lookup"><span data-stu-id="13bde-346">Must be static</span></span>
- <span data-ttu-id="13bde-347">パラメーターなしである必要があります</span><span class="sxs-lookup"><span data-stu-id="13bde-347">Must be parameterless</span></span>
- <span data-ttu-id="13bde-348">void を返す必要があります</span><span class="sxs-lookup"><span data-stu-id="13bde-348">Must return void</span></span>
- <span data-ttu-id="13bde-349">ジェネリック メソッドであってはなりません</span><span class="sxs-lookup"><span data-stu-id="13bde-349">Must not be a generic method</span></span>
- <span data-ttu-id="13bde-350">ジェネリック クラスに含まれていてはなりません</span><span class="sxs-lookup"><span data-stu-id="13bde-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="13bde-351">それを含むモジュールからアクセスできる必要があります</span><span class="sxs-lookup"><span data-stu-id="13bde-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="13bde-352">最後の項目は事実上、メソッドとそれを含んでいるクラスが internal または public である必要があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="13bde-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="13bde-353">メソッドをローカル関数にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="13bde-353">The method can't be a local function.</span></span>
