---
title: C# での継承
description: C# ライブラリやアプリケーションでの継承の使用について学習します。
ms.date: 07/05/2018
ms.technology: csharp-fundamentals
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 70db8716bea84984ad56d79fa9e26aab3a8182fa
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063511"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="b97b1-103">C# と .NET での継承</span><span class="sxs-lookup"><span data-stu-id="b97b1-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="b97b1-104">このチュートリアルでは、C# での継承について説明します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="b97b1-105">継承は、オブジェクト指向プログラミング言語の一機能であり、特定の機能 (データおよび動作) を提供する基底クラスを定義し、その機能を継承またはオーバーライドする派生クラスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b97b1-106">必須コンポーネント</span><span class="sxs-lookup"><span data-stu-id="b97b1-106">Prerequisites</span></span>

<span data-ttu-id="b97b1-107">このチュートリアルでは、.NET Core SDK がインストールされていることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="b97b1-108">ダウンロードするには、[.NET Core ダウンロード](https://dotnet.microsoft.com/download) ページにアクセスしてください。</span><span class="sxs-lookup"><span data-stu-id="b97b1-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="b97b1-109">コード エディターも必要です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-109">You also need a code editor.</span></span> <span data-ttu-id="b97b1-110">このチュートリアルでは [Visual Studio Code](https://code.visualstudio.com) を使用していますが、任意のコード エディターを使用して構いません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="b97b1-111">例の実行</span><span class="sxs-lookup"><span data-stu-id="b97b1-111">Running the examples</span></span>

<span data-ttu-id="b97b1-112">このチュートリアル内の例を作成して実行するには、コマンド ラインの [dotnet](../../core/tools/dotnet.md) ユーティリティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="b97b1-113">それぞれの例について、次の手順に従います。</span><span class="sxs-lookup"><span data-stu-id="b97b1-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="b97b1-114">例を格納するディレクトリを作成します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="b97b1-115">コマンド プロンプトで [dotnet new コンソール](../../core/tools/dotnet-new.md) コマンドを入力し、新しい .NET Core プロジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="b97b1-116">例にあるコードをコピーして、コード エディターに貼り付けます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="b97b1-117">コマンド ラインから [dotnet restore](../../core/tools/dotnet-restore.md) コマンドを入力し、プロジェクトの依存関係を読み込みまたは復元します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

   [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="b97b1-118">[dotnet run](../../core/tools/dotnet-run.md) コマンドを入力して、例をコンパイルし実行します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="b97b1-119">背景: 継承とは何か</span><span class="sxs-lookup"><span data-stu-id="b97b1-119">Background: What is inheritance?</span></span>

<span data-ttu-id="b97b1-120">*継承*とは、オブジェクト指向プログラミングの基本的な属性の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="b97b1-121">親クラスの動作を再利用 (継承)、拡張、または変更する子クラスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="b97b1-122">メンバーの継承元となるクラスを、*基底クラス*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="b97b1-123">基底クラスのメンバーを継承するクラスを、*派生クラス*と呼びます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="b97b1-124">C# と .NET は*単一継承*のみをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="b97b1-125">つまり、1 つのクラスは、1 つのクラスからしか継承できないことになります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="b97b1-126">ただし継承は推移的であり、一連の型の継承階層を定義することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="b97b1-127">たとえば、`D` 型は `C` 型から継承でき、この `C` 型は `B` 型から継承され、この `B` 型は基底クラスである `A` 型から継承されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="b97b1-128">継承が推移的であるため、`A` 型のメンバーは `D` 型で使用できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="b97b1-129">基底クラスのすべてのメンバーが、派生クラスによって継承されるわけではありません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="b97b1-130">以下のメンバーは継承されません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-130">The following members are not inherited:</span></span>

- <span data-ttu-id="b97b1-131">[静的コンスラクター](../programming-guide/classes-and-structs/static-constructors.md)。クラスの静的データを初期化するもの。</span><span class="sxs-lookup"><span data-stu-id="b97b1-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="b97b1-132">[インスタンス コンストラクター](../programming-guide/classes-and-structs/constructors.md)。クラスの新しいインスタンスを作成するために呼び出すもの。</span><span class="sxs-lookup"><span data-stu-id="b97b1-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="b97b1-133">各クラスはそれ自身のコンストラクターを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="b97b1-134">[ファイナライザー](../programming-guide/classes-and-structs/destructors.md)。ランタイムのガベージ コレクターによって呼び出され、クラスのインスタンスを破棄するもの。</span><span class="sxs-lookup"><span data-stu-id="b97b1-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="b97b1-135">他のすべての基底クラスのメンバーは派生クラスに継承されますが、それらが表示されるどうかはアクセシビリティに依存します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="b97b1-136">メンバーのアクセシビリティは、次のとおり、派生したクラスの可視性に影響します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="b97b1-137">[プライベート](../language-reference/keywords/private.md) メンバーは、基底クラスで入れ子になっている派生クラスでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="b97b1-138">それ以外の場合、派生クラスでは表示されません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="b97b1-139">次の例では、`A.B` は `A` から派生した入れ子になったクラスで、`C` は `A` から派生しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="b97b1-140">プライベートの `A.value` フィールドは A.B で表示されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="b97b1-141">しかし、`C.GetValue` メソッドからコメントを削除して例をコンパイルしようとすると、コンパイラ エラー CS0122 "'A.value' is inaccessible due to its protection level." ('A.value' はアクセスできない保護レベルになっています") が生成されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="b97b1-142">[プロテクト](../language-reference/keywords/protected.md) メンバーは派生クラスでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="b97b1-143">[内部](../language-reference/keywords/internal.md)メンバーは、基底クラスと同じアセンブリ内にある派生クラスでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="b97b1-144">基底クラスとは別のアセンブリにある派生クラスでは、表示されません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="b97b1-145">[パブリック](../language-reference/keywords/public.md) メンバーは派生クラスで表示され、派生クラスのパブリック インターフェイスの一部です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="b97b1-146">パブリックの継承されたメンバーは、派生クラスで定義された場合と同様に呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="b97b1-147">次の例では、クラス `A` が `Method1` という名前のメソッドを定義し、クラス `B` がクラス `A` から継承します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="b97b1-148">そこでこの例は、`Method1` を `B` 上のインスタンス メソッドであるかのように呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="b97b1-149">派生クラスはまた、代替実装を行うことにより、継承されたメンバーを*オーバーライド*することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="b97b1-150">メンバーをオーバーライドするためには、基底クラスのメンバーは [virtual](../language-reference/keywords/virtual.md) のキーワードでマークされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="b97b1-151">既定では基底クラスのメンバーは `virtual` としてマークされていないので、オーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="b97b1-152">次の例のように、非仮想メンバーをオーバーライドしようとすると、コンパイラ エラー CS0506 "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override." ("継承されたメンバー member が virtual、abstract、または override でマークされていないため、member でオーバーライドすることができません") が生成されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="b97b1-153">場合によっては、派生クラスは基底クラスの実装をオーバーライドする*必要があります*。</span><span class="sxs-lookup"><span data-stu-id="b97b1-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="b97b1-154">[abstract](../language-reference/keywords/abstract.md) キーワードでマークされた基底クラスのメンバーは、派生クラスによってオーバーライドされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="b97b1-155">次の例をコンパイルしようとすると、コンパイラ エラー CS0534 (「&lt;クラス&gt; は継承抽象メンバー &lt;メンバー&gt; を実装しません。」) が生成されます。これは、クラス `B` が `A.Method1` の実装を提供していないためです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="b97b1-156">継承は、クラスとインターフェイスにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="b97b1-157">その他の種類のカテゴリ (構造体、デリゲート、および列挙型) は、継承をサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="b97b1-158">これらのルールのため、次の例のようなコードをコンパイルしようとすると、コンパイラ エラー CS0527 "インターフェイス リストの型 'ValueType' はインターフェイスではありません。" が生成されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="b97b1-159">このエラー メッセージは、構造体が実装するインターフェイスを定義することはできても、継承はサポートされないことを示します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="b97b1-160">暗黙的な継承</span><span class="sxs-lookup"><span data-stu-id="b97b1-160">Implicit inheritance</span></span>

<span data-ttu-id="b97b1-161">.NET 型システムの型はすべて、単一継承によって継承する型のほかに、<xref:System.Object> またはその派生型から暗黙的に継承します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="b97b1-162"><xref:System.Object> の共通の機能はあらゆる型で使用できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="b97b1-163">暗黙的な継承とはどのようなものか、新しいクラス `SimpleClass` を定義してみましょう。単純な空のクラス定義です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="b97b1-164">次に、リフレクション (型のメタデータを検査して、その型の情報を取得できるもの) を使用して、`SimpleClass` 型に属するメンバーの一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="b97b1-165">`SimpleClass` クラスにはメンバーをまだ定義していないにもかかわらず、この例の出力は、9 つのメンバーが存在することを示しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="b97b1-166">これらのメンバーのうちの 1 つは、パラメーターなし (既定) のコンストラクターで、C# コンパイラによって `SimpleClass` 型に自動的に提供されるものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="b97b1-167">あとの 8 つは <xref:System.Object> のメンバーで、この型から、.NET 型システムのすべてのクラスとインターフェイスが最終的に暗黙的に継承します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="b97b1-168"><xref:System.Object> クラスからの暗黙的な継承により、`SimpleClass` クラスで以下のメソッドが使用可能になります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="b97b1-169">パブリック `ToString` メソッド。`SimpleClass` オブジェクトを文字列表記に変換し、完全修飾型名を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="b97b1-170">ここで、`ToString` メソッドは文字列 "SimpleClass" を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="b97b1-171">2 つのオブジェクトが等しいかどうか調べる 3 つのメソッド: パブリック インスタンス `Equals(Object)` メソッド、パブリック静的 `Equals(Object, Object)` メソッド、およびパブリック静的 `ReferenceEquals(Object, Object)` メソッド。</span><span class="sxs-lookup"><span data-stu-id="b97b1-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="b97b1-172">既定により、これらのメソッドは参照の等価性を調べます。つまり、等価であるためには、2 つのオブジェクトの変数が同じオブジェクトを参照している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="b97b1-173">パブリック `GetHashCode` メソッド。型インスタンスのハッシュされたコレクションでの使用を許可する値を計算します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="b97b1-174">パブリック `GetType` メソッド。`SimpleClass` 型を表す <xref:System.Type> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="b97b1-175">保護された <xref:System.Object.Finalize%2A> メソッド。オブジェクトのメモリがガベージ コレクターによって回収される前にアンマネージ リソースを解放するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="b97b1-176">保護された <xref:System.Object.MemberwiseClone%2A> メソッド。現在のオブジェクトの浅い複製を作成します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="b97b1-177">暗黙的な継承によって、`SimpleClass` オブジェクトから任意の継承されたメンバーを、`SimpleClass` クラスで定義されたメンバーであるかのように呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="b97b1-178">たとえば、次の例では `SimpleClass.ToString` メソッドを呼び出しますが、これは `SimpleClass` が <xref:System.Object> から継承しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="b97b1-179">次の表は、C# で作成できる型のカテゴリと、暗黙的に継承する元となる型の一覧です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="b97b1-180">各々の基本型によって、暗黙的な派生型への継承を通して、異なるメンバーのセットが利用可能となります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="b97b1-181">型のカテゴリ</span><span class="sxs-lookup"><span data-stu-id="b97b1-181">Type category</span></span> | <span data-ttu-id="b97b1-182">暗黙的な継承元</span><span class="sxs-lookup"><span data-stu-id="b97b1-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="b97b1-183">class</span><span class="sxs-lookup"><span data-stu-id="b97b1-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="b97b1-184">struct</span><span class="sxs-lookup"><span data-stu-id="b97b1-184">struct</span></span>        | <span data-ttu-id="b97b1-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b97b1-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="b97b1-186">enum</span><span class="sxs-lookup"><span data-stu-id="b97b1-186">enum</span></span>          | <span data-ttu-id="b97b1-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b97b1-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="b97b1-188">delegate</span><span class="sxs-lookup"><span data-stu-id="b97b1-188">delegate</span></span>      | <span data-ttu-id="b97b1-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="b97b1-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="b97b1-190">継承と "is a" 関係</span><span class="sxs-lookup"><span data-stu-id="b97b1-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="b97b1-191">継承は通常、基底クラスと 1 つまたは複数の派生クラスとの "is a" 関係を表現するのに使用します。ここで、派生クラスは基底クラスの特殊化されたバージョン、つまり基底クラスの 1 つの型です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="b97b1-192">たとえば、`Publication` クラスはあらゆる種類の出版物を表しますが、`Book` クラスおよび `Magazine` クラスは特定の種類の出版物を表します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="b97b1-193">1 つのクラスまたは構造体は、1 つまたは複数のインターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="b97b1-194">インターフェイスの実装は、単一継承の回避策として、または構造体とともに継承を使用する方法として提示されることが多いですが、継承というよりは、インターフェイスとその実装型の間の別の関係 ("can do" 関係) を表すものとして意図されています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="b97b1-195">インターフェイスは、その実装型で使用可能とする機能 (等価性を調べる機能、オブジェクトを比較または並べ替える機能、カルチャに依存した解析および書式設定のサポート機能など) のサブセットを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="b97b1-196">なお、"is a" 関係は、型とその型の特定のインスタンス化の間の関係も表します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="b97b1-197">次の例では、`Automobile` は一意の読み取り専用プロパティを 3 つ持つクラスです。自動車の製造メーカーである `Make`、車種である `Model`、そして製造年である `Year` の 3 つです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="b97b1-198">この `Automobile` クラスはまた、プロパティ値に割り当てられている引数があるコンストラクターを持ち、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドして、`Automobile` クラスではなく `Automobile` インスタンスを一意に識別する文字列を生成します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="b97b1-199">この場合、特定の自動車メーカーと車種を表すために継承に依存すべきではありません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="b97b1-200">たとえば、Packard Motor Car 社によって製造された自動車を表すのに、`Packard` という型を定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="b97b1-201">代わりに、次の例のように、`Automobile` オブジェクトを作成して、そのクラス コンストラクターに適切な値を渡すことによって同社の自動車を表すことができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="b97b1-202">継承に基づいた is-a 関係の適用が最も適しているのは、基底クラスと、基底クラスにメンバーを追加する派生クラス、または基底クラスにない追加機能が必要な派生クラスです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="b97b1-203">基底クラスと派生クラスの設計</span><span class="sxs-lookup"><span data-stu-id="b97b1-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="b97b1-204">基底クラスとその派生クラスを設計するプロセスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="b97b1-205">このセクションでは、基底クラス `Publication` を定義します。書籍、雑誌、新聞、ジャーナル、記事などの任意の種類の出版物を表します。さらに `Publication` から派生する `Book` クラスも定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="b97b1-206">この例を拡張して、簡単に `Magazine`、`Journal`、`Newspaper`、および `Article` などの他の派生クラスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="b97b1-207">基底 Publication クラス</span><span class="sxs-lookup"><span data-stu-id="b97b1-207">The base Publication class</span></span>

<span data-ttu-id="b97b1-208">`Publication` クラスを設計するにあたり、次のように、設計についていくつか決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="b97b1-209">どのメンバーを基底クラス `Publication` に含めるか、`Publication` メンバーがメソッドの実装を提供するかどうか、`Publication` をその派生クラスのテンプレートとなる抽象基底クラスとするかどうか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="b97b1-210">ここで、`Publication` クラスはメソッドの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="b97b1-211">「[抽象基底クラスとその派生クラスの設計](#abstract)」セクションには、抽象基底クラスを使用して、派生クラスがオーバーライドする必要があるメソッドを定義する例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="b97b1-212">派生クラスは、その派生型に適した任意の実装を提供することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="b97b1-213">コードを再利用する機能 (つまり、複数の派生クラスが基底クラスのメソッドの宣言と実装を共有し、それらをオーバーライドする必要がないこと) は、非抽象基底クラスの利点です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="b97b1-214">そこで、コードが `Publication` 型の複数または非常に特殊化されたものによって共有される可能性が高い場合は、メンバーを `Publication` に追加します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="b97b1-215">基底クラスの実装を効率的に提供できていないと、基底クラスでの単一の実装で済むところを、派生クラスでほぼ同一のメンバーの実装を行わなければいけないことになります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="b97b1-216">複数の箇所で重複するコードを保守する必要が生じ、バグを引き起こす元となりえます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="b97b1-217">コードの再利用を最大化し、同時に論理的で直感的な継承階層を作成するために、`Publication` クラスには必ず、すべてもしくはほとんどの出版物に共通したデータと機能のみを含めるようにします。</span><span class="sxs-lookup"><span data-stu-id="b97b1-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="b97b1-218">そして派生クラスは、それ自身が表す特定の種類の出版物に固有のメンバーを実装します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="b97b1-219">クラス階層をどの程度まで拡張すべきか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="b97b1-220">1 つの基底クラスと 1 つまたは複数の派生クラスではなく、3 つ以上のクラス階層を作るかどうか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="b97b1-221">たとえば、`Publication` は `Periodical` の基底クラスになり得ますが、この Periodical は `Magazine`、`Journal`、および `Newspaper` の基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="b97b1-222">この例では、`Publication` クラスと 1 つの派生クラス `Book` という小さな階層を使用します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="b97b1-223">この例を簡単に拡張して、`Magazine` や `Article` など、`Publication` から派生する多くの追加のクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-223">You could easily extend the example to create a number of additional classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="b97b1-224">基底クラスのインスタンス化に意味があるのか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="b97b1-225">意味がなければ、そのクラスには [abstract](../language-reference/keywords/abstract.md) キーワードを適用します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="b97b1-226">それ以外の場合、`Publication` クラスはそのクラス コンストラクターを呼び出すことによってインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="b97b1-227">`abstract` キーワードでマークされたクラスを、そのクラス コンストラクターへの直接呼び出しによってインスタンス化しようとすると、C# コンパイラはエラー CS0144 "Cannot create an instance of the abstract class or interface." ("抽象クラスまたはインターフェイスのインスタンスを作成できません") を生成します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="b97b1-228">リフレクションを使用してクラスをインスタンス化しようとすると、そのリフレクション メソッドは <xref:System.MemberAccessException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="b97b1-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="b97b1-229">既定では、基底クラスはそのクラス コンストラクターを呼び出すことによってインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="b97b1-230">クラス コンストラクターを明示的に定義する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="b97b1-231">基底クラスのソース コード内に存在しない場合、C# コンパイラは自動的に既定の (パラメーターなしの) コンストラクターを提供します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="b97b1-232">この例では、`Publication` クラスを [abstract](../language-reference/keywords/abstract.md) としてマークして、インスタンス化できないようにします。</span><span class="sxs-lookup"><span data-stu-id="b97b1-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="b97b1-233">`abstract` メソッドなしの `abstract` クラスは、このクラスが、いくつかの具象クラス (`Book`、`Journal` など) で共有される抽象概念を表すことを示します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="b97b1-234">派生クラスで、特定のメンバーの基底クラス実装を継承する必要があるかどうか、基底クラス実装をオーバーライドするオプションがあるかどうか、または実装を提供する必要があるかどうか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="b97b1-235">[abstract](../language-reference/keywords/abstract.md) キーワードを使用して、派生クラスで実装を提供するように強制します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="b97b1-236">[virtual](../language-reference/keywords/virtual.md) キーワードを使用して、派生クラスによる基底クラス メソッドのオーバーライドを許可します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="b97b1-237">既定では、基底クラスで定義されているメソッドはオーバーライド*できません*。</span><span class="sxs-lookup"><span data-stu-id="b97b1-237">By default, methods defined in the base class are *not* overridable.</span></span>

  <span data-ttu-id="b97b1-238">`Publication` クラスには `abstract` メソッドはありませんが、クラス自体が `abstract` になります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="b97b1-239">派生クラスが継承階層内の最後のクラスを表していて、それ自体が追加の派生クラスの基底クラスとして使用できないかどうか。</span><span class="sxs-lookup"><span data-stu-id="b97b1-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="b97b1-240">既定では、どのクラスも基底クラスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="b97b1-241">[sealed](../language-reference/keywords/sealed.md) キーワードを適用すると、クラスが追加クラスの基底クラスとして使用できないことを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="b97b1-242">sealed クラスからの派生を試みると、コンパイラ エラー CS0509 "cannot derive from sealed type \<typeName>" ("シール型 typeName から派生することができません") が生成されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="b97b1-243">この例では、派生クラスを `sealed` としてマークします。</span><span class="sxs-lookup"><span data-stu-id="b97b1-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="b97b1-244">次の例では、`Publication` のソース コードを、`Publication.PublicationType` プロパティに返される `PublicationType` 列挙型とともに示します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="b97b1-245"><xref:System.Object> から継承したメンバーに加え、`Publication` クラスは次の一意のメンバーおよびメンバー オーバーライドを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="b97b1-246">コンストラクター</span><span class="sxs-lookup"><span data-stu-id="b97b1-246">A constructor</span></span>

  <span data-ttu-id="b97b1-247">`Publication` クラスは `abstract` なので、次の例のようなコードから直接インスタンス化することはできません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="b97b1-248">ただし、`Book` クラスのソース コードが示すように、インスタンス コンストラクターは派生クラスのコンストラクターから直接呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="b97b1-249">出版物に関する 2 つのプロパティ</span><span class="sxs-lookup"><span data-stu-id="b97b1-249">Two publication-related properties</span></span>

  <span data-ttu-id="b97b1-250">`Title` は読み取り専用の <xref:System.String> プロパティで、`Publication` コンストラクターを呼び出すことでその値が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="b97b1-251">`Pages` は読み取り/書き込みの <xref:System.Int32> プロパティで、出版物の総ページ数を示します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="b97b1-252">その値は `totalPages` というプライベート フィールドに格納されています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="b97b1-253">正の数である必要があり、そうでなければ <xref:System.ArgumentOutOfRangeException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="b97b1-254">出版社に関するメンバー</span><span class="sxs-lookup"><span data-stu-id="b97b1-254">Publisher-related members</span></span>

  <span data-ttu-id="b97b1-255">2 つの読み取り専用プロパティ `Publisher` と `Type`。</span><span class="sxs-lookup"><span data-stu-id="b97b1-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="b97b1-256">これらの値はもともと `Publication` クラスのコンストラクターへの呼び出しによって提供されるものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="b97b1-257">出版に関するメンバー</span><span class="sxs-lookup"><span data-stu-id="b97b1-257">Publishing-related members</span></span>

  <span data-ttu-id="b97b1-258">`Publish` および `GetPublicationDate` という 2 つのメソッドは、発行日を設定して返すものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="b97b1-259">`Publish` メソッドは、呼び出されるとプライベートの `published` フラグを `true` に設定し、渡された日付を引数としてプライベート `datePublished` フィールドに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="b97b1-260">`GetPublicationDate` メソッドは、`published` フラグが `false` の場合に文字列 "NYP" を返し、`true` の場合に `datePublished` フィールドの値を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="b97b1-261">著作権に関するメンバー</span><span class="sxs-lookup"><span data-stu-id="b97b1-261">Copyright-related members</span></span>

  <span data-ttu-id="b97b1-262">`Copyright` メソッドは、著作権者の名前および著作権年を引数として受け取り、`CopyrightName` および `CopyrightDate` プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="b97b1-263">`ToString` メソッドのオーバーライド</span><span class="sxs-lookup"><span data-stu-id="b97b1-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="b97b1-264">ある型が <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドをオーバーライドしない場合、その型の完全修飾名を返しますが、これはインスタンスの区別にはほとんど役に立ちません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="b97b1-265">`Publication` クラスは <xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドして、`Title` プロパティの値を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="b97b1-266">次の図は、基底の `Publication` クラスとその暗黙的に継承された <xref:System.Object> クラスの関係を表しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Object および Publication クラス](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="b97b1-268">`Book` クラス</span><span class="sxs-lookup"><span data-stu-id="b97b1-268">The `Book` class</span></span>

<span data-ttu-id="b97b1-269">`Book` クラスは、特定の種類の出版物としての本を表します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="b97b1-270">次の例は、`Book` クラスのソース コードを示しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="b97b1-271">`Publication` から継承したメンバーに加え、`Book` クラスは次の一意のメンバーおよびメンバー オーバーライドを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="b97b1-272">2 つのコンストラクター</span><span class="sxs-lookup"><span data-stu-id="b97b1-272">Two constructors</span></span>

  <span data-ttu-id="b97b1-273">2 つの `Book` コンストラクターは、共通パラメーターを 3 つ共有しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="b97b1-274">*タイトル*および*出版社*の 2 つは、`Publication` コンストラクターのパラメーターに対応します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="b97b1-275">3 つ目は*著者*で、パブリックの変更不可の `Author` プロパティに格納されています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="b97b1-276">1 つのコンストラクターには *isbn* パラメーターが 1 つ含まれていて、`ISBN` 自動プロパティに格納されています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="b97b1-277">最初のコンストラクターは[この](../language-reference/keywords/this.md)キーワードを使用して、他のコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="b97b1-278">コンストラクター チェーンは、コンストラクターを定義する上で一般的なパターンです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="b97b1-279">パラメーターが最も多いコンストラクターを呼び出すときに、パラメーターのより少ないコンストラクターが既定値を提供するものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="b97b1-280">2 番目のコンストラクターは [base](../language-reference/keywords/base.md) キーワードを使用して、基底クラスのコンストラクターにタイトルと出版社名を渡します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="b97b1-281">ソース コードで基底クラスのコンストラクターを明示的に呼び出さない場合、C# コンパイラは、基底クラスの既定またはパラメーターなしのコンストラクターへの呼び出しを自動的に提供します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="b97b1-282">読み取り専用の `ISBN` プロパティ。`Book` オブジェクトの ISBN (一意の 10 ～ 13 桁の数字) を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="b97b1-283">ISBN は `Book` コンストラクターの 1 つに引数として提供されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="b97b1-284">ISBN は、コンパイラで自動生成されるプライベート バッキング フィールドに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="b97b1-285">読み取り専用の `Author` プロパティ。</span><span class="sxs-lookup"><span data-stu-id="b97b1-285">A read-only `Author` property.</span></span> <span data-ttu-id="b97b1-286">著者名は両方の `Book` コンストラクターに引数として提供され、プロパティに格納されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="b97b1-287">価格に関する、2 つの読み取り専用の `Price` と `Currency` のプロパティ。</span><span class="sxs-lookup"><span data-stu-id="b97b1-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="b97b1-288">これらの値は、`SetPrice` メソッド呼び出しで引数として提供されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="b97b1-289">`Currency` プロパティは 3 桁の ISO 通貨記号 (たとえば米ドルの場合は USD) です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="b97b1-290">ISO 通貨記号は <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> プロパティから取得できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="b97b1-291">これらのプロパティは両方とも外部では読み取り専用ですが、`Book` クラスのコードによって設定できます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="b97b1-292">`SetPrice` メソッド。`Price` プロパティおよび `Currency` プロパティの値を設定します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="b97b1-293">これらの値は、それぞれ同じプロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="b97b1-294">`ToString` メソッド (`Publication` から継承) へのオーバーライドと、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドおよび <xref:System.Object.GetHashCode%2A> メソッド (<xref:System.Object> から継承) へのオーバーライド。</span><span class="sxs-lookup"><span data-stu-id="b97b1-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="b97b1-295">オーバーライドされない限り、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドは参照の等価性を調べます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="b97b1-296">つまり、2 つのオブジェクト変数は同じオブジェクトを参照している場合に等価であると見なされます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="b97b1-297">一方、`Book` クラスでは、2 つの `Book` オブジェクトは同じ ISBN を持つ場合に等価であるはずです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="b97b1-298"><xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドする場合、<xref:System.Object.GetHashCode%2A> メソッドもオーバーライドする必要があります。このメソッドは、ランタイムで項目をハッシュされたコレクションに格納し効率的に取得するために使用する値を返すものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="b97b1-299">ハッシュ コードは、等価性のテストと一致する値を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="b97b1-300"><xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> をオーバーライドして、2 つの `Book` オブジェクトの ISBN プロパティが等しい場合に `true` を返すようにしたので、`ISBN` プロパティによって返される文字列の <xref:System.String.GetHashCode%2A> メソッドを呼び出すことにより計算されるハッシュ コードを返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="b97b1-301">次の図は、`Book` クラスとその基底クラスである `Publication` の関係を表しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Publication クラスおよび Book クラス](media/book-class.jpg)

<span data-ttu-id="b97b1-303">これで、次の例に示すように、`Book` オブジェクトをインスタンス化して、その一意のメンバーと継承されたメンバーの両方を呼び出し、`Publication` 型または `Book` 型のパラメーターを必要とするメソッドに引数として渡すことができるようになりました。</span><span class="sxs-lookup"><span data-stu-id="b97b1-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="b97b1-304">抽象基底クラスとその派生クラスの設計</span><span class="sxs-lookup"><span data-stu-id="b97b1-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="b97b1-305">前述の例では、多くのメソッドの実装を提供する基底クラスを定義し、派生クラスがコードを共有できるようにしました。</span><span class="sxs-lookup"><span data-stu-id="b97b1-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="b97b1-306">しかし多くの場合、基底クラスが実装を提供する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b97b1-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="b97b1-307">むしろ基底クラスは、*抽象メソッド* を宣言する*抽象クラス* であり、各派生クラスで実装する必要があるメンバーを定義するテンプレートとして機能します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="b97b1-308">通常、抽象基底クラスでは、派生型の実装はそれぞれその型に固有のものです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="b97b1-309">クラスでは出版物に共通の機能の実装が提供されましたが、`Publication` オブジェクトをインスタンス化しても意味はないので、クラスは abstract キーワードでマークしました。</span><span class="sxs-lookup"><span data-stu-id="b97b1-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="b97b1-310">たとえば、2 次元の閉じた幾何学図形には、2 つのプロパティが含まれます。図形の内部の大きさである面積と、図形の辺に沿った長さである周です。</span><span class="sxs-lookup"><span data-stu-id="b97b1-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="b97b1-311">一方で、これらのプロパティの計算方法は、それぞれの図形によって違います。</span><span class="sxs-lookup"><span data-stu-id="b97b1-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="b97b1-312">たとえば、円周の計算式は、三角形の周の計算式とは異なります。</span><span class="sxs-lookup"><span data-stu-id="b97b1-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="b97b1-313">`Shape` クラスは、`abstract` メソッドがある `abstract` クラスです。</span><span class="sxs-lookup"><span data-stu-id="b97b1-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="b97b1-314">これは、派生クラスで同じ機能が共有されるものの、それらの派生クラスではその機能が異なる方法で実装されることを示します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="b97b1-315">次の例では、`Area` と `Perimeter` という 2 つのプロパティを定義する、`Shape` という名前の抽象基底クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="b97b1-316">クラスを [abstract](../language-reference/keywords/abstract.md) キーワードでマークするだけでなく、インスタンス メンバーもそれぞれ [abstract](../language-reference/keywords/abstract.md) キーワードでマークされます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="b97b1-317">ここで `Shape` は <xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドもオーバーライドして、完全修飾名ではなく、その型の名前を返します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="b97b1-318">そして `GetArea` と `GetPerimeter` の 2 つの静的メンバーを定義し、呼び出し元で任意の派生クラスのインスタンスの面積と周を簡単に取得できるようにします。</span><span class="sxs-lookup"><span data-stu-id="b97b1-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="b97b1-319">これらのメソッドのいずれかに派生クラスのインスタンスを渡すとき、ランタイムは派生クラスのメソッド オーバーライドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="b97b1-320">ここで特定の図形を表す `Shape` から、いくつかのクラスを派生させることができます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="b97b1-321">次の例では、`Triangle`、`Rectangle`、および `Circle` の 3 つのクラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="b97b1-322">これらのクラスはそれぞれ、その図形に一意の数式を使用して面積と周を計算します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="b97b1-323">一部の派生クラスも、`Rectangle.Diagonal` や `Circle.Diameter` など、その図形に固有のプロパティを定義します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="b97b1-324">次の例では、`Shape` から派生したオブジェクトを使用しています。</span><span class="sxs-lookup"><span data-stu-id="b97b1-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="b97b1-325">ここでは `Shape` から派生したオブジェクトの配列をインスタンス化して、`Shape` クラスの静的メソッドを呼び出します。これにより、返された `Shape` のプロパティ値がラップされます。</span><span class="sxs-lookup"><span data-stu-id="b97b1-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="b97b1-326">ランタイムは、派生型のオーバーライドされたプロパティから値を取得します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="b97b1-327">この例ではまた、配列内の `Shape` オブジェクトをそれぞれの派生型にキャストし、キャストが成功すると、その特定の `Shape` サブクラスのプロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="b97b1-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="b97b1-328">関連項目</span><span class="sxs-lookup"><span data-stu-id="b97b1-328">See also</span></span>

- [<span data-ttu-id="b97b1-329">継承 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="b97b1-329">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
