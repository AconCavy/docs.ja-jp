---
title: C# の構造体 - C# 言語のツアー
description: 構造体と呼ばれる C# の値型の基本を学ぶ
ms.date: 08/10/2016
ms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8
ms.openlocfilehash: d22cb23fe095874f24d7c002dfdb3eefdde66722
ms.sourcegitcommit: d9a0071d0fd490ae006c816f78a563b9946e269a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/25/2019
ms.locfileid: "55065961"
---
# <a name="structs"></a>構造体

***構造体***は、クラスと同様に、データ メンバーおよび関数メンバーを含むことができるデータ構造ですが、値型でありヒープ割り当てを必要としない点でクラスと異なります。 構造体型の変数は、構造体のデータを直接格納しますが、クラス型の変数は、動的に割り当てられたオブジェクトへの参照を格納します。 構造体型はユーザー指定の継承をサポートせず、すべての構造体型は暗黙的に <xref:System.ValueType> 型を継承し、この型はさらに `object` を暗黙的に継承します。

構造体は、値セマンティクスを持つ小規模なデータ構造に特に便利です。 構造体の主な例としては、複素数、座標系のポイント、ディクショナリのキーと値のペアなどがあります。 小規模なデータ構造には、クラスよりむしろ構造体を使用するほうが、アプリケーションが実行するメモリ割り当ての数を大幅に減らすことができます。 たとえば、次のプログラムでは、100 個のポイントの配列を作成し初期化します。 `Point` をクラスとして実装すると、101 個の別々のオブジェクトがインスタンス化されます。配列に1 個、残りは 100 個の要素に 1 個ずつです。

[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]

これに代わる方法が、ポイントを構造体にすることです。

[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]

ここでは 1 つのオブジェクトのみがインスタンス化されます。すなわち、配列に 1 個です。そして、`Point` インスタンスがその配列内にインラインで格納されます。

構造体コンストラクターは、クラス コンストラクターに似た `new` 演算子で呼び出されます。 ただし、オブジェクトをマネージド ヒープに動的に割り当てそこへの参照を返す代わりに、構造体コンストラクターは単に構造体の値自体 (通常、スタック上の一時的な場所) を返し、この値は必要に応じてコピーされます。

クラスを使用すると、2 つの変数が同じオブジェクトを参照できるため、1 つの変数に対する操作によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができます。 構造体を使用すると、各々の変数がデータのコピーを各々で持ち、1 つに対する操作がもう一方に影響を与えることはできません。 たとえば、次のコードによって生成される出力は、ポイントがクラスであるか構造体であるかによって異なります。

[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]

`Point` がクラスである場合、`a` と `b` は同じオブジェクトを参照しているので、出力は 20 です。 `Point` が構造体である場合、出力は 10 です。`a` の `b` への割り当ては値のコピーを作成し、このコピーは後続の `a.x` への割り当てには影響されないからです。

前述の例では、構造体の 2 つの制限事項が強調されています。 1 つめは、構造体全体をコピーすることは通常、オブジェクト参照をコピーするよりも非効率であり、割り当てと値パラメーターの引き渡しは参照型よりも構造体のほうが手がかかるということです。 2 つめは、`in`、`ref`、`out` パラメーターを除いて、構造体への参照を作成することはできず、そのために構造体を使用できない状況が数多くあるということです。

>[!div class="step-by-step"]
>[前へ](classes-and-objects.md)
>[次へ](arrays.md)
