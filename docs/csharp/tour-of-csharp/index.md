---
title: C# のツアー - C# ガイド
description: C# を始めてお使いの方のために、 この言語の基本を説明します。
ms.date: 08/06/2020
ms.openlocfilehash: 84775a436deb0958d3c05ec7d0207e76be28f27c
ms.sourcegitcommit: e7acba36517134238065e4d50bb4a1cfe47ebd06
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/04/2020
ms.locfileid: "89465001"
---
# <a name="a-tour-of-the-c-language"></a><span data-ttu-id="1a06f-104">C# 言語のツアー</span><span class="sxs-lookup"><span data-stu-id="1a06f-104">A tour of the C# language</span></span>

<span data-ttu-id="1a06f-105">C# ("シー シャープ" と読みます) は、最新のタイプ セーフなオブジェクト指向のプログラミング言語です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-105">C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language.</span></span> <span data-ttu-id="1a06f-106">C# は C 言語ファミリーをルーツとしているため、C、C++、Java、JavaScript のプログラマーであればすぐに使いこなすことができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-106">C# has its roots in the C family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers.</span></span> <span data-ttu-id="1a06f-107">このツアーでは、C# 8 以前の言語の主要なコンポーネントの概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-107">This tour provides an overview of the major components of the language in C# 8 and earlier.</span></span> <span data-ttu-id="1a06f-108">対話型の例を通して言語を調べたい場合は、[C# の概要](../tutorials/intro-to-csharp/index.md)に関するチュートリアルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1a06f-108">If you want to explore the language through interactive examples, try the [introduction to C#](../tutorials/intro-to-csharp/index.md) tutorials.</span></span>

<span data-ttu-id="1a06f-109">C# は、オブジェクト指向、"***コンポーネント指向***" のプログラミング言語です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-109">C# is an object-oriented, ***component-oriented*** programming language.</span></span> <span data-ttu-id="1a06f-110">C# はこれらの概念を直接サポートする言語コンストラクトを提供しているので、自然にソフトウェア コンポーネントを作成して使用することができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-110">C# provides language constructs to directly support these concepts, making C# a natural language in which to create and use software components.</span></span> <span data-ttu-id="1a06f-111">当初から、C# では、新しいワークロードと新しいソフトウェア設計プラクティスをサポートする機能が追加されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-111">Since its origin, C# has added features to support new workloads and emerging software design practices.</span></span>

<span data-ttu-id="1a06f-112">C# には、堅牢で永続的なアプリケーションの構築を支援するさまざまな機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-112">Several C# features aid in the construction of robust and durable applications.</span></span> <span data-ttu-id="1a06f-113">"[***ガベージ コレクション***](../../standard/garbage-collection/index.md)" は、到達できず、使用されていないオブジェクトによって占有されたメモリを自動的に解放します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-113">[***Garbage collection***](../../standard/garbage-collection/index.md) automatically reclaims memory occupied by unreachable unused objects.</span></span> <span data-ttu-id="1a06f-114">"[***例外処理***](../programming-guide/exceptions/index.md)" は、エラーの検出と復旧を行うための構造化された拡張可能なアプローチを提供します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-114">[***Exception handling***](../programming-guide/exceptions/index.md) provides a structured and extensible approach to error detection and recovery.</span></span> <span data-ttu-id="1a06f-115">"[***ラムダ式***](../language-reference/operators/lambda-expressions.md)" は、関数型プログラミング手法をサポートします。</span><span class="sxs-lookup"><span data-stu-id="1a06f-115">[***Lambda expressions***](../language-reference/operators/lambda-expressions.md) support functional programming techniques.</span></span> <span data-ttu-id="1a06f-116">"[***クエリ構文***](../linq/index.md)" では、任意のソースからのデータを操作するための一般的なパターンが作成されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-116">[***Query syntax***](../linq/index.md) creates a common pattern for working with data from any source.</span></span> <span data-ttu-id="1a06f-117">"[***非同期操作***](../programming-guide/concepts/async/index.md)" の言語サポートでは、分散システムを構築するための構文が提供されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-117">Language support for [***asynchronous operations***](../programming-guide/concepts/async/index.md) provides syntax for building distributed systems.</span></span> <span data-ttu-id="1a06f-118">"[***パターン マッチング***](..//pattern-matching.md)" には、最新の分散システムのアルゴリズムからのデータを簡単に分割するための構文が用意されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-118">[***Pattern matching***](..//pattern-matching.md) provides syntax to easily separate data from algorithms in modern distributed systems.</span></span> <span data-ttu-id="1a06f-119">C# は "[***統合型システム***](../programming-guide/types/index.md)" を採用しています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-119">C# has a [***unified type system***](../programming-guide/types/index.md).</span></span> <span data-ttu-id="1a06f-120">`int` や `double` などのプリミティブ型を含めた C# のすべての型は、ルートとなる 1 つの `object` 型から派生しています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-120">All C# types, including primitive types such as `int` and `double`, inherit from a single root `object` type.</span></span> <span data-ttu-id="1a06f-121">すべての型は、一般的な操作のセットを共有します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-121">All types share a set of common operations.</span></span> <span data-ttu-id="1a06f-122">すべての型の値を一貫した方法で格納、転送、操作することができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-122">Values of any type can be stored, transported, and operated upon in a consistent manner.</span></span> <span data-ttu-id="1a06f-123">さらに、C# では、ユーザー定義の参照型と値型の両方がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-123">Furthermore, C# supports both user-defined reference types and value types.</span></span> <span data-ttu-id="1a06f-124">C# では、オブジェクトを動的に割り当てたり、軽量の構造体をインラインで格納したりすることもできます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-124">C# allows dynamic allocation of objects and in-line storage of lightweight structures.</span></span>

<span data-ttu-id="1a06f-125">C# では、プログラムとライブラリが互換性を保ちながら時間とともに進化できるように、"***バージョン管理***" に重点が置かれています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-125">C# emphasizes ***versioning*** to ensure programs and libraries can evolve over time in a compatible manner.</span></span> <span data-ttu-id="1a06f-126">C# の設計でバージョン管理の考慮の影響を直接受けている側面として、別個の `virtual` 修飾子と `override` 修飾子、メソッドのオーバーロードの解決規則、明示的なインターフェイス メンバー宣言のサポートなどがあります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-126">Aspects of C#'s design that were directly influenced by versioning considerations include the separate `virtual` and `override` modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</span></span>

## <a name="hello-world"></a><span data-ttu-id="1a06f-127">Hello world</span><span class="sxs-lookup"><span data-stu-id="1a06f-127">Hello world</span></span>

<span data-ttu-id="1a06f-128">"Hello, World" は、プログラミング言語を紹介するために伝統的に使用されているプログラムです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-128">The "Hello, World" program is traditionally used to introduce a programming language.</span></span> <span data-ttu-id="1a06f-129">これを C# で記述すると次のようになります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-129">Here it is in C#:</span></span>

:::code language="csharp" interactive="try-dotnet" source="./snippets/shared/HelloWorld.cs":::

<span data-ttu-id="1a06f-130">"Hello, World" プログラムは `System` 名前空間を参照する `using` ディレクティブで始まります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-130">The "Hello, World" program starts with a `using` directive that references the `System` namespace.</span></span> <span data-ttu-id="1a06f-131">名前空間は、C# のプログラムとライブラリを階層的に整理するための手段です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-131">Namespaces provide a hierarchical means of organizing C# programs and libraries.</span></span> <span data-ttu-id="1a06f-132">名前空間には、型と他の名前空間が含まれます。たとえば、`System` 名前空間には多数の型 (プログラムで参照される `Console` クラスなど) と、他の多数の名前空間 (`IO` や `Collections` など) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-132">Namespaces contain types and other namespaces—for example, the `System` namespace contains a number of types, such as the `Console` class referenced in the program, and a number of other namespaces, such as `IO` and `Collections`.</span></span> <span data-ttu-id="1a06f-133">特定の名前空間を参照する `using` ディレクティブを使用すると、その名前空間のメンバーである型を修飾せずに使用できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-133">A `using` directive that references a given namespace enables unqualified use of the types that are members of that namespace.</span></span> <span data-ttu-id="1a06f-134">`using` ディレクティブにより、プログラムで `Console.WriteLine` を `System.Console.WriteLine` の省略形として使用できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-134">Because of the `using` directive, the program can use `Console.WriteLine` as shorthand for `System.Console.WriteLine`.</span></span>

<span data-ttu-id="1a06f-135">"Hello, World" プログラムで宣言された `Hello` クラスにはメンバーが 1 つあります。`Main` という名前のメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-135">The `Hello` class declared by the "Hello, World" program has a single member, the method named `Main`.</span></span> <span data-ttu-id="1a06f-136">`Main` メソッドは `static` 修飾子を使用して宣言されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-136">The `Main` method is declared with the `static` modifier.</span></span> <span data-ttu-id="1a06f-137">インスタンス メソッドが `this` で囲んだ特定のオブジェクト インスタンスを参照できるのに対し、静的メソッドは特定のオブジェクトを参照せずに機能します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-137">While instance methods can reference a particular enclosing object instance using the keyword `this`, static methods operate without reference to a particular object.</span></span> <span data-ttu-id="1a06f-138">規則により、`Main` という名前の静的メソッドは C# プログラムのエントリ ポイントとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-138">By convention, a static method named `Main` serves as the entry point of a C# program.</span></span>

<span data-ttu-id="1a06f-139">プログラムの出力は、`System` 名前空間にある `Console` クラスの `WriteLine` メソッドによって生成されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-139">The output of the program is produced by the `WriteLine` method of the `Console` class in the `System` namespace.</span></span> <span data-ttu-id="1a06f-140">このクラスは、コンパイラによって自動的に参照される、標準のクラス ライブラリで提供されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-140">This class is provided by the standard class libraries, which, by default, are automatically referenced by the compiler.</span></span>

## <a name="types-and-variables"></a><span data-ttu-id="1a06f-141">型と変数</span><span class="sxs-lookup"><span data-stu-id="1a06f-141">Types and variables</span></span>

<span data-ttu-id="1a06f-142">C# には、*値型*と*参照型*という 2 種類の型があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-142">There are two kinds of types in C#: *value types* and *reference types*.</span></span> <span data-ttu-id="1a06f-143">値型の変数が直接データを格納するのに対して、参照型の変数はデータへの参照を格納し、後者はオブジェクトとして知られています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-143">Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects.</span></span> <span data-ttu-id="1a06f-144">参照型を使用すると 2 つの変数が同じオブジェクトを参照でき、1 つの変数に対する演算によって、もう一方の変数によって参照されるオブジェクトに影響を与えることができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-144">With reference types, it's possible for two variables to reference the same object and possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="1a06f-145">値型の場合、各変数によって独自のデータ コピーが保持され、1 つの変数に対する演算によって別の変数に影響を与えることはできません (`ref` と `out` のパラメーターの変数を除く)。</span><span class="sxs-lookup"><span data-stu-id="1a06f-145">With value types, the variables each have their own copy of the data, and it isn't possible for operations on one to affect the other (except for `ref` and `out` parameter variables).</span></span>

<span data-ttu-id="1a06f-146">"***識別子***" は変数名です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-146">An ***identifier*** is a variable name.</span></span> <span data-ttu-id="1a06f-147">識別子は、空白を含まない unicode 文字のシーケンスです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-147">An identifier is a sequence of unicode characters without any whitespace.</span></span> <span data-ttu-id="1a06f-148">先頭に `@` が指定されている場合、識別子は C# の予約語になります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-148">An identifier may be a C# reserved word, if it is prefixed by `@`.</span></span> <span data-ttu-id="1a06f-149">これは、他の言語と対話するときに便利です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-149">That can be useful when interacting with other languages.</span></span>

<span data-ttu-id="1a06f-150">C# の値の型はさらに、"*単純型*"、"*列挙型*"、"*構造体型*"、"*null 許容値型*"、および "*タプル値型*" に分けられます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-150">C#'s value types are further divided into *simple types*, *enum types*, *struct types*, *nullable value types* and *tuple value types*.</span></span> <span data-ttu-id="1a06f-151">C# の参照型はさらに、"*クラス型*"、"*インターフェイス型*"、"*配列型*"、および "*デリゲート型*" に分けられます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-151">C#'s reference types are further divided into *class types*, *interface types*, *array types*, and *delegate types*.</span></span>

<span data-ttu-id="1a06f-152">以下は、C# の型システムの概要です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-152">The following outline provides an overview of C#'s type system.</span></span>

- [<span data-ttu-id="1a06f-153">値型</span><span class="sxs-lookup"><span data-stu-id="1a06f-153">Value types</span></span>](../language-reference/builtin-types/value-types.md)
  - [<span data-ttu-id="1a06f-154">単純型</span><span class="sxs-lookup"><span data-stu-id="1a06f-154">Simple types</span></span>](../language-reference/builtin-types/value-types.md#built-in-value-types)
    - <span data-ttu-id="1a06f-155">[符号付きの整数](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`、`short`、`int`、`long`</span><span class="sxs-lookup"><span data-stu-id="1a06f-155">[Signed integral](../language-reference/builtin-types/integral-numeric-types.md): `sbyte`, `short`, `int`, `long`</span></span>
    - <span data-ttu-id="1a06f-156">[符号なしの整数](../language-reference/builtin-types/integral-numeric-types.md): `byte`、`ushort`、`uint`、`ulong`</span><span class="sxs-lookup"><span data-stu-id="1a06f-156">[Unsigned integral](../language-reference/builtin-types/integral-numeric-types.md): `byte`, `ushort`, `uint`, `ulong`</span></span>
    - <span data-ttu-id="1a06f-157">[Unicode 文字](../../standard/base-types/character-encoding-introduction.md): `char` (UTF-16 コード単位を表します)</span><span class="sxs-lookup"><span data-stu-id="1a06f-157">[Unicode characters](../../standard/base-types/character-encoding-introduction.md): `char`, which represents a UTF-16 code unit</span></span>
    - <span data-ttu-id="1a06f-158">[IEEE バイナリ浮動小数点数](../language-reference/builtin-types/floating-point-numeric-types.md): `float`、`double`</span><span class="sxs-lookup"><span data-stu-id="1a06f-158">[IEEE binary floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `float`, `double`</span></span>
    - <span data-ttu-id="1a06f-159">[高精度 10 進浮動小数点数](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span><span class="sxs-lookup"><span data-stu-id="1a06f-159">[High-precision decimal floating-point](../language-reference/builtin-types/floating-point-numeric-types.md): `decimal`</span></span>
    - <span data-ttu-id="1a06f-160">ブール値: `bool` (ブール値を表します。値は `true` か `false` のどちらかです)</span><span class="sxs-lookup"><span data-stu-id="1a06f-160">Boolean: `bool`, which represents Boolean values—values that are either `true` or `false`</span></span>
  - [<span data-ttu-id="1a06f-161">列挙型</span><span class="sxs-lookup"><span data-stu-id="1a06f-161">Enum types</span></span>](../language-reference/builtin-types/enum.md)
    - <span data-ttu-id="1a06f-162">形式 `enum E {...}` のユーザー定義型。</span><span class="sxs-lookup"><span data-stu-id="1a06f-162">User-defined types of the form `enum E {...}`.</span></span> <span data-ttu-id="1a06f-163">`enum` 型は、名前付き定数を持つ固有の型です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-163">An `enum` type is a distinct type with named constants.</span></span> <span data-ttu-id="1a06f-164">`enum` 型にはそれぞれ基になる型があり、これは 8 つの整数型のいずれかでなければいけません。</span><span class="sxs-lookup"><span data-stu-id="1a06f-164">Every `enum` type has an underlying type, which must be one of the eight integral types.</span></span> <span data-ttu-id="1a06f-165">`enum` 型の値のセットは、その基になる型の値のセットと同じです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-165">The set of values of an `enum` type is the same as the set of values of the underlying type.</span></span>
  - [<span data-ttu-id="1a06f-166">構造体の型</span><span class="sxs-lookup"><span data-stu-id="1a06f-166">Struct types</span></span>](../language-reference/builtin-types/struct.md)
    - <span data-ttu-id="1a06f-167">`struct S {...}` 形式のユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="1a06f-167">User-defined types of the form `struct S {...}`</span></span>
  - [<span data-ttu-id="1a06f-168">null 許容値型</span><span class="sxs-lookup"><span data-stu-id="1a06f-168">Nullable value types</span></span>](../language-reference/builtin-types/nullable-value-types.md)
    - <span data-ttu-id="1a06f-169">`null` 値を持つその他すべての値型の拡張子</span><span class="sxs-lookup"><span data-stu-id="1a06f-169">Extensions of all other value types with a `null` value</span></span>
  - [<span data-ttu-id="1a06f-170">タプル値型</span><span class="sxs-lookup"><span data-stu-id="1a06f-170">Tuple value types</span></span>](../language-reference/builtin-types/value-tuples.md)
    - <span data-ttu-id="1a06f-171">`(T1, T2, ...)` 形式のユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="1a06f-171">User-defined types of the form `(T1, T2, ...)`</span></span>
- [<span data-ttu-id="1a06f-172">参照型</span><span class="sxs-lookup"><span data-stu-id="1a06f-172">Reference types</span></span>](../language-reference/keywords/reference-types.md)
  - [<span data-ttu-id="1a06f-173">クラス型</span><span class="sxs-lookup"><span data-stu-id="1a06f-173">Class types</span></span>](../language-reference/keywords/class.md)
    - <span data-ttu-id="1a06f-174">その他すべての型の最終的な基底クラス: `object`</span><span class="sxs-lookup"><span data-stu-id="1a06f-174">Ultimate base class of all other types: `object`</span></span>
    - <span data-ttu-id="1a06f-175">[Unicode 文字列](../../standard/base-types/character-encoding-introduction.md): `string` (一連の UTF-16 コード単位を表します)</span><span class="sxs-lookup"><span data-stu-id="1a06f-175">[Unicode strings](../../standard/base-types/character-encoding-introduction.md): `string`, which represents a sequence of UTF-16 code units</span></span>
    - <span data-ttu-id="1a06f-176">`class C {...}` 形式のユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="1a06f-176">User-defined types of the form `class C {...}`</span></span>
  - [<span data-ttu-id="1a06f-177">インターフェイス型</span><span class="sxs-lookup"><span data-stu-id="1a06f-177">Interface types</span></span>](../language-reference/keywords/interface.md)
    - <span data-ttu-id="1a06f-178">`interface I {...}` 形式のユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="1a06f-178">User-defined types of the form `interface I {...}`</span></span>
  - [<span data-ttu-id="1a06f-179">配列型</span><span class="sxs-lookup"><span data-stu-id="1a06f-179">Array types</span></span>](../programming-guide/arrays/index.md)
    - <span data-ttu-id="1a06f-180">1 次元、多次元、およびジャグ。</span><span class="sxs-lookup"><span data-stu-id="1a06f-180">Single-dimensional, multi-dimensional and jagged.</span></span> <span data-ttu-id="1a06f-181">例: `int[]`、`int[,]`、`int[][]`</span><span class="sxs-lookup"><span data-stu-id="1a06f-181">For example: `int[]`, `int[,]`, and `int[][]`</span></span>
  - [<span data-ttu-id="1a06f-182">デリゲート型</span><span class="sxs-lookup"><span data-stu-id="1a06f-182">Delegate types</span></span>](../language-reference/builtin-types/reference-types.md#the-delegate-type)
    - <span data-ttu-id="1a06f-183">`delegate int D(...)` 形式のユーザー定義型</span><span class="sxs-lookup"><span data-stu-id="1a06f-183">User-defined types of the form `delegate int D(...)`</span></span>

<span data-ttu-id="1a06f-184">C# プログラムでは*型宣言*を使用して新しい型を作成します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-184">C# programs use *type declarations* to create new types.</span></span> <span data-ttu-id="1a06f-185">型宣言は、新しい型の名前とメンバーを指定します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-185">A type declaration specifies the name and the members of the new type.</span></span> <span data-ttu-id="1a06f-186">C# の型カテゴリのうち 6 つはユーザー定義が可能です。クラス型、構造体型、インターフェイス型、列挙型、デリゲート型、およびタプル値型です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-186">Six of C#'s categories of types are user-definable: class types, struct types, interface types, enum types, delegate types and tuple value types.</span></span>

- <span data-ttu-id="1a06f-187">`class` 型は、データ メンバー (フィールド) と関数メンバー (メソッド、プロパティ、その他) を含むデータ構造を定義します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-187">A `class` type defines a data structure that contains data members (fields) and function members (methods, properties, and others).</span></span> <span data-ttu-id="1a06f-188">クラス型では、単一継承とポリモーフィズムをサポートします。このメカニズムによって派生クラスが基底クラスを拡張して特殊化できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-188">Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</span></span>
- <span data-ttu-id="1a06f-189">`struct` 型は、データ メンバーおよび関数メンバーで構造体を表す点において、クラス型に似ています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-189">A `struct` type is similar to a class type in that it represents a structure with data members and function members.</span></span> <span data-ttu-id="1a06f-190">ただしクラスと異なり、構造体は値型で、通常はヒープ割り当てが不要です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-190">However, unlike classes, structs are value types and don't typically require heap allocation.</span></span> <span data-ttu-id="1a06f-191">構造体型ではユーザー指定の継承がサポートされず、すべての構造体型によって暗黙的に `object` 型が継承されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-191">Struct types don't support user-specified inheritance, and all struct types implicitly inherit from type `object`.</span></span>
- <span data-ttu-id="1a06f-192">`interface` 型では、パブリック メンバーの名前付きセットとしてコントラクトが定義されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-192">An `interface` type defines a contract as a named set of public members.</span></span> <span data-ttu-id="1a06f-193">`interface` を実装する `class` または `struct` は、インターフェイスのメンバーの実装を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-193">A `class` or `struct` that implements an `interface` must provide implementations of the interface's members.</span></span> <span data-ttu-id="1a06f-194">`interface` は複数の基底インターフェイスから継承することがあり、`class` または `struct` は複数のインターフェイスを実装することがあります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-194">An `interface` may inherit from multiple base interfaces, and a `class` or `struct` may implement multiple interfaces.</span></span>
- <span data-ttu-id="1a06f-195">`delegate` 型は、特定のパラメーター リストおよび戻り値を使用してメソッドへの参照を表します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-195">A `delegate` type represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="1a06f-196">デリゲートを使用すると、変数に割り当ててパラメーターとして渡すことのできるエンティティとして、メソッドを処理できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-196">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="1a06f-197">デリゲートは、関数型言語で提供される関数の型に似ています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-197">Delegates are analogous to function types provided by functional languages.</span></span> <span data-ttu-id="1a06f-198">また、他のいくつかの言語で見られる関数ポインターの概念に似ています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-198">They're also similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="1a06f-199">ただし、関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セーフです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-199">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="1a06f-200">`class`、`struct`、`interface` および `delegate` の型はすべてジェネリックをサポートし、他の型と共にパラメーター化できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-200">The `class`, `struct`, `interface`, and `delegate` types all support generics, whereby they can be parameterized with other types.</span></span>

<span data-ttu-id="1a06f-201">C# では、あらゆる型の 1 次元および多次元の配列がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-201">C# supports single-dimensional and multi-dimensional arrays of any type.</span></span> <span data-ttu-id="1a06f-202">上記の型とは異なり、配列型は使用前に宣言する必要がありません。</span><span class="sxs-lookup"><span data-stu-id="1a06f-202">Unlike the types listed above, array types don't have to be declared before they can be used.</span></span> <span data-ttu-id="1a06f-203">代わりに配列型は、角かっこで囲んだ型名を後に付けることにより構成されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-203">Instead, array types are constructed by following a type name with square brackets.</span></span> <span data-ttu-id="1a06f-204">たとえば、`int[]` は `int` の 1 次元配列、`int[,]` は `int` の 2 次元配列、`int[][]` は `int` の 1 次元配列の 1 次元配列、または "ジャグ" 配列です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-204">For example, `int[]` is a single-dimensional array of `int`, `int[,]` is a two-dimensional array of `int`, and `int[][]` is a single-dimensional array of single-dimensional arrays, or a "jagged" array, of `int`.</span></span>

<span data-ttu-id="1a06f-205">null 許容型は個別の定義を必要としません。</span><span class="sxs-lookup"><span data-stu-id="1a06f-205">Nullable types don't require a separate definition.</span></span> <span data-ttu-id="1a06f-206">null 非許容型 `T` のそれぞれについて、対応する null 許容型 `T?` があり、これは追加値 `null` を保持することができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-206">For each non-nullable type `T`, there's a corresponding nullable type `T?`, which can hold an additional value, `null`.</span></span> <span data-ttu-id="1a06f-207">たとえば、`int?` は 32 ビット整数または値 `null` を保持できる型であり、`string?` は `string` または値 `null` を保持できる型です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-207">For instance, `int?` is a type that can hold any 32-bit integer or the value `null`, and `string?` is a type that can hold any `string` or the value `null`.</span></span>

<span data-ttu-id="1a06f-208">C# の型システムは、任意の型の値を `object` として扱えるように統一されています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-208">C#'s type system is unified such that a value of any type can be treated as an `object`.</span></span> <span data-ttu-id="1a06f-209">C# における型はすべて、直接的または間接的に `object` クラス型から派生し、`object` はすべての型の究極の基底クラスです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-209">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="1a06f-210">参照型の値は、値を単純に `object` 型としてみなすことによってオブジェクトとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-210">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="1a06f-211">値型の値は、*ボックス化*と*ボックス化解除操作*を実行することによって、オブジェクトとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-211">Values of value types are treated as objects by performing *boxing* and *unboxing operations*.</span></span> <span data-ttu-id="1a06f-212">次の例では、`int` 値は `object` 値に変換され、また `int` に戻されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-212">In the following example, an `int` value is converted to `object` and back again to `int`.</span></span>

:::code language="csharp" source="./snippets/shared/Program.cs" ID="boxing" :::

<span data-ttu-id="1a06f-213">値型の値が `object` 参照に割り当てられている場合は、値を保持するために "ボックス" が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-213">When a value of a value type is assigned to an `object` reference, a "box" is allocated to hold the value.</span></span> <span data-ttu-id="1a06f-214">このボックスは参照型のインスタンスであり、そのボックスに値がコピーされます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-214">That box is an instance of a reference type, and the value is copied into that box.</span></span> <span data-ttu-id="1a06f-215">逆に、`object` 参照が値型にキャストされると、参照先の `object` が適切な値型のボックスかどうかが確認されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-215">Conversely, when an `object` reference is cast to a value type, a check is made that the referenced `object` is a box of the correct value type.</span></span> <span data-ttu-id="1a06f-216">確認が成功すると、ボックス内の値が値型にコピーされます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-216">If the check succeeds, the value in the box is copied to the value type.</span></span>

<span data-ttu-id="1a06f-217">C# の型システムが統一されたということは、実質的には値型が "オンデマンドで" `object` 参照として扱われるということです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-217">C#'s unified type system effectively means that value types are treated as `object` references "on demand."</span></span> <span data-ttu-id="1a06f-218">こうした統一性があるため、`object` 型を使用する汎用的なライブラリは、参照型と値型の両方を含め、`object` から派生するすべての型で使用できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-218">Because of the unification, general-purpose libraries that use type `object` can be used with all types that derive from `object`, including both reference types and value types.</span></span>

<span data-ttu-id="1a06f-219">C# には、フィールド、配列要素、ローカル変数、パラメーターなどの、いくつかの種類の*変数*があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-219">There are several kinds of *variables* in C#, including fields, array elements, local variables, and parameters.</span></span> <span data-ttu-id="1a06f-220">変数は格納場所を表します。</span><span class="sxs-lookup"><span data-stu-id="1a06f-220">Variables represent storage locations.</span></span> <span data-ttu-id="1a06f-221">各変数には型があり、次のように、この型によって変数に格納できる値が決まります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-221">Every variable has a type that determines what values can be stored in the variable, as shown below.</span></span>

- <span data-ttu-id="1a06f-222">null 非許容値型</span><span class="sxs-lookup"><span data-stu-id="1a06f-222">Non-nullable value type</span></span>
  - <span data-ttu-id="1a06f-223">型そのものの値</span><span class="sxs-lookup"><span data-stu-id="1a06f-223">A value of that exact type</span></span>
- <span data-ttu-id="1a06f-224">null 許容値型</span><span class="sxs-lookup"><span data-stu-id="1a06f-224">Nullable value type</span></span>
  - <span data-ttu-id="1a06f-225">`null` 値、またはその型そのものの値</span><span class="sxs-lookup"><span data-stu-id="1a06f-225">A `null` value or a value of that exact type</span></span>
- <span data-ttu-id="1a06f-226">object</span><span class="sxs-lookup"><span data-stu-id="1a06f-226">object</span></span>
  - <span data-ttu-id="1a06f-227">`null` 参照、任意の参照型のオブジェクトへの参照、または任意の値型のボックス化された値への参照</span><span class="sxs-lookup"><span data-stu-id="1a06f-227">A `null` reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</span></span>
- <span data-ttu-id="1a06f-228">クラス型</span><span class="sxs-lookup"><span data-stu-id="1a06f-228">Class type</span></span>
  - <span data-ttu-id="1a06f-229">`null` 参照、そのクラス型のインスタンスへの参照、またはそのクラス型から派生したクラスのインスタンスへの参照</span><span class="sxs-lookup"><span data-stu-id="1a06f-229">A `null` reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</span></span>
- <span data-ttu-id="1a06f-230">インターフェイスの型</span><span class="sxs-lookup"><span data-stu-id="1a06f-230">Interface type</span></span>
  - <span data-ttu-id="1a06f-231">`null` 参照、そのインターフェイスの型を実装するクラス型のインスタンスへの参照、またはそのインターフェイス型を実装する値型のボックス化された値への参照</span><span class="sxs-lookup"><span data-stu-id="1a06f-231">A `null` reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</span></span>
- <span data-ttu-id="1a06f-232">配列型</span><span class="sxs-lookup"><span data-stu-id="1a06f-232">Array type</span></span>
  - <span data-ttu-id="1a06f-233">`null` 参照、その配列型のインスタンスへの参照、または互換性のある配列型のインスタンスへの参照</span><span class="sxs-lookup"><span data-stu-id="1a06f-233">A `null` reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</span></span>
- <span data-ttu-id="1a06f-234">デリゲート型</span><span class="sxs-lookup"><span data-stu-id="1a06f-234">Delegate type</span></span>
  - <span data-ttu-id="1a06f-235">`null` 参照、またはそのデリゲート型と互換性のあるインスタンスへの参照</span><span class="sxs-lookup"><span data-stu-id="1a06f-235">A `null` reference or a reference to an instance of a compatible delegate type</span></span>

## <a name="program-structure"></a><span data-ttu-id="1a06f-236">プログラムの構造</span><span class="sxs-lookup"><span data-stu-id="1a06f-236">Program structure</span></span>

<span data-ttu-id="1a06f-237">C# における主要な組織的概念は、"[***プログラム***](../programming-guide/inside-a-program/index.md)"、"[***名前空間***](../programming-guide/namespaces/index.md)"、"[***型***](../programming-guide/types/index.md)"、"[***メンバー***](../programming-guide/classes-and-structs/members.md)"、および "[***アセンブリ***](../../standard/assembly/index.md)" です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-237">The key organizational concepts in C# are [***programs***](../programming-guide/inside-a-program/index.md), [***namespaces***](../programming-guide/namespaces/index.md), [***types***](../programming-guide/types/index.md), [***members***](../programming-guide/classes-and-structs/members.md), and [***assemblies***](../../standard/assembly/index.md).</span></span> <span data-ttu-id="1a06f-238">プログラムは型を宣言します。型にはメンバーが含まれていて、複数の名前空間に編成することができます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-238">Programs declare types, which contain members and can be organized into namespaces.</span></span> <span data-ttu-id="1a06f-239">型の例には、クラス、構造体、インターフェイスがあります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-239">Classes, structs, and interfaces are examples of types.</span></span> <span data-ttu-id="1a06f-240">メンバーの例には、フィールド、メソッド、プロパティ、およびイベントがあります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-240">Fields, methods, properties, and events are examples of members.</span></span> <span data-ttu-id="1a06f-241">C# プログラムはコンパイルされると、物理的にアセンブリにパッケージ化されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-241">When C# programs are compiled, they're physically packaged into assemblies.</span></span> <span data-ttu-id="1a06f-242">アセンブリには通常、***アプリケーション***または***ライブラリ***のどちらかを実行するかに応じて、それぞれ `.exe` または `.dll` のファイル拡張子があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-242">Assemblies typically have the file extension `.exe` or `.dll`, depending on whether they implement ***applications*** or ***libraries***, respectively.</span></span>

<span data-ttu-id="1a06f-243">小さな例として、次のコードを含むアセンブリについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-243">As a small example, consider an assembly that contains the following code:</span></span>

:::code language="csharp" source="./snippets/shared/AcmeStack.cs":::

<span data-ttu-id="1a06f-244">このクラスの完全修飾名は `Acme.Collections.Stack` です。</span><span class="sxs-lookup"><span data-stu-id="1a06f-244">The fully qualified name of this class is `Acme.Collections.Stack`.</span></span> <span data-ttu-id="1a06f-245">このクラスには複数のメンバーが含まれています: `top` という名前のフィールドが 1 つ、`Push` と `Pop` という名前のメソッドが合わせて 2 つ、そして `Entry` という名前の入れ子になったクラスです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-245">The class contains several members: a field named `top`, two methods named `Push` and `Pop`, and a nested class named `Entry`.</span></span> <span data-ttu-id="1a06f-246">`Entry` クラスにはさらに、3 つのメンバーが含まれています: `next` という名前のフィールド、`data` という名前のフィールド、およびコンストラクターです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-246">The `Entry` class further contains three members: a field named `next`, a field named `data`, and a constructor.</span></span> <span data-ttu-id="1a06f-247">`Stack` は "*ジェネリック*" クラスです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-247">The `Stack` is a *generic* class.</span></span> <span data-ttu-id="1a06f-248">これには、使用時に具象型に置き換えられる 1 つの型パラメーター `T` があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-248">It has one type parameter, `T` that is replaced with a concrete type when it's used.</span></span>

> [!NOTE]
> <span data-ttu-id="1a06f-249">"*スタック*" は "先入れ後出し" (FILO) コレクションです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-249">A *stack* is a "first in - last out" (FILO) collection.</span></span> <span data-ttu-id="1a06f-250">新しい要素がスタックの先頭に追加されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-250">New elements are added to the top of the stack.</span></span> <span data-ttu-id="1a06f-251">要素が削除されると、それはスタックの一番上から削除されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-251">When an element is removed, it is removed from the top of the stack.</span></span>

<span data-ttu-id="1a06f-252">アセンブリには実行可能なコードが中間言語 (IL) の形式で含まれていて、シンボル情報がメタデータの形式で含まれています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-252">Assemblies contain executable code in the form of Intermediate Language (IL) instructions, and symbolic information in the form of metadata.</span></span> <span data-ttu-id="1a06f-253">実行前に、.NET 共通言語ランタイムの Just-In-Time (JIT) コンパイラによって、アセンブリの IL コードはプロセッサ固有のコードに変換されます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-253">Before it's executed, the Just-In-Time (JIT) compiler of .NET Common Language Runtime converts the IL code in an assembly to processor-specific code.</span></span>

<span data-ttu-id="1a06f-254">アセンブリはコードとメタデータの両方を含む自己記述的な機能的単位であるため、`#include` ディレクティブおよびヘッダー ファイルを C# に含める必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1a06f-254">Because an assembly is a self-describing unit of functionality containing both code and metadata, there's no need for `#include` directives and header files in C#.</span></span> <span data-ttu-id="1a06f-255">特定のアセンブリに含まれているパブリックの型とメンバーは、単にプログラムのコンパイル中にそのアセンブリを参照することにより、C# プログラムで利用可能になります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-255">The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program.</span></span> <span data-ttu-id="1a06f-256">たとえば、このプログラムでは `acme.dll` アセンブリの `Acme.Collections.Stack` クラスを使用しています。</span><span class="sxs-lookup"><span data-stu-id="1a06f-256">For example, this program uses the `Acme.Collections.Stack` class from the `acme.dll` assembly:</span></span>

:::code language="csharp" source="./snippets/shared/StackUsage.cs":::

<span data-ttu-id="1a06f-257">このプログラムをコンパイルするには、前の例で定義されているスタック クラスを含むアセンブリを "*参照*" する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-257">To compile this program, you would need to *reference* the assembly containing the stack class defined in the earlier example.</span></span>

<span data-ttu-id="1a06f-258">C# プログラムは複数のソース ファイルに格納できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-258">C# programs can be stored in several source files.</span></span> <span data-ttu-id="1a06f-259">C# プログラムがコンパイルされると、すべてのソース ファイルがまとめて処理され、ソース ファイルは自由に相互参照できます。</span><span class="sxs-lookup"><span data-stu-id="1a06f-259">When a C# program is compiled, all of the source files are processed together, and the source files can freely reference each other.</span></span> <span data-ttu-id="1a06f-260">概念的には、処理される前にすべてのソース ファイルが 1 つの大きなファイルに連結されるかのようになります。</span><span class="sxs-lookup"><span data-stu-id="1a06f-260">Conceptually, it's as if all the source files were concatenated into one large file before being processed.</span></span> <span data-ttu-id="1a06f-261">C# では事前宣言をする必要がありません。ごく一部の例外を除いて、宣言の順序は重要でないためです。</span><span class="sxs-lookup"><span data-stu-id="1a06f-261">Forward declarations are never needed in C# because, with few exceptions, declaration order is insignificant.</span></span> <span data-ttu-id="1a06f-262">C# ではソース ファイルがパブリック型 1 つのみの宣言に制限されません。また、ソース ファイルの名前がソース ファイルで宣言された型に一致する必要もありません。</span><span class="sxs-lookup"><span data-stu-id="1a06f-262">C# doesn't limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</span></span>

<span data-ttu-id="1a06f-263">これらの組織ブロックについては、このツアーの他の記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="1a06f-263">Further articles in this tour explain these organizational blocks.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="1a06f-264">次へ</span><span class="sxs-lookup"><span data-stu-id="1a06f-264">Next</span></span>](types.md)
