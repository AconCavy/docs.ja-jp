---
title: デリゲートの使用 - C# プログラミング ガイド
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- delegates [C#], how to use
ms.assetid: 99a2fc27-a32e-4a34-921c-e65497520eec
ms.openlocfilehash: a0422b5cd3083f351bde44deae5871599a649140
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/01/2019
ms.locfileid: "73423301"
---
# <a name="using-delegates-c-programming-guide"></a><span data-ttu-id="0c0c0-102">デリゲートの使用 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="0c0c0-102">Using Delegates (C# Programming Guide)</span></span>

<span data-ttu-id="0c0c0-103">[デリゲート](../../language-reference/builtin-types/reference-types.md)は、C および C++ の関数ポインターのようなメソッドを安全にカプセル化する型です。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-103">A [delegate](../../language-reference/builtin-types/reference-types.md) is a type that safely encapsulates a method, similar to a function pointer in C and C++.</span></span> <span data-ttu-id="0c0c0-104">ただし、C 関数ポインターとは異なり、デリゲートはオブジェクト指向で、タイプ セーフで、安全です。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-104">Unlike C function pointers, delegates are object-oriented, type safe, and secure.</span></span> <span data-ttu-id="0c0c0-105">デリゲートの型は、デリゲートの名前によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-105">The type of a delegate is defined by the name of the delegate.</span></span> <span data-ttu-id="0c0c0-106">次の例では、引数として[文字列](../../language-reference/builtin-types/reference-types.md)を受け取り、[void](../../language-reference/keywords/void.md) を返すメソッドをカプセル化できる `Del` という名前のデリゲートを宣言しています。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-106">The following example declares a delegate named `Del` that can encapsulate a method that takes a [string](../../language-reference/builtin-types/reference-types.md) as an argument and returns [void](../../language-reference/keywords/void.md):</span></span>

[!code-csharp[csProgGuideDelegates#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#21)]

<span data-ttu-id="0c0c0-107">デリゲート オブジェクトは、通常、デリゲートがラップするメソッドの名前を指定して構成されるか、[匿名関数](../statements-expressions-operators/anonymous-functions.md)を使用して構成されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-107">A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an [anonymous function](../statements-expressions-operators/anonymous-functions.md).</span></span> <span data-ttu-id="0c0c0-108">デリゲートがインスタンス化されると、デリゲートに対するメソッドの呼び出しが、デリゲートからメソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-108">Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method.</span></span> <span data-ttu-id="0c0c0-109">呼び出し元によってデリゲートに渡されるパラメーターはメソッドに渡され、戻り値がある場合は、デリゲートによってメソッドから呼び出し元に返されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-109">The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate.</span></span> <span data-ttu-id="0c0c0-110">これは、デリゲートの呼び出しと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-110">This is known as invoking the delegate.</span></span> <span data-ttu-id="0c0c0-111">インスタンス化されたデリゲートは、ラップされたメソッドそのものであるかのように呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-111">An instantiated delegate can be invoked as if it were the wrapped method itself.</span></span> <span data-ttu-id="0c0c0-112">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-112">For example:</span></span>

[!code-csharp[csProgGuideDelegates#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#22)]  

[!code-csharp[csProgGuideDelegates#23](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#23)]

<span data-ttu-id="0c0c0-113">デリゲート型は、.NET Framework の <xref:System.Delegate> クラスから派生しています。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-113">Delegate types are derived from the <xref:System.Delegate> class in the .NET Framework.</span></span> <span data-ttu-id="0c0c0-114">デリゲート型は [sealed](../../language-reference/keywords/sealed.md) (派生できません) であり、<xref:System.Delegate> からカスタム クラスを派生することはできません。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-114">Delegate types are [sealed](../../language-reference/keywords/sealed.md)—they cannot be derived from— and it is not possible to derive custom classes from <xref:System.Delegate>.</span></span> <span data-ttu-id="0c0c0-115">インスタンス化されたデリゲートはオブジェクトであるため、パラメーターとして渡したり、プロパティに割り当てたりすることができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-115">Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property.</span></span> <span data-ttu-id="0c0c0-116">これにより、メソッドは、パラメーターとしてデリゲートを受け入れ、後でデリゲートを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-116">This allows a method to accept a delegate as a parameter, and call the delegate at some later time.</span></span> <span data-ttu-id="0c0c0-117">これは非同期のコールバックと呼ばれ、長いプロセスの完了時に呼び出し元に通知する一般的な方法です。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-117">This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed.</span></span> <span data-ttu-id="0c0c0-118">デリゲートをこの方法で使用する場合、デリゲートを使用するコードは、使用されるメソッドの実装について認識している必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-118">When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used.</span></span> <span data-ttu-id="0c0c0-119">機能は、カプセル化インターフェイスが提供する機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-119">The functionality is similar to the encapsulation interfaces provide.</span></span>

<span data-ttu-id="0c0c0-120">コールバックの別の一般的な使用方法は、カスタム比較メソッドの定義およびそのデリゲートの並べ替えメソッドへの引き渡しです。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-120">Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method.</span></span> <span data-ttu-id="0c0c0-121">これにより、呼び出し元のコードを並べ替えアルゴリズムの一部にすることができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-121">It allows the caller's code to become part of the sort algorithm.</span></span> <span data-ttu-id="0c0c0-122">次の例のメソッドは `Del` 型をパラメーターとして使用しています。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-122">The following example method uses the `Del` type as a parameter:</span></span>

[!code-csharp[csProgGuideDelegates#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#24)]

<span data-ttu-id="0c0c0-123">上記で作成したデリゲートをメソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-123">You can then pass the delegate created above to that method:</span></span>

[!code-csharp[csProgGuideDelegates#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#25)]

<span data-ttu-id="0c0c0-124">次の出力がコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-124">and receive the following output to the console:</span></span>

```console
The number is: 3
```

<span data-ttu-id="0c0c0-125">抽象化としてデリゲートを使用する場合、`MethodWithCallback` がコンソールを直接呼び出す必要はありません。コンソールに留意して設計する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-125">Using the delegate as an abstraction, `MethodWithCallback` does not need to call the console directly—it does not have to be designed with a console in mind.</span></span> <span data-ttu-id="0c0c0-126">`MethodWithCallback` は文字列を準備し、文字列を別のメソッドに渡すだけです。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-126">What `MethodWithCallback` does is simply prepare a string and pass the string to another method.</span></span> <span data-ttu-id="0c0c0-127">これは、デリゲート メソッドが任意の数のパラメーターを使用できるため、特に強力です。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-127">This is especially powerful since a delegated method can use any number of parameters.</span></span>

<span data-ttu-id="0c0c0-128">インスタンス メソッドをラップするようにデリゲートが構築された場合、デリゲートはインスタンスとメソッドの両方を参照します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-128">When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method.</span></span> <span data-ttu-id="0c0c0-129">デリゲートはラップするメソッド以外のインスタンス型を認識しないため、デリゲート シグネチャと一致するオブジェクトにメソッドがある限り、どの型のオブジェクトでも参照できます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-129">A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature.</span></span> <span data-ttu-id="0c0c0-130">静的メソッドをラップするようにデリゲートが構築された場合、デリゲートはそのメソッドのみを参照します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-130">When a delegate is constructed to wrap a static method, it only references the method.</span></span> <span data-ttu-id="0c0c0-131">次に宣言の例を示します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-131">Consider the following declarations:</span></span>

[!code-csharp[csProgGuideDelegates#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#26)]

<span data-ttu-id="0c0c0-132">以前に示した静的な `DelegateMethod` と共に、`Del` インスタンスによってラップできるメソッドが 3 つあります。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-132">Along with the static `DelegateMethod` shown previously, we now have three methods that can be wrapped by a `Del` instance.</span></span>

<span data-ttu-id="0c0c0-133">デリゲートは、呼び出されたときに複数のメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-133">A delegate can call more than one method when invoked.</span></span> <span data-ttu-id="0c0c0-134">これはマルチキャスティングと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-134">This is referred to as multicasting.</span></span> <span data-ttu-id="0c0c0-135">デリゲートのメソッドの一覧 (呼び出しリスト) に追加のメソッドを追加するには、加算演算子または加算代入演算子 ('+' または '+=') を使用して 2 つのデリゲートを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-135">To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+=').</span></span> <span data-ttu-id="0c0c0-136">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-136">For example:</span></span>

[!code-csharp[csProgGuideDelegates#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#27)]

<span data-ttu-id="0c0c0-137">この時点で、`allMethodsDelegate` には、呼び出しリスト内の 3 つのメソッド (`Method1`、`Method2`、`DelegateMethod`) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-137">At this point `allMethodsDelegate` contains three methods in its invocation list—`Method1`, `Method2`, and `DelegateMethod`.</span></span> <span data-ttu-id="0c0c0-138">元の 3 つのデリゲートである `d1`、`d2`、および `d3` は変更されません。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-138">The original three delegates, `d1`, `d2`, and `d3`, remain unchanged.</span></span> <span data-ttu-id="0c0c0-139">`allMethodsDelegate` が呼び出されると、すべての 3 つのメソッドが順に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-139">When `allMethodsDelegate` is invoked, all three methods are called in order.</span></span> <span data-ttu-id="0c0c0-140">デリゲートで参照パラメーターを使用する場合、参照は、3 つのメソッドに順番に渡され、1 つのメソッドによって行われた変更は、次のメソッドに示されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-140">If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method.</span></span> <span data-ttu-id="0c0c0-141">いずれかのメソッドがメソッド内でキャッチされない例外をスローした場合、デリゲートの呼び出し元に例外が渡され、呼び出しリスト内の後続のメソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-141">When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called.</span></span> <span data-ttu-id="0c0c0-142">デリゲートに戻り値や out パラメーターがある場合、デリゲートは戻り値と最後に呼び出されたメソッドのパラメーターを返します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-142">If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked.</span></span> <span data-ttu-id="0c0c0-143">呼び出しリストからメソッドを削除するには、[減算演算子または減算代入演算子](../../language-reference/operators/subtraction-operator.md) (`-` または `-=`) を使います。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-143">To remove a method from the invocation list, use the [subtraction or subtraction assignment operators](../../language-reference/operators/subtraction-operator.md) (`-` or `-=`).</span></span> <span data-ttu-id="0c0c0-144">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-144">For example:</span></span>

[!code-csharp[csProgGuideDelegates#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#28)]

<span data-ttu-id="0c0c0-145">デリゲート型が `System.Delegate` から派生しているため、そのクラスで定義されるメソッドとプロパティはデリゲートで呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-145">Because delegate types are derived from `System.Delegate`, the methods and properties defined by that class can be called on the delegate.</span></span> <span data-ttu-id="0c0c0-146">たとえば、デリゲートの呼び出しリスト内のメソッドの数を検索するには、次のように記述します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-146">For example, to find the number of methods in a delegate's invocation list, you may write:</span></span>

[!code-csharp[csProgGuideDelegates#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#29)]

<span data-ttu-id="0c0c0-147">呼び出しリストに複数のメソッドがあるデリゲートは、<xref:System.MulticastDelegate> のサブクラスである `System.Delegate` から派生します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-147">Delegates with more than one method in their invocation list derive from <xref:System.MulticastDelegate>, which is a subclass of `System.Delegate`.</span></span> <span data-ttu-id="0c0c0-148">上記のコードでは、両方のクラスが `GetInvocationList` をサポートしているため、いずれの場合も機能します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-148">The above code works in either case because both classes support `GetInvocationList`.</span></span>

<span data-ttu-id="0c0c0-149">マルチキャスト デリゲートは、イベント処理で広く使用されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-149">Multicast delegates are used extensively in event handling.</span></span> <span data-ttu-id="0c0c0-150">イベント ソース オブジェクトはイベントを受け取るように登録されている受信者オブジェクトにイベント通知を送信します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-150">Event source objects send event notifications to recipient objects that have registered to receive that event.</span></span> <span data-ttu-id="0c0c0-151">イベントを登録するには、受信者は、イベントを処理するようにデザインされたメソッドを作成し、そのメソッドのデリゲートを作成してイベント ソースにデリゲートを渡します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-151">To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source.</span></span> <span data-ttu-id="0c0c0-152">イベントが発生すると、ソースがデリゲートを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-152">The source calls the delegate when the event occurs.</span></span> <span data-ttu-id="0c0c0-153">デリゲートは、受信者のイベント処理メソッドを呼び出し、イベント データを配信します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-153">The delegate then calls the event handling method on the recipient, delivering the event data.</span></span> <span data-ttu-id="0c0c0-154">特定のイベントのデリゲート型は、イベント ソースによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-154">The delegate type for a given event is defined by the event source.</span></span> <span data-ttu-id="0c0c0-155">詳細については、「[イベント (C# プログラミング ガイド)](../events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-155">For more, see [Events](../events/index.md).</span></span>

<span data-ttu-id="0c0c0-156">コンパイル時に割り当てられた 2 つの異なる型のデリゲートを比較すると、コンパイル エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-156">Comparing delegates of two different types assigned at compile-time will result in a compilation error.</span></span> <span data-ttu-id="0c0c0-157">デリゲート インスタンスが静的な `System.Delegate` 型の場合は、比較できますが、実行時に false が返されます。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-157">If the delegate instances are statically of the type `System.Delegate`, then the comparison is allowed, but will return false at run time.</span></span> <span data-ttu-id="0c0c0-158">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0c0c0-158">For example:</span></span>

[!code-csharp[csProgGuideDelegates#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideDelegates/CS/Delegates.cs#30)]

## <a name="see-also"></a><span data-ttu-id="0c0c0-159">関連項目</span><span class="sxs-lookup"><span data-stu-id="0c0c0-159">See also</span></span>

- [<span data-ttu-id="0c0c0-160">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="0c0c0-160">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="0c0c0-161">デリゲート</span><span class="sxs-lookup"><span data-stu-id="0c0c0-161">Delegates</span></span>](./index.md)
- [<span data-ttu-id="0c0c0-162">デリゲートの変性の使用</span><span class="sxs-lookup"><span data-stu-id="0c0c0-162">Using Variance in Delegates</span></span>](../concepts/covariance-contravariance/using-variance-in-delegates.md)
- [<span data-ttu-id="0c0c0-163">デリゲートの変性</span><span class="sxs-lookup"><span data-stu-id="0c0c0-163">Variance in Delegates</span></span>](../concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="0c0c0-164">Func および Action 汎用デリゲートでの変性の使用</span><span class="sxs-lookup"><span data-stu-id="0c0c0-164">Using Variance for Func and Action Generic Delegates</span></span>](../concepts/covariance-contravariance/using-variance-for-func-and-action-generic-delegates.md)
- [<span data-ttu-id="0c0c0-165">イベント</span><span class="sxs-lookup"><span data-stu-id="0c0c0-165">Events</span></span>](../events/index.md)
