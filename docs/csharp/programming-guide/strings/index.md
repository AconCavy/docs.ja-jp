---
title: 文字列 - C# プログラミング ガイド
ms.custom: seodec18
ms.date: 06/27/2019
helpviewer_keywords:
- C# language, strings
- strings [C#]
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
ms.openlocfilehash: 46820fe4137f5080b956cd1345d3e95c2e06f9ca
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/03/2020
ms.locfileid: "75635081"
---
# <a name="strings-c-programming-guide"></a><span data-ttu-id="3b8e8-102">文字列 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="3b8e8-102">Strings (C# Programming Guide)</span></span>
<span data-ttu-id="3b8e8-103">文字列は、値がテキストの <xref:System.String> 型のオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-103">A string is an object of type <xref:System.String> whose value is text.</span></span> <span data-ttu-id="3b8e8-104">内部では、テキストは <xref:System.Char> オブジェクトの順次読み取り専用コレクションとして格納されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-104">Internally, the text is stored as a sequential read-only collection of <xref:System.Char> objects.</span></span> <span data-ttu-id="3b8e8-105">C# の文字列の末尾には null 終端文字はありません。したがって、C# の文字列には任意の数の null 文字 ('\0') を埋め込むことができます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-105">There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0').</span></span> <span data-ttu-id="3b8e8-106">文字列の <xref:System.String.Length%2A> プロパティは、Unicode 文字の数ではなく、文字列に含まれている `Char` オブジェクトの数を表します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-106">The <xref:System.String.Length%2A> property of a string represents the number of `Char` objects it contains, not the number of Unicode characters.</span></span> <span data-ttu-id="3b8e8-107">文字列内の個別の Unicode コード ポイントにアクセスするには、<xref:System.Globalization.StringInfo> オブジェクトを使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-107">To access the individual Unicode code points in a string, use the <xref:System.Globalization.StringInfo> object.</span></span>  
  
## <a name="string-vs-systemstring"></a><span data-ttu-id="3b8e8-108">文字列と System.String</span><span class="sxs-lookup"><span data-stu-id="3b8e8-108">string vs. System.String</span></span>  
 <span data-ttu-id="3b8e8-109">C# では、`string` キーワードは <xref:System.String> のエイリアスです。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-109">In C#, the `string` keyword is an alias for <xref:System.String>.</span></span> <span data-ttu-id="3b8e8-110">したがって、`String` と `string` は等価であり、どちらの名前付け規則を使用してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-110">Therefore, `String` and `string` are equivalent, and you can use whichever naming convention you prefer.</span></span> <span data-ttu-id="3b8e8-111">`String` クラスは、文字列を安全に作成、操作、比較するためのさまざまなメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-111">The `String` class provides many methods for safely creating, manipulating, and comparing strings.</span></span> <span data-ttu-id="3b8e8-112">また、C# 言語は、一般的な文字列操作を簡略化するためにいくつかの演算子をオーバーロードします。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-112">In addition, the C# language overloads some operators to simplify common string operations.</span></span> <span data-ttu-id="3b8e8-113">キーワードの詳細については、「[string](../../language-reference/builtin-types/reference-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-113">For more information about the keyword, see [string](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="3b8e8-114">型およびメソッドの詳細については、「<xref:System.String>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-114">For more information about the type and its methods, see <xref:System.String>.</span></span>  
  
## <a name="declaring-and-initializing-strings"></a><span data-ttu-id="3b8e8-115">文字列の宣言と初期化</span><span class="sxs-lookup"><span data-stu-id="3b8e8-115">Declaring and Initializing Strings</span></span>  
 <span data-ttu-id="3b8e8-116">次の例に示すように、文字列はさまざまな方法で宣言および初期化できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-116">You can declare and initialize strings in various ways, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#1)]  
  
 <span data-ttu-id="3b8e8-117">文字列を文字の配列で初期化する場合を除き、文字列オブジェクトの作成に [new](../../language-reference/operators/new-operator.md) 演算子を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-117">Note that you do not use the [new](../../language-reference/operators/new-operator.md) operator to create a string object except when initializing the string with an array of chars.</span></span>  
  
 <span data-ttu-id="3b8e8-118">文字列の長さが 0 の新しい <xref:System.String> オブジェクトを作成するには、<xref:System.String.Empty> 定数値で文字列を初期化します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-118">Initialize a string with the <xref:System.String.Empty> constant value to create a new <xref:System.String> object whose string is of zero length.</span></span> <span data-ttu-id="3b8e8-119">長さ 0 の文字列のリテラル文字列表現は "" です。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-119">The string literal representation of a zero-length string is "".</span></span> <span data-ttu-id="3b8e8-120">[null](../../language-reference/keywords/null.md) の代わりに <xref:System.String.Empty> 値を使用して文字列を初期化すると、<xref:System.NullReferenceException> が発生する可能性を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-120">By initializing strings with the <xref:System.String.Empty> value instead of [null](../../language-reference/keywords/null.md), you can reduce the chances of a <xref:System.NullReferenceException> occurring.</span></span> <span data-ttu-id="3b8e8-121">静的な <xref:System.String.IsNullOrEmpty%28System.String%29> メソッドを使用すると、アクセスを試行する前に文字列の値を検証できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-121">Use the static <xref:System.String.IsNullOrEmpty%28System.String%29> method to verify the value of a string before you try to access it.</span></span>  
  
## <a name="immutability-of-string-objects"></a><span data-ttu-id="3b8e8-122">文字列オブジェクトの不変性</span><span class="sxs-lookup"><span data-stu-id="3b8e8-122">Immutability of String Objects</span></span>  
 <span data-ttu-id="3b8e8-123">文字列オブジェクトは*変更不可*です。つまり、作成した文字列オブジェクトは変更できません。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-123">String objects are *immutable*: they cannot be changed after they have been created.</span></span> <span data-ttu-id="3b8e8-124">文字列を変更するように見える <xref:System.String> メソッドと C# 演算子はすべて、実際には新しい文字列オブジェクトで結果を返します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-124">All of the <xref:System.String> methods and C# operators that appear to modify a string actually return the results in a new string object.</span></span> <span data-ttu-id="3b8e8-125">次の例では、`s1` と `s2` の内容を連結して 1 つの文字列を形成するときに、2 つの元の文字列は変更されません。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-125">In the following example, when the contents of `s1` and `s2` are concatenated to form a single string, the two original strings are unmodified.</span></span> <span data-ttu-id="3b8e8-126">`+=` 演算子で、連結した内容を含む新しい文字列が作成されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-126">The `+=` operator creates a new string that contains the combined contents.</span></span> <span data-ttu-id="3b8e8-127">新しいオブジェクトは変数 `s1` に代入され、`s1` に代入された元のオブジェクトはガベージ コレクションに対して解放されます。これは、他の変数がこのオブジェクトへの参照を保持していないためです。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-127">That new object is assigned to the variable `s1`, and the original object that was assigned to `s1` is released for garbage collection because no other variable holds a reference to it.</span></span>  
  
 [!code-csharp[csProgGuideStrings#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#2)]  
  
 <span data-ttu-id="3b8e8-128">文字列の "変更" では、実際には文字列が新しく作成されるため、文字列への参照を作成するときには注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-128">Because a string "modification" is actually a new string creation, you must use caution when you create references to strings.</span></span> <span data-ttu-id="3b8e8-129">文字列の参照を作成し、元の文字列を "変更" する場合、参照は文字列が変更されたときに作成された新しいオブジェクトではなく、元のオブジェクトを指したままになります。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-129">If you create a reference to a string, and then "modify" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified.</span></span> <span data-ttu-id="3b8e8-130">この動作を表すコードの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-130">The following code illustrates this behavior:</span></span>  
  
 [!code-csharp[csProgGuideStrings#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#25)]  
  
 <span data-ttu-id="3b8e8-131">元の文字列での検索操作や置換操作などの変更に基づく新しい文字列を作成する方法の詳細については、[文字列の内容を変更する方法](../../how-to/modify-string-contents.md)に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-131">For more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>  
  
## <a name="regular-and-verbatim-string-literals"></a><span data-ttu-id="3b8e8-132">標準リテラル文字列と逐語的リテラル文字列</span><span class="sxs-lookup"><span data-stu-id="3b8e8-132">Regular and Verbatim String Literals</span></span>  
 <span data-ttu-id="3b8e8-133">次の例に示すように、C# で提供されるエスケープ文字を埋め込む必要がある場合は、標準リテラル文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-133">Use regular string literals when you must embed escape characters provided by C#, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#3)]  
  
 <span data-ttu-id="3b8e8-134">文字列テキストに円記号が含まれる場合 (ファイル パスなど) は、使いやすさと読みやすさを考慮して、逐語的文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-134">Use verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths.</span></span> <span data-ttu-id="3b8e8-135">逐語的文字列は、文字列テキストの一部として改行文字を保持するため、複数行文字列の初期化に使用できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-135">Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings.</span></span> <span data-ttu-id="3b8e8-136">引用符を逐語的文字列に埋め込むには、二重引用符を使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-136">Use double quotation marks to embed a quotation mark inside a verbatim string.</span></span> <span data-ttu-id="3b8e8-137">逐語的文字列の一般的な使用方法の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-137">The following example shows some common uses for verbatim strings:</span></span>  
  
 [!code-csharp[csProgGuideStrings#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#4)]  
  
## <a name="string-escape-sequences"></a><span data-ttu-id="3b8e8-138">文字列のエスケープ シーケンス</span><span class="sxs-lookup"><span data-stu-id="3b8e8-138">String Escape Sequences</span></span>  
  
|<span data-ttu-id="3b8e8-139">エスケープ シーケンス</span><span class="sxs-lookup"><span data-stu-id="3b8e8-139">Escape sequence</span></span>|<span data-ttu-id="3b8e8-140">文字名</span><span class="sxs-lookup"><span data-stu-id="3b8e8-140">Character name</span></span>|<span data-ttu-id="3b8e8-141">Unicode エンコーディング</span><span class="sxs-lookup"><span data-stu-id="3b8e8-141">Unicode encoding</span></span>|  
|---------------------|--------------------|----------------------|  
|<span data-ttu-id="3b8e8-142">\\'</span><span class="sxs-lookup"><span data-stu-id="3b8e8-142">\\'</span></span>|<span data-ttu-id="3b8e8-143">単一引用符</span><span class="sxs-lookup"><span data-stu-id="3b8e8-143">Single quote</span></span>|<span data-ttu-id="3b8e8-144">0x0027</span><span class="sxs-lookup"><span data-stu-id="3b8e8-144">0x0027</span></span>|  
|<span data-ttu-id="3b8e8-145">\\"</span><span class="sxs-lookup"><span data-stu-id="3b8e8-145">\\"</span></span>|<span data-ttu-id="3b8e8-146">二重引用符</span><span class="sxs-lookup"><span data-stu-id="3b8e8-146">Double quote</span></span>|<span data-ttu-id="3b8e8-147">0x0022</span><span class="sxs-lookup"><span data-stu-id="3b8e8-147">0x0022</span></span>|  
|\\\\ |<span data-ttu-id="3b8e8-148">円記号</span><span class="sxs-lookup"><span data-stu-id="3b8e8-148">Backslash</span></span>|<span data-ttu-id="3b8e8-149">0x005C</span><span class="sxs-lookup"><span data-stu-id="3b8e8-149">0x005C</span></span>|  
|<span data-ttu-id="3b8e8-150">\0</span><span class="sxs-lookup"><span data-stu-id="3b8e8-150">\0</span></span>|<span data-ttu-id="3b8e8-151">Null</span><span class="sxs-lookup"><span data-stu-id="3b8e8-151">Null</span></span>|<span data-ttu-id="3b8e8-152">0x0000</span><span class="sxs-lookup"><span data-stu-id="3b8e8-152">0x0000</span></span>|  
|<span data-ttu-id="3b8e8-153">\a</span><span class="sxs-lookup"><span data-stu-id="3b8e8-153">\a</span></span>|<span data-ttu-id="3b8e8-154">警告</span><span class="sxs-lookup"><span data-stu-id="3b8e8-154">Alert</span></span>|<span data-ttu-id="3b8e8-155">0x0007</span><span class="sxs-lookup"><span data-stu-id="3b8e8-155">0x0007</span></span>|  
|<span data-ttu-id="3b8e8-156">\b</span><span class="sxs-lookup"><span data-stu-id="3b8e8-156">\b</span></span>|<span data-ttu-id="3b8e8-157">バックスペース</span><span class="sxs-lookup"><span data-stu-id="3b8e8-157">Backspace</span></span>|<span data-ttu-id="3b8e8-158">0x0008</span><span class="sxs-lookup"><span data-stu-id="3b8e8-158">0x0008</span></span>|  
|<span data-ttu-id="3b8e8-159">\f</span><span class="sxs-lookup"><span data-stu-id="3b8e8-159">\f</span></span>|<span data-ttu-id="3b8e8-160">フォーム フィード</span><span class="sxs-lookup"><span data-stu-id="3b8e8-160">Form feed</span></span>|<span data-ttu-id="3b8e8-161">0x000C</span><span class="sxs-lookup"><span data-stu-id="3b8e8-161">0x000C</span></span>|  
|<span data-ttu-id="3b8e8-162">\n</span><span class="sxs-lookup"><span data-stu-id="3b8e8-162">\n</span></span>|<span data-ttu-id="3b8e8-163">改行</span><span class="sxs-lookup"><span data-stu-id="3b8e8-163">New line</span></span>|<span data-ttu-id="3b8e8-164">0x000A</span><span class="sxs-lookup"><span data-stu-id="3b8e8-164">0x000A</span></span>|  
|<span data-ttu-id="3b8e8-165">\r</span><span class="sxs-lookup"><span data-stu-id="3b8e8-165">\r</span></span>|<span data-ttu-id="3b8e8-166">キャリッジ リターン</span><span class="sxs-lookup"><span data-stu-id="3b8e8-166">Carriage return</span></span>|<span data-ttu-id="3b8e8-167">0x000D</span><span class="sxs-lookup"><span data-stu-id="3b8e8-167">0x000D</span></span>|  
|<span data-ttu-id="3b8e8-168">\t</span><span class="sxs-lookup"><span data-stu-id="3b8e8-168">\t</span></span>|<span data-ttu-id="3b8e8-169">水平タブ</span><span class="sxs-lookup"><span data-stu-id="3b8e8-169">Horizontal tab</span></span>|<span data-ttu-id="3b8e8-170">0x0009</span><span class="sxs-lookup"><span data-stu-id="3b8e8-170">0x0009</span></span>|  
|<span data-ttu-id="3b8e8-171">\v</span><span class="sxs-lookup"><span data-stu-id="3b8e8-171">\v</span></span>|<span data-ttu-id="3b8e8-172">垂直タブ</span><span class="sxs-lookup"><span data-stu-id="3b8e8-172">Vertical tab</span></span>|<span data-ttu-id="3b8e8-173">0x000B</span><span class="sxs-lookup"><span data-stu-id="3b8e8-173">0x000B</span></span>|  
|<span data-ttu-id="3b8e8-174">\u</span><span class="sxs-lookup"><span data-stu-id="3b8e8-174">\u</span></span>|<span data-ttu-id="3b8e8-175">Unicode エスケープ シーケンス (UTF-16)</span><span class="sxs-lookup"><span data-stu-id="3b8e8-175">Unicode escape sequence (UTF-16)</span></span>|<span data-ttu-id="3b8e8-176">`\uHHHH` (範囲:0000 - FFFF; 例: `\u00E7` = "ç")</span><span class="sxs-lookup"><span data-stu-id="3b8e8-176">`\uHHHH` (range: 0000 - FFFF; example: `\u00E7` = "ç")</span></span>|  
|<span data-ttu-id="3b8e8-177">\U</span><span class="sxs-lookup"><span data-stu-id="3b8e8-177">\U</span></span>|<span data-ttu-id="3b8e8-178">Unicode エスケープ シーケンス (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="3b8e8-178">Unicode escape sequence (UTF-32)</span></span>|<span data-ttu-id="3b8e8-179">`\U00HHHHHH` (範囲:000000 - 10FFFF; 例: `\U0001F47D` = "&#x1F47D;")</span><span class="sxs-lookup"><span data-stu-id="3b8e8-179">`\U00HHHHHH` (range: 000000 - 10FFFF; example: `\U0001F47D` = "&#x1F47D;")</span></span>|  
|<span data-ttu-id="3b8e8-180">\x</span><span class="sxs-lookup"><span data-stu-id="3b8e8-180">\x</span></span>|<span data-ttu-id="3b8e8-181">可変長である点を除き "\u" に類似した Unicode エスケープ シーケンス</span><span class="sxs-lookup"><span data-stu-id="3b8e8-181">Unicode escape sequence similar to "\u" except with variable length</span></span>|<span data-ttu-id="3b8e8-182">`\xH[H][H][H]` (範囲:0 - FFFF; 例: `\x00E7`、`\x0E7`、または `\xE7` = "ç")</span><span class="sxs-lookup"><span data-stu-id="3b8e8-182">`\xH[H][H][H]` (range: 0 - FFFF; example: `\x00E7` or `\x0E7` or `\xE7` = "ç")</span></span>|  
  
> [!WARNING]
> <span data-ttu-id="3b8e8-183">`\x` のエスケープ シーケンスを使用していて、指定している 16 進数が 4 桁未満である場合に、エスケープ シーケンスの直後の文字が有効な 16 進数 (0-9、A-F、a-f) であると、それらはエスケープ シーケンスの一部として解釈されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-183">When using the `\x` escape sequence and specifying less than 4 hex digits, if the characters that immediately follow the escape sequence are valid hex digits (i.e. 0-9, A-F, and a-f), they will be interpreted as being part of the escape sequence.</span></span> <span data-ttu-id="3b8e8-184">たとえば、`\xA1` はコード ポイント U+00A1 の "&#161;" を生成します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-184">For example, `\xA1` produces "&#161;", which is code point U+00A1.</span></span> <span data-ttu-id="3b8e8-185">ただし、次の文字が "A" または "a" である場合、エスケープ シーケンスは代わりに `\xA1A` であると解釈され、コード ポイント U+0A1A の "&#x0A1A;" を生成します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-185">However, if the next character is "A" or "a", then the escape sequence will instead be interpreted as being `\xA1A` and produce "&#x0A1A;", which is code point U+0A1A.</span></span> <span data-ttu-id="3b8e8-186">そのような場合、4 桁の 16 進数すべてを指定する (例: `\x00A1`) と、誤って解釈される可能性がすべて排除されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-186">In such cases, specifying all 4 hex digits (e.g. `\x00A1` ) will prevent any possible misinterpretation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3b8e8-187">コンパイル時に、逐語的文字列はエスケープ シーケンスと同様に通常の文字列に変換されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-187">At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences.</span></span> <span data-ttu-id="3b8e8-188">したがって、逐語的文字列をデバッガーのウォッチ ウィンドウで表示すると、ソース コードの逐語的バージョンではなく、コンパイラが追加したエスケープ文字が表示されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-188">Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code.</span></span> <span data-ttu-id="3b8e8-189">たとえば、逐語的文字列 `@"C:\files.txt"` は、ウォッチ ウィンドウでは "C:\\\files.txt" と表示されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-189">For example, the verbatim string `@"C:\files.txt"` will appear in the watch window as "C:\\\files.txt".</span></span>  
  
## <a name="format-strings"></a><span data-ttu-id="3b8e8-190">書式指定文字列</span><span class="sxs-lookup"><span data-stu-id="3b8e8-190">Format Strings</span></span>  
 <span data-ttu-id="3b8e8-191">書式指定文字列は、その内容が実行時に動的に決定される文字列です。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-191">A format string is a string whose contents are determined dynamically at runtime.</span></span> <span data-ttu-id="3b8e8-192">書式指定文字列を作成するには、文字列内の中かっこの内側に "*挿入式*" かプレースホルダーを埋め込みます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-192">Format strings are created by embedding *interpolated expressions* or placeholders inside of braces within a string.</span></span> <span data-ttu-id="3b8e8-193">中かっこ (`{...}`) 内にあるものはすべて値に解決され、実行時に書式設定された文字列として出力されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-193">Everything inside the braces (`{...}`) will be resolved to a value and output as a formatted string at runtime.</span></span> <span data-ttu-id="3b8e8-194">書式指定文字列を作成するには、文字列補間と複合書式設定の 2 つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-194">There are two methods to create format strings: string interpolation and composite formatting.</span></span>

### <a name="string-interpolation"></a><span data-ttu-id="3b8e8-195">文字列補間</span><span class="sxs-lookup"><span data-stu-id="3b8e8-195">String Interpolation</span></span>
<span data-ttu-id="3b8e8-196">C# 6.0 以降で使用できる ["*補間文字列*"](../../language-reference/tokens/interpolated.md) は、特殊文字 `$` によって識別され、中かっこ内に挿入式を含みます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-196">Available in C# 6.0 and later, [*interpolated strings*](../../language-reference/tokens/interpolated.md) are identified by the `$` special character and include interpolated expressions in braces.</span></span> <span data-ttu-id="3b8e8-197">文字列補間を初めて使用する場合は、簡単な概要として「[文字列補間 - C# の対話形式チュートリアル](../../tutorials/exploration/interpolated-strings.yml)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-197">If you are new to string interpolation, see the [String interpolation - C# interactive tutorial](../../tutorials/exploration/interpolated-strings.yml) for a quick overview.</span></span>

<span data-ttu-id="3b8e8-198">文字列補間を使ってコードの読みやすさと保守性を向上させます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-198">Use string interpolation to improve the readability and maintainability of your code.</span></span> <span data-ttu-id="3b8e8-199">文字列補間がもたらす結果は `String.Format` メソッドと同じですが、使いやすさとインラインのわかりやすさが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-199">String interpolation achieves the same results as the `String.Format` method, but improves ease of use and inline clarity.</span></span>

[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringInterpolation)]

### <a name="composite-formatting"></a><span data-ttu-id="3b8e8-200">複合書式指定</span><span class="sxs-lookup"><span data-stu-id="3b8e8-200">Composite Formatting</span></span>
<span data-ttu-id="3b8e8-201"><xref:System.String.Format%2A?displayProperty=nameWithType> では、中かっこ内のプレースホルダーを使って書式指定文字列を作成します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-201">The <xref:System.String.Format%2A?displayProperty=nameWithType> utilizes placeholders in braces to create a format string.</span></span> <span data-ttu-id="3b8e8-202">この例では、上で使用した文字列補間の方法と同様の出力が生じます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-202">This example results in similar output to the string interpolation method used above.</span></span>
  
[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringFormat)]

<span data-ttu-id="3b8e8-203">.NET 型の書式設定について詳しくは、「[.NET での型の書式設定](../../../standard/base-types/formatting-types.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-203">For more information on formatting .NET types see [Formatting Types in .NET](../../../standard/base-types/formatting-types.md).</span></span>
  
## <a name="substrings"></a><span data-ttu-id="3b8e8-204">部分文字列</span><span class="sxs-lookup"><span data-stu-id="3b8e8-204">Substrings</span></span>  
 <span data-ttu-id="3b8e8-205">部分文字列は、1 つの文字列に含まれる一連の文字です。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-205">A substring is any sequence of characters that is contained in a string.</span></span> <span data-ttu-id="3b8e8-206">元の文字列の一部から新しい文字列を作成するには、<xref:System.String.Substring%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-206">Use the <xref:System.String.Substring%2A> method to create a new string from a part of the original string.</span></span> <span data-ttu-id="3b8e8-207"><xref:System.String.IndexOf%2A> メソッドを使用して、1 つまたは複数の部分文字列を検索できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-207">You can search for one or more occurrences of a substring by using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="3b8e8-208">指定されたすべての部分文字列を新しい文字列に置換するには、<xref:System.String.Replace%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-208">Use the <xref:System.String.Replace%2A> method to replace all occurrences of a specified substring with a new string.</span></span> <span data-ttu-id="3b8e8-209"><xref:System.String.Substring%2A> メソッドと同様に、<xref:System.String.Replace%2A> は実際に新しい文字列を返し、元の文字列は変更しません。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-209">Like the <xref:System.String.Substring%2A> method, <xref:System.String.Replace%2A> actually returns a new string and does not modify the original string.</span></span> <span data-ttu-id="3b8e8-210">詳細については、「[文字列を検索する方法](../../how-to/search-strings.md)」と[文字列の内容を変更する方法](../../how-to/modify-string-contents.md)に関する記事をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-210">For more information, see [How to search strings](../../how-to/search-strings.md) and [How to modify string contents](../../how-to/modify-string-contents.md).</span></span>
  
 [!code-csharp[csProgGuideStrings#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#9)]  
  
## <a name="accessing-individual-characters"></a><span data-ttu-id="3b8e8-211">各文字へのアクセス</span><span class="sxs-lookup"><span data-stu-id="3b8e8-211">Accessing Individual Characters</span></span>  
 <span data-ttu-id="3b8e8-212">次の例に示すように、配列表記とインデックス値を使用すると、それぞれの文字への読み取り専用アクセスが可能になります。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-212">You can use array notation with an index value to acquire read-only access to individual characters, as in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStrings#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#8)]  
  
 <span data-ttu-id="3b8e8-213"><xref:System.String> メソッドが、文字列内の個別の文字を変更する必要がある機能を提供していない場合は、<xref:System.Text.StringBuilder> オブジェクトを使用して個別の文字の "埋め込み先" を変更し、<xref:System.Text.StringBuilder> メソッドを使用することで、結果を格納する新しい文字列を作成できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-213">If the <xref:System.String> methods do not provide the functionality that you must have to modify individual characters in a string, you can use a <xref:System.Text.StringBuilder> object to modify the individual chars "in-place", and then create a new string to store the results by using the <xref:System.Text.StringBuilder> methods.</span></span> <span data-ttu-id="3b8e8-214">次の例では、特定の方法で元の文字列を変更し、将来使用するためにその結果を保存する必要があるとします。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-214">In the following example, assume that you must modify the original string in a particular way and then store the results for future use:</span></span>  
  
 [!code-csharp[csProgGuideStrings#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#27)]  
  
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="3b8e8-215">null 文字列と空の文字列</span><span class="sxs-lookup"><span data-stu-id="3b8e8-215">Null Strings and Empty Strings</span></span>  
 <span data-ttu-id="3b8e8-216">空の文字列はゼロ文字を含む <xref:System.String?displayProperty=nameWithType> オブジェクトのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-216">An empty string is an instance of a <xref:System.String?displayProperty=nameWithType> object that contains zero characters.</span></span> <span data-ttu-id="3b8e8-217">空の文字列は、空のテキスト フィールドを表すため、さまざまなプログラミング シナリオでよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-217">Empty strings are used often in various programming scenarios to represent a blank text field.</span></span> <span data-ttu-id="3b8e8-218">有効な <xref:System.String?displayProperty=nameWithType> オブジェクトであるため、空の文字列でメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-218">You can call methods on empty strings because they are valid <xref:System.String?displayProperty=nameWithType> objects.</span></span> <span data-ttu-id="3b8e8-219">空の文字列は、次のように初期化されます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-219">Empty strings are initialized as follows:</span></span>  
  
```csharp  
string s = String.Empty;  
```  
  
 <span data-ttu-id="3b8e8-220">これに対し、null 文字列は <xref:System.String?displayProperty=nameWithType> オブジェクトのインスタンスを参照しないので、null 文字列でメソッドを呼び出そうとすると <xref:System.NullReferenceException> が発生します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-220">By contrast, a null string does not refer to an instance of a <xref:System.String?displayProperty=nameWithType> object and any attempt to call a method on a null string causes a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="3b8e8-221">しかし、null 文字列を他の文字列に連結したり、他の文字列と比較することは可能です。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-221">However, you can use null strings in concatenation and comparison operations with other strings.</span></span> <span data-ttu-id="3b8e8-222">次に、null 文字列の参照によって例外がスローされる場合とされない場合の例を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-222">The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:</span></span>  
  
 [!code-csharp[csProgGuideStrings#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#20)]  
  
## <a name="using-stringbuilder-for-fast-string-creation"></a><span data-ttu-id="3b8e8-223">文字列を迅速に作成するための StringBuilder の使用</span><span class="sxs-lookup"><span data-stu-id="3b8e8-223">Using StringBuilder for Fast String Creation</span></span>  
 <span data-ttu-id="3b8e8-224">.NET での文字列操作は高度に最適化されており、ほとんどの場合パフォーマンスに大きく影響することはありません。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-224">String operations in .NET are highly optimized and in most cases do not significantly impact performance.</span></span> <span data-ttu-id="3b8e8-225">ただし、短いループが数百回または数千回実行されている場合など、シナリオによっては文字列操作がパフォーマンスに影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-225">However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance.</span></span> <span data-ttu-id="3b8e8-226"><xref:System.Text.StringBuilder> クラスが作成する文字列バッファーにより、プログラムで大量の文字列操作を実行する場合のパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-226">The <xref:System.Text.StringBuilder> class creates a string buffer that offers better performance if your program performs many string manipulations.</span></span> <span data-ttu-id="3b8e8-227"><xref:System.Text.StringBuilder> 文字列を使用すると、組み込み文字列データ型ではサポートされていない個別の文字を再割り当てできます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-227">The <xref:System.Text.StringBuilder> string also enables you to reassign individual characters, something the built-in string data type does not support.</span></span> <span data-ttu-id="3b8e8-228">たとえば、このコードでは、新しい文字列を作成せずに、文字列の内容を変更します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-228">This code, for example, changes the content of a string without creating a new string:</span></span>  
  
 [!code-csharp[csProgGuideStrings#15](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#15)]  
  
 <span data-ttu-id="3b8e8-229">この例では、<xref:System.Text.StringBuilder> オブジェクトを使用して、複数の数値型から 1 つの文字列を作成します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-229">In this example, a <xref:System.Text.StringBuilder> object is used to create a string from a set of numeric types:</span></span>  
  
 [!code-csharp[TestStringBuilder#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/TestStringBuilder.cs)]
  
## <a name="strings-extension-methods-and-linq"></a><span data-ttu-id="3b8e8-230">文字列、拡張メソッド、LINQ</span><span class="sxs-lookup"><span data-stu-id="3b8e8-230">Strings, Extension Methods and LINQ</span></span>  
 <span data-ttu-id="3b8e8-231"><xref:System.String> 型は、<xref:System.Collections.Generic.IEnumerable%601> を実装するので、文字列には <xref:System.Linq.Enumerable> クラスで定義した拡張メソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-231">Because the <xref:System.String> type implements <xref:System.Collections.Generic.IEnumerable%601>, you can use the extension methods defined in the <xref:System.Linq.Enumerable> class on strings.</span></span> <span data-ttu-id="3b8e8-232">見やすさを考慮して、これらのメソッドは <xref:System.String> 型の IntelliSense からは除外されていますが、使用できます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-232">To avoid visual clutter, these methods are excluded from IntelliSense for the <xref:System.String> type, but they are available nevertheless.</span></span> <span data-ttu-id="3b8e8-233">文字列で LINQ クエリ式を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-233">You can also use LINQ query expressions on strings.</span></span> <span data-ttu-id="3b8e8-234">詳細については、「[LINQ と文字列](../concepts/linq/linq-and-strings.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-234">For more information, see [LINQ and Strings](../concepts/linq/linq-and-strings.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="3b8e8-235">関連トピック</span><span class="sxs-lookup"><span data-stu-id="3b8e8-235">Related Topics</span></span>  
  
|<span data-ttu-id="3b8e8-236">トピック</span><span class="sxs-lookup"><span data-stu-id="3b8e8-236">Topic</span></span>|<span data-ttu-id="3b8e8-237">説明</span><span class="sxs-lookup"><span data-stu-id="3b8e8-237">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="3b8e8-238">文字列の内容を変更する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-238">How to modify string contents</span></span>](../../how-to/modify-string-contents.md)|<span data-ttu-id="3b8e8-239">文字列の変換および文字列の内容を変更する手法を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-239">Illustrates techniques to transform strings and modify the contents of strings.</span></span>|  
|[<span data-ttu-id="3b8e8-240">文字列を比較する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-240">How to compare strings</span></span>](../../how-to/compare-strings.md)|<span data-ttu-id="3b8e8-241">文字列の序数とカルチャ固有の比較を実行する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-241">Shows how to perform ordinal and culture specific comparisons of strings.</span></span>|  
|[<span data-ttu-id="3b8e8-242">複数の文字列を連結する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-242">How to concatenate multiple strings</span></span>](../../how-to/concatenate-multiple-strings.md)|<span data-ttu-id="3b8e8-243">複数の文字列を 1 つに結合するさまざまな方法を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-243">Demonstrates various ways to join multiple strings into one.</span></span>|
|[<span data-ttu-id="3b8e8-244">String.Split を使用して文字列を解析する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-244">How to parse strings using String.Split</span></span>](../../how-to/parse-strings-using-split.md)|<span data-ttu-id="3b8e8-245">`String.Split` メソッドを使用して文字列を解析するコード例を紹介します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-245">Contains code examples that illustrate how to use the `String.Split` method to parse strings.</span></span>|  
|[<span data-ttu-id="3b8e8-246">文字列を検索する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-246">How to search strings</span></span>](../../how-to/search-strings.md)|<span data-ttu-id="3b8e8-247">特定のテキストまたは文字列のパターンの検索を使用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-247">Explains how to use search for specific text or patterns in strings.</span></span>|  
|[<span data-ttu-id="3b8e8-248">文字列が数値を表しているかどうかを確認する方法</span><span class="sxs-lookup"><span data-stu-id="3b8e8-248">How to determine whether a string represents a numeric value</span></span>](./how-to-determine-whether-a-string-represents-a-numeric-value.md)|<span data-ttu-id="3b8e8-249">文字列を安全に解析して、有効な数値があるかどうかを確認する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-249">Shows how to safely parse a string to see whether it has a valid numeric value.</span></span>|  
|[<span data-ttu-id="3b8e8-250">文字列補間</span><span class="sxs-lookup"><span data-stu-id="3b8e8-250">String interpolation</span></span>](../../language-reference/tokens/interpolated.md)|<span data-ttu-id="3b8e8-251">書式指定文字列に便利な構文を提供する文字列補間機能について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-251">Describes the string interpolation feature that provides a convenient syntax to format strings.</span></span>|
|[<span data-ttu-id="3b8e8-252">基本的な文字列操作</span><span class="sxs-lookup"><span data-stu-id="3b8e8-252">Basic String Operations</span></span>](../../../standard/base-types/basic-string-operations.md)|<span data-ttu-id="3b8e8-253"><xref:System.String?displayProperty=nameWithType> メソッドおよび <xref:System.Text.StringBuilder?displayProperty=nameWithType> メソッドを使用し文字列の基本操作を実行する、トピックへのリンクがあります。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-253">Provides links to topics that use <xref:System.String?displayProperty=nameWithType> and <xref:System.Text.StringBuilder?displayProperty=nameWithType> methods to perform basic string operations.</span></span>|  
|[<span data-ttu-id="3b8e8-254">文字列の解析</span><span class="sxs-lookup"><span data-stu-id="3b8e8-254">Parsing Strings</span></span>](../../../standard/base-types/parsing-strings.md)|<span data-ttu-id="3b8e8-255">.NET の基本データ型の文字列形式を対応する型のインスタンスに変換する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-255">Describes how to convert string representations of .NET base types to instances of the corresponding types.</span></span>|  
|[<span data-ttu-id="3b8e8-256">.NET での日付と時刻文字列の解析</span><span class="sxs-lookup"><span data-stu-id="3b8e8-256">Parsing Date and Time Strings in .NET</span></span>](../../../standard/base-types/parsing-datetime.md)|<span data-ttu-id="3b8e8-257">"01/24/2008" などの文字列を、<xref:System.DateTime?displayProperty=nameWithType> オブジェクトに変換する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-257">Shows how to convert a string such as "01/24/2008" to a <xref:System.DateTime?displayProperty=nameWithType> object.</span></span>|  
|[<span data-ttu-id="3b8e8-258">文字列の比較</span><span class="sxs-lookup"><span data-stu-id="3b8e8-258">Comparing Strings</span></span>](../../../standard/base-types/comparing.md)|<span data-ttu-id="3b8e8-259">文字列を比較する方法について説明し、C# および Visual Basic での例を示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-259">Includes information about how to compare strings and provides examples in C# and Visual Basic.</span></span>|  
|[<span data-ttu-id="3b8e8-260">StringBuilder クラスの使用</span><span class="sxs-lookup"><span data-stu-id="3b8e8-260">Using the StringBuilder Class</span></span>](../../../standard/base-types/stringbuilder.md)|<span data-ttu-id="3b8e8-261"><xref:System.Text.StringBuilder> クラスの動的な文字列オブジェクトを作成および変更する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-261">Describes how to create and modify dynamic string objects by using the <xref:System.Text.StringBuilder> class.</span></span>|  
|[<span data-ttu-id="3b8e8-262">LINQ と文字列</span><span class="sxs-lookup"><span data-stu-id="3b8e8-262">LINQ and Strings</span></span>](../concepts/linq/linq-and-strings.md)|<span data-ttu-id="3b8e8-263">LINQ クエリを使用してさまざまな文字列操作を実行する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-263">Provides information about how to perform various string operations by using LINQ queries.</span></span>|  
|[<span data-ttu-id="3b8e8-264">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="3b8e8-264">C# Programming Guide</span></span>](../index.md)|<span data-ttu-id="3b8e8-265">C# のプログラミング要素について説明するトピックへのリンクを示します。</span><span class="sxs-lookup"><span data-stu-id="3b8e8-265">Provides links to topics that explain programming constructs in C#.</span></span>|  
