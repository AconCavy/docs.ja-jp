---
title: 継承 - C# プログラミング ガイド
ms.date: 07/20/2015
helpviewer_keywords:
- abstract methods [C#]
- abstract classes [C#]
- inheritance [C#]
- derived classes [C#]
- virtual methods [C#]
- C# language, inheritance
ms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea
ms.openlocfilehash: 3c59741fa646111d27f6d1087a9275178c1a41a1
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/07/2020
ms.locfileid: "75705549"
---
# <a name="inheritance-c-programming-guide"></a><span data-ttu-id="9d46b-102">継承 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="9d46b-102">Inheritance (C# Programming Guide)</span></span>

<span data-ttu-id="9d46b-103">継承は、カプセル化およびポリモーフィズムと共に、オブジェクト指向プログラミングの主要な 3 つの特性の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="9d46b-103">Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming.</span></span> <span data-ttu-id="9d46b-104">継承を使用すると、他のクラスで定義されている動作を再利用、拡張、および変更する新しいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-104">Inheritance enables you to create new classes that reuse, extend, and modify the behavior that is defined in other classes.</span></span> <span data-ttu-id="9d46b-105">メンバーが継承される側のクラスを "*基底クラス*" と呼び、メンバーを継承する側のクラスを "*派生クラス*" と呼びます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-105">The class whose members are inherited is called the *base class*, and the class that inherits those members is called the *derived class*.</span></span> <span data-ttu-id="9d46b-106">派生クラスは、直接の基底クラスを 1 つだけ持つことができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-106">A derived class can have only one direct base class.</span></span> <span data-ttu-id="9d46b-107">ただし、継承は推移的です。</span><span class="sxs-lookup"><span data-stu-id="9d46b-107">However, inheritance is transitive.</span></span> <span data-ttu-id="9d46b-108">ClassC が ClassB から派生し、ClassB が ClassA から派生している場合、ClassC は ClassB と ClassA で宣言されたメンバーを継承します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-108">If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="9d46b-109">構造体では、継承がサポートされていませんが、インターフェイスを実装することはできます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-109">Structs do not support inheritance, but they can implement interfaces.</span></span> <span data-ttu-id="9d46b-110">詳細については、「[インターフェイス](../interfaces/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-110">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
 <span data-ttu-id="9d46b-111">概念的には、派生クラスは基底クラスから特化したクラスです。</span><span class="sxs-lookup"><span data-stu-id="9d46b-111">Conceptually, a derived class is a specialization of the base class.</span></span> <span data-ttu-id="9d46b-112">たとえば、基底クラス `Animal` がある場合、`Mammal` という名前の派生クラスと、`Reptile` という名前の別の派生クラスを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-112">For example, if you have a base class `Animal`, you might have one derived class that is named `Mammal` and another derived class that is named `Reptile`.</span></span> <span data-ttu-id="9d46b-113">`Mammal` は `Animal` であり、`Reptile` も `Animal` ですが、各派生クラスは、基底クラスから別々の特殊化を表します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-113">A `Mammal` is an `Animal`, and a `Reptile` is an `Animal`, but each derived class represents different specializations of the base class.</span></span>  
  
 <span data-ttu-id="9d46b-114">クラスを別のクラスから派生するように定義すると、派生クラスには、コンストラクターとファイナライザーを除く、基底クラスのすべてのメンバーが暗黙的に引き継がれます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-114">When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers.</span></span> <span data-ttu-id="9d46b-115">そのため、派生クラスでは、基底クラスのコードを再実装しなくても再利用できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-115">The derived class can thereby reuse the code in the base class without having to re-implement it.</span></span> <span data-ttu-id="9d46b-116">派生クラスには、メンバーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-116">In the derived class, you can add more members.</span></span> <span data-ttu-id="9d46b-117">このような方法で、派生クラスは基底クラスの機能を拡張します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-117">In this manner, the derived class extends the functionality of the base class.</span></span>  
  
 <span data-ttu-id="9d46b-118">次の図は、あるビジネス プロセスの作業項目を表す `WorkItem` クラスを示しています。</span><span class="sxs-lookup"><span data-stu-id="9d46b-118">The following illustration shows a class `WorkItem` that represents an item of work in some business process.</span></span> <span data-ttu-id="9d46b-119">他のすべてのクラスと同様に、<xref:System.Object?displayProperty=nameWithType> から派生し、そのすべてのメソッドを継承します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-119">Like all classes, it derives from <xref:System.Object?displayProperty=nameWithType> and inherits all its methods.</span></span> <span data-ttu-id="9d46b-120">`WorkItem` には、独自のメンバーが 5 つ追加されています。</span><span class="sxs-lookup"><span data-stu-id="9d46b-120">`WorkItem` adds five members of its own.</span></span> <span data-ttu-id="9d46b-121">これにはコンストラクターが含まれています。コンストラクターは継承されないためです。</span><span class="sxs-lookup"><span data-stu-id="9d46b-121">These include a constructor, because constructors are not inherited.</span></span> <span data-ttu-id="9d46b-122">`WorkItem` から継承される `ChangeRequest` クラスは、特定の種類の作業項目を表します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-122">Class `ChangeRequest` inherits from `WorkItem` and represents a particular kind of work item.</span></span> <span data-ttu-id="9d46b-123">`ChangeRequest` には、`WorkItem` と <xref:System.Object> から継承したメンバーに 2 つのメンバーが追加されます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-123">`ChangeRequest` adds two more members to the members that it inherits from `WorkItem` and from <xref:System.Object>.</span></span> <span data-ttu-id="9d46b-124">独自のコンストラクターを追加する必要があるほか、さらに `originalItemID` も追加されます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-124">It must add its own constructor, and it also adds `originalItemID`.</span></span> <span data-ttu-id="9d46b-125">`originalItemID` プロパティを使用すると、`ChangeRequest` インスタンスは、変更要求が適用される元の `WorkItem` と関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-125">Property `originalItemID` enables the `ChangeRequest` instance to be associated with the original `WorkItem` to which the change request applies.</span></span>  
  
 ![クラスの継承を示す図](./media/inheritance/class-inheritance-diagram.png)  
  
 <span data-ttu-id="9d46b-127">次の例は、前の図に示したクラスの関係が C# でどのように表現されるかを示しています。</span><span class="sxs-lookup"><span data-stu-id="9d46b-127">The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#.</span></span> <span data-ttu-id="9d46b-128">また、`WorkItem` が仮想メソッド <xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドする方法と、`ChangeRequest` クラスが `WorkItem` によるメソッドの実装を継承する方法も示しています。</span><span class="sxs-lookup"><span data-stu-id="9d46b-128">The example also shows how `WorkItem` overrides the virtual method <xref:System.Object.ToString%2A?displayProperty=nameWithType>, and how the `ChangeRequest` class inherits the `WorkItem` implementation of the method.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#49](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#49)]  
  
## <a name="abstract-and-virtual-methods"></a><span data-ttu-id="9d46b-129">抽象メソッドと仮想メソッド</span><span class="sxs-lookup"><span data-stu-id="9d46b-129">Abstract and Virtual Methods</span></span>  
 <span data-ttu-id="9d46b-130">基底クラスでメソッドを [virtual](../../language-reference/keywords/virtual.md) として宣言する場合、派生クラスはそのメソッドを独自の実装で[オーバーライド](../../language-reference/keywords/override.md)することができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-130">When a base class declares a method as [virtual](../../language-reference/keywords/virtual.md), a derived class can [override](../../language-reference/keywords/override.md) the method with its own implementation.</span></span> <span data-ttu-id="9d46b-131">基底クラスでメンバーを [abstract](../../language-reference/keywords/abstract.md) として宣言する場合、そのクラスから直接継承される非抽象クラスで、そのメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d46b-131">If a base class declares a member as [abstract](../../language-reference/keywords/abstract.md), that method must be overridden in any non-abstract class that directly inherits from that class.</span></span> <span data-ttu-id="9d46b-132">派生クラス自体が抽象クラスである場合は、抽象メンバーを実装することなく継承します。</span><span class="sxs-lookup"><span data-stu-id="9d46b-132">If a derived class is itself abstract, it inherits abstract members without implementing them.</span></span> <span data-ttu-id="9d46b-133">抽象メンバーと仮想メンバーは、オブジェクト指向プログラミングの重要な特性の 2 つ目であるポリモーフィズムの基礎です。</span><span class="sxs-lookup"><span data-stu-id="9d46b-133">Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming.</span></span> <span data-ttu-id="9d46b-134">詳細については、「[ポリモーフィズム](./polymorphism.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-134">For more information, see [Polymorphism](./polymorphism.md).</span></span>  
  
## <a name="abstract-base-classes"></a><span data-ttu-id="9d46b-135">抽象基本クラス</span><span class="sxs-lookup"><span data-stu-id="9d46b-135">Abstract Base Classes</span></span>  
 <span data-ttu-id="9d46b-136">[new](../../language-reference/operators/new-operator.md) 演算子を使用して直接インスタンス化されないようにする場合は、クラスを [abstract](../../language-reference/keywords/abstract.md) として宣言できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-136">You can declare a class as [abstract](../../language-reference/keywords/abstract.md) if you want to prevent direct instantiation by using the [new](../../language-reference/operators/new-operator.md) operator.</span></span> <span data-ttu-id="9d46b-137">このようにすると、そのクラスは、新しいクラスを派生させないと使用できません。</span><span class="sxs-lookup"><span data-stu-id="9d46b-137">If you do this, the class can be used only if a new class is derived from it.</span></span> <span data-ttu-id="9d46b-138">抽象クラスには、それ自体が abstract として宣言された 1 つ以上のメソッド シグネチャを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-138">An abstract class can contain one or more method signatures that themselves are declared as abstract.</span></span> <span data-ttu-id="9d46b-139">これらのシグネチャは、パラメーターと戻り値を指定しますが、実装 (メソッドの本体) は持ちません。</span><span class="sxs-lookup"><span data-stu-id="9d46b-139">These signatures specify the parameters and return value but have no implementation (method body).</span></span> <span data-ttu-id="9d46b-140">抽象クラスには、抽象メンバーを含める必要はありません。ただし、クラスに抽象メンバーが含まれている場合は、クラス自体を抽象クラスとして宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d46b-140">An abstract class does not have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract.</span></span> <span data-ttu-id="9d46b-141">抽象クラスでない派生クラスは、抽象基底クラスから継承した抽象メソッドすべてを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d46b-141">Derived classes that are not abstract themselves must provide the implementation for any abstract methods from an abstract base class.</span></span> <span data-ttu-id="9d46b-142">詳細については、「[抽象クラスとシール クラス、およびクラス メンバー](./abstract-and-sealed-classes-and-class-members.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-142">For more information, see [Abstract and Sealed Classes and Class Members](./abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
## <a name="interfaces"></a><span data-ttu-id="9d46b-143">インターフェイス</span><span class="sxs-lookup"><span data-stu-id="9d46b-143">Interfaces</span></span>  
 <span data-ttu-id="9d46b-144">"*インターフェイス*" は、抽象メンバーのみで構成される抽象基底クラスに類似した参照型です。</span><span class="sxs-lookup"><span data-stu-id="9d46b-144">An *interface* is a reference type that is somewhat similar to an abstract base class that consists of only abstract members.</span></span> <span data-ttu-id="9d46b-145">クラスでインターフェイスを実装するときは、インターフェイスのすべてのメンバーを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9d46b-145">When a class implements an interface, it must provide an implementation for all the members of the interface.</span></span> <span data-ttu-id="9d46b-146">クラスは、直接的には 1 つの基底クラスからしか派生できませんが、複数のインターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-146">A class can implement multiple interfaces even though it can derive from only a single direct base class.</span></span>  
  
 <span data-ttu-id="9d46b-147">インターフェイスは、必ずしも "is a" 関係を持たないクラスの特定の機能を定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-147">Interfaces are used to define specific capabilities for classes that do not necessarily have an "is a" relationship.</span></span> <span data-ttu-id="9d46b-148">たとえば、ある型の 2 つのオブジェクトが等しいかどうかをクライアント コードで判別できるようにする (ただし、等価性の定義は型によって行う) クラスまたは構造体では、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスを実装できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-148">For example, the <xref:System.IEquatable%601?displayProperty=nameWithType> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence).</span></span> <span data-ttu-id="9d46b-149"><xref:System.IEquatable%601> は、基底クラスと派生クラス間に存在する "is a" 関係 ("`Mammal` は `Animal` である" など) と同様の意味を示すものではありません。</span><span class="sxs-lookup"><span data-stu-id="9d46b-149"><xref:System.IEquatable%601> does not imply the same kind of "is a" relationship that exists between a base class and a derived class (for example, a `Mammal` is an `Animal`).</span></span> <span data-ttu-id="9d46b-150">詳細については、「[インターフェイス](../interfaces/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-150">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
## <a name="preventing-further-derivation"></a><span data-ttu-id="9d46b-151">それ以上の派生の禁止</span><span class="sxs-lookup"><span data-stu-id="9d46b-151">Preventing Further Derivation</span></span>  
 <span data-ttu-id="9d46b-152">クラス自体またはメンバーを [sealed](../../language-reference/keywords/sealed.md)と宣言することにより、他のクラスがそのクラスまたはそのクラスのメンバーを継承できないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-152">A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="9d46b-153">詳細については、「[抽象クラスとシール クラス、およびクラス メンバー](./abstract-and-sealed-classes-and-class-members.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-153">For more information, see [Abstract and Sealed Classes and Class Members](./abstract-and-sealed-classes-and-class-members.md).</span></span>  
  
## <a name="derived-class-hiding-of-base-class-members"></a><span data-ttu-id="9d46b-154">派生クラスによる基底クラスのメンバーの隠ぺい</span><span class="sxs-lookup"><span data-stu-id="9d46b-154">Derived Class Hiding of Base Class Members</span></span>  
 <span data-ttu-id="9d46b-155">派生クラスは、同じ名前とシグネチャでメンバーを宣言することで、基底クラスのメンバーを隠ぺいすることができます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-155">A derived class can hide base class members by declaring members with the same name and signature.</span></span> <span data-ttu-id="9d46b-156">[new](../../language-reference/keywords/new-modifier.md) 修飾子を使用すると、そのメンバーが基底クラスのメンバーのオーバーライドとして用意されているのではないことを明示的に指定できます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-156">The [new](../../language-reference/keywords/new-modifier.md) modifier can be used to explicitly indicate that the member is not intended to be an override of the base member.</span></span> <span data-ttu-id="9d46b-157">[new](../../language-reference/keywords/new-modifier.md) の使用は必須ではありませんが、[new](../../language-reference/keywords/new-modifier.md) が使用されていない場合はコンパイラの警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="9d46b-157">The use of [new](../../language-reference/keywords/new-modifier.md) is not required, but a compiler warning will be generated if [new](../../language-reference/keywords/new-modifier.md) is not used.</span></span> <span data-ttu-id="9d46b-158">詳細については、「[Override キーワードと New キーワードによるバージョン管理](./versioning-with-the-override-and-new-keywords.md)」および「[Override キーワードと New キーワードを使用する場合について](./knowing-when-to-use-override-and-new-keywords.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9d46b-158">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md) and [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9d46b-159">関連項目</span><span class="sxs-lookup"><span data-stu-id="9d46b-159">See also</span></span>

- [<span data-ttu-id="9d46b-160">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="9d46b-160">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="9d46b-161">クラスと構造体</span><span class="sxs-lookup"><span data-stu-id="9d46b-161">Classes and Structs</span></span>](./index.md)
- [<span data-ttu-id="9d46b-162">class</span><span class="sxs-lookup"><span data-stu-id="9d46b-162">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="9d46b-163">struct</span><span class="sxs-lookup"><span data-stu-id="9d46b-163">struct</span></span>](../../language-reference/keywords/struct.md)
