---
title: 匿名型 - C# プログラミング ガイド
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: 63bc5560ba19ff36764465a6b89b81c13beec97a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79170339"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="8e637-102">匿名型 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="8e637-102">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="8e637-103">匿名型を使用すると、あらかじめ明示的に型を定義することなく、一連の読み取り専用プロパティを単一のオブジェクトにカプセル化できるので便利です。</span><span class="sxs-lookup"><span data-stu-id="8e637-103">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="8e637-104">型の名前はコンパイラにより生成され、ソース コード レベルでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8e637-104">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="8e637-105">各プロパティの型はコンパイラにより推測されます。</span><span class="sxs-lookup"><span data-stu-id="8e637-105">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="8e637-106">匿名型を作成するには、[new](../../language-reference/operators/new-operator.md) 演算子をオブジェクト初期化子と一緒に使用します。</span><span class="sxs-lookup"><span data-stu-id="8e637-106">You create anonymous types by using the [new](../../language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="8e637-107">オブジェクト初期化子の詳細については、「[オブジェクト初期化子とコレクション初期化子](./object-and-collection-initializers.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8e637-107">For more information about object initializers, see [Object and Collection Initializers](./object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="8e637-108">次の例では、`Amount` および `Message` という名前の 2 つのプロパティがある、初期化される匿名型を示します。</span><span class="sxs-lookup"><span data-stu-id="8e637-108">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="8e637-109">通常、匿名型はクエリ式の [select](../../language-reference/keywords/select-clause.md) 句で使用され、ソース シーケンスの各オブジェクトからプロパティのサブセットを返します。</span><span class="sxs-lookup"><span data-stu-id="8e637-109">Anonymous types typically are used in the [select](../../language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="8e637-110">クエリの詳細については、「[C# での LINQ](../../linq/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8e637-110">For more information about queries, see [LINQ in C#](../../linq/index.md).</span></span>  
  
 <span data-ttu-id="8e637-111">匿名型には、読み取り専用パブリック プロパティが 1 つ以上含まれます。</span><span class="sxs-lookup"><span data-stu-id="8e637-111">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="8e637-112">それ以外のクラス メンバー (メソッドやイベントなど) は無効です。</span><span class="sxs-lookup"><span data-stu-id="8e637-112">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="8e637-113">プロパティの初期化に使用される式に、`null`、匿名関数、ポインター型を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="8e637-113">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="8e637-114">最も一般的な用例は、別の型のプロパティを使用して匿名型を初期化することです。</span><span class="sxs-lookup"><span data-stu-id="8e637-114">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="8e637-115">次の例では、`Product` という名前のクラスが存在すると仮定します。</span><span class="sxs-lookup"><span data-stu-id="8e637-115">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="8e637-116">`Product` クラスには、さまざまなプロパティが含まれますが、ここで注目するのは `Color` と `Price` プロパティです。</span><span class="sxs-lookup"><span data-stu-id="8e637-116">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="8e637-117">変数 `products` は、`Product` オブジェクトのコレクションです。</span><span class="sxs-lookup"><span data-stu-id="8e637-117">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="8e637-118">匿名型の宣言は、`new` キーワードで始まります。</span><span class="sxs-lookup"><span data-stu-id="8e637-118">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="8e637-119">この宣言により、`Product` の 2 つのプロパティだけを使用する新しい型が初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8e637-119">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="8e637-120">この結果、クエリに返されるデータの量が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="8e637-120">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="8e637-121">匿名型のメンバー名を指定しない場合、コンパイラは初期化に使用されるプロパティと同じ名前を匿名型メンバーに付けます。</span><span class="sxs-lookup"><span data-stu-id="8e637-121">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="8e637-122">前の例で示されているように、式を使用して初期化されるプロパティの名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8e637-122">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="8e637-123">次の例では、`Color` と `Price` が匿名型のプロパティの名前になっています。</span><span class="sxs-lookup"><span data-stu-id="8e637-123">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="8e637-124">通常、変数の初期化に匿名型を使用する場合は、[var](../../language-reference/keywords/var.md) を使用することにより、変数を暗黙的に型指定したローカル変数として宣言します。</span><span class="sxs-lookup"><span data-stu-id="8e637-124">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../language-reference/keywords/var.md).</span></span> <span data-ttu-id="8e637-125">コンパイラだけが匿名型の基になる名前にアクセスできるため、変数宣言では型の名前を指定できません。</span><span class="sxs-lookup"><span data-stu-id="8e637-125">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="8e637-126">`var` の詳細については、「[暗黙的に型指定されたローカル変数](./implicitly-typed-local-variables.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8e637-126">For more information about `var`, see [Implicitly Typed Local Variables](./implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="8e637-127">次の例に示すように、暗黙的に型指定されたローカル変数と暗黙的に型指定された配列を組み合わせることにより、匿名型の要素の配列を作成できます。</span><span class="sxs-lookup"><span data-stu-id="8e637-127">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="8e637-128">解説</span><span class="sxs-lookup"><span data-stu-id="8e637-128">Remarks</span></span>  
 <span data-ttu-id="8e637-129">匿名型は [object](../../language-reference/keywords/class.md) から直接派生した [class](../../language-reference/builtin-types/reference-types.md) 型であり、[object](../../language-reference/builtin-types/reference-types.md) 以外の型にキャストできません。</span><span class="sxs-lookup"><span data-stu-id="8e637-129">Anonymous types are [class](../../language-reference/keywords/class.md) types that derive directly from [object](../../language-reference/builtin-types/reference-types.md), and that cannot be cast to any type except [object](../../language-reference/builtin-types/reference-types.md).</span></span> <span data-ttu-id="8e637-130">コンパイラは各匿名型に名前を付けますが、この名前にアプリケーションはアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="8e637-130">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="8e637-131">共通言語ランタイムから見た場合、匿名型と他の参照型に違いはありません。</span><span class="sxs-lookup"><span data-stu-id="8e637-131">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="8e637-132">アセンブリ内の複数の匿名オブジェクト初期化子が、同じ順序で同じ名前や型を持つプロパティのシーケンスを指定する場合、コンパイラはそれらのオブジェクトを同じ型のインスタンスとして処理します。</span><span class="sxs-lookup"><span data-stu-id="8e637-132">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="8e637-133">これらのオブジェクトは、コンパイラで生成された同一の型情報を共有します。</span><span class="sxs-lookup"><span data-stu-id="8e637-133">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="8e637-134">フィールド、プロパティ、イベント、またはメソッドの戻り値の型は、匿名型を持つものとして宣言できません。</span><span class="sxs-lookup"><span data-stu-id="8e637-134">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="8e637-135">同様に、メソッドの仮パラメーター、プロパティ、コンストラクター、またはインデクサーも、匿名型を持つものとして宣言できません。</span><span class="sxs-lookup"><span data-stu-id="8e637-135">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="8e637-136">メソッドの引数として匿名型または匿名型を含むコレクションを渡すために、パラメーターを型オブジェクトとして宣言できます。</span><span class="sxs-lookup"><span data-stu-id="8e637-136">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="8e637-137">ただし、これにより厳密な型指定が無効になります。</span><span class="sxs-lookup"><span data-stu-id="8e637-137">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="8e637-138">クエリ結果をメソッドの境界を越えて格納したり渡したりする必要がある場合、匿名型の代わりに、通常の名前の構造体またはクラスの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="8e637-138">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="8e637-139">匿名型の <xref:System.Object.Equals%2A> メソッドと <xref:System.Object.GetHashCode%2A> メソッドは、プロパティの `Equals` メソッドと `GetHashCode` メソッドとして定義されています。このため、同じ匿名型の 2 つのインスタンスは、すべてのプロパティが等しい場合のみ等しいとみなされます。</span><span class="sxs-lookup"><span data-stu-id="8e637-139">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8e637-140">参照</span><span class="sxs-lookup"><span data-stu-id="8e637-140">See also</span></span>

- [<span data-ttu-id="8e637-141">C# プログラミングガイド</span><span class="sxs-lookup"><span data-stu-id="8e637-141">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="8e637-142">オブジェクト初期化子とコレクション初期化子</span><span class="sxs-lookup"><span data-stu-id="8e637-142">Object and Collection Initializers</span></span>](./object-and-collection-initializers.md)
- [<span data-ttu-id="8e637-143">C# の LINQ の概要</span><span class="sxs-lookup"><span data-stu-id="8e637-143">Getting Started with LINQ in C#</span></span>](../concepts/linq/index.md)
- [<span data-ttu-id="8e637-144">C# での LINQ</span><span class="sxs-lookup"><span data-stu-id="8e637-144">LINQ in C#</span></span>](../../linq/index.md)
