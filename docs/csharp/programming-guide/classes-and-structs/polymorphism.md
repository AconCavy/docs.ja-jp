---
title: ポリモーフィズム - C# プログラミング ガイド
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: be075c358d9ca2c36b6d173fca983c16f6b0d78c
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/12/2019
ms.locfileid: "73970337"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="0e635-102">ポリモーフィズム (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="0e635-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="0e635-103">ポリモーフィズムは、カプセル化と継承に次ぐ、オブジェクト指向プログラミングの第 3 の柱と言われることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="0e635-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="0e635-104">ポリモーフィズムは、ギリシャ語で "多形" を意味し、次の 2 つの側面を持っています。</span><span class="sxs-lookup"><span data-stu-id="0e635-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
- <span data-ttu-id="0e635-105">メソッド パラメーター、コレクション、配列などに渡された派生クラスのオブジェクトは、実行時に基底クラスのオブジェクトとして扱われることがあります。</span><span class="sxs-lookup"><span data-stu-id="0e635-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="0e635-106">この場合、オブジェクトの宣言された型は、その実行時の型と同じではなくなります。</span><span class="sxs-lookup"><span data-stu-id="0e635-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
- <span data-ttu-id="0e635-107">基底クラスでは、[virtual](../../language-reference/keywords/virtual.md) *メソッド*を定義して実行できます。派生クラスでそれを[オーバーライド](../../language-reference/keywords/override.md)すると、独自の定義と実装を提供できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-107">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="0e635-108">実行時には、クライアント コードがメソッドを呼び出したとき、CLR によってオブジェクトの実行時の型が検索され、仮想メソッドのオーバーライドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0e635-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="0e635-109">このように、ソース コード内で基底クラスのメソッドを呼び出して、派生クラスのメソッドが実行されるようにできます。</span><span class="sxs-lookup"><span data-stu-id="0e635-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="0e635-110">仮想メソッドを使用すると、関連するオブジェクトのグループを同一の方法で扱うことができます。</span><span class="sxs-lookup"><span data-stu-id="0e635-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="0e635-111">たとえば、描画サーフェイスにさまざまな種類の図形を作成できる描画アプリケーションがあるとします。</span><span class="sxs-lookup"><span data-stu-id="0e635-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="0e635-112">コンパイル時には、ユーザーがどのような種類の図形を作成するかわかりません。</span><span class="sxs-lookup"><span data-stu-id="0e635-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="0e635-113">しかし、アプリケーションでは、作成されたさまざまな種類の図形を追跡し、ユーザーのマウス操作に応じて更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0e635-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="0e635-114">ポリモーフィズムを使用すると、2 つの基本的な手順でこの問題を解決できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1. <span data-ttu-id="0e635-115">各図形クラスが共通の基底クラスから派生するようなクラス階層を作成します。</span><span class="sxs-lookup"><span data-stu-id="0e635-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2. <span data-ttu-id="0e635-116">仮想メソッドを使用して、基底クラスの 1 つのメソッドを呼び出すことで、派生クラスの適切なメソッドが呼び出されるようにします。</span><span class="sxs-lookup"><span data-stu-id="0e635-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="0e635-117">まず、`Shape` という基底クラスと、`Rectangle`、`Circle`、`Triangle` などの派生クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="0e635-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="0e635-118">`Shape` クラスで `Draw` という仮想メソッドを定義し、各派生クラスでそれをオーバーライドして、そのクラスが表す特定の図形を描画します。</span><span class="sxs-lookup"><span data-stu-id="0e635-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="0e635-119">`List<Shape>` オブジェクトを作成し、Circle、Triangle、および Rectangle を追加します。</span><span class="sxs-lookup"><span data-stu-id="0e635-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="0e635-120">描画サーフェイスを更新するには、[foreach](../../language-reference/keywords/foreach-in.md) ループを使用してリストを反復処理し、リスト内の各 `Shape` オブジェクトの `Draw` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0e635-120">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="0e635-121">リスト内の各オブジェクトの宣言された型は `Shape` ですが、呼び出されるのは実行時の型 (それぞれの派生クラスでオーバーライドされたメソッド) になります。</span><span class="sxs-lookup"><span data-stu-id="0e635-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 [!code-csharp[csProgGuideInheritance#50](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#50)]  
  
 <span data-ttu-id="0e635-122">C# では、すべての型がポリモーフィックです。これは、ユーザー定義型を含むすべての型が <xref:System.Object> から派生するためです。</span><span class="sxs-lookup"><span data-stu-id="0e635-122">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="0e635-123">ポリモーフィズムの概要</span><span class="sxs-lookup"><span data-stu-id="0e635-123">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="0e635-124">仮想メンバー</span><span class="sxs-lookup"><span data-stu-id="0e635-124">Virtual Members</span></span>  
 <span data-ttu-id="0e635-125">基底クラスから派生クラスを継承すると、派生クラスは、基底クラスのすべてのメソッド、フィールド、プロパティ、およびイベントを継承します。</span><span class="sxs-lookup"><span data-stu-id="0e635-125">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="0e635-126">派生クラスの設計者は、次の点を選択できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-126">The designer of the derived class can choose whether to</span></span>  
  
- <span data-ttu-id="0e635-127">基底クラスの仮想メンバーをオーバーライドするかどうか</span><span class="sxs-lookup"><span data-stu-id="0e635-127">override virtual members in the base class,</span></span>  
  
- <span data-ttu-id="0e635-128">最も近い基底クラスのメソッドを、オーバーライドせずに継承するかどうか</span><span class="sxs-lookup"><span data-stu-id="0e635-128">inherit the closest base class method without overriding it</span></span>  
  
- <span data-ttu-id="0e635-129">これらのメンバーの仮想でない実装を新しく定義して、基底クラスの実装を隠ぺいするかどうか</span><span class="sxs-lookup"><span data-stu-id="0e635-129">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="0e635-130">派生クラスが基底クラスのメンバーをオーバーライドできるのは、基底クラスのメンバーが [virtual](../../language-reference/keywords/virtual.md) または [abstract](../../language-reference/keywords/abstract.md) として宣言されている場合だけです。</span><span class="sxs-lookup"><span data-stu-id="0e635-130">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="0e635-131">派生メンバーでは、[override](../../language-reference/keywords/override.md) キーワードを使用して、そのメソッドが仮想呼び出しに加わることを明示的に示す必要があります。</span><span class="sxs-lookup"><span data-stu-id="0e635-131">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="0e635-132">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-132">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#20)]  
  
 <span data-ttu-id="0e635-133">フィールドは仮想メンバーにできません。仮想メンバーにできるのは、メソッド、プロパティ、イベント、およびインデクサーに限られます。</span><span class="sxs-lookup"><span data-stu-id="0e635-133">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="0e635-134">派生クラスが仮想メンバーをオーバーライドすると、派生クラスのメンバーは、そのクラスのインスタンスが基底クラスのインスタンスとしてアクセスされるときでも呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0e635-134">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="0e635-135">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-135">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#21)]  
  
 <span data-ttu-id="0e635-136">仮想メソッドとプロパティを使用すると、派生クラスは、基底クラスのメソッドの実装を使用せずに基底クラスを拡張できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-136">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="0e635-137">詳細については、「[Override キーワードと New キーワードによるバージョン管理](./versioning-with-the-override-and-new-keywords.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0e635-137">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="0e635-138">1 つまたは一連のメソッドを定義し、その実装を派生クラスに任せるもう 1 つの方法として、インターフェイスがあります。</span><span class="sxs-lookup"><span data-stu-id="0e635-138">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="0e635-139">詳細については、「[インターフェイス](../interfaces/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0e635-139">For more information, see [Interfaces](../interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="0e635-140">新しいメンバーによる基底クラスのメンバーの隠ぺい</span><span class="sxs-lookup"><span data-stu-id="0e635-140">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="0e635-141">派生メンバーに基底クラスのメンバーと同じ名前を付けながら、そのメンバーが仮想呼び出しに加わらないようにするには、[new](../../language-reference/keywords/new-modifier.md) キーワードを使用します。</span><span class="sxs-lookup"><span data-stu-id="0e635-141">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword.</span></span> <span data-ttu-id="0e635-142">`new` キーワードは、置き換えられるクラス メンバーの戻り値の型の前に配置します。</span><span class="sxs-lookup"><span data-stu-id="0e635-142">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="0e635-143">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-143">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#18)]  
  
 <span data-ttu-id="0e635-144">基底クラスのメンバーが隠ぺいされても、派生クラスのインスタンスを基底クラスのインスタンスにキャストすることで、クライアント コードから基底クラスのメンバーにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0e635-144">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="0e635-145">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-145">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#19)]  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="0e635-146">派生クラスが仮想メンバーをオーバーライドしないようにする</span><span class="sxs-lookup"><span data-stu-id="0e635-146">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="0e635-147">仮想メンバーは、それを最初に宣言したクラスとの間でどれほど多くのクラスが宣言されても、いつまでも仮想のままです。</span><span class="sxs-lookup"><span data-stu-id="0e635-147">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="0e635-148">たとえば、クラス A が仮想メンバーを宣言し、クラス B がクラス A から派生し、クラス C がクラス B から派生した場合、クラス C は仮想メンバーを継承し、クラス B がその仮想メンバーのオーバーライドを宣言したかどうかに関係なく、そのメンバーをオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="0e635-148">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="0e635-149">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-149">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#22)]  
  
 <span data-ttu-id="0e635-150">派生クラスでは、オーバーライドを [sealed](../../language-reference/keywords/sealed.md) として宣言することで仮想継承を中止できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-150">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="0e635-151">この場合、クラス メンバーの宣言で、`sealed` キーワードの前に `override` キーワードを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0e635-151">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="0e635-152">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-152">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#24](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#24)]  
  
 <span data-ttu-id="0e635-153">上の例では、`DoWork` メソッドは C から派生したどのクラスに対しても仮想メソッドではありません。C のインスタンスに対しては、B 型や A 型にキャストされた場合でも、依然として仮想メソッドです。シール メソッドは、次のコード例に示すように、`new` キーワードを使用して派生クラスに置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="0e635-153">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#25)]  
  
 <span data-ttu-id="0e635-154">このコード例では、`DoWork` が、D 型の変数を使用して D で呼び出されると、新しい `DoWork` が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="0e635-154">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="0e635-155">また、C 型、B 型、または A 型の変数を使用して D のインスタンスにアクセスした場合、`DoWork` への呼び出しは、仮想継承の規則に従って、クラス C の `DoWork` の実装に転送されます。</span><span class="sxs-lookup"><span data-stu-id="0e635-155">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="0e635-156">派生クラスからの基底クラスの仮想メンバーへのアクセス</span><span class="sxs-lookup"><span data-stu-id="0e635-156">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="0e635-157">メソッドやプロパティを置き換えたり、オーバーライドしたりした派生クラスでは、`base` キーワードを使用して、基底クラスのメソッドやプロパティに引き続きアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="0e635-157">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="0e635-158">次にコード例を示します。</span><span class="sxs-lookup"><span data-stu-id="0e635-158">The following code provides an example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#26](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#26)]  
  
 <span data-ttu-id="0e635-159">詳細については、「[base](../../language-reference/keywords/base.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="0e635-159">For more information, see [base](../../language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="0e635-160">仮想メンバーの場合、その固有の実装で `base` を使用して、その仮想メンバーの基底クラス実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="0e635-160">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="0e635-161">基底クラスの動作を実行できるようにすることで、派生クラスは、派生クラスに固有の動作を実装することに集中できます。</span><span class="sxs-lookup"><span data-stu-id="0e635-161">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="0e635-162">基底クラス実装を呼び出さない場合は、基底クラスの動作と互換性のある動作を派生クラスで実現する必要があります。</span><span class="sxs-lookup"><span data-stu-id="0e635-162">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="0e635-163">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="0e635-163">In This Section</span></span>  
  
- [<span data-ttu-id="0e635-164">Override キーワードと New キーワードによるバージョン管理</span><span class="sxs-lookup"><span data-stu-id="0e635-164">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)  
  
- [<span data-ttu-id="0e635-165">Override キーワードと New キーワードを使用する場合について</span><span class="sxs-lookup"><span data-stu-id="0e635-165">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)  
  
- [<span data-ttu-id="0e635-166">ToString メソッドをオーバーライドする方法</span><span class="sxs-lookup"><span data-stu-id="0e635-166">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)
  
## <a name="see-also"></a><span data-ttu-id="0e635-167">関連項目</span><span class="sxs-lookup"><span data-stu-id="0e635-167">See also</span></span>

- [<span data-ttu-id="0e635-168">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="0e635-168">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="0e635-169">継承</span><span class="sxs-lookup"><span data-stu-id="0e635-169">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="0e635-170">抽象クラスとシール クラス、およびクラス メンバー</span><span class="sxs-lookup"><span data-stu-id="0e635-170">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="0e635-171">メソッド</span><span class="sxs-lookup"><span data-stu-id="0e635-171">Methods</span></span>](./methods.md)
- [<span data-ttu-id="0e635-172">イベント</span><span class="sxs-lookup"><span data-stu-id="0e635-172">Events</span></span>](../events/index.md)
- [<span data-ttu-id="0e635-173">プロパティ</span><span class="sxs-lookup"><span data-stu-id="0e635-173">Properties</span></span>](./properties.md)
- [<span data-ttu-id="0e635-174">インデクサー</span><span class="sxs-lookup"><span data-stu-id="0e635-174">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="0e635-175">型</span><span class="sxs-lookup"><span data-stu-id="0e635-175">Types</span></span>](../types/index.md)
