---
title: 拡張メソッド - C# プログラミング ガイド
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 5cce8eb3ad36208c3d376bc8c94da484e9f9181e
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/12/2019
ms.locfileid: "73971053"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="9b76b-102">拡張メソッド (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="9b76b-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="9b76b-103">拡張メソッドを使用すると、新規の派生型の作成、再コンパイル、または元の型の変更を行うことなく既存の型にメソッドを "追加" できます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="9b76b-104">拡張メソッドは特別な種類の静的メソッドですが、拡張された型のインスタンス メソッドのように呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="9b76b-105">C#、F#、および Visual Basic で作成されたクライアント コードの場合は、拡張メソッドの呼び出しと、型で実際に定義されたメソッドの呼び出しに明確な違いはありません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="9b76b-106">最も一般的な拡張メソッドは、既存の [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 型および <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 型にクエリ機能を追加する <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 標準クエリ演算子です。</span><span class="sxs-lookup"><span data-stu-id="9b76b-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="9b76b-107">この標準クエリ演算子を使用するには、まず `using System.Linq` ディレクティブを使用して、スコープに含めます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="9b76b-108"><xref:System.Collections.Generic.IEnumerable%601> を実装するすべての型は、<xref:System.Linq.Enumerable.GroupBy%2A>、<xref:System.Linq.Enumerable.OrderBy%2A>、<xref:System.Linq.Enumerable.Average%2A> などのインスタンス メソッドを持っていると考えられます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="9b76b-109"><xref:System.Collections.Generic.List%601>、<xref:System.Array> などの <xref:System.Collections.Generic.IEnumerable%601> 型のインスタンスの後に "ドット" を入力すると、IntelliSense により、ステートメントの入力候補としてこれらの追加メソッドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="9b76b-110">整数の配列において、標準クエリ演算子の `OrderBy` メソッドを呼び出す方法を次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="9b76b-111">かっこ内の式はラムダ式です。</span><span class="sxs-lookup"><span data-stu-id="9b76b-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="9b76b-112">標準クエリ演算子の多くはパラメーターとしてラムダ式を受け取りますが、拡張メソッドでは、これは必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="9b76b-113">詳細については、「[ラムダ式](../statements-expressions-operators/lambda-expressions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-113">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]  
  
 <span data-ttu-id="9b76b-114">拡張メソッドは、静的メソッドとして定義しますが、インスタンス メソッドの構文を使用して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-114">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="9b76b-115">最初のパラメーターでは、メソッドが操作する型を指定します。このパラメーターの前には [this](../../language-reference/keywords/this.md) 修飾子を付加します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-115">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="9b76b-116">`using` ディレクティブを使用して名前空間をソース コードに明示的にインポートした場合、拡張メソッドはそのスコープでのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="9b76b-116">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="9b76b-117"><xref:System.String?displayProperty=nameWithType> クラスに対して拡張メソッドを定義する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-117">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9b76b-118">入れ子になっていない、非ジェネリックの静的クラス内で定義されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-118">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]  
  
 <span data-ttu-id="9b76b-119">この `WordCount` ディレクティブを使用することで、`using` 拡張メソッドをスコープに取り込むことができます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-119">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```csharp  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="9b76b-120">また、この構文を使用することで、アプリケーションから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-120">And it can be called from an application by using this syntax:</span></span>  
  
```csharp  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="9b76b-121">コードでは、インスタンス メソッドの構文を使用して拡張メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-121">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="9b76b-122">ただし、コンパイラが生成する中間言語 (IL: Intermediate Language) により、コードは静的メソッドに対する呼び出しに変換されます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-122">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="9b76b-123">したがって、カプセル化の原則には実質的に違反していません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-123">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="9b76b-124">実際に、拡張メソッドは、それらが拡張している型のプライベート変数にはアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-124">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="9b76b-125">詳細については、「[カスタム拡張メソッドを実装して呼び出す方法](./how-to-implement-and-call-a-custom-extension-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-125">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>
  
 <span data-ttu-id="9b76b-126">一般的には、独自の拡張メソッドを実装するよりも、拡張メソッドを呼び出すことの方がはるかに多くなります。</span><span class="sxs-lookup"><span data-stu-id="9b76b-126">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="9b76b-127">拡張メソッドは、インスタンス メソッドの構文を使用して呼び出すので、特別な知識がなくてもクライアント コードからそれらを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-127">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="9b76b-128">メソッドが定義されている名前空間に関する `using` ディレクティブを追加するだけで、特定の型の拡張メソッドを使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9b76b-128">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="9b76b-129">たとえば、標準クエリ演算子を使用するには、次の `using` ディレクティブをコードに追加します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-129">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```csharp  
using System.Linq;  
```  
  
 <span data-ttu-id="9b76b-130">場合によっては、System.Core.dll への参照も追加する必要があります。ほとんどの <xref:System.Collections.Generic.IEnumerable%601> 型で利用できる追加メソッドとして、標準クエリ演算子が IntelliSense により表示されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="9b76b-130">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="9b76b-131">コンパイル時の拡張メソッドのバインディング</span><span class="sxs-lookup"><span data-stu-id="9b76b-131">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="9b76b-132">拡張メソッドを使用してクラスまたはインターフェイスを拡張することはできますが、これらをオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-132">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="9b76b-133">インターフェイス メソッドまたはクラス メソッドと同じ名前およびシグネチャを持つ拡張メソッドは決して呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-133">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="9b76b-134">コンパイル時に、型自体で定義されているインスタンス メソッドよりも低い優先順位が拡張メソッドには必ず設定されます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-134">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="9b76b-135">つまり、型に `Process(int i)` という名前のメソッドがあり、これと同じシグネチャの拡張メソッドがある場合、コンパイラは必ずインスタンス メソッドにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9b76b-135">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="9b76b-136">コンパイラは、メソッド呼び出しを検出すると、最初に型のインスタンス メソッドから一致するものを探します。</span><span class="sxs-lookup"><span data-stu-id="9b76b-136">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="9b76b-137">一致するものが見つからない場合、型に対して定義されている拡張メソッドを検索し、見つかった最初の拡張メソッドにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9b76b-137">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="9b76b-138">次の例は、コンパイラが拡張メソッドとインスタンス メソッドのどちらにバインドするかを決定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9b76b-138">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="9b76b-139">例</span><span class="sxs-lookup"><span data-stu-id="9b76b-139">Example</span></span>  
 <span data-ttu-id="9b76b-140">次の例は、C# のコンパイラがメソッド呼び出しを型のインスタンス メソッドにバインドするか、拡張メソッドにバインドするかを決定するときに従う規則を示しています。</span><span class="sxs-lookup"><span data-stu-id="9b76b-140">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="9b76b-141">`Extensions` 静的クラスには、`IMyInterface` を実装する型に対して定義された拡張メソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9b76b-141">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="9b76b-142">`A`、`B`、および `C` の各クラスはすべてこのインターフェイスを実装しています。</span><span class="sxs-lookup"><span data-stu-id="9b76b-142">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="9b76b-143">`MethodB` 拡張メソッドは、その名前とシグネチャがクラスにより既に実装されているメソッドと完全に一致しているため、呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-143">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="9b76b-144">コンパイラは、一致するシグネチャを持つインスタンス メソッドを検出できない場合、一致する拡張メソッド (存在する場合) にバインドします。</span><span class="sxs-lookup"><span data-stu-id="9b76b-144">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]  
  
## <a name="general-guidelines"></a><span data-ttu-id="9b76b-145">一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="9b76b-145">General Guidelines</span></span>  
 <span data-ttu-id="9b76b-146">拡張メソッドは、一般的に、必要な場合に限り注意して実装することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9b76b-146">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="9b76b-147">クライアント コードで既存の型を拡張する必要がある場合、可能であれば既存の型から派生した新しい型を作成することで行ってください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-147">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="9b76b-148">詳細については、「[継承](./inheritance.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-148">For more information, see [Inheritance](./inheritance.md).</span></span>  
  
 <span data-ttu-id="9b76b-149">拡張メソッドを使用して、変更できないソース コードのある型を拡張する場合、型の実装の変更により拡張メソッドが破損するというリスクを負うことになります。</span><span class="sxs-lookup"><span data-stu-id="9b76b-149">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="9b76b-150">所定の型の拡張メソッドを実装する場合、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-150">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
- <span data-ttu-id="9b76b-151">拡張メソッドが型で定義されているメソッドと同じシグネチャを持つ場合、その拡張メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="9b76b-151">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
- <span data-ttu-id="9b76b-152">拡張メソッドは名前空間レベルでスコープ内に取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-152">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="9b76b-153">たとえば、`Extensions` という名前の単一の名前空間に、拡張メソッドを含む複数の静的クラスがある場合、`using Extensions;` ディレクティブによって、それらのすべての拡張メソッドがスコープ内に取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="9b76b-153">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="9b76b-154">実装したクラス ライブラリでは、アセンブリのバージョン番号のインクリメントを避けるために、拡張メソッドは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-154">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="9b76b-155">ソース コードを所有するライブラリに重要な機能を追加する場合は、アセンブリのバージョン管理について標準の .NET Framework ガイドラインに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="9b76b-155">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="9b76b-156">詳細については、「[アセンブリのバージョン管理](../../../standard/assembly/versioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9b76b-156">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9b76b-157">関連項目</span><span class="sxs-lookup"><span data-stu-id="9b76b-157">See also</span></span>

- [<span data-ttu-id="9b76b-158">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="9b76b-158">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="9b76b-159">並列プログラミングのサンプル (拡張メソッドの例が多数掲載されています)</span><span class="sxs-lookup"><span data-stu-id="9b76b-159">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="9b76b-160">ラムダ式</span><span class="sxs-lookup"><span data-stu-id="9b76b-160">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="9b76b-161">標準クエリ演算子の概要</span><span class="sxs-lookup"><span data-stu-id="9b76b-161">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="9b76b-162">インスタンス パラメーターの変換規則とその影響</span><span class="sxs-lookup"><span data-stu-id="9b76b-162">Conversion rules for Instance parameters and their impact</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="9b76b-163">拡張メソッドの言語間での相互運用性</span><span class="sxs-lookup"><span data-stu-id="9b76b-163">Extension methods Interoperability between languages</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="9b76b-164">拡張メソッドとカリー化デリゲート</span><span class="sxs-lookup"><span data-stu-id="9b76b-164">Extension methods and Curried Delegates</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)
- [<span data-ttu-id="9b76b-165">バインディングとエラー報告に関する拡張メソッド</span><span class="sxs-lookup"><span data-stu-id="9b76b-165">Extension method Binding and Error reporting</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)
