---
title: 拡張メソッド - C# プログラミング ガイド
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0f9c0f053e531a44640084a35dc5d8e844ee0b46
ms.sourcegitcommit: 1eae045421d9ea2bfc82aaccfa5b1ff1b8c9e0e4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/16/2020
ms.locfileid: "84803182"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="9a161-102">拡張メソッド (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="9a161-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="9a161-103">拡張メソッドを使用すると、新規の派生型の作成、再コンパイル、または元の型の変更を行うことなく既存の型にメソッドを "追加" できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="9a161-104">拡張メソッドは静的メソッドですが、拡張された型のインスタンス メソッドのように呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a161-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="9a161-105">C#、F#、Visual Basic で作成されたクライアント コードの場合は、拡張メソッドの呼び出しと、型で定義されているメソッドの呼び出しに明確な違いはありません。</span><span class="sxs-lookup"><span data-stu-id="9a161-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="9a161-106">最も一般的な拡張メソッドは、既存の <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 型および <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 型にクエリ機能を追加する LINQ 標準クエリ演算子です。</span><span class="sxs-lookup"><span data-stu-id="9a161-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="9a161-107">この標準クエリ演算子を使用するには、まず `using System.Linq` ディレクティブを使用して、スコープに含めます。</span><span class="sxs-lookup"><span data-stu-id="9a161-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="9a161-108"><xref:System.Collections.Generic.IEnumerable%601> を実装するすべての型は、<xref:System.Linq.Enumerable.GroupBy%2A>、<xref:System.Linq.Enumerable.OrderBy%2A>、<xref:System.Linq.Enumerable.Average%2A> などのインスタンス メソッドを持っていると考えられます。</span><span class="sxs-lookup"><span data-stu-id="9a161-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="9a161-109"><xref:System.Collections.Generic.List%601>、<xref:System.Array> などの <xref:System.Collections.Generic.IEnumerable%601> 型のインスタンスの後に "ドット" を入力すると、IntelliSense により、ステートメントの入力候補としてこれらの追加メソッドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9a161-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="9a161-110">OrderBy の例</span><span class="sxs-lookup"><span data-stu-id="9a161-110">OrderBy Example</span></span>

<span data-ttu-id="9a161-111">整数の配列において、標準クエリ演算子の `OrderBy` メソッドを呼び出す方法を次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="9a161-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="9a161-112">かっこ内の式はラムダ式です。</span><span class="sxs-lookup"><span data-stu-id="9a161-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="9a161-113">標準クエリ演算子の多くはパラメーターとしてラムダ式を受け取りますが、拡張メソッドでは、これは必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="9a161-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="9a161-114">詳細については、「[ラムダ式](../statements-expressions-operators/lambda-expressions.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a161-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="9a161-115">拡張メソッドは、静的メソッドとして定義しますが、インスタンス メソッドの構文を使用して呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a161-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="9a161-116">最初のパラメーターでは、メソッドによって操作される型を指定します。</span><span class="sxs-lookup"><span data-stu-id="9a161-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="9a161-117">このパラメーターの前には [this](../../language-reference/keywords/this.md) 修飾子を付けます。</span><span class="sxs-lookup"><span data-stu-id="9a161-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="9a161-118">`using` ディレクティブを使用して名前空間をソース コードに明示的にインポートした場合、拡張メソッドはそのスコープでのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="9a161-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="9a161-119"><xref:System.String?displayProperty=nameWithType> クラスに対して拡張メソッドを定義する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9a161-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9a161-120">入れ子になっていない、非ジェネリックの静的クラス内で定義されています。</span><span class="sxs-lookup"><span data-stu-id="9a161-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="9a161-121">この `WordCount` ディレクティブを使用することで、`using` 拡張メソッドをスコープに取り込むことができます。</span><span class="sxs-lookup"><span data-stu-id="9a161-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="9a161-122">また、この構文を使用することで、アプリケーションから呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9a161-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="9a161-123">コードでは、インスタンス メソッドの構文を使用して、拡張メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a161-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="9a161-124">コンパイラによって生成される中間言語 (IL) により、コードは静的メソッドの呼び出しに変換されます。</span><span class="sxs-lookup"><span data-stu-id="9a161-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="9a161-125">カプセル化の原則には実質的に違反していません。</span><span class="sxs-lookup"><span data-stu-id="9a161-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="9a161-126">拡張メソッドでは、それが拡張している型のプライベート変数にはアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="9a161-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="9a161-127">詳細については、「[カスタム拡張メソッドを実装して呼び出す方法](./how-to-implement-and-call-a-custom-extension-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a161-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="9a161-128">一般に、独自に実装するより、拡張メソッドを呼び出す方がはるかに多くなると思われます。</span><span class="sxs-lookup"><span data-stu-id="9a161-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="9a161-129">拡張メソッドは、インスタンス メソッドの構文を使用して呼び出すので、特別な知識がなくてもクライアント コードからそれらを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="9a161-130">メソッドが定義されている名前空間に関する `using` ディレクティブを追加するだけで、特定の型の拡張メソッドを使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9a161-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="9a161-131">たとえば、標準クエリ演算子を使用するには、次の `using` ディレクティブをコードに追加します。</span><span class="sxs-lookup"><span data-stu-id="9a161-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="9a161-132">場合によっては、System.Core.dll への参照も追加する必要があります。ほとんどの <xref:System.Collections.Generic.IEnumerable%601> 型で利用できる追加メソッドとして、標準クエリ演算子が IntelliSense に表示されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="9a161-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="9a161-133">コンパイル時の拡張メソッドのバインディング</span><span class="sxs-lookup"><span data-stu-id="9a161-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="9a161-134">拡張メソッドを使用してクラスまたはインターフェイスを拡張することはできますが、これらをオーバーライドすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9a161-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="9a161-135">インターフェイス メソッドまたはクラス メソッドと同じ名前およびシグネチャを持つ拡張メソッドは決して呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="9a161-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="9a161-136">コンパイル時に、型自体で定義されているインスタンス メソッドよりも低い優先順位が拡張メソッドには必ず設定されます。</span><span class="sxs-lookup"><span data-stu-id="9a161-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="9a161-137">つまり、型に `Process(int i)` という名前のメソッドがあり、これと同じシグネチャの拡張メソッドがある場合、コンパイラは必ずインスタンス メソッドにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9a161-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="9a161-138">コンパイラは、メソッド呼び出しを検出すると、最初に型のインスタンス メソッドから一致するものを探します。</span><span class="sxs-lookup"><span data-stu-id="9a161-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="9a161-139">一致するものが見つからない場合、型に対して定義されている拡張メソッドを検索し、見つかった最初の拡張メソッドにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9a161-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="9a161-140">次の例は、コンパイラが拡張メソッドとインスタンス メソッドのどちらにバインドするかを決定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a161-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="9a161-141">例</span><span class="sxs-lookup"><span data-stu-id="9a161-141">Example</span></span>

<span data-ttu-id="9a161-142">次の例は、C# のコンパイラがメソッド呼び出しを型のインスタンス メソッドにバインドするか、拡張メソッドにバインドするかを決定するときに従う規則を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a161-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="9a161-143">`Extensions` 静的クラスには、`IMyInterface` を実装する型に対して定義された拡張メソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a161-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="9a161-144">`A`、`B`、および `C` の各クラスはすべてこのインターフェイスを実装しています。</span><span class="sxs-lookup"><span data-stu-id="9a161-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="9a161-145">`MethodB` 拡張メソッドは、その名前とシグネチャがクラスにより既に実装されているメソッドと完全に一致しているため、呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="9a161-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="9a161-146">コンパイラは、一致するシグネチャを持つインスタンス メソッドを検出できない場合、一致する拡張メソッドが存在する場合はそれにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9a161-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="9a161-147">一般的な使用パターン</span><span class="sxs-lookup"><span data-stu-id="9a161-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="9a161-148">コレクションの機能</span><span class="sxs-lookup"><span data-stu-id="9a161-148">Collection Functionality</span></span>

<span data-ttu-id="9a161-149">これまでは、特定の型の <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> インターフェイスが実装され、その型のコレクションに対して動作する機能が含まれている、"コレクション クラス" を作成するのが一般的でした。</span><span class="sxs-lookup"><span data-stu-id="9a161-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="9a161-150">この種類のコレクション オブジェクトを作成しても問題はありませんが、<xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> の拡張機能を使用して同じ機能を実現できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9a161-151">拡張機能には、その型の <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> が実装されている <xref:System.Array?displayProperty=nameWithType> や <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> などの任意のコレクションから機能を呼び出すことができるという利点があります。</span><span class="sxs-lookup"><span data-stu-id="9a161-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="9a161-152">Int32 の配列のこの使用例については、[この記事で既に](#orderby-example)示されています。</span><span class="sxs-lookup"><span data-stu-id="9a161-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="9a161-153">レイヤー固有の機能</span><span class="sxs-lookup"><span data-stu-id="9a161-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="9a161-154">オニオン アーキテクチャまたは他のレイヤー化アプリケーション設計を使用する場合は、アプリケーションの境界を越えて通信するために使用できるドメイン エンティティまたはデータ転送オブジェクトのセットを使用するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="9a161-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="9a161-155">これらのオブジェクトには、通常、機能が含まれていないか、またはアプリケーションのすべてのレイヤーに適用される最小限の機能のみが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a161-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="9a161-156">他のレイヤーで必要のないメソッドや望ましくないメソッドを使用してオブジェクトを読み込むことなしに、拡張メソッドを使用して、各アプリケーション レイヤーに固有の機能を追加することができます。</span><span class="sxs-lookup"><span data-stu-id="9a161-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="9a161-157">定義済みの型の拡張</span><span class="sxs-lookup"><span data-stu-id="9a161-157">Extending Predefined Types</span></span>

<span data-ttu-id="9a161-158">再利用可能な機能を作成する必要があるときに、新しいオブジェクトを作成するのではなく、多くの場合、.NET や CLR 型などの既存の型を拡張できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="9a161-159">たとえば、拡張メソッドを使用しない場合は、コード内の複数の場所から呼び出すことができる `Engine` または `Query` クラスを作成して、SQL サーバーに対するクエリの実行を処理することが考えられます。</span><span class="sxs-lookup"><span data-stu-id="9a161-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="9a161-160">一方、代わりに拡張メソッドを使用して <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> クラスを拡張すると、SQL サーバーに接続している任意の場所からそのクエリを実行することができます。</span><span class="sxs-lookup"><span data-stu-id="9a161-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="9a161-161">他の例としては、<xref:System.String?displayProperty=nameWithType> クラスへの共通機能の追加、<xref:System.IO.File?displayProperty=nameWithType> および <xref:System.IO.Stream?displayProperty=nameWithType> オブジェクトのデータ処理機能の拡張、特定のエラー処理機能のための <xref:System.Exception?displayProperty=nameWithType> オブジェクトなどがあります。</span><span class="sxs-lookup"><span data-stu-id="9a161-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="9a161-162">この種のユース ケースは、開発者の想像力と良識によってのみ制限されます。</span><span class="sxs-lookup"><span data-stu-id="9a161-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="9a161-163">`struct` 型は、メソッドに値で渡されるため、定義済みの型を拡張するのが難かしい場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a161-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="9a161-164">これは、構造体への変更が構造体のコピーに対して行われることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9a161-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="9a161-165">そのような変更は、拡張メソッドが終了した後では認識できません。</span><span class="sxs-lookup"><span data-stu-id="9a161-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="9a161-166">C# 7.2 以降では、拡張メソッドの最初の引数に `ref` 修飾子を追加できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="9a161-167">`ref` 修飾子を追加すると、最初の引数が参照によって渡されます。</span><span class="sxs-lookup"><span data-stu-id="9a161-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="9a161-168">これにより、拡張されている構造体の状態を変更する拡張メソッドを記述できます。</span><span class="sxs-lookup"><span data-stu-id="9a161-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="9a161-169">一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="9a161-169">General Guidelines</span></span>

<span data-ttu-id="9a161-170">オブジェクトのコードを変更したり新しい型を派生させたりすることによって機能を追加することが妥当かつ可能である場合は、そのようにすることがやはり推奨されますが、.NET エコシステムの全体で、拡張メソッドが再利用可能な機能を作成するための重要なオプションになってきています。</span><span class="sxs-lookup"><span data-stu-id="9a161-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="9a161-171">元のソースを制御できない場合、派生オブジェクトが不適切または不可能な場合、または該当するスコープを超えて機能を公開してはならない場合は、拡張メソッドが優れた選択肢になります。</span><span class="sxs-lookup"><span data-stu-id="9a161-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="9a161-172">派生型について詳しくは、「[継承](./inheritance.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="9a161-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="9a161-173">ソース コードを制御できない型を、拡張メソッドを使用して拡張すると、型の実装の変更により拡張メソッドが破損するというリスクを負うことになります。</span><span class="sxs-lookup"><span data-stu-id="9a161-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="9a161-174">所定の型の拡張メソッドを実装する場合、次の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="9a161-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="9a161-175">拡張メソッドが型で定義されているメソッドと同じシグネチャを持つ場合、その拡張メソッドは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="9a161-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="9a161-176">拡張メソッドは名前空間レベルでスコープ内に取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="9a161-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="9a161-177">たとえば、`Extensions` という名前の単一の名前空間に、拡張メソッドを含む複数の静的クラスがある場合、`using Extensions;` ディレクティブによって、それらのすべての拡張メソッドがスコープ内に取り込まれます。</span><span class="sxs-lookup"><span data-stu-id="9a161-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="9a161-178">実装したクラス ライブラリでは、アセンブリのバージョン番号のインクリメントを避けるために、拡張メソッドは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="9a161-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="9a161-179">ソース コードを所有するライブラリに重要な機能を追加する場合は、アセンブリのバージョン管理について、.NET ガイドラインに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a161-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="9a161-180">詳細については、「[アセンブリのバージョン管理](../../../standard/assembly/versioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a161-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="9a161-181">関連項目</span><span class="sxs-lookup"><span data-stu-id="9a161-181">See also</span></span>

- [<span data-ttu-id="9a161-182">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="9a161-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="9a161-183">並列プログラミングのサンプル (拡張メソッドの例が多数掲載されています)</span><span class="sxs-lookup"><span data-stu-id="9a161-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="9a161-184">ラムダ式</span><span class="sxs-lookup"><span data-stu-id="9a161-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="9a161-185">標準クエリ演算子の概要</span><span class="sxs-lookup"><span data-stu-id="9a161-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="9a161-186">インスタンス パラメーターの変換規則とその影響</span><span class="sxs-lookup"><span data-stu-id="9a161-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="9a161-187">拡張メソッドの言語間での相互運用性</span><span class="sxs-lookup"><span data-stu-id="9a161-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="9a161-188">拡張メソッドとカリー化デリゲート</span><span class="sxs-lookup"><span data-stu-id="9a161-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="9a161-189">バインディングとエラー報告に関する拡張メソッド</span><span class="sxs-lookup"><span data-stu-id="9a161-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
