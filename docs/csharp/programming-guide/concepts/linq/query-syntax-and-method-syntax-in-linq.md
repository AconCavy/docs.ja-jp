---
title: LINQ でのクエリ構文とメソッド構文 (C#)
ms.date: 07/20/2015
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
ms.openlocfilehash: 17280daaf98010245bbd019652a2a46d7f66ab59
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "75635497"
---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a><span data-ttu-id="fdd0c-102">LINQ でのクエリ構文とメソッド構文 (C#)</span><span class="sxs-lookup"><span data-stu-id="fdd0c-102">Query Syntax and Method Syntax in LINQ (C#)</span></span>
<span data-ttu-id="fdd0c-103">統合言語クエリ (LINQ) の入門的なドキュメントでは、ほとんどのクエリが、LINQ の宣言型クエリ構文を使用して記述されています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-103">Most queries in the introductory Language Integrated Query (LINQ) documentation are written by using the LINQ declarative query syntax.</span></span> <span data-ttu-id="fdd0c-104">ただし、クエリ構文は、コードのコンパイル時に、.NET 共通言語ランタイム (CLR) 用のメソッド呼び出しに変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-104">However, the query syntax must be translated into method calls for the .NET common language runtime (CLR) when the code is compiled.</span></span> <span data-ttu-id="fdd0c-105">これらのメソッド呼び出しが、標準クエリ演算子 (`Where`、`Select`、`GroupBy`、`Join`、`Max`、`Average` など) を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-105">These method calls invoke the standard query operators, which have names such as `Where`, `Select`, `GroupBy`, `Join`, `Max`, and `Average`.</span></span> <span data-ttu-id="fdd0c-106">これらは、クエリ構文ではなくメソッド構文を使用して直接呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-106">You can call them directly by using method syntax instead of query syntax.</span></span>  
  
 <span data-ttu-id="fdd0c-107">クエリ構文とメソッド構文は意味的には同じものですが、多くの人は、クエリ構文のほうがシンプルで読みやすいと感じます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-107">Query syntax and method syntax are semantically identical, but many people find query syntax simpler and easier to read.</span></span> <span data-ttu-id="fdd0c-108">一部のクエリは、メソッド呼び出しとして表現する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-108">Some queries must be expressed as method calls.</span></span> <span data-ttu-id="fdd0c-109">たとえば、指定した条件に一致する要素の数を取得するクエリを表すには、メソッド呼び出しを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-109">For example, you must use a method call to express a query that retrieves the number of elements that match a specified condition.</span></span> <span data-ttu-id="fdd0c-110">また、ソース シーケンスで最大の値を持つ要素を取得するクエリにも、メソッド呼び出しを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-110">You also must use a method call for a query that retrieves the element that has the maximum value in a source sequence.</span></span> <span data-ttu-id="fdd0c-111"><xref:System.Linq> 名前空間の標準クエリ演算子のリファレンス ドキュメントでは、通常、メソッド構文が使用されます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-111">The reference documentation for the standard query operators in the <xref:System.Linq> namespace generally uses method syntax.</span></span> <span data-ttu-id="fdd0c-112">そのため、LINQ クエリの記述をこれから学習する初心者にとっても、クエリやクエリ式自体の中でメソッド構文をどのように使用すればよいか理解しておくことは有用です。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-112">Therefore, even when getting started writing LINQ queries, it is useful to be familiar with how to use method syntax in queries and in query expressions themselves.</span></span>  
  
## <a name="standard-query-operator-extension-methods"></a><span data-ttu-id="fdd0c-113">標準クエリ演算子の拡張メソッド</span><span class="sxs-lookup"><span data-stu-id="fdd0c-113">Standard Query Operator Extension Methods</span></span>  
 <span data-ttu-id="fdd0c-114">次の例は、シンプルな*クエリ式*と、*メソッド ベースのクエリ*として記述された、意味的に同等のクエリを示したものです。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-114">The following example shows a simple *query expression* and the semantically equivalent query written as a *method-based query*.</span></span>  
  
 [!code-csharp[csLINQGettingStarted#22](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQGettingStarted/CS/Class1.cs#22)]  
  
 <span data-ttu-id="fdd0c-115">2 つの例からの出力は同じです。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-115">The output from the two examples is identical.</span></span> <span data-ttu-id="fdd0c-116">クエリ変数の型は、どちらの形式でも同じです: <xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-116">You can see that the type of the query variable is the same in both forms: <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="fdd0c-117">メソッド ベースのクエリを理解するために、より詳しく調べていきましょう。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-117">To understand the method-based query, let's examine it more closely.</span></span> <span data-ttu-id="fdd0c-118">式の右側を見ると、`where` 句が `numbers` オブジェクトのインスタンス メソッドとして表されていることがわかります。これは、既におわかりのように、`IEnumerable<int>` の型を持っています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-118">On the right side of the expression, notice that the `where` clause is now expressed as an instance method on the `numbers` object, which as you will recall has a type of `IEnumerable<int>`.</span></span> <span data-ttu-id="fdd0c-119">ジェネリック型の <xref:System.Collections.Generic.IEnumerable%601> インターフェイスについて知識があれば、これが `Where` メソッドではないことがわかるでしょう。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-119">If you are familiar with the generic <xref:System.Collections.Generic.IEnumerable%601> interface, you know that it does not have a `Where` method.</span></span> <span data-ttu-id="fdd0c-120">しかし、Visual Studio IDE で IntelliSense の入力補完リストを呼び出すと、`Where` メソッドだけでなく、`Select`、`SelectMany`、`Join`、`Orderby` など、他にも多くのメソッドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-120">However, if you invoke the IntelliSense completion list in the Visual Studio IDE, you will see not only a `Where` method, but many other methods such as `Select`, `SelectMany`, `Join`, and `Orderby`.</span></span> <span data-ttu-id="fdd0c-121">これらはすべて、標準クエリ演算子です。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-121">These are all the standard query operators.</span></span>  
  
 ![Intellisense の標準クエリ演算子をすべて示すスクリーンショット。](./media/query-syntax-and-method-syntax-in-linq/standard-query-operators.png)  
  
 <span data-ttu-id="fdd0c-123">一見、<xref:System.Collections.Generic.IEnumerable%601> が再定義され、これらのメソッドが追加されたかのように見えますが、実際にはそうではありません。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-123">Although it looks as if <xref:System.Collections.Generic.IEnumerable%601> has been redefined to include these additional methods, in fact this is not the case.</span></span> <span data-ttu-id="fdd0c-124">標準クエリ演算子は、*拡張メソッド*という新しい種類のメソッドとして実装されています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-124">The standard query operators are implemented as a new kind of method called *extension methods*.</span></span> <span data-ttu-id="fdd0c-125">拡張メソッドは、既存の型を "拡張" します。これらは、あたかもその型のインスタンス メソッドであるかのように呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-125">Extensions methods "extend" an existing type; they can be called as if they were instance methods on the type.</span></span> <span data-ttu-id="fdd0c-126">標準クエリ演算子が <xref:System.Collections.Generic.IEnumerable%601> を拡張しているため、`numbers.Where(...)` を書き込むことができます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-126">The standard query operators extend <xref:System.Collections.Generic.IEnumerable%601> and that is why you can write `numbers.Where(...)`.</span></span>  
  
 <span data-ttu-id="fdd0c-127">LINQ の初心者が拡張メソッドについて知っておくべき最も重要なことは、適切な `using` ディレクティブを使用して、アプリケーションのスコープ内にそれらを取り込む方法です。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-127">To get started using LINQ, all that you really have to know about extension methods is how to bring them into scope in your application by using the correct `using` directives.</span></span> <span data-ttu-id="fdd0c-128">アプリケーションの観点から見れば、拡張メソッドは通常のインスタンス メソッドと同じものです。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-128">From your application's point of view, an extension method and a regular instance method are the same.</span></span>  
  
 <span data-ttu-id="fdd0c-129">拡張メソッドについて詳しくは、「[拡張メソッド](../../classes-and-structs/extension-methods.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-129">For more information about extension methods, see [Extension Methods](../../classes-and-structs/extension-methods.md).</span></span> <span data-ttu-id="fdd0c-130">標準クエリ演算子について詳しくは、「[標準クエリ演算子の概要 (C#)](./standard-query-operators-overview.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-130">For more information about standard query operators, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span> <span data-ttu-id="fdd0c-131">一部の LINQ プロバイダー ([!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] や [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] など) では、<xref:System.Collections.Generic.IEnumerable%601> 以外の型に対応するため、独自の標準クエリ演算子と追加の拡張メソッドを実装しています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-131">Some LINQ providers, such as [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] and [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], implement their own standard query operators and additional extension methods for other types besides <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
## <a name="lambda-expressions"></a><span data-ttu-id="fdd0c-132">ラムダ式</span><span class="sxs-lookup"><span data-stu-id="fdd0c-132">Lambda Expressions</span></span>  
 <span data-ttu-id="fdd0c-133">上記の例では、条件式 (`num % 2 == 0`) がインライン引数として `Where` メソッドに渡さています: `Where(num => num % 2 == 0).` このインライン式は、ラムダ式と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-133">In the previous example, notice that the conditional expression (`num % 2 == 0`) is passed as an in-line argument to the `Where` method: `Where(num => num % 2 == 0).` This inline expression is called a lambda expression.</span></span> <span data-ttu-id="fdd0c-134">これを使用すると、本来であれば、匿名メソッド、ジェネリック デリゲート、式ツリーなど、より複雑な形式で記述しなければならないコードを、簡単に記述できます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-134">It is a convenient way to write code that would otherwise have to be written in more cumbersome form as an anonymous method or a generic delegate or an expression tree.</span></span> <span data-ttu-id="fdd0c-135">C# では、`=>` がラムダ演算子で、"goes to" という読み方をします。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-135">In C# `=>` is the lambda operator, which is read as "goes to".</span></span> <span data-ttu-id="fdd0c-136">演算子の左側にある `num` は、クエリ式の `num` に対応する入力変数です。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-136">The `num` on the left of the operator is the input variable which corresponds to `num` in the query expression.</span></span> <span data-ttu-id="fdd0c-137">コンパイラは、`num` がジェネリック `numbers` 型であることがわかっているため、<xref:System.Collections.Generic.IEnumerable%601> の型を推論できます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-137">The compiler can infer the type of `num` because it knows that `numbers` is a generic <xref:System.Collections.Generic.IEnumerable%601> type.</span></span> <span data-ttu-id="fdd0c-138">ラムダの本体は、クエリ構文や、C# のその他の式やステートメントの式と同じです。これには、メソッド呼び出しやその他の複雑なロジックを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-138">The body of the lambda is just the same as the expression in query syntax or in any other C# expression or statement; it can include method calls and other complex logic.</span></span> <span data-ttu-id="fdd0c-139">"戻り値" は、式の結果だけです。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-139">The "return value" is just the expression result.</span></span>  
  
 <span data-ttu-id="fdd0c-140">LINQ の初心者の場合、ラムダを広範に使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-140">To get started using LINQ, you do not have to use lambdas extensively.</span></span> <span data-ttu-id="fdd0c-141">ただし、一部のクエリはメソッド構文でしか表現できず、ラムダ式が必須となるものもあります。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-141">However, certain queries can only be expressed in method syntax and some of those require lambda expressions.</span></span> <span data-ttu-id="fdd0c-142">ラムダに慣れてきたら、これが LINQ のツールボックスで使用できる強力で柔軟なツールであることがおわかりいただけるでしょう。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-142">After you become more familiar with lambdas, you will find that they are a powerful and flexible tool in your LINQ toolbox.</span></span> <span data-ttu-id="fdd0c-143">詳しくは、「[ラムダ式](../../statements-expressions-operators/lambda-expressions.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-143">For more information, see [Lambda Expressions](../../statements-expressions-operators/lambda-expressions.md).</span></span>  
  
## <a name="composability-of-queries"></a><span data-ttu-id="fdd0c-144">クエリの構成可能性</span><span class="sxs-lookup"><span data-stu-id="fdd0c-144">Composability of Queries</span></span>  
 <span data-ttu-id="fdd0c-145">上記の例で、`OrderBy` メソッドは `Where` への呼び出しでドット演算子を使用して起動されています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-145">In the previous code example, note that the `OrderBy` method is invoked by using the dot operator on the call to `Where`.</span></span> <span data-ttu-id="fdd0c-146">`Where` は、フィルター処理されたシーケンスを生成し、その後 `Orderby` は、そのシーケンスをソートして操作しています。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-146">`Where` produces a filtered sequence, and then `Orderby` operates on that sequence by sorting it.</span></span> <span data-ttu-id="fdd0c-147">クエリが `IEnumerable` を返すので、開発者は、メソッド呼び出しをつないでいきながら、メソッド構文でそれらを編成します。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-147">Because queries return an `IEnumerable`, you compose them in method syntax by chaining the method calls together.</span></span> <span data-ttu-id="fdd0c-148">これが、クエリ構文を使ってクエリを記述する際に、コンパイラがバック グラウンドで行っていることなのです。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-148">This is what the compiler does behind the scenes when you write queries by using query syntax.</span></span> <span data-ttu-id="fdd0c-149">また、クエリ変数にはクエリの結果が格納されないので、開発者はそれが実行された後でも、それを随時変更したり、新しいクエリのベースとして使用することができます。</span><span class="sxs-lookup"><span data-stu-id="fdd0c-149">And because a query variable does not store the results of the query, you can modify it or use it as the basis for a new query at any time, even after it has been executed.</span></span>  
