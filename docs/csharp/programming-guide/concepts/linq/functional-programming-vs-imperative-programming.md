---
title: 関数型プログラミングと命令型プログラミング (C#)
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: a163a62912ed2a44d6ea8cad5bc536f03343f15c
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "69594317"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="b65c2-102">関数型プログラミングと命令型プログラミング (C#)</span><span class="sxs-lookup"><span data-stu-id="b65c2-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="b65c2-103">このトピックでは、関数型プログラミングを従来の命令型 (手続き型) プログラミングと比較対照します。</span><span class="sxs-lookup"><span data-stu-id="b65c2-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="b65c2-104">関数型プログラミングと命令型プログラミング</span><span class="sxs-lookup"><span data-stu-id="b65c2-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="b65c2-105">"*関数型プログラミング*" のパラダイムは、問題解決に適用する純粋関数型の方法をサポートするために、わかりやすく作成されています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="b65c2-106">関数型プログラミングは、"*宣言型プログラミング*" の一種です。</span><span class="sxs-lookup"><span data-stu-id="b65c2-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="b65c2-107">一方、C#、Visual Basic、C++、Java などのオブジェクト指向プログラミング (OOP) 言語を含むほとんどの主流言語は、主に "*命令型*" (手続き型) プログラミングをサポートするために作成されています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="b65c2-108">命令型の方法では、開発者はコードを記述して、目的を達成するためにコンピューターが実行するステップを詳細に示します。</span><span class="sxs-lookup"><span data-stu-id="b65c2-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="b65c2-109">これを "*アルゴリズム*" プログラミングと呼ぶこともあります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="b65c2-110">一方、関数型の方法では、実行される一連の関数として問題が組み立てられ、</span><span class="sxs-lookup"><span data-stu-id="b65c2-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="b65c2-111">それぞれの関数に何が入力され、何が返されるのかが、慎重に定義されます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="b65c2-112">この 2 つの方法の一般的な違いを次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="b65c2-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="b65c2-113">特徴</span><span class="sxs-lookup"><span data-stu-id="b65c2-113">Characteristic</span></span>|<span data-ttu-id="b65c2-114">命令型の方法</span><span class="sxs-lookup"><span data-stu-id="b65c2-114">Imperative approach</span></span>|<span data-ttu-id="b65c2-115">関数型の方法</span><span class="sxs-lookup"><span data-stu-id="b65c2-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="b65c2-116">プログラミングの焦点</span><span class="sxs-lookup"><span data-stu-id="b65c2-116">Programmer focus</span></span>|<span data-ttu-id="b65c2-117">タスク (アルゴリズム) の実行方法と状態の変化の追跡方法。</span><span class="sxs-lookup"><span data-stu-id="b65c2-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="b65c2-118">目的となる情報と必要な変換。</span><span class="sxs-lookup"><span data-stu-id="b65c2-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="b65c2-119">状態変更</span><span class="sxs-lookup"><span data-stu-id="b65c2-119">State changes</span></span>|<span data-ttu-id="b65c2-120">重要。</span><span class="sxs-lookup"><span data-stu-id="b65c2-120">Important.</span></span>|<span data-ttu-id="b65c2-121">存在しない。</span><span class="sxs-lookup"><span data-stu-id="b65c2-121">Non-existent.</span></span>|  
|<span data-ttu-id="b65c2-122">実行の順序</span><span class="sxs-lookup"><span data-stu-id="b65c2-122">Order of execution</span></span>|<span data-ttu-id="b65c2-123">重要。</span><span class="sxs-lookup"><span data-stu-id="b65c2-123">Important.</span></span>|<span data-ttu-id="b65c2-124">あまり重要ではない。</span><span class="sxs-lookup"><span data-stu-id="b65c2-124">Low importance.</span></span>|  
|<span data-ttu-id="b65c2-125">主要なフロー制御</span><span class="sxs-lookup"><span data-stu-id="b65c2-125">Primary flow control</span></span>|<span data-ttu-id="b65c2-126">ループ、条件、および関数 (メソッド) 呼び出し。</span><span class="sxs-lookup"><span data-stu-id="b65c2-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="b65c2-127">関数呼び出し (再帰を含む)。</span><span class="sxs-lookup"><span data-stu-id="b65c2-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="b65c2-128">主要な操作単位</span><span class="sxs-lookup"><span data-stu-id="b65c2-128">Primary manipulation unit</span></span>|<span data-ttu-id="b65c2-129">構造体またはクラスのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="b65c2-129">Instances of structures or classes.</span></span>|<span data-ttu-id="b65c2-130">ファーストクラス オブジェクトとしての関数とデータ コレクション。</span><span class="sxs-lookup"><span data-stu-id="b65c2-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="b65c2-131">ほとんどの言語は特定のプログラミング パラダイムをサポートするために作成されていますが、汎用言語の多くは、複数のパラダイムをサポートできる柔軟性を備えています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="b65c2-132">たとえば、関数ポインターを含むほとんどの言語で関数型プログラミングがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="b65c2-133">さらに、C# には、ラムダ式や型推論など、関数型プログラミングをサポートするための明確な言語拡張が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="b65c2-134">LINQ テクノロジは、宣言型 (関数型) プログラミングの一種です。</span><span class="sxs-lookup"><span data-stu-id="b65c2-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="b65c2-135">XSLT による関数型プログラミング</span><span class="sxs-lookup"><span data-stu-id="b65c2-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="b65c2-136">純粋関数型の方法については、多くの XSLT 開発者が精通しています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="b65c2-137">XSLT スタイル シートを開発するための最も効果的な方法では、各テンプレートが、分離された構成可能な変換として扱われ、</span><span class="sxs-lookup"><span data-stu-id="b65c2-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="b65c2-138">実行の順序はまったく重要ではなくなります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="b65c2-139">また、XSLT では副作用も許可されません (例外として、手続き型のコードを実行するためのエスケープ メカニズムによって副作用が導入されることがあります。このため、純粋関数型ではなくなる場合があります)。</span><span class="sxs-lookup"><span data-stu-id="b65c2-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="b65c2-140">XSLT は有効なツールですが、その一方で、最適とは言えない特性もあります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="b65c2-141">たとえば、プログラミング構成要素が XML で表現されるため、コードが比較的冗長になり、保守が困難になります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="b65c2-142">また、フロー制御のために再帰に大きく依存しているため、コードが読みにくくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="b65c2-143">XSLT について詳しくは、「[XSLT 変換](../../../../standard/data/xml/xslt-transformations.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="b65c2-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="b65c2-144">ただし、XML の形式を変換する場合に純粋関数型の方法を使用する意味は、XSLT によって証明されます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="b65c2-145">LINQ to XML による純粋関数型プログラミングは多くの点で XSLT に似ていますが、</span><span class="sxs-lookup"><span data-stu-id="b65c2-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="b65c2-146">LINQ to XML と C# によって導入されるプログラミング構成要素を使用すると、XSLT より読みやすく、保守も容易な、純粋関数型変換を記述することができます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="b65c2-147">純粋関数の利点</span><span class="sxs-lookup"><span data-stu-id="b65c2-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="b65c2-148">関数型変換を純粋関数として実装する最大の理由は、純粋関数が構成可能であること (自己完結していて、ステートレスなこと) です。</span><span class="sxs-lookup"><span data-stu-id="b65c2-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="b65c2-149">これらの特性は、以下に示すようなさまざまな利点をもたらします。</span><span class="sxs-lookup"><span data-stu-id="b65c2-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="b65c2-150">読みやすさが向上し、保守が容易になる。</span><span class="sxs-lookup"><span data-stu-id="b65c2-150">Increased readability and maintainability.</span></span> <span data-ttu-id="b65c2-151">これは、それぞれの関数が、引数を渡されると特定のタスクを実行するように作られていて、</span><span class="sxs-lookup"><span data-stu-id="b65c2-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="b65c2-152">外部の状態に依存しないためです。</span><span class="sxs-lookup"><span data-stu-id="b65c2-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="b65c2-153">反復開発が容易になる。</span><span class="sxs-lookup"><span data-stu-id="b65c2-153">Easier reiterative development.</span></span> <span data-ttu-id="b65c2-154">コードのリファクタリングが容易になるため、多くの場合、設計変更を実装しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="b65c2-155">たとえば、複雑な変換を記述していて、何度も繰り返されているコードがあることに気付いた場合、</span><span class="sxs-lookup"><span data-stu-id="b65c2-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="b65c2-156">純粋メソッドによるリファクタリングでは、副作用を考慮せずにその純粋メソッドを自由に呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="b65c2-157">テストやデバッグが容易になる。</span><span class="sxs-lookup"><span data-stu-id="b65c2-157">Easier testing and debugging.</span></span> <span data-ttu-id="b65c2-158">純粋関数は単独でのテストが容易なため、典型的な値、有効なエッジ ケース、および無効なエッジ ケースを使用して純粋関数を呼び出すテスト コードを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="b65c2-159">OOP 開発者向けの移行</span><span class="sxs-lookup"><span data-stu-id="b65c2-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="b65c2-160">従来のオブジェクト指向プログラミング (OOP) では、ほとんどの開発者が命令型/手続き型スタイルのプログラミングに慣れています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="b65c2-161">純粋関数型スタイルの開発に移行するには、考え方を切り替えて、開発に適用する方法を変える必要があります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="b65c2-162">問題を解決する際、OOP 開発者は、クラス階層を設計し、適切なカプセル化に焦点を絞り、クラス コントラクトの観点から考えます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="b65c2-163">何より重要なのはオブジェクト型の動作と状態であり、それに対処するために、クラス、インターフェイス、継承、ポリモーフィズムなどの言語機能が用意されています。</span><span class="sxs-lookup"><span data-stu-id="b65c2-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="b65c2-164">一方、関数型プログラミングでは、計算の問題を、データ コレクションの純粋関数型変換の 1 つの課題として捉えます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="b65c2-165">関数型プログラミングでは、状態や変化するデータを避け、関数の適用を重視します。</span><span class="sxs-lookup"><span data-stu-id="b65c2-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="b65c2-166">C# では、命令型と関数型の両方のプログラミング方法がサポートされているため、関数型プログラミングに完全に移行する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b65c2-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="b65c2-167">開発者は、個々のシナリオに適した方法を選択できます。</span><span class="sxs-lookup"><span data-stu-id="b65c2-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="b65c2-168">実際、プログラムで両方の方法が組み合わされている場合もよくあります。</span><span class="sxs-lookup"><span data-stu-id="b65c2-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b65c2-169">関連項目</span><span class="sxs-lookup"><span data-stu-id="b65c2-169">See also</span></span>

- [<span data-ttu-id="b65c2-170">純粋関数型変換の概要 (C#)</span><span class="sxs-lookup"><span data-stu-id="b65c2-170">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="b65c2-171">XSLT 変換</span><span class="sxs-lookup"><span data-stu-id="b65c2-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="b65c2-172">純粋関数へのリファクタリング (C#)</span><span class="sxs-lookup"><span data-stu-id="b65c2-172">Refactoring Into Pure Functions (C#)</span></span>](./refactoring-into-pure-functions.md)
