---
title: 例外の使用 - C# プログラミング ガイド
description: 例外を使用する方法について説明します。 例外は、エラーが発生したコードによってスローされ、エラーを修正するコードによってキャッチされます。
ms.date: 12/09/2020
helpviewer_keywords:
- exception handling [C#], about exception handling
- exceptions [C#], about exceptions
ms.assetid: 71472c62-320a-470a-97d2-67995180389d
ms.openlocfilehash: 30a7c3eecb599493dfa74d664c4899836c1b9276
ms.sourcegitcommit: 9b877e160c326577e8aa5ead22a937110d80fa44
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/11/2020
ms.locfileid: "97110222"
---
# <a name="use-exceptions-c-programming-guide"></a>例外の使用 (C# プログラミング ガイド)

C# では、例外と呼ばれるメカニズムを使用して、プログラムの実行時に発生したエラーがプログラムに伝えられます。 例外は、エラーが発生したコードによってスローされ、エラーを修正できるコードによってキャッチされます。 例外をスローできるのは、.NET ランタイム、またはプログラム内のコードです。 スローされた例外は、例外の `catch` ステートメントが見つかるまで呼び出し履歴をさかのぼります。 キャッチされない例外は、システムが提供する汎用の例外ハンドラーによって処理されます。このとき、ダイアログ ボックスが表示されます。

例外は、<xref:System.Exception> から派生したクラスによって表されます。 このクラスは例外の型を識別し、例外に関する詳細情報が含まれたプロパティを保持します。 例外をスローするには、例外の派生クラスのインスタンスを作成し、必要に応じて例外のプロパティを設定してから、`throw` キーワードを使用してオブジェクトをスローする必要があります。 次に例を示します。

:::code language="csharp" source="snippets/exceptions/Program.cs" id="ThrowException":::

例外がスローされると、ランタイムは、現在のステートメントが `try` ブロック内に存在するかどうかを確認します。 存在する場合は、`try` ブロックに関連付けられている `catch` ブロックをチェックして、例外をキャッチできるかどうかを確認します。 通常は、この `Catch` ブロックによって例外の型が指定されます。`catch` ブロックの型が、例外または例外の基底クラスの型と一致する場合、`catch` ブロックはメソッドを処理できます。 次に例を示します。

:::code language="csharp" source="snippets/exceptions/Program.cs" id="CatchException":::

例外をスローするステートメントが `try` ブロック内にない場合、または `try` ブロックにそれが含まれていても、対応する `catch` ブロックが存在しない場合は、ランタイムによって呼び出し側のメソッドで `try` ステートメントと `catch` ブロックが確認されます。 続けて、呼び出し履歴で、対応する `catch` ブロックを探します。 `catch` ブロックが見つかり実行されると、その `catch` ブロックの後にある次のステートメントに制御が渡されます。

`try` ステートメントには、複数の `catch` ブロックを含めることができます。 例外を処理できる最初の `catch` ステートメントが実行され、その後の `catch` ステートメントは、対応していても無視されます。 catch ブロックは、常に最も具体的なもの (または最も派生したもの) から最も具体的でないものの順序にする必要があります。 次に例を示します。

:::code language="csharp" source="snippets/exceptions/CatchOrder.cs":::

`catch` ブロックが実行される前に、ランタイムにより `finally` ブロックがチェックされます。 `Finally` ブロックを使用すると、中止された `try` ブロックによって残ることがある、あいまいな状態をクリーンアップできます。また、ランタイムのガベージ コレクターによってオブジェクトが終了されるのを待たずに外部リソース (グラフィック ハンドル、データベース接続、ファイル ストリームなど) を解放することもできます。 次に例を示します。

:::code language="csharp" source="snippets/exceptions/Program.cs" id="TestFinally":::

`WriteByte()` から例外がスローされた場合、`file.Close()` が呼び出されなければ、ファイルを再度開こうとする 2 番目の `try` ブロックのコードが失敗し、ファイルはロックされたままになります。 例外がスローされても `finally` ブロックは実行されるため、上の例の `finally` ブロックではファイルを適切に閉じて、エラーを回避できます。

例外がスローされた後、対応する `catch` ブロックが呼び出し履歴に見つからない場合は、次のいずれかが発生します。

- 例外がファイナライザーの内部で発生した場合、ファイナライザーは中止され、基本ファイナライザー (存在する場合) が呼び出されます。
- 呼び出し履歴に静的コンストラクターまたは静的フィールド初期化子が含まれている場合は、<xref:System.TypeInitializationException> がスローされ、新しい例外の <xref:System.Exception.InnerException%2A> プロパティに元の例外が割り当てられます。
- スレッドの開始位置に到達すると、スレッドは終了します。
