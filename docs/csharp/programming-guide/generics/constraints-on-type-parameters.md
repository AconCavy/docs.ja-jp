---
title: 型パラメーターの制約 - C# プログラミング ガイド
ms.date: 04/12/2018
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.openlocfilehash: 4c4554c808ab15776f3217c257e0a60119ea2338
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2020
ms.locfileid: "84368362"
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="c80d6-102">型パラメーターの制約 (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="c80d6-102">Constraints on type parameters (C# Programming Guide)</span></span>

<span data-ttu-id="c80d6-103">制約では、型引数に必要な機能をコンパイラに通知します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-103">Constraints inform the compiler about the capabilities a type argument must have.</span></span> <span data-ttu-id="c80d6-104">制約のない型引数は、任意の型にすることができます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-104">Without any constraints, the type argument could be any type.</span></span> <span data-ttu-id="c80d6-105">コンパイラは、.NET 型の最終的な基底クラスになる、<xref:System.Object?displayProperty=nameWithType> のメンバーを見なすことができるだけです。</span><span class="sxs-lookup"><span data-stu-id="c80d6-105">The compiler can only assume the members of <xref:System.Object?displayProperty=nameWithType>, which is the ultimate base class for any .NET type.</span></span> <span data-ttu-id="c80d6-106">詳細については、「[制約を使用する理由](#why-use-constraints)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c80d6-106">For more information, see [Why use constraints](#why-use-constraints).</span></span> <span data-ttu-id="c80d6-107">クライアント コードが制約を満たさない型を使用している場合、コンパイラではエラーが発行されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-107">If client code uses a type that doesn't satisfy a constraint, the compiler issues an error.</span></span> <span data-ttu-id="c80d6-108">制約を指定するには、`where` コンテキスト キーワードを使用します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-108">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="c80d6-109">次の表では、7 種類の制約を一覧しています。</span><span class="sxs-lookup"><span data-stu-id="c80d6-109">The following table lists the seven types of constraints:</span></span>

|<span data-ttu-id="c80d6-110">制約</span><span class="sxs-lookup"><span data-stu-id="c80d6-110">Constraint</span></span>|<span data-ttu-id="c80d6-111">説明</span><span class="sxs-lookup"><span data-stu-id="c80d6-111">Description</span></span>|
|----------------|-----------------|
|`where T : struct`|<span data-ttu-id="c80d6-112">この型引数は null 非許容値型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-112">The type argument must be a non-nullable value type.</span></span> <span data-ttu-id="c80d6-113">null 許容値型の詳細については、「[null 許容値型](../../language-reference/builtin-types/nullable-value-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c80d6-113">For information about nullable value types, see [Nullable value types](../../language-reference/builtin-types/nullable-value-types.md).</span></span> <span data-ttu-id="c80d6-114">すべての値の型にはアクセス可能なパラメーターなしのコンストラクターがあるため、`struct` 制約は `new()` 制約を意味し、`new()` 制約と組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-114">Because all value types have an accessible parameterless constructor, the `struct` constraint implies the `new()` constraint and can't be combined with the `new()` constraint.</span></span> <span data-ttu-id="c80d6-115">`struct` 制約を `unmanaged` 制約と組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-115">You can't combine the `struct` constraint with the `unmanaged` constraint.</span></span>|
|`where T : class`|<span data-ttu-id="c80d6-116">この型引数は参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-116">The type argument must be a reference type.</span></span> <span data-ttu-id="c80d6-117">この制約は、任意のクラス、インターフェイス、デリゲート、または配列型にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-117">This constraint applies also to any class, interface, delegate, or array type.</span></span> <span data-ttu-id="c80d6-118">C# 8.0 以降の null 許容コンテキストでは、`T` は null 非許容の参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-118">In a nullable context in C# 8.0 or later, `T` must be a non-nullable reference type.</span></span> |
|`where T : class?`|<span data-ttu-id="c80d6-119">型の引数は、null 許容または null 非許容の参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-119">The type argument must be a reference type, either nullable or non-nullable.</span></span> <span data-ttu-id="c80d6-120">この制約は、任意のクラス、インターフェイス、デリゲート、または配列型にも適用されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-120">This constraint applies also to any class, interface, delegate, or array type.</span></span>|
|`where T : notnull`|<span data-ttu-id="c80d6-121">この型引数は null 非許容型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-121">The type argument must be a non-nullable type.</span></span> <span data-ttu-id="c80d6-122">引数は、C# 8.0 以降の null 非許容参照型、または null 非許容値型にできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-122">The argument can be a non-nullable reference type in C# 8.0 or later, or a non-nullable value type.</span></span> |
|`where T : unmanaged`|<span data-ttu-id="c80d6-123">この型引数は null 非許容で[アンマネージド型](../../language-reference/builtin-types/unmanaged-types.md)である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-123">The type argument must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="c80d6-124">`unmanaged` 制約は `struct` 制約を意味し、`struct` 制約とも `new()` 制約とも組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-124">The `unmanaged` constraint implies the `struct` constraint and can't be combined with either the `struct` or `new()` constraints.</span></span>|
|`where T : new()`|<span data-ttu-id="c80d6-125">この型引数には、パラメーターなしのパブリック コンストラクターが必要です。</span><span class="sxs-lookup"><span data-stu-id="c80d6-125">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="c80d6-126">`new()` 制約を別の制約と併用する場合、この制約を最後に指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-126">When used together with other constraints, the `new()` constraint must be specified last.</span></span> <span data-ttu-id="c80d6-127">`new()` 制約は、`struct` や `unmanaged` 制約と組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-127">The `new()` constraint can't be combined with the `struct` and `unmanaged` constraints.</span></span>|
|<span data-ttu-id="c80d6-128">`where T :` *\<base class name>*</span><span class="sxs-lookup"><span data-stu-id="c80d6-128">`where T :` *\<base class name>*</span></span>|<span data-ttu-id="c80d6-129">この型引数は、指定された基底クラスであるか、そのクラスから派生している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-129">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="c80d6-130">C# 8.0 以降の null 許容コンテキストでは、`T` は指定の基底クラスから派生した null 非許容の参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-130">In a nullable context in C# 8.0 and later, `T` must be a non-nullable reference type derived from the specified base class.</span></span> |
|<span data-ttu-id="c80d6-131">`where T :` *\<base class name>?*</span><span class="sxs-lookup"><span data-stu-id="c80d6-131">`where T :` *\<base class name>?*</span></span>|<span data-ttu-id="c80d6-132">この型引数は、指定された基底クラスであるか、そのクラスから派生している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-132">The type argument must be or derive from the specified base class.</span></span> <span data-ttu-id="c80d6-133">C# 8.0 以降の null 許容コンテキストでは、`T` は指定の基底クラスから派生した null 許容または非許容のいずれかの参照型である場合があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-133">In a nullable context in C# 8.0 and later, `T` may be either a nullable or non-nullable type derived from the specified base class.</span></span> |
|<span data-ttu-id="c80d6-134">`where T :` *\<interface name>*</span><span class="sxs-lookup"><span data-stu-id="c80d6-134">`where T :` *\<interface name>*</span></span>|<span data-ttu-id="c80d6-135">この型引数は、指定されたインターフェイスであるか、そのインターフェイスを実装している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-135">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="c80d6-136">複数のインターフェイス制約を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-136">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="c80d6-137">制約のインターフェイスを汎用的にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-137">The constraining interface can also be generic.</span></span> <span data-ttu-id="c80d6-138">C# 8.0 以降の null 許容コンテキストでは、`T` は指定したインターフェイスを実装する null 非許容型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-138">In a nullable context in C# 8.0 and later, `T` must be a non-nullable type that implements the specified interface.</span></span>|
|<span data-ttu-id="c80d6-139">`where T :` *\<interface name>?*</span><span class="sxs-lookup"><span data-stu-id="c80d6-139">`where T :` *\<interface name>?*</span></span>|<span data-ttu-id="c80d6-140">この型引数は、指定されたインターフェイスであるか、そのインターフェイスを実装している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-140">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="c80d6-141">複数のインターフェイス制約を指定することができます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-141">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="c80d6-142">制約のインターフェイスを汎用的にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-142">The constraining interface can also be generic.</span></span> <span data-ttu-id="c80d6-143">C# 8.0 の null 許容コンテキストでは、`T` は null 許容参照型、null 非許容参照型、または値型である場合があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-143">In a nullable context in C# 8.0, `T` may be a nullable reference type, a non-nullable reference type, or a value type.</span></span> <span data-ttu-id="c80d6-144">`T` は null 許容値型ではない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-144">`T` may not be a nullable value type.</span></span>|
|`where T : U`|<span data-ttu-id="c80d6-145">`T` に指定する型引数は、`U` に指定された引数であるか、その引数から派生している必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-145">The type argument supplied for `T` must be or derive from the argument supplied for `U`.</span></span> <span data-ttu-id="c80d6-146">null 許容コンテキストでは、`U` が null 非許容参照型である場合、`T` は null 非許容参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-146">In a nullable context, if `U` is a non-nullable reference type, `T` must be non-nullable reference type.</span></span> <span data-ttu-id="c80d6-147">`U` が null 許容参照型である場合、`T` は null 許容または null 非許容のいずれかになります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-147">If `U` is a nullable reference type, `T` may be either nullable or non-nullable.</span></span> |

## <a name="why-use-constraints"></a><span data-ttu-id="c80d6-148">制約を使用する理由</span><span class="sxs-lookup"><span data-stu-id="c80d6-148">Why use constraints</span></span>

<span data-ttu-id="c80d6-149">制約では、型パラメーターの能力と期待を指定します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-149">Constraints specify the capabilities and expectations of a type parameter.</span></span> <span data-ttu-id="c80d6-150">これらの制約を宣言することで、制約型の操作とメソッドの呼び出しを使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-150">Declaring those constraints means you can use the operations and method calls of the constraining type.</span></span> <span data-ttu-id="c80d6-151">お使いのジェネリック クラスまたはメソッドが、単純な割り当てや、<xref:System.Object?displayProperty=nameWithType> でサポートされていない任意のメソッド呼び出しでジェネリック メンバーに対して任意の操作を使用する場合、型パラメーターに制約を適用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-151">If your generic class or method uses any operation on the generic members beyond simple assignment or calling any methods not supported by <xref:System.Object?displayProperty=nameWithType>, you'll have to apply constraints to the type parameter.</span></span> <span data-ttu-id="c80d6-152">たとえば、この基底クラスの制約は、この型のオブジェクト、またはこの型から派生したオブジェクトのみを型引数として使用することをコンパイラに指示しています。</span><span class="sxs-lookup"><span data-stu-id="c80d6-152">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="c80d6-153">コンパイラがこの保証を獲得したら、その型のメソッドをジェネリック クラスで呼び出すことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-153">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="c80d6-154">基底クラスの制約を適用して `GenericList<T>` クラス (「[ジェネリックの概要](../../../standard/generics/index.md)」を参照) に追加できる機能を説明するコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-154">The following code example demonstrates the functionality you can add to the `GenericList<T>` class (in [Introduction to Generics](../../../standard/generics/index.md)) by applying a base class constraint.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#9)]

<span data-ttu-id="c80d6-155">この制約ではジェネリック クラスで `Employee.Name` プロパティを使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="c80d6-155">The constraint enables the generic class to use the `Employee.Name` property.</span></span> <span data-ttu-id="c80d6-156">制約では、型 `T` のすべての項目が、`Employee` オブジェクトまたは `Employee` から継承するオブジェクトのいずれかになることが保証されることを指定します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-156">The constraint specifies that all items of type `T` are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>

<span data-ttu-id="c80d6-157">同じ型パラメーターに複数の制約を適用できます。また、制約自体をジェネリック型にすることもできます。次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-157">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#10)]

<span data-ttu-id="c80d6-158">`where T : class` 制約を適用する場合は、型パラメーターに `==` および `!=` 演算子を使用しないでください。これらの演算子でテストされるのは、値の等価性ではなく、参照 ID についてのみです。</span><span class="sxs-lookup"><span data-stu-id="c80d6-158">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="c80d6-159">これらの演算子が、引数として使用されている型内でオーバーロードされている場合でも、この動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-159">This behavior occurs even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="c80d6-160">この点を説明するコードを次に示します。<xref:System.String> クラスが `==` 演算子をオーバーロードしている場合でも、出力は false です。</span><span class="sxs-lookup"><span data-stu-id="c80d6-160">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#11)]

<span data-ttu-id="c80d6-161">コンパイラは `T` がコンパイル時に参照型であることしか認識しておらず、すべての参照型で有効な既定の演算子を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-161">The compiler only knows that `T` is a reference type at compile time and must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="c80d6-162">値の等価性をテストする必要がある場合は、`where T : IEquatable<T>` または `where T : IComparable<T>` 制約も適用し、ジェネリック クラスの制約に使用されるすべてのクラスでそのインターフェイスを実装することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c80d6-162">If you must test for value equality, the recommended way is to also apply the `where T : IEquatable<T>` or `where T : IComparable<T>` constraint and implement the interface in any class that will be used to construct the generic class.</span></span>

## <a name="constraining-multiple-parameters"></a><span data-ttu-id="c80d6-163">複数のパラメーターを制約する</span><span class="sxs-lookup"><span data-stu-id="c80d6-163">Constraining multiple parameters</span></span>

<span data-ttu-id="c80d6-164">複数のパラメーターに制約を適用できます。また、複数の制約を 1 つのパラメーターに適用することができます。次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-164">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#12)]

## <a name="unbounded-type-parameters"></a><span data-ttu-id="c80d6-165">非バインド型パラメーター</span><span class="sxs-lookup"><span data-stu-id="c80d6-165">Unbounded type parameters</span></span>

 <span data-ttu-id="c80d6-166">パブリック クラス `SampleClass<T>{}` の T など、制約がない型パラメーターは、非バインド型パラメーターと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-166">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="c80d6-167">非バインド型パラメーターには次の規則があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-167">Unbounded type parameters have the following rules:</span></span>

- <span data-ttu-id="c80d6-168">`!=` および `==` 演算子は使用できません。これは、具象型引数によってこれらの演算子がサポートされるという保証がないためです。</span><span class="sxs-lookup"><span data-stu-id="c80d6-168">The `!=` and `==` operators can't be used because there's no guarantee that the concrete type argument will support these operators.</span></span>
- <span data-ttu-id="c80d6-169">これらの演算子は `System.Object` との間で相互に変換できます。また、任意のインターフェイス型に明示的に変換できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-169">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>
- <span data-ttu-id="c80d6-170">これらは [null](../../language-reference/keywords/null.md) と比較することができます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-170">You can compare them to [null](../../language-reference/keywords/null.md).</span></span> <span data-ttu-id="c80d6-171">非バインド型パラメーターと `null` を比較し、その型引数が値の型の場合、比較結果として常に false が返されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-171">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>

## <a name="type-parameters-as-constraints"></a><span data-ttu-id="c80d6-172">制約としての型パラメーター</span><span class="sxs-lookup"><span data-stu-id="c80d6-172">Type parameters as constraints</span></span>

<span data-ttu-id="c80d6-173">制約としてジェネリック型パラメーターを使用する方法は、独自の型パラメーターがあるメンバー関数が、含まれる型の型パラメーターにそのパラメーターを制約する必要がある場合に便利です。次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-173">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#13)]

<span data-ttu-id="c80d6-174">前の例の `T` は、`Add` メソッドのコンテキストでは型の制約ですが、`List` クラスのコンテキストでは非バインド型パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="c80d6-174">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>

<span data-ttu-id="c80d6-175">型パラメーターは、ジェネリック クラス定義の制約としても使用できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-175">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="c80d6-176">型パラメーターは、他の型パラメーターと共に山かっこ内で宣言する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-176">The type parameter must be declared within the angle brackets together with any other type parameters:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#14)]

<span data-ttu-id="c80d6-177">ジェネリック クラスで制約として型パラメーターを使用する方法が便利なのは、限られた場合のみです。コンパイラでは、`System.Object` から派生したことを除き、型パラメーターに関して何も仮定できないためです。</span><span class="sxs-lookup"><span data-stu-id="c80d6-177">The usefulness of type parameters as constraints with generic classes is limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="c80d6-178">2 つの型パラメーター間に継承関係を適用するシナリオには、ジェネリック クラスの制約として型パラメーターを使用してください。</span><span class="sxs-lookup"><span data-stu-id="c80d6-178">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>

## <a name="notnull-constraint"></a><span data-ttu-id="c80d6-179">NotNull 制約</span><span class="sxs-lookup"><span data-stu-id="c80d6-179">NotNull constraint</span></span>

<span data-ttu-id="c80d6-180">C# 8.0 以降の null 許容コンテキストでは、`notnull` 制約を使用して、型引数が null 非許容値型または null 非許容参照型である必要があることを指定できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-180">Beginning with C# 8.0 in a nullable context, you can use the `notnull` constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type.</span></span> <span data-ttu-id="c80d6-181">`notnull` 制約は、`nullable enable` コンテキストでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-181">The `notnull` constraint can only be used in a `nullable enable` context.</span></span> <span data-ttu-id="c80d6-182">null 許容が未指定のコンテキストに `notnull` 制約を追加すると、コンパイラにより警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-182">The compiler generates a warning if you add the `notnull` constraint in a nullable oblivious context.</span></span>

<span data-ttu-id="c80d6-183">他の制約とは異なり、型引数が `notnull` 制約に違反すると、そのコードが `nullable enable` コンテキストでコンパイルされるときにコンパイラにより警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-183">Unlike other constraints, when a type argument violates the `notnull` constraint, the compiler generates a warning when that code is compiled in a `nullable enable` context.</span></span> <span data-ttu-id="c80d6-184">null 許容が未指定のコンテキストでコードがコンパイルされた場合、コンパイラによって警告やエラーは生成されません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-184">If the code is compiled in a nullable oblivious context, the compiler doesn't generate any warnings or errors.</span></span>

<span data-ttu-id="c80d6-185">C# 8.0 以降の null 許容コンテキストでは、`class` 制約を使用して、型引数が null 非許容型である必要があることを指定できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-185">Beginning with C# 8.0 in a nullable context, the `class` constraint specifies that the type argument must be a non-nullable reference type.</span></span> <span data-ttu-id="c80d6-186">null 許容コンテキストでは、型パラメーターが null 許容参照型である場合、コンパイラによって警告が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-186">In a nullable context, when a type parameter is a nullable reference type, the compiler generates a warning.</span></span>

## <a name="unmanaged-constraint"></a><span data-ttu-id="c80d6-187">アンマネージド制約</span><span class="sxs-lookup"><span data-stu-id="c80d6-187">Unmanaged constraint</span></span>

<span data-ttu-id="c80d6-188">C# 7.3 以降、`unmanaged` 制約を指定して、型パラメーターが null 非許容で[アンマネージド型](../../language-reference/builtin-types/unmanaged-types.md)である必要があることを指定できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-188">Beginning with C# 7.3, you can use the `unmanaged` constraint to specify that the type parameter must be a non-nullable [unmanaged type](../../language-reference/builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="c80d6-189">`unmanaged` 制約では、次の例のように、メモリのブロックとして操作できる型を処理する再利用可能なルーチンを記述できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-189">The `unmanaged` constraint enables you to write reusable routines to work with types that can be manipulated as blocks of memory, as shown in the following example:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#15)]

<span data-ttu-id="c80d6-190">ビルトイン型ではない型で `sizeof` 演算子を使用するため、先行するメソッドは `unsafe` コンテキストでコンパイルされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c80d6-190">The preceding method must be compiled in an `unsafe` context because it uses the `sizeof` operator on a type not known to be a built-in type.</span></span> <span data-ttu-id="c80d6-191">`unmanaged` 制約なしで、`sizeof` 演算子を使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-191">Without the `unmanaged` constraint, the `sizeof` operator is unavailable.</span></span>

<span data-ttu-id="c80d6-192">`unmanaged` 制約は `struct` 制約を意味するため、これと組み合わせることはできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-192">The `unmanaged` constraint implies the `struct` constraint and can't be combined with it.</span></span> <span data-ttu-id="c80d6-193">`struct` 制約は `new()` 制約を意味するため、`unmanaged` 制約を `new()` 制約と組み合わせることもできません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-193">Because the `struct` constraint implies the `new()` constraint, the `unmanaged` constraint can't be combined with the `new()` constraint as well.</span></span>

## <a name="delegate-constraints"></a><span data-ttu-id="c80d6-194">制約をデリゲートする</span><span class="sxs-lookup"><span data-stu-id="c80d6-194">Delegate constraints</span></span>

<span data-ttu-id="c80d6-195">また、C# 7.3 以降、基底クラスの制約として <xref:System.Delegate?displayProperty=nameWithType> または <xref:System.MulticastDelegate?displayProperty=nameWithType> を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-195">Also beginning with C# 7.3, you can use <xref:System.Delegate?displayProperty=nameWithType> or <xref:System.MulticastDelegate?displayProperty=nameWithType> as a base class constraint.</span></span> <span data-ttu-id="c80d6-196">CLR では常にこの制約を許可していますが、C# 言語では許可されていません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-196">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="c80d6-197">`System.Delegate` 制約では、タイプ セーフな方法でデリゲートを処理するコードを記述できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-197">The `System.Delegate` constraint enables you to write code that works with delegates in a type-safe manner.</span></span> <span data-ttu-id="c80d6-198">次のコードでは、2 つのデリゲートが同じ型である場合にそれらを組み合わせる拡張メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-198">The following code defines an extension method that combines two delegates provided they're the same type:</span></span>

[!code-csharp[using the delegate constraint](snippets/GenericWhereConstraints.cs#16)]

<span data-ttu-id="c80d6-199">上述のメソッドを使用して、同じ型のデリゲートを組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-199">You can use the above method to combine delegates that are the same type:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#17)]

<span data-ttu-id="c80d6-200">最後の行のコメントを解除した場合、コンパイルされません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-200">If you uncomment the last line, it won't compile.</span></span> <span data-ttu-id="c80d6-201">`first` と `test` は両方ともデリゲート型ですが、これらは異なるデリゲート型です。</span><span class="sxs-lookup"><span data-stu-id="c80d6-201">Both `first` and `test` are delegate types, but they're different delegate types.</span></span>

## <a name="enum-constraints"></a><span data-ttu-id="c80d6-202">列挙の制約</span><span class="sxs-lookup"><span data-stu-id="c80d6-202">Enum constraints</span></span>

<span data-ttu-id="c80d6-203">C# 7.3 以降、基底クラスの制約として <xref:System.Enum?displayProperty=nameWithType> 型を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-203">Beginning in C# 7.3, you can also specify the <xref:System.Enum?displayProperty=nameWithType> type as a base class constraint.</span></span> <span data-ttu-id="c80d6-204">CLR では常にこの制約を許可していますが、C# 言語では許可されていません。</span><span class="sxs-lookup"><span data-stu-id="c80d6-204">The CLR always allowed this constraint, but the C# language disallowed it.</span></span> <span data-ttu-id="c80d6-205">`System.Enum` を使用するジェネリックは、`System.Enum` の静的メソッドの使用から結果をキャッシュするために、タイプ セーフのプログラミングを提供します。</span><span class="sxs-lookup"><span data-stu-id="c80d6-205">Generics using `System.Enum` provide type-safe programming to cache results from using the static methods in `System.Enum`.</span></span> <span data-ttu-id="c80d6-206">次の例では、列挙型の有効な値をすべて見つけて、それらの値をその文字列表記にマップするディクショナリをビルドします。</span><span class="sxs-lookup"><span data-stu-id="c80d6-206">The following sample finds all the valid values for an enum type, and then builds a dictionary that maps those values to its string representation.</span></span>

[!code-csharp[using the enum constraint](snippets/GenericWhereConstraints.cs#18)]

<span data-ttu-id="c80d6-207">`Enum.GetValues` と `Enum.GetName` ではリフレクションが使用されます。これは、パフォーマンスに影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-207">`Enum.GetValues` and `Enum.GetName` use reflection, which has performance implications.</span></span> <span data-ttu-id="c80d6-208">リフレクションを必要とする呼び出しを繰り返すのではなく、`EnumNamedValues` を呼び出してキャッシュおよび再利用されるコレクションを作成できます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-208">You can call `EnumNamedValues` to build a collection that is cached and reused rather than repeating the calls that require reflection.</span></span>

<span data-ttu-id="c80d6-209">次の例で示すように、このメソッドを使用して、列挙を作成し、その値と名前のディクショナリをビルドできます。</span><span class="sxs-lookup"><span data-stu-id="c80d6-209">You could use it as shown in the following sample to create an enum and build a dictionary of its values and names:</span></span>

[!code-csharp[enum definition](snippets/GenericWhereConstraints.cs#19)]

[!code-csharp[using the enum constrained method](snippets/GenericWhereConstraints.cs#20)]

## <a name="see-also"></a><span data-ttu-id="c80d6-210">関連項目</span><span class="sxs-lookup"><span data-stu-id="c80d6-210">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="c80d6-211">C# プログラミング ガイド</span><span class="sxs-lookup"><span data-stu-id="c80d6-211">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="c80d6-212">ジェネリックの概要</span><span class="sxs-lookup"><span data-stu-id="c80d6-212">Introduction to Generics</span></span>](./index.md)
- [<span data-ttu-id="c80d6-213">ジェネリック クラス</span><span class="sxs-lookup"><span data-stu-id="c80d6-213">Generic Classes</span></span>](./generic-classes.md)
- [<span data-ttu-id="c80d6-214">new 制約</span><span class="sxs-lookup"><span data-stu-id="c80d6-214">new Constraint</span></span>](../../language-reference/keywords/new-constraint.md)
