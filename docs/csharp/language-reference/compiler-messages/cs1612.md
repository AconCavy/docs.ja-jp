---
title: コンパイラ エラー CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: fa0e9e6ad575273d3e8c9c4cee21cd14208aee47
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173875"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="cf8f9-102">コンパイラ エラー CS1612</span><span class="sxs-lookup"><span data-stu-id="cf8f9-102">Compiler Error CS1612</span></span>
<span data-ttu-id="cf8f9-103">変数ではないため、'<式>' の戻り値を変更できません</span><span class="sxs-lookup"><span data-stu-id="cf8f9-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="cf8f9-104">中間式の結果として生成され、変数には格納されない値型を変更しようとしました。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="cf8f9-105">このエラーは、ジェネリック コレクション内の構造体を直接変更しようとしたときに発生する可能性があります。例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="cf8f9-106">構造体を変更するには、まず構造体をローカル変数に割り当て、変数を変更します。その後、コレクションの項目に変数を代入して戻します。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="cf8f9-107">このエラーは、値型が代入時にコピーされるために発生します。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="cf8f9-108">プロパティやインデクサーから値型を取得する場合は、オブジェクト自体への参照ではなく、そのオブジェクトのコピーを取得することになります。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="cf8f9-109">返されたコピーは、プロパティやインデクサーには格納されていません。これは、プロパティやインデクサーが格納場所 (変数) ではなく、実際はメソッドであるためです。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="cf8f9-110">このコピーを変更するには、ユーザーが宣言した変数にコピーを格納する必要があります。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="cf8f9-111">参照型の場合は、プロパティやインデクサーから既存のオブジェクトへの参照 (格納場所) が返されるため、このエラーは発生しません。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="cf8f9-112">クラスまたは構造体を定義している場合は、プロパティ宣言を変更して構造体のメンバーにアクセスできるようにすることで、このエラーを解決できます。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="cf8f9-113">クライアント コードを記述している場合にエラーを解決するには、構造体の独自のインスタンスを作成し、そのフィールドを変更してから、構造体全体をプロパティに再度代入します。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="cf8f9-114">第 3 の方法として、構造体をクラスに変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="cf8f9-115">例</span><span class="sxs-lookup"><span data-stu-id="cf8f9-115">Example</span></span>  
 <span data-ttu-id="cf8f9-116">CS1612 エラーは、構造体全体を返す外側のクラスのプロパティを通じて、構造体のメンバーにアクセスしようとしたときにも発生します。例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="cf8f9-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;
    }  
  
    public static void Main()
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="cf8f9-117">関連項目</span><span class="sxs-lookup"><span data-stu-id="cf8f9-117">See also</span></span>

- [<span data-ttu-id="cf8f9-118">構造体型</span><span class="sxs-lookup"><span data-stu-id="cf8f9-118">Structure types</span></span>](../builtin-types/struct.md)
- [<span data-ttu-id="cf8f9-119">値型</span><span class="sxs-lookup"><span data-stu-id="cf8f9-119">Value types</span></span>](../builtin-types/value-types.md)
- [<span data-ttu-id="cf8f9-120">参照型</span><span class="sxs-lookup"><span data-stu-id="cf8f9-120">Reference types</span></span>](../keywords/reference-types.md)
