---
description: コンパイラ エラー CS0029
title: コンパイラ エラー CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: 310a730733cb76b0afb29f5496ad22b77fb29243
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/30/2020
ms.locfileid: "89139932"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="f09ff-103">コンパイラ エラー CS0029</span><span class="sxs-lookup"><span data-stu-id="f09ff-103">Compiler Error CS0029</span></span>

<span data-ttu-id="f09ff-104">型 'type' を 'type' に暗黙的に変換できません</span><span class="sxs-lookup"><span data-stu-id="f09ff-104">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="f09ff-105">コンパイラでは、明示的な変換が必要です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-105">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="f09ff-106">たとえば、左辺値と同じ型の右辺値をキャストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-106">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="f09ff-107">また、特定の演算子のオーバーロードをサポートするための変換ルーチンを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-107">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="f09ff-108">型の変数を別の型の変数に割り当てた場合、変換を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-108">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="f09ff-109">異なる型の変数間で割り当て行うと、コンパイラで代入演算子の右辺の型を代入演算子の左辺の型に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-109">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="f09ff-110">次のコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="f09ff-110">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="f09ff-111">`i = lng;` は割り当てを行いますが、代入演算子の左辺と右辺で変数のデータ型が一致しません。</span><span class="sxs-lookup"><span data-stu-id="f09ff-111">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="f09ff-112">割り当てを行う前に、コンパイラは long 型の変数 `lng` を暗黙的に int に変換しています。この変換の実行をコンパイラに明示的に指示するコードがないため、これは暗黙的です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-112">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="f09ff-113">このコードの問題は、このコードが縮小変換と見なされ、データが失われる可能性があるため、コンパイラが暗黙的な縮小変換を許可しないことです。</span><span class="sxs-lookup"><span data-stu-id="f09ff-113">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="f09ff-114">変換元のデータ型よりもメモリに占める記憶域スペースが少ないデータ型に変換するときに、縮小変換が存在します。</span><span class="sxs-lookup"><span data-stu-id="f09ff-114">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="f09ff-115">たとえば、long を int に変換すると、縮小変換と見なされます。</span><span class="sxs-lookup"><span data-stu-id="f09ff-115">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="f09ff-116">long のメモリ占有スペースは 8 バイトですが、int の占有スペースは 4 バイトです。</span><span class="sxs-lookup"><span data-stu-id="f09ff-116">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="f09ff-117">データ損失の発生状況を確認するには、次のサンプルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f09ff-117">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="f09ff-118">変数 `lng` には、大きすぎるため変数 `i` に格納できない値が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f09ff-118">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="f09ff-119">この値を int 型に変換しようとすると、データの一部が失われ、変換後の値は変換前の値とは同じになりません。</span><span class="sxs-lookup"><span data-stu-id="f09ff-119">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="f09ff-120">拡大変換は縮小変換の逆の処理です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-120">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="f09ff-121">拡大変換では、変換元のデータ型よりもメモリに占める記憶域スペースが多いデータ型に変換します。</span><span class="sxs-lookup"><span data-stu-id="f09ff-121">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="f09ff-122">拡大変換の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="f09ff-122">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="f09ff-123">このコード サンプルと、最初のサンプルの違いに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f09ff-123">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="f09ff-124">今回、変数 `lng` は代入演算子の左辺にあるため、割り当ての対象です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-124">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="f09ff-125">割り当てを行う前に、コンパイラで int 型の変数 `i` は long 型に暗黙的に変換される必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-125">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="f09ff-126">メモリの占有スペースが 4 バイトの型 (int) をメモリの占有スペースが 8 バイトの型 (long) に変換するため、これは拡大変換です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-126">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="f09ff-127">データ損失の可能性がないため、暗黙の拡大変換は許可されます。</span><span class="sxs-lookup"><span data-stu-id="f09ff-127">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="f09ff-128">int に格納できる値は、long にも格納できます。</span><span class="sxs-lookup"><span data-stu-id="f09ff-128">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="f09ff-129">前述のように、暗黙的な縮小変換は許可されないため、このコードをコンパイルできるようにするには、データ型を明示的に変換する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-129">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="f09ff-130">明示的な変換にはキャストが使用されます。</span><span class="sxs-lookup"><span data-stu-id="f09ff-130">Explicit conversions are done using casting.</span></span> <span data-ttu-id="f09ff-131">キャストとは、あるデータ型を別のデータ型に変換する処理を示すために C# で使用される用語です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-131">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="f09ff-132">コードをコンパイルするには、次の構文を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-132">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="f09ff-133">このコードの 3 行目では、割り当てを行う前に、long 型の変数 `lng` を int に明示的に変換するようにコンパイラに指示しています。</span><span class="sxs-lookup"><span data-stu-id="f09ff-133">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="f09ff-134">ただし、縮小変換にはデータ損失の可能性がある点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="f09ff-134">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="f09ff-135">縮小変換を慎重に使用する必要があります。コードをコンパイルできるとしても、実行時に予期しない結果が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-135">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="f09ff-136">この問題は値の型のみが対象です。</span><span class="sxs-lookup"><span data-stu-id="f09ff-136">This discussion has only been for value types.</span></span> <span data-ttu-id="f09ff-137">値の型を操作する場合、変数に格納されているデータを直接操作します。</span><span class="sxs-lookup"><span data-stu-id="f09ff-137">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="f09ff-138">一方、.NET Framework の場合は参照型もあります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-138">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="f09ff-139">参照型を操作する場合、実際のデータではなく、変数の参照を操作することになります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-139">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="f09ff-140">参照型の例として、クラス、インターフェイス、および配列があります。</span><span class="sxs-lookup"><span data-stu-id="f09ff-140">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="f09ff-141">コンパイラが特定の変換を許可している場合、または適切な変換演算子が実装されている場合を除き、ある参照型を別の参照型に暗黙的または明示的に変換することはできません。</span><span class="sxs-lookup"><span data-stu-id="f09ff-141">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="f09ff-142">次の例では CS0029 が生成されます。</span><span class="sxs-lookup"><span data-stu-id="f09ff-142">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="f09ff-143">関連項目</span><span class="sxs-lookup"><span data-stu-id="f09ff-143">See also</span></span>

- [<span data-ttu-id="f09ff-144">ユーザー定義の変換演算子</span><span class="sxs-lookup"><span data-stu-id="f09ff-144">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
