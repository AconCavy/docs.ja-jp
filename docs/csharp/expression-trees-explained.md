---
title: 式ツリーの説明
description: 式ツリーについて、また、外部実行のためのアルゴリズム変換と実行前のコード検査で式ツリーがいかに役立つかについて説明します。
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036993"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="eab2d-103">式ツリーの説明</span><span class="sxs-lookup"><span data-stu-id="eab2d-103">Expression Trees Explained</span></span>

[<span data-ttu-id="eab2d-104">前回 -- 概要</span><span class="sxs-lookup"><span data-stu-id="eab2d-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="eab2d-105">式ツリーはコードを定義するデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="eab2d-106">式ツリーは、コードの分析とコンパイル済み出力の生成にコンパイラが使用する構造と同じ構造に基づいています。</span><span class="sxs-lookup"><span data-stu-id="eab2d-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="eab2d-107">このチュートリアルを読むと、式ツリーと、[Analyzers と CodeFixes](https://github.com/dotnet/roslyn-analyzers) の構築に Roslyn API で使用される型が似ている点が多くあることがわかります</span><span class="sxs-lookup"><span data-stu-id="eab2d-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="eab2d-108">(Analyzers と CodeFixes は、コードに対して静的分析を実行し、開発者に修正案を示す機能がある NuGet パッケージです)。概念が似ており、最終的に、わかりやすい方法でソース コードを調査できるデータ構造になります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="eab2d-109">ただし、式ツリーは Roslyn API とまったく異なるクラスと API のセットに基づいています。</span><span class="sxs-lookup"><span data-stu-id="eab2d-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="eab2d-110">単純な例を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="eab2d-110">Let's look at a simple example.</span></span>
<span data-ttu-id="eab2d-111">次のコードがあります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="eab2d-112">この式ツリーを分析すると、ツリーにはいくつかのノードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="eab2d-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="eab2d-113">最も外側のノードは、代入 (`var sum = 1 + 2;`) ありの変数宣言ステートメントです。この最も外側のノードには、いくつかの子ノードが含まれています。変数の宣言、代入演算子、そして等号の右側を表す式です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="eab2d-114">この式は、さらに加算演算と加算の左右のオペランドを表す式に分割されます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="eab2d-115">等号の右側を構成する式を詳しく見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="eab2d-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="eab2d-116">式は `1 + 2` です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="eab2d-117">これは二項式です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-117">That's a binary expression.</span></span> <span data-ttu-id="eab2d-118">具体的には、二項加算式です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="eab2d-119">二項加算式には、加算式の左ノードと右ノードを表す 2 つの子があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="eab2d-120">ここで、いずれのノードも定数式です。左オペランドは値 `1`、右オペランドは値 `2` です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="eab2d-121">見た目では、ステートメント全体が 1 つのツリーです。ルート ノードから始めて、ツリーの各ノードをたどり、ステートメントを構成するコードを確認することができます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="eab2d-122">代入 (`var sum = 1 + 2;`) ありの変数宣言ステートメント</span><span class="sxs-lookup"><span data-stu-id="eab2d-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="eab2d-123">暗黙的な変数の型宣言 (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="eab2d-124">暗黙的な var キーワード (`var`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="eab2d-125">変数名の宣言 (`sum`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="eab2d-126">代入演算子 (`=`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="eab2d-127">二項加算式 (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="eab2d-128">左オペランド (`1`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="eab2d-129">加算演算子 (`+`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="eab2d-130">右オペランド (`2`)</span><span class="sxs-lookup"><span data-stu-id="eab2d-130">Right operand (`2`)</span></span>

<span data-ttu-id="eab2d-131">これは複雑に見えるかもしれませんが、とても強力です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="eab2d-132">同じプロセスに従って、はるかに複雑な式を分解することができます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="eab2d-133">次の式について考えます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="eab2d-134">上の式も、代入ありの変数宣言です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="eab2d-135">この例では、代入の右側はとても複雑なツリーです。</span><span class="sxs-lookup"><span data-stu-id="eab2d-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="eab2d-136">ここではこの式を分解しませんが、どのようなノードがあるかを考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="eab2d-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="eab2d-137">現在のオブジェクトをレシーバーとして使用するメソッド呼び出しがあります。1 つは明示的な `this` レシーバーを持つものと、もう 1 つは持たないものです。</span><span class="sxs-lookup"><span data-stu-id="eab2d-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="eab2d-138">他のレシーバー オブジェクトを使用するメソッド呼び出しがあり、さまざまな型の定数の引数があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="eab2d-139">最後に、二項加算演算子があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="eab2d-140">`SecretSauceFunction()` または `MoreSecretSauce()` の戻り値の型にもよりますが、二項加算演算子がオーバーライドされた加算演算子のメソッド呼び出しになり、静的メソッド呼び出しがクラスに定義されている二項加算演算子に解決されることがあります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="eab2d-141">このような複雑さはありますが、上の式では、最初のサンプルと同じくらい簡単にたどることができるツリー構造が作成されます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="eab2d-142">子ノードをたどっていくと、式内のリーフ ノードを見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="eab2d-143">親ノードには子への参照があり、各ノードにはノードの種類を説明するプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="eab2d-144">式ツリーの構造には高い一貫性があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="eab2d-145">基本がわかると、非常に複雑なコードが式ツリーとして表された場合でも理解できるようになります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="eab2d-146">データ構造が洗練されているので、C# コンパイラが非常に複雑な C# プログラムをどのように分析し、複雑なソース コードから正しい出力を生成できるかがわかります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="eab2d-147">式ツリーの構造に慣れると、その身につけた知識を他の高度なシナリオにもすぐに応用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="eab2d-148">式ツリーには優れた機能があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="eab2d-149">他の環境で実行されるアルゴリズムを変換するだけでなく、式ツリーを使用してコードの実行前に調査するアルゴリズムを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="eab2d-150">引数が式のメソッドを作成し、その式を調査してからコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="eab2d-151">式ツリーは、コード全体を表したものです。任意のサブ式の値を確認できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="eab2d-152">メソッドとプロパティ名を確認できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-152">You can see method and property names.</span></span> <span data-ttu-id="eab2d-153">定数式の値を確認できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="eab2d-154">また、式ツリーを実行可能なデリゲートに変換し、コードを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="eab2d-155">式ツリーの API を使用すると、ほぼすべての有効なコード コンストラクトを表すツリーを作成できます。</span><span class="sxs-lookup"><span data-stu-id="eab2d-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="eab2d-156">ただし、可能な限り単純にするために、式ツリーでは一部の C# の表現方法を作成できません。</span><span class="sxs-lookup"><span data-stu-id="eab2d-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="eab2d-157">たとえば、(`async` および `await` キーワードを使用する) 非同期式です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="eab2d-158">非同期アルゴリズムが必要な場合は、コンパイラのサポートに頼らず、`Task` オブジェクトを直接操作する必要があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="eab2d-159">もう 1 つの例は、ループの作成時です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-159">Another is in creating loops.</span></span> <span data-ttu-id="eab2d-160">通常、ループの作成には `for`、`foreach`、`while`、または `do` ループを使用します。</span><span class="sxs-lookup"><span data-stu-id="eab2d-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="eab2d-161">[このシリーズの後半](expression-trees-building.md)で説明しますが、式ツリーの API は、ループの繰り返しを制御する `break` 式と `continue` 式を使用した 1 つのループ式をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="eab2d-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="eab2d-162">実行できないことの 1 つが式ツリーの変更です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="eab2d-163">式ツリーは不変のデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="eab2d-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="eab2d-164">式ツリーを変更するには、元の式ツリーのコピーに変更を加えた新しいツリーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="eab2d-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="eab2d-165">次回 -- 式ツリーをサポートするフレームワークの型</span><span class="sxs-lookup"><span data-stu-id="eab2d-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
