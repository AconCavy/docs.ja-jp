---
title: デリゲートとイベントの識別
description: デリゲートとイベントの違いと、.NET Core の各機能を使用する状況について説明します。
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 04738ac2dd82da9c577e88598d0bb737a93333c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146179"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="ebd0a-103">デリゲートとイベントの識別</span><span class="sxs-lookup"><span data-stu-id="ebd0a-103">Distinguishing Delegates and Events</span></span>

<span data-ttu-id="ebd0a-104">[[戻る]](modern-events.md)</span><span class="sxs-lookup"><span data-stu-id="ebd0a-104">[Previous](modern-events.md)</span></span>

<span data-ttu-id="ebd0a-105">.NET Core プラットフォームを初めて利用する開発者は、`delegates` に基づく設計と `events` に基づく設計のどちらにするか迷うことがあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="ebd0a-106">これは難しい問題です。この 2 つの言語機能は非常に似ているためです。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="ebd0a-107">さらに言えば、イベントはデリゲートの言語サポートを利用して構築されています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="ebd0a-108">いずれも遅延バインディングのシナリオを提供します。実行時にのみ認識されるメソッドを呼び出すことでコンポーネントが通信するシナリオが可能になります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="ebd0a-109">いずれもシングルとマルチのサブスクライバー メソッドに対応しています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="ebd0a-110">これはシングルキャストまたはマルチキャスト サポートと呼ばれることがあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="ebd0a-111">いずれも、ハンドラーの追加と削除に同じような構文を利用しています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="ebd0a-112">最後になりますが、イベントを発生させ、デリゲートを呼び出すとき、まったく同じメソッド呼び出し構文が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="ebd0a-113">いずれも、`Invoke()` 演算子で使用する同じ `?.` メソッド構文をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="ebd0a-114">このような類似点があるため、どちらを使用するか決定することは簡単ではありません。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="ebd0a-115">イベントの待機は任意です</span><span class="sxs-lookup"><span data-stu-id="ebd0a-115">Listening to Events is Optional</span></span>

<span data-ttu-id="ebd0a-116">使用する言語機能を決定するときに考慮するべき最も重要なことは、サブスクライバーをアタッチする必要があるのかどうかです。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="ebd0a-117">サブスクライバーが提供するコードをコードが呼び出す必要がある場合、デリゲートに基づくデザインを使用してください。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="ebd0a-118">サブスクライバーを呼び出さなくてもすべての作業をコードで完了できる場合、イベントに基づくデザインを使用してください。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="ebd0a-119">このセクションで作成されたサンプルを考察してください。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-119">Consider the examples built during this section.</span></span> <span data-ttu-id="ebd0a-120">`List.Sort()` を利用して作成したコードには、要素を適切に並べ替える目的で、比較関数を与える必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="ebd0a-121">LINQ クエリには、返す要素を決定する目的で、デリゲートを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="ebd0a-122">いずれもデリゲートで作成したデザインを使用しています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="ebd0a-123">`Progress` イベントを考察してください。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-123">Consider the `Progress` event.</span></span> <span data-ttu-id="ebd0a-124">これはタスクの進行状況を報告します。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-124">It reports progress on a task.</span></span>
<span data-ttu-id="ebd0a-125">リスナーの有無に関係なく、このタスクは続行します。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="ebd0a-126">`FileSearcher` は別の例です。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="ebd0a-127">イベント サブスクライバーがアタッチされていませんが、要求されたすべてのファイルを検索します。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="ebd0a-128">サブスクライバーがイベントを待ち受けていなくても、UX コントロールは正しく動作します。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="ebd0a-129">いずれもイベントに基づくデザインを使用しています。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="ebd0a-130">戻り値でデリゲートが必要になる</span><span class="sxs-lookup"><span data-stu-id="ebd0a-130">Return Values Require Delegates</span></span>

<span data-ttu-id="ebd0a-131">別の考慮事項として、デリゲート メソッドのために必要なメソッド プロトタイプがあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="ebd0a-132">ご覧のとおり、イベントに使用されるデリゲートにはすべて戻り値の型 void が与えられます。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="ebd0a-133">また、イベント引数オブジェクトのプロパティを変更することでイベント ソースに情報を戻すイベント ハンドラーを作成する表現形式があります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="ebd0a-134">そのような表現形式は実際に機能しますが、メソッドから値を返すことと同じように自然ではありません。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="ebd0a-135">多くの場合、これらの 2 つのヒューリスティックが存在します。デリゲート メソッドが値を返す場合、何らかの形式でアルゴリズムに影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="ebd0a-136">イベント リスナーの有効期間が頻繁に長くなる</span><span class="sxs-lookup"><span data-stu-id="ebd0a-136">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="ebd0a-137">これは少々弱い根拠です。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="ebd0a-138">しかしながら、イベント ソースが長期間にわたりイベントを発生させるとき、イベント基準の設計の方が自然であることがあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="ebd0a-139">このような例は、さまざまなシステムの UX コントロールで確認できます。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="ebd0a-140">イベントを受信登録すると、イベント ソースはプログラムの有効期間にわたりイベントを発生させることがあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="ebd0a-141">(不要になったらイベントの受信登録を解除できます。)</span><span class="sxs-lookup"><span data-stu-id="ebd0a-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="ebd0a-142">さまざまなデリゲート基準デザインと比較してみてください。デリゲート基準デザインの場合、デリゲートはメソッドの引数として使用され、そのメソッドが戻った後、デリゲートは使用されません。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="ebd0a-143">慎重に評価する</span><span class="sxs-lookup"><span data-stu-id="ebd0a-143">Evaluate Carefully</span></span>

<span data-ttu-id="ebd0a-144">以上の考慮事項は絶対厳守の決まりではありません。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="ebd0a-145">代わりに、特定の用途に最適な選択肢はどれかを決定する際の指南になります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="ebd0a-146">どちらも似ているため、両方を試作し、どちらが自然に動作するか検討するという方法もあります。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="ebd0a-147">いずれも遅延バインディング シナリオを効率的に処理します。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="ebd0a-148">自分の設計を最もよく伝える方を利用してください。</span><span class="sxs-lookup"><span data-stu-id="ebd0a-148">Use the one that communicates your design the best.</span></span>
