---
title: .NET Compiler Platform SDK 構文モデルを使用する
description: この概要は、構文ノードを理解して操作するために使用する型を理解するためのものです。
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fc1b1f5ae5ec985425c8d6aec49ef7f830ea9162
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "75740474"
---
# <a name="work-with-syntax"></a><span data-ttu-id="df415-103">構文の使用</span><span class="sxs-lookup"><span data-stu-id="df415-103">Work with syntax</span></span>

<span data-ttu-id="df415-104">**構文ツリー**は、コンパイラ API によって公開される基本的なデータ構造です。</span><span class="sxs-lookup"><span data-stu-id="df415-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="df415-105">これらのツリーは、ソース コードの字句および構文構造を表します。</span><span class="sxs-lookup"><span data-stu-id="df415-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="df415-106">これらは、次の 2 つの重要な目的を果たします。</span><span class="sxs-lookup"><span data-stu-id="df415-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="df415-107">IDE、アドイン、コード分析ツール、リファクタリングなどのツールで、ユーザーのプロジェクトのソース コードの構文構造を表示および処理できるようにします。</span><span class="sxs-lookup"><span data-stu-id="df415-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="df415-108">リファクタリングや IDE などのツールで、テキストを直接編集せず、自然な方法でソース コードを作成、変更、再配置できるようにします。</span><span class="sxs-lookup"><span data-stu-id="df415-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="df415-109">ツリーを作成して操作することで、ツールでソース コードを簡単に作成して再配置することができます。</span><span class="sxs-lookup"><span data-stu-id="df415-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="df415-110">構文ツリー</span><span class="sxs-lookup"><span data-stu-id="df415-110">Syntax trees</span></span>

<span data-ttu-id="df415-111">構文ツリーは、コンパイル、コード分析、バインディング、リファクタリング、IDE 機能、コード生成に使用されるプライマリ構造です。</span><span class="sxs-lookup"><span data-stu-id="df415-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="df415-112">ソース コードは、最初に識別され、多くのよく知られている構造的な言語要素の 1 つに分類されないと、どの部分も認識されません。</span><span class="sxs-lookup"><span data-stu-id="df415-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="df415-113">構文ツリーには、3 つのキー属性があります。</span><span class="sxs-lookup"><span data-stu-id="df415-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="df415-114">1 番目の属性は、構文ツリーがすべてのソース情報を正確に保持するためのものです。</span><span class="sxs-lookup"><span data-stu-id="df415-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="df415-115">これは、構文ツリーには、ソース テキスト内で見つかったすべての情報、すべての文法的なコンストラクト、すべての構文トークン、およびその間にある他のすべてのもの (空白文字、コメント、プリプロセッサ ディレクティブを含む) が含まれることを意味します。</span><span class="sxs-lookup"><span data-stu-id="df415-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="df415-116">たとえば、ソースに記載されている各リテラルは、入力されているとおりに表されます。</span><span class="sxs-lookup"><span data-stu-id="df415-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="df415-117">構文ツリーは、プログラムが不完全または形式が正しくない場合にも、構文ツリー内のスキップされたトークンまたは見つからないトークンを表すことで、ソース コードのエラーを表します。</span><span class="sxs-lookup"><span data-stu-id="df415-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>

<span data-ttu-id="df415-118">これにより、構文ツリーの 2 番目の属性が有効になります。</span><span class="sxs-lookup"><span data-stu-id="df415-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="df415-119">パーサーから取得された構文ツリーは、解析元の正確なテキストを生成できます。</span><span class="sxs-lookup"><span data-stu-id="df415-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="df415-120">任意の構文ノードから、そのノードで root 化されたサブツリーのテキスト表現を取得することができます。</span><span class="sxs-lookup"><span data-stu-id="df415-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="df415-121">これは、ソース テキストを構築および編集する方法として構文ツリーが使用できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="df415-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="df415-122">ツリーを作成することによって、暗黙的に同じテキストを作成しており、構文ツリーを編集することで、既存のツリーへの変更から新しいツリーを作成し、効果的にテキストを編集しています。</span><span class="sxs-lookup"><span data-stu-id="df415-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="df415-123">構文ツリーの 3 番目の属性は、変更不可でスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="df415-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="df415-124">つまり、取得後のツリーは、コードの現在の状態のスナップショットで、変化しないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="df415-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="df415-125">これにより、ロックや重複を発生させずに、複数のユーザーが異なるスレッドで同時に同じ構文ツリーと対話できます。</span><span class="sxs-lookup"><span data-stu-id="df415-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="df415-126">ツリーは変更不可でツリーを直接変更することはできないため、ツリーの追加のスナップショットを作成することで構文ツリーを作成および変更するファクトリ メソッドが役立ちます。</span><span class="sxs-lookup"><span data-stu-id="df415-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="df415-127">基になるノードを再利用するという点でツリーは効果的であるため、追加のメモリをほとんど使用せずに、新しいバージョンをすばやく再構築することができます。</span><span class="sxs-lookup"><span data-stu-id="df415-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="df415-128">構文ツリーは、文字どおりのツリー データ構造で、非終端構造の要素が他の要素の親となります。</span><span class="sxs-lookup"><span data-stu-id="df415-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="df415-129">各構文ツリーは、ノード、トークン、およびトリビアで構成されます。</span><span class="sxs-lookup"><span data-stu-id="df415-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="df415-130">構文ノード</span><span class="sxs-lookup"><span data-stu-id="df415-130">Syntax nodes</span></span>

<span data-ttu-id="df415-131">構文ノードは、構文ツリーのプライマリ要素の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="df415-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="df415-132">これらのノードは、宣言、ステートメント、句、および式などの構文構造を表します。</span><span class="sxs-lookup"><span data-stu-id="df415-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="df415-133">構文ノードの各カテゴリは、<xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> から派生した別のクラスによって表されます。</span><span class="sxs-lookup"><span data-stu-id="df415-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="df415-134">一連のノード クラスは拡張できません。</span><span class="sxs-lookup"><span data-stu-id="df415-134">The set of node classes is not extensible.</span></span>

<span data-ttu-id="df415-135">すべての構文ノードは、構文ツリー内の非終端ノードで、これは他のノードとトークンを常に子として持つことを意味します。</span><span class="sxs-lookup"><span data-stu-id="df415-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="df415-136">別のノードの子として、各ノードは <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> プロパティからアクセスできる親ノードを持ちます。</span><span class="sxs-lookup"><span data-stu-id="df415-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="df415-137">ノードとツリーは変更できないため、ノードの親が変わることはありません。</span><span class="sxs-lookup"><span data-stu-id="df415-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="df415-138">ツリーのルートには Null 親があります。</span><span class="sxs-lookup"><span data-stu-id="df415-138">The root of the tree has a null parent.</span></span>

<span data-ttu-id="df415-139">各ノードには <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> メソッドがあり、子ノードのリストをソース テキスト内の位置に基づいて順番に返します。</span><span class="sxs-lookup"><span data-stu-id="df415-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="df415-140">このリストにはトークンは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="df415-140">This list does not contain tokens.</span></span> <span data-ttu-id="df415-141">各ノードには、<xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>、<xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>、または <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> などの子孫を調べるメソッドもあります。これらは、そのノードをルートとするサブツリー内に存在するすべてのノード、トークン、またはトリビアのリストを表しています。</span><span class="sxs-lookup"><span data-stu-id="df415-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the sub-tree rooted by that node.</span></span>

<span data-ttu-id="df415-142">さらに、構文ノードの各サブクラスは、厳密に型指定されたプロパティを通じて、まったく同じ子を公開します。</span><span class="sxs-lookup"><span data-stu-id="df415-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="df415-143">たとえば、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> ノード クラスには二項演算子に固有の 3 つのプロパティ、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> があります。</span><span class="sxs-lookup"><span data-stu-id="df415-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="df415-144"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> と <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> の型は <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> で、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> の型は <xref:Microsoft.CodeAnalysis.SyntaxToken> です。</span><span class="sxs-lookup"><span data-stu-id="df415-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="df415-145">一部の構文ノードには、省略可能な子があります。</span><span class="sxs-lookup"><span data-stu-id="df415-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="df415-146">たとえば、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> には省略可能な <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax> があります。</span><span class="sxs-lookup"><span data-stu-id="df415-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="df415-147">子が存在しない場合、プロパティは null を返します。</span><span class="sxs-lookup"><span data-stu-id="df415-147">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="df415-148">構文トークン</span><span class="sxs-lookup"><span data-stu-id="df415-148">Syntax tokens</span></span>

<span data-ttu-id="df415-149">構文トークンとは、コードの最小の構文フラグメントを表す、言語文法の終端です。</span><span class="sxs-lookup"><span data-stu-id="df415-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="df415-150">これらが他のノードやトークンの親になることはありません。</span><span class="sxs-lookup"><span data-stu-id="df415-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="df415-151">構文トークンは、キーワード、識別子、リテラル、および句読点で構成されます。</span><span class="sxs-lookup"><span data-stu-id="df415-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="df415-152">効率を高めるため、<xref:Microsoft.CodeAnalysis.SyntaxToken> 型は CLR 値型になっています。</span><span class="sxs-lookup"><span data-stu-id="df415-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="df415-153">そのため、構文ノードとは異なり、すべての種類のトークンに対して 1 つの構造しかなく、プロパティを組み合わせることで、表現されているトークンの種類に応じて意味を持たせます。</span><span class="sxs-lookup"><span data-stu-id="df415-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="df415-154">たとえば、整数リテラル トークンは、数値を表します。</span><span class="sxs-lookup"><span data-stu-id="df415-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="df415-155">リテラル トークンには、トークンの範囲となる未加工のソース テキストに加え、正確にデコードされた整数値を示す <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="df415-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="df415-156">このプロパティは、多くのプリミティブ型の 1 つである場合があるため、<xref:System.Object> として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="df415-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="df415-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> プロパティは <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> プロパティと同じ情報を提供しますが、このプロパティは常に <xref:System.String> として型指定されます。</span><span class="sxs-lookup"><span data-stu-id="df415-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="df415-158">C# ソース テキスト内の識別子には、Unicode のエスケープ文字を含めることができますが、エスケープ シーケンスの構文自体は、識別子名の一部と見なされません。</span><span class="sxs-lookup"><span data-stu-id="df415-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="df415-159">そのため、トークンの範囲である未加工のテキストにはエスケープ シーケンスが含まれますが、<xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> プロパティには含まれません。</span><span class="sxs-lookup"><span data-stu-id="df415-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="df415-160">代わりに、エスケープで識別される Unicode 文字が含まれます。</span><span class="sxs-lookup"><span data-stu-id="df415-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="df415-161">たとえば、ソース テキストに `\u03C0` として記述された識別子が含まれている場合、このトークンの <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> プロパティは `π` を返します。</span><span class="sxs-lookup"><span data-stu-id="df415-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="df415-162">構文トリビア</span><span class="sxs-lookup"><span data-stu-id="df415-162">Syntax trivia</span></span>

<span data-ttu-id="df415-163">構文トリビアは、空白、コメント、およびプリプロセッサ ディレクティブなど、コードを通常に理解するためにはさほど重要ではないソース テキストの部分を表します。</span><span class="sxs-lookup"><span data-stu-id="df415-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="df415-164">構文トークンと同じく、トリビアも値型です。</span><span class="sxs-lookup"><span data-stu-id="df415-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="df415-165">トリビアのすべての種類を記述するために 1 つの <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> 型が使用されます。</span><span class="sxs-lookup"><span data-stu-id="df415-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="df415-166">トリビアは通常の言語構文の一部ではなく、任意の 2 つのトークンの間の任意の場所に表示できるため、トリビアはノードの子として構文ツリーには含まれません。</span><span class="sxs-lookup"><span data-stu-id="df415-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="df415-167">しかしトリビアは、リファクタリングなどの機能を実装するときや、ソース テキストへの忠実性を維持するには重要なため、構文ツリーの一部として存在します。</span><span class="sxs-lookup"><span data-stu-id="df415-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="df415-168">トークンの <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> または <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> コレクションを調べることで、トリビアにアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="df415-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="df415-169">ソース テキストが解析される時に、トリビアのシーケンスがトークンに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="df415-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="df415-170">一般に、その後トークンは任意のトリビアを次のトークンまで同じ行で所有します。</span><span class="sxs-lookup"><span data-stu-id="df415-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="df415-171">その行以降のすべてのトリビアは、後続のトークンに関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="df415-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="df415-172">ソース ファイル内の最初のトークンがすべての初期トリビアを取得し、ファイル内のトリビアの最後のシーケンスが EOF トークンに付加されます。それ以外の場合は幅が 0 になります。</span><span class="sxs-lookup"><span data-stu-id="df415-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="df415-173">構文ノードやトークンとは異なり、構文トリビアには親がありません。</span><span class="sxs-lookup"><span data-stu-id="df415-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="df415-174">しかし、構文トリビアはツリーの一部で、それぞれが 1 つのトークンに関連付けられているため、<xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> プロパティを使用して、トリビアが関連付けられているトークンにアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="df415-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="df415-175">範囲</span><span class="sxs-lookup"><span data-stu-id="df415-175">Spans</span></span>

<span data-ttu-id="df415-176">ノード、トークン、またはトリビアはそれぞれ、ソース テキスト内の各自の位置と構成文字数を把握しています。</span><span class="sxs-lookup"><span data-stu-id="df415-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="df415-177">テキストの位置は、0 から始まる `char` インデックスの 32 ビット整数値として表されます。</span><span class="sxs-lookup"><span data-stu-id="df415-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="df415-178"><xref:Microsoft.CodeAnalysis.Text.TextSpan> オブジェクトは開始位置と文字数で、どちらも整数として表されます。</span><span class="sxs-lookup"><span data-stu-id="df415-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="df415-179"><xref:Microsoft.CodeAnalysis.Text.TextSpan> の長さが 0 の場合、2 つの文字の間の場所を参照します。</span><span class="sxs-lookup"><span data-stu-id="df415-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="df415-180">各ノードには、<xref:Microsoft.CodeAnalysis.Text.TextSpan>、<xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> という 2 つの <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> プロパティが含まれます。</span><span class="sxs-lookup"><span data-stu-id="df415-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="df415-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> プロパティは、ノードのサブツリー内の最初のトークンの先頭から最後のトークンの末尾までのテキスト範囲です。</span><span class="sxs-lookup"><span data-stu-id="df415-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="df415-182">この範囲には、先頭または末尾のトリビアはいずれも含まれません。</span><span class="sxs-lookup"><span data-stu-id="df415-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="df415-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> プロパティは、ノードの通常の範囲に加え、任意の先頭または末尾のトリビアの範囲を含むテキスト範囲です。</span><span class="sxs-lookup"><span data-stu-id="df415-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="df415-184">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="df415-184">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="df415-185">ブロック内のステートメント ノードには、1 つの縦棒 (|) によって示される範囲があります。</span><span class="sxs-lookup"><span data-stu-id="df415-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="df415-186">これには文字 `throw new Exception("Not right.");` が含まれています。</span><span class="sxs-lookup"><span data-stu-id="df415-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="df415-187">完全な範囲は、二重の縦棒 (||) によって示されます。</span><span class="sxs-lookup"><span data-stu-id="df415-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="df415-188">これには、範囲と同じ文字と先頭および末尾のトリビアに関連付けられている文字が含まれます。</span><span class="sxs-lookup"><span data-stu-id="df415-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="df415-189">種類</span><span class="sxs-lookup"><span data-stu-id="df415-189">Kinds</span></span>

<span data-ttu-id="df415-190">ノード、トークン、またはトリビアにはそれぞれ、表される正確な構文要素を識別する <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> 型の <xref:System.Int32?displayProperty=nameWithType> プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="df415-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="df415-191">この値は、言語固有の列挙型にキャストすることができます。</span><span class="sxs-lookup"><span data-stu-id="df415-191">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="df415-192">C# または Visual Basic の各言語には、文法で可能なすべてのノード、トークン、およびトリビア要素を一覧表示する、1 つの `SyntaxKind` 列挙型 (それぞれ <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> と <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>) があります。</span><span class="sxs-lookup"><span data-stu-id="df415-192">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="df415-193">この変換は、<xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> または <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> の拡張メソッドにアクセスすることで自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="df415-193">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="df415-194"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> プロパティは、同じノード クラスを共有する構文ノード型の簡単なあいまいさ排除を可能にします。</span><span class="sxs-lookup"><span data-stu-id="df415-194">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="df415-195">トークンとトリビアでは、このプロパティは要素の型を区別するための唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="df415-195">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="df415-196">たとえば、1 つの <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> クラスに、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>、および <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> が子としてあるとします。</span><span class="sxs-lookup"><span data-stu-id="df415-196">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="df415-197"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> プロパティは、構文ノードの種類が <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>、または <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> であるかどうかを識別します。</span><span class="sxs-lookup"><span data-stu-id="df415-197">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="df415-198">エラー</span><span class="sxs-lookup"><span data-stu-id="df415-198">Errors</span></span>

<span data-ttu-id="df415-199">ソース テキストに構文エラーが含まれている場合でも、ソースへのラウンドトリップが可能な完全な構文ツリーが公開されます。</span><span class="sxs-lookup"><span data-stu-id="df415-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="df415-200">パーサーは、定義されている言語の構文に準拠しないコードを検出すると、次の 2 つのいずれかの手法を使って構文ツリーを作成します。</span><span class="sxs-lookup"><span data-stu-id="df415-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="df415-201">1 つ目は、パーサーが特定の種類のトークンを想定していたがそれが見つからない場合、その見つからないトークンを構文ツリーの想定されていた場所に挿入します。</span><span class="sxs-lookup"><span data-stu-id="df415-201">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="df415-202">見つからないトークンは、想定されていた実際のトークンを表しますが、範囲は空で、その <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> プロパティは `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="df415-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="df415-203">2 つ目は、パーサーは解析を続行できるトークンが見つかるまでトークンをスキップします。</span><span class="sxs-lookup"><span data-stu-id="df415-203">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="df415-204">この場合、スキップされたトークンは、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia> の種類を持つトリビア ノードとしてアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="df415-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
