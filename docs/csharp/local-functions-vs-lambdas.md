---
title: ローカル関数とラムダ式の比較
description: ローカル関数がラムダ式よりも適した選択肢となり得る理由について。
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173342"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="fb4b0-103">ローカル関数とラムダ式の比較</span><span class="sxs-lookup"><span data-stu-id="fb4b0-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="fb4b0-104">一見したところ、[ローカル関数](programming-guide/classes-and-structs/local-functions.md)と[ラムダ式](./programming-guide/statements-expressions-operators/lambda-expressions.md)は、非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="fb4b0-105">多くの場合、ラムダ式とローカル関数の使用のどちらを選択するかは、スタイルと個人的な好みの問題です。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="fb4b0-106">ただし、どちらか一方を使用できる場合、認識しておくべき実質的な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="fb4b0-107">階乗アルゴリズムのローカル関数とラムダ式の実装の違いについて見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="fb4b0-108">まずは、ローカル関数を使用するバージョンです。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="fb4b0-109">ラムダ式を使用するバージョンの実装と比較します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="fb4b0-110">ローカル関数には名前があります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-110">The local functions have names.</span></span> <span data-ttu-id="fb4b0-111">ラムダ式は匿名メソッドであり、`Func` または `Action` 型である変数に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="fb4b0-112">ローカル関数を宣言する場合、引数の型と戻り値の型は関数宣言の一部となります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="fb4b0-113">引数の型と戻り値の型は、ラムダ式の本体の一部ではなく、ラムダ式の変数型宣言の一部となります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="fb4b0-114">これら 2 つの違いにより、コードがわかりやすくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="fb4b0-115">ローカル関数には、ラムダ式とは異なる確実な代入のルールがあります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="fb4b0-116">ローカル関数宣言は、スコープ内にある任意のコードの場所から参照できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="fb4b0-117">ラムダ式はデリゲート変数に割り当てないと、アクセスできません (ラムダ式を参照するデリゲートを通じて呼び出すこともできません)ラムダ式を使用したバージョンでは、ラムダ式 `nthFactorial` を定義する前に、宣言と初期化を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="fb4b0-118">その手順を踏まないと、`nthFactorial` の割り当て前に参照することによるコンパイル時エラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="fb4b0-119">これらの違いは、再帰的なアルゴリズムの作成はローカル関数を使用する方が簡単であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="fb4b0-120">自身を呼び出すローカル関数を宣言して定義することができます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="fb4b0-121">ラムダ式は宣言して、既定値を割り当てないと、同じラムダ式を参照する本体に再割り当てできません。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="fb4b0-122">確実な代入ルールは、ローカル関数またはラムダ式でキャプチャされる変数にも影響します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="fb4b0-123">ローカル関数とラムダ式の両方のルールでは、ローカル関数またはラムダ式がデリゲートに変換された時点で、キャプチャされた変数が確実に代入されることが要求されます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="fb4b0-124">違いは、ラムダ式が宣言時にデリゲートに変換されることです。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="fb4b0-125">ローカル関数は、デリゲートとして使用される場合にのみ、デリゲートに変換されます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="fb4b0-126">ローカル関数を宣言し、メソッドのように呼び出して参照のみを行う場合は、デリゲートに変換されません。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="fb4b0-127">このルールでは、外側のスコープ内の便利な場所でローカル関数を宣言できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="fb4b0-128">親メソッドの末尾 (すべての return ステートメントの後) にローカル関数を宣言するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="fb4b0-129">3 つ目は、コンパイラは静的分析を実行できることです。これにより、ローカル関数で外側のスコープ内のキャプチャされた変数を確実に割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="fb4b0-130">次の例について考えます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="fb4b0-131">コンパイラは、呼び出し時に `LocalFunction` が `y` を確実に割り当てるかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="fb4b0-132">`return` ステートメントの前に `LocalFunction` が呼び出されるため、`y` は `return` ステートメントで確実に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="fb4b0-133">分析例を使用する分析では、4 つ目の違いを確認できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="fb4b0-134">ローカル関数では、その使用に応じて、ラムダ式では常に必要なヒープの割り当てを回避できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="fb4b0-135">ローカル関数がデリゲートに変換されておらず、ローカル関数でキャプチャされたいずれの変数も、デリゲートに変換された他のラムダやローカル関数でキャプチャされていない場合、コンパイラはヒープの割り当てを回避できます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="fb4b0-136">次の非同期の例について考えます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="fb4b0-137">このラムダ式のクロージャに含まれるのは、`address`、`index`、および `name` 変数です。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="fb4b0-138">ローカル関数の場合、クロージャを実装するオブジェクトが `struct` になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="fb4b0-139">その構造体型はローカル関数に参照によって渡されます。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="fb4b0-140">この実装の違いにより、割り当てが少なくなります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="fb4b0-141">ラムダ式に必要なインスタンス化では、余分なメモリの割り当てが必要となり、タイム クリティカルなコード パスに影響を与えるパフォーマンス因子となる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="fb4b0-142">ローカル関数では、このオーバーヘッドは発生しません。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="fb4b0-143">上記の例では、ローカル関数のバージョンは、ラムダ式のバージョンよりも割り当てが 2 つ少なくなっています。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="fb4b0-144">このメソッドのローカル関数と同等のものも、同じクロージャのクラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="fb4b0-145">ローカル関数のクロージャが `class` として実装される場合でも、実装の詳細が `struct` である場合でも同様です。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="fb4b0-146">ローカル関数は `struct` を使用する場合がありますが、ラムダは常に `class` を使用します。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="fb4b0-147">この例では説明しませんが、最後の 1 つの利点は値のシーケンスを生成するために `yield return` 構文を使用して、ローカル関数を反復子として実装できることです。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="fb4b0-148">ラムダ式では `yield return` ステートメントは許可されません。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="fb4b0-149">ローカル関数はラムダ式より冗長に思えるかもしれませんが、実際にはさまざまな目的に役立ち、用途もさまざまです。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="fb4b0-150">ローカル関数は、別のメソッドのコンテキストからのみ呼び出される関数を記述する場合に、より効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="fb4b0-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
