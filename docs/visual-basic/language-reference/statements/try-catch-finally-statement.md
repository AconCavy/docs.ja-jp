---
title: お試しください...キャッチ...Finally ステートメント
description: Visual Basic Try/Catch/Finally ステートメントで例外処理を使用する方法について説明します。
ms.date: 12/07/2018
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
ms.custom: seodec18
ms.openlocfilehash: eb04b6cff0847009407e38a3696e9be7c700356c
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337331"
---
# <a name="trycatchfinally-statement-visual-basic"></a><span data-ttu-id="159a0-103">Try...Catch...Finally ステートメント (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="159a0-103">Try...Catch...Finally Statement (Visual Basic)</span></span>

<span data-ttu-id="159a0-104">コードを実行したまま、特定のコードブロックで発生する可能性のあるエラーの一部またはすべてを処理する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="159a0-104">Provides a way to handle some or all possible errors that may occur in a given block of code, while still running code.</span></span>

## <a name="syntax"></a><span data-ttu-id="159a0-105">構文</span><span class="sxs-lookup"><span data-stu-id="159a0-105">Syntax</span></span>

```vb
Try
    [ tryStatements ]
    [ Exit Try ]
[ Catch [ exception [ As type ] ] [ When expression ]
    [ catchStatements ]
    [ Exit Try ] ]
[ Catch ... ]
[ Finally
    [ finallyStatements ] ]
End Try
```

## <a name="parts"></a><span data-ttu-id="159a0-106">のコンポーネント</span><span class="sxs-lookup"><span data-stu-id="159a0-106">Parts</span></span>

|<span data-ttu-id="159a0-107">用語</span><span class="sxs-lookup"><span data-stu-id="159a0-107">Term</span></span>|<span data-ttu-id="159a0-108">Definition</span><span class="sxs-lookup"><span data-stu-id="159a0-108">Definition</span></span>|
|---|---|
|`tryStatements`|<span data-ttu-id="159a0-109">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-109">Optional.</span></span> <span data-ttu-id="159a0-110">エラーが発生する可能性のあるステートメント。</span><span class="sxs-lookup"><span data-stu-id="159a0-110">Statement(s) where an error can occur.</span></span> <span data-ttu-id="159a0-111">複合ステートメントにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="159a0-111">Can be a compound statement.</span></span>|
|`Catch`|<span data-ttu-id="159a0-112">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-112">Optional.</span></span> <span data-ttu-id="159a0-113">複数の `Catch` ブロックが許可されています。</span><span class="sxs-lookup"><span data-stu-id="159a0-113">Multiple `Catch` blocks permitted.</span></span> <span data-ttu-id="159a0-114">`Try` ブロックの処理中に例外が発生した場合、各 `Catch` ステートメントは、スローされた例外を表す `exception` を使用して、例外を処理するかどうかを判断するためにテキスト順に検証されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-114">If an exception occurs when processing the `Try` block, each `Catch` statement is examined in textual order to determine whether it handles the exception, with `exception` representing the exception that has been thrown.</span></span>|
|`exception`|<span data-ttu-id="159a0-115">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-115">Optional.</span></span> <span data-ttu-id="159a0-116">任意の変数名を指定します。</span><span class="sxs-lookup"><span data-stu-id="159a0-116">Any variable name.</span></span> <span data-ttu-id="159a0-117">`exception` の初期値は、スローされたエラーの値です。</span><span class="sxs-lookup"><span data-stu-id="159a0-117">The initial value of `exception` is the value of the thrown error.</span></span> <span data-ttu-id="159a0-118">キャッチされたエラーを指定するために `Catch` と共に使用します。</span><span class="sxs-lookup"><span data-stu-id="159a0-118">Used with `Catch` to specify the error caught.</span></span> <span data-ttu-id="159a0-119">省略した場合、`Catch` ステートメントは例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="159a0-119">If omitted, the `Catch` statement catches any exception.</span></span>|
|`type`|<span data-ttu-id="159a0-120">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-120">Optional.</span></span> <span data-ttu-id="159a0-121">クラスフィルターの種類を指定します。</span><span class="sxs-lookup"><span data-stu-id="159a0-121">Specifies the type of class filter.</span></span> <span data-ttu-id="159a0-122">`exception` の値が、`type` または派生型のによって指定された型である場合、識別子は例外オブジェクトにバインドされます。</span><span class="sxs-lookup"><span data-stu-id="159a0-122">If the value of `exception` is of the type specified by `type` or of a derived type, the identifier becomes bound to the exception object.</span></span>|
|`When`|<span data-ttu-id="159a0-123">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-123">Optional.</span></span> <span data-ttu-id="159a0-124">`When` 句を含む `Catch` ステートメントは、`expression` が `True`に評価された場合にのみ例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="159a0-124">A `Catch` statement with a `When` clause catches exceptions only when `expression` evaluates to `True`.</span></span> <span data-ttu-id="159a0-125">`When` 句は、例外の型をチェックした後にのみ適用され、`expression` は例外を表す識別子を参照する場合があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-125">A `When` clause is applied only after checking the type of the exception, and `expression` may refer to the identifier representing the exception.</span></span>|
|`expression`|<span data-ttu-id="159a0-126">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-126">Optional.</span></span> <span data-ttu-id="159a0-127">`Boolean`に暗黙的に変換可能である必要があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-127">Must be implicitly convertible to `Boolean`.</span></span> <span data-ttu-id="159a0-128">汎用フィルターを記述する任意の式。</span><span class="sxs-lookup"><span data-stu-id="159a0-128">Any expression that describes a generic filter.</span></span> <span data-ttu-id="159a0-129">通常、エラー番号でフィルター処理するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-129">Typically used to filter by error number.</span></span> <span data-ttu-id="159a0-130">`When` キーワードと共に使用して、エラーがキャッチされる状況を指定します。</span><span class="sxs-lookup"><span data-stu-id="159a0-130">Used with `When` keyword to specify circumstances under which the error is caught.</span></span>|
|`catchStatements`|<span data-ttu-id="159a0-131">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-131">Optional.</span></span> <span data-ttu-id="159a0-132">関連付けられている `Try` ブロックで発生したエラーを処理するステートメント。</span><span class="sxs-lookup"><span data-stu-id="159a0-132">Statement(s) to handle errors that occur in the associated `Try` block.</span></span> <span data-ttu-id="159a0-133">複合ステートメントにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="159a0-133">Can be a compound statement.</span></span>|
|`Exit Try`|<span data-ttu-id="159a0-134">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-134">Optional.</span></span> <span data-ttu-id="159a0-135">`Try...Catch...Finally` 構造体を分割するキーワード。</span><span class="sxs-lookup"><span data-stu-id="159a0-135">Keyword that breaks out of the `Try...Catch...Finally` structure.</span></span> <span data-ttu-id="159a0-136">`End Try` ステートメントの直後のコードで実行が再開されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-136">Execution resumes with the code immediately following the `End Try` statement.</span></span> <span data-ttu-id="159a0-137">`Finally` ステートメントは引き続き実行されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-137">The `Finally` statement will still be executed.</span></span> <span data-ttu-id="159a0-138">`Finally` ブロックでは許可されていません。</span><span class="sxs-lookup"><span data-stu-id="159a0-138">Not allowed in `Finally` blocks.</span></span>|
|`Finally`|<span data-ttu-id="159a0-139">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-139">Optional.</span></span> <span data-ttu-id="159a0-140">`Finally` ブロックは、実行が `Try...Catch` ステートメントの任意の部分を離れると常に実行されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-140">A `Finally` block is always executed when execution leaves any part of the `Try...Catch` statement.</span></span>|
|`finallyStatements`|<span data-ttu-id="159a0-141">省略可。</span><span class="sxs-lookup"><span data-stu-id="159a0-141">Optional.</span></span> <span data-ttu-id="159a0-142">他のすべてのエラー処理が発生した後に実行されるステートメントです。</span><span class="sxs-lookup"><span data-stu-id="159a0-142">Statement(s) that are executed after all other error processing has occurred.</span></span>|
|`End Try`|<span data-ttu-id="159a0-143">`Try...Catch...Finally` 構造体を終了します。</span><span class="sxs-lookup"><span data-stu-id="159a0-143">Terminates the `Try...Catch...Finally` structure.</span></span>|

## <a name="remarks"></a><span data-ttu-id="159a0-144">コメント</span><span class="sxs-lookup"><span data-stu-id="159a0-144">Remarks</span></span>

<span data-ttu-id="159a0-145">特定の例外がコードの特定のセクションで発生することが予想される場合は、コードを `Try` ブロックに配置し、`Catch` ブロックを使用してコントロールを保持し、発生した場合は例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="159a0-145">If you expect that a particular exception might occur during a particular section of code, put the code in a `Try` block and use a `Catch` block to retain control and handle the exception if it occurs.</span></span>

<span data-ttu-id="159a0-146">`Try…Catch` ステートメントは、`Try` ブロックと、さまざまな例外のハンドラーを指定する1つ以上の `Catch` 句で構成されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-146">A `Try…Catch` statement consists of a `Try` block followed by one or more `Catch` clauses, which specify handlers for various exceptions.</span></span> <span data-ttu-id="159a0-147">`Try` ブロックで例外がスローされると、Visual Basic は例外を処理する `Catch` ステートメントを検索します。</span><span class="sxs-lookup"><span data-stu-id="159a0-147">When an exception is thrown in a `Try` block, Visual Basic looks for the `Catch` statement that handles the exception.</span></span> <span data-ttu-id="159a0-148">一致する `Catch` ステートメントが見つからない場合、Visual Basic は、現在のメソッドを呼び出したメソッド、および呼び出し履歴を調べます。</span><span class="sxs-lookup"><span data-stu-id="159a0-148">If a matching `Catch` statement is not found, Visual Basic examines the method that called the current method, and so on up the call stack.</span></span> <span data-ttu-id="159a0-149">`Catch` ブロックが見つからない場合、Visual Basic はハンドルされない例外メッセージをユーザーに表示し、プログラムの実行を停止します。</span><span class="sxs-lookup"><span data-stu-id="159a0-149">If no `Catch` block is found, Visual Basic displays an unhandled exception message to the user and stops execution of the program.</span></span>

<span data-ttu-id="159a0-150">`Try…Catch` ステートメントでは、複数の `Catch` ステートメントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="159a0-150">You can use more than one `Catch` statement in a `Try…Catch` statement.</span></span> <span data-ttu-id="159a0-151">これを行うと、`Catch` 句の順序は順番に検査されるため、重要になります。</span><span class="sxs-lookup"><span data-stu-id="159a0-151">If you do this, the order of the `Catch` clauses is significant because they are examined in order.</span></span> <span data-ttu-id="159a0-152">例外は、特殊性の高い順にキャッチしてください。</span><span class="sxs-lookup"><span data-stu-id="159a0-152">Catch the more specific exceptions before the less specific ones.</span></span>

<span data-ttu-id="159a0-153">次の `Catch` ステートメントの条件は最も限定的ではなく、<xref:System.Exception> クラスから派生したすべての例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="159a0-153">The following `Catch` statement conditions are the least specific, and will catch all exceptions that derive from the <xref:System.Exception> class.</span></span> <span data-ttu-id="159a0-154">通常は、必要なすべての例外をキャッチした後、これらのバリエーションのいずれかを `Try...Catch...Finally` 構造の最後の `Catch` ブロックとして使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-154">You should ordinarily use one of these variations as the last `Catch` block in the `Try...Catch...Finally` structure, after catching all the specific exceptions you expect.</span></span> <span data-ttu-id="159a0-155">制御フローは、これらのいずれかのバリエーションに従う `Catch` ブロックにはできません。</span><span class="sxs-lookup"><span data-stu-id="159a0-155">Control flow can never reach a `Catch` block that follows either of these variations.</span></span>

- <span data-ttu-id="159a0-156">`type` は `Exception`です。例: `Catch ex As Exception`</span><span class="sxs-lookup"><span data-stu-id="159a0-156">The `type` is `Exception`, for example: `Catch ex As Exception`</span></span>

- <span data-ttu-id="159a0-157">ステートメントには `exception` の変数がありません。例: `Catch`</span><span class="sxs-lookup"><span data-stu-id="159a0-157">The statement has no `exception` variable, for example: `Catch`</span></span>

<span data-ttu-id="159a0-158">`Try…Catch…Finally` ステートメントが別の `Try` ブロックに入れ子になっている場合、Visual Basic は、最も内側の `Try` ブロック内の各 `Catch` ステートメントをまず調べます。</span><span class="sxs-lookup"><span data-stu-id="159a0-158">When a `Try…Catch…Finally` statement is nested in another `Try` block, Visual Basic first examines each `Catch` statement in the innermost `Try` block.</span></span> <span data-ttu-id="159a0-159">一致する `Catch` ステートメントが見つからない場合は、外側の `Try…Catch…Finally` ブロックの `Catch` ステートメントに進みます。</span><span class="sxs-lookup"><span data-stu-id="159a0-159">If no matching `Catch` statement is found, the search proceeds to the `Catch` statements of the outer `Try…Catch…Finally` block.</span></span>

<span data-ttu-id="159a0-160">`Try` ブロックのローカル変数は、個別のブロックであるため、`Catch` ブロックでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="159a0-160">Local variables from a `Try` block are not available in a `Catch` block because they are separate blocks.</span></span> <span data-ttu-id="159a0-161">複数のブロックで変数を使用する場合は、`Try...Catch...Finally` 構造体の外で変数を宣言します。</span><span class="sxs-lookup"><span data-stu-id="159a0-161">If you want to use a variable in more than one block, declare the variable outside the `Try...Catch...Finally` structure.</span></span>

> [!TIP]
> <span data-ttu-id="159a0-162">`Try…Catch…Finally` ステートメントは、IntelliSense コードスニペットとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="159a0-162">The `Try…Catch…Finally` statement is available as an IntelliSense code snippet.</span></span> <span data-ttu-id="159a0-163">コードスニペットマネージャーで、[コードパターン-If] を展開し、[ **Catch]、[プロパティ]** などをクリックして、 **[エラー処理 (例外)]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="159a0-163">In the Code Snippets Manager, expand **Code Patterns - If, For Each, Try Catch, Property, etc**, and then **Error Handling (Exceptions)**.</span></span> <span data-ttu-id="159a0-164">詳細については、「[Code Snippets](/visualstudio/ide/code-snippets)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="159a0-164">For more information, see [Code Snippets](/visualstudio/ide/code-snippets).</span></span>

## <a name="finally-block"></a><span data-ttu-id="159a0-165">Finally ブロック</span><span class="sxs-lookup"><span data-stu-id="159a0-165">Finally block</span></span>

<span data-ttu-id="159a0-166">`Try` 構造体を終了する前に実行する必要のあるステートメントが1つ以上ある場合は、`Finally` ブロックを使用します。</span><span class="sxs-lookup"><span data-stu-id="159a0-166">If you have one or more statements that must run before you exit the `Try` structure, use a `Finally` block.</span></span> <span data-ttu-id="159a0-167">制御は、`Try…Catch` 構造から渡される直前に `Finally` ブロックに渡されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-167">Control passes to the `Finally` block just before it passes out of the `Try…Catch` structure.</span></span> <span data-ttu-id="159a0-168">これは、`Try` 構造内のどこかで例外が発生した場合でも当てはまります。</span><span class="sxs-lookup"><span data-stu-id="159a0-168">This is true even if an exception occurs anywhere inside the `Try` structure.</span></span>

<span data-ttu-id="159a0-169">`Finally` ブロックは、例外が発生した場合でも実行する必要があるコードを実行する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="159a0-169">A `Finally` block is useful for running any code that must execute even if there is an exception.</span></span> <span data-ttu-id="159a0-170">コントロールは、`Try...Catch` ブロックの終了方法に関係なく、`Finally` ブロックに渡されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-170">Control is passed to the `Finally` block regardless of how the `Try...Catch` block exits.</span></span>

<span data-ttu-id="159a0-171">`Finally` ブロック内のコードは、コードが `Try` または `Catch` ブロックで `Return` ステートメントを検出した場合でも実行されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-171">The code in a `Finally` block runs even if your code encounters a `Return` statement in a `Try` or `Catch` block.</span></span> <span data-ttu-id="159a0-172">次の場合、コントロールは、`Try` または `Catch` ブロックから対応する `Finally` ブロックに渡されません。</span><span class="sxs-lookup"><span data-stu-id="159a0-172">Control does not pass from a `Try` or `Catch` block to the corresponding `Finally` block in the following cases:</span></span>

- <span data-ttu-id="159a0-173">`Try` または `Catch` ブロックで[End ステートメント](end-statement.md)が見つかりました。</span><span class="sxs-lookup"><span data-stu-id="159a0-173">An [End Statement](end-statement.md) is encountered in the `Try` or `Catch` block.</span></span>

- <span data-ttu-id="159a0-174"><xref:System.StackOverflowException>でスローされたが、`Try`または`Catch`ブロックします。</span><span class="sxs-lookup"><span data-stu-id="159a0-174">A <xref:System.StackOverflowException> is thrown in the `Try` or `Catch` block.</span></span>

<span data-ttu-id="159a0-175">実行を明示的に `Finally` ブロックに転送することは無効です。</span><span class="sxs-lookup"><span data-stu-id="159a0-175">It is not valid to explicitly transfer execution into a `Finally` block.</span></span> <span data-ttu-id="159a0-176">例外を除き、`Finally` ブロックの実行を転送することはできません。</span><span class="sxs-lookup"><span data-stu-id="159a0-176">Transferring execution out of a `Finally` block is not valid, except through an exception.</span></span>

<span data-ttu-id="159a0-177">`Try` ステートメントに少なくとも1つの `Catch` ブロックが含まれていない場合は、`Finally` ブロックが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-177">If a `Try` statement does not contain at least one `Catch` block, it must contain a `Finally` block.</span></span>

> [!TIP]
> <span data-ttu-id="159a0-178">特定の例外をキャッチする必要がない場合、`Using` ステートメントは、ブロックを終了する方法に関係なく、`Try…Finally` ブロックのように動作し、リソースの破棄を保証します。</span><span class="sxs-lookup"><span data-stu-id="159a0-178">If you do not have to catch specific exceptions, the `Using` statement behaves like a `Try…Finally` block, and guarantees disposal of the resources, regardless of how you exit the block.</span></span> <span data-ttu-id="159a0-179">これは、ハンドルされない例外が発生した場合でも同様です。</span><span class="sxs-lookup"><span data-stu-id="159a0-179">This is true even with an unhandled exception.</span></span> <span data-ttu-id="159a0-180">詳細については、「[sing ステートメント](using-statement.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="159a0-180">For more information, see [Using Statement](using-statement.md).</span></span>

## <a name="exception-argument"></a><span data-ttu-id="159a0-181">Exception 引数</span><span class="sxs-lookup"><span data-stu-id="159a0-181">Exception argument</span></span>

<span data-ttu-id="159a0-182">`Catch` block `exception` 引数は <xref:System.Exception> クラスのインスタンス、または `Exception` クラスから派生したクラスです。</span><span class="sxs-lookup"><span data-stu-id="159a0-182">The `Catch` block `exception` argument is an instance of the <xref:System.Exception> class or a class that derives from the `Exception` class.</span></span> <span data-ttu-id="159a0-183">`Exception` クラスのインスタンスは、`Try` ブロックで発生したエラーに対応します。</span><span class="sxs-lookup"><span data-stu-id="159a0-183">The `Exception` class instance corresponds to the error that occurred in the `Try` block.</span></span>

<span data-ttu-id="159a0-184">`Exception` オブジェクトのプロパティは、例外の原因と場所を特定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="159a0-184">The properties of the `Exception` object help to identify the cause and location of an exception.</span></span> <span data-ttu-id="159a0-185">たとえば、<xref:System.Exception.StackTrace%2A> プロパティには、例外の原因となったメソッドが一覧表示され、コード内でエラーが発生した場所を見つけるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="159a0-185">For example, the <xref:System.Exception.StackTrace%2A> property lists the called methods that led to the exception, helping you find where the error occurred in the code.</span></span> <span data-ttu-id="159a0-186"><xref:System.Exception.Message%2A> は、例外を説明するメッセージを返します。</span><span class="sxs-lookup"><span data-stu-id="159a0-186"><xref:System.Exception.Message%2A> returns a message that describes the exception.</span></span> <span data-ttu-id="159a0-187"><xref:System.Exception.HelpLink%2A> は、関連付けられているヘルプファイルへのリンクを返します。</span><span class="sxs-lookup"><span data-stu-id="159a0-187"><xref:System.Exception.HelpLink%2A> returns a link to an associated Help file.</span></span> <span data-ttu-id="159a0-188"><xref:System.Exception.InnerException%2A> は、現在の例外の原因となった `Exception` オブジェクトを返すか、元の `Exception`がない場合は `Nothing` を返します。</span><span class="sxs-lookup"><span data-stu-id="159a0-188"><xref:System.Exception.InnerException%2A> returns the `Exception` object that caused the current exception, or it returns `Nothing` if there is no original `Exception`.</span></span>

## <a name="considerations-when-using-a-trycatch-statement"></a><span data-ttu-id="159a0-189">Try…Catchステートメントを使用に関する注意点</span><span class="sxs-lookup"><span data-stu-id="159a0-189">Considerations when using a Try…Catch statement</span></span>

<span data-ttu-id="159a0-190">`Try…Catch` ステートメントのみを使用して、異常なプログラムイベントまたは予期しないプログラムイベントの発生を通知します。</span><span class="sxs-lookup"><span data-stu-id="159a0-190">Use a `Try…Catch` statement only to signal the occurrence of unusual or unanticipated program events.</span></span> <span data-ttu-id="159a0-191">これには、次のような理由があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-191">Reasons for this include the following:</span></span>

- <span data-ttu-id="159a0-192">実行時に例外をキャッチするとオーバーヘッドが増加するため、例外を回避するための事前チェックよりも低速になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-192">Catching exceptions at runtime creates additional overhead, and is likely to be slower than pre-checking to avoid exceptions.</span></span>

- <span data-ttu-id="159a0-193">`Catch` ブロックが正しく処理されない場合、例外はユーザーに正しく報告されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-193">If a `Catch` block is not handled correctly, the exception might not be reported correctly to users.</span></span>

- <span data-ttu-id="159a0-194">例外処理を使用すると、プログラムがより複雑になります。</span><span class="sxs-lookup"><span data-stu-id="159a0-194">Exception handling makes a program more complex.</span></span>

<span data-ttu-id="159a0-195">常に、発生する可能性がある条件をチェックするために `Try…Catch` ステートメントは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="159a0-195">You do not always need a `Try…Catch` statement to check for a condition that is likely to occur.</span></span> <span data-ttu-id="159a0-196">次の例では、ファイルが存在するかどうかを確認してから開こうとします。</span><span class="sxs-lookup"><span data-stu-id="159a0-196">The following example checks whether a file exists before trying to open it.</span></span> <span data-ttu-id="159a0-197">これにより、<xref:System.IO.File.OpenText%2A> メソッドによってスローされた例外をキャッチする必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="159a0-197">This reduces the need for catching an exception thrown by the <xref:System.IO.File.OpenText%2A> method.</span></span>

[!code-vb[VbVbalrStatements#94](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#94)]

<span data-ttu-id="159a0-198">スレッドセーフなログ記録と適切なメッセージのどちらを使用しても、`Catch` ブロック内のコードがユーザーに例外を正しく報告できることを確認します。</span><span class="sxs-lookup"><span data-stu-id="159a0-198">Ensure that code in `Catch` blocks can properly report exceptions to users, whether through thread-safe logging or appropriate messages.</span></span> <span data-ttu-id="159a0-199">それ以外の場合、例外は不明なままになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-199">Otherwise, exceptions might remain unknown.</span></span>

## <a name="async-methods"></a><span data-ttu-id="159a0-200">非同期メソッド</span><span class="sxs-lookup"><span data-stu-id="159a0-200">Async methods</span></span>

<span data-ttu-id="159a0-201">[非同期](../modifiers/async.md)修飾子を使用してメソッドをマークした場合は、メソッドで[Await](../operators/await-operator.md)演算子を使用できます。</span><span class="sxs-lookup"><span data-stu-id="159a0-201">If you mark a method with the [Async](../modifiers/async.md) modifier, you can use the [Await](../operators/await-operator.md) operator in the method.</span></span> <span data-ttu-id="159a0-202">`Await` 演算子を持つステートメントは、待機中のタスクが完了するまでメソッドの実行を中断します。</span><span class="sxs-lookup"><span data-stu-id="159a0-202">A statement with the `Await` operator suspends execution of the method until the awaited task completes.</span></span> <span data-ttu-id="159a0-203">このタスクは、進行中の作業を表します。</span><span class="sxs-lookup"><span data-stu-id="159a0-203">The task represents ongoing work.</span></span> <span data-ttu-id="159a0-204">`Await` オペレーターに関連付けられているタスクが完了すると、同じ方法で実行が再開されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-204">When the task that's associated with the `Await` operator finishes, execution resumes in the same method.</span></span> <span data-ttu-id="159a0-205">詳細については、「[非同期プログラムの制御フロー](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="159a0-205">For more information, see [Control Flow in Async Programs](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).</span></span>

<span data-ttu-id="159a0-206">非同期メソッドによって返されるタスクは、未処理の例外によって完了したことを示す、faulted 状態で終了することがあります。</span><span class="sxs-lookup"><span data-stu-id="159a0-206">A task returned by an Async method may end in a faulted state, indicating that it completed due to an unhandled exception.</span></span> <span data-ttu-id="159a0-207">また、タスクは取り消された状態で終了することもあります。その結果、await 式から `OperationCanceledException` がスローされます。</span><span class="sxs-lookup"><span data-stu-id="159a0-207">A task may also end in a canceled state, which results in an `OperationCanceledException` being thrown out of the await expression.</span></span> <span data-ttu-id="159a0-208">いずれかの種類の例外をキャッチするには、タスクに関連付けられている `Await` 式を `Try` ブロックに配置し、`Catch` ブロックで例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="159a0-208">To catch either type of exception, place the `Await` expression that's associated with the task in a `Try` block, and catch the exception in the `Catch` block.</span></span> <span data-ttu-id="159a0-209">例については、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="159a0-209">An example is provided later in this topic.</span></span>

<span data-ttu-id="159a0-210">複数の例外がエラーの原因になっているため、タスクが faulted 状態になることがあります。</span><span class="sxs-lookup"><span data-stu-id="159a0-210">A task can be in a faulted state because multiple exceptions were responsible for its faulting.</span></span> <span data-ttu-id="159a0-211">たとえば、タスクは <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> の呼び出しの結果になることがあります。</span><span class="sxs-lookup"><span data-stu-id="159a0-211">For example, the task might be the result of a call to <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="159a0-212">このようなタスクを待機すると、キャッチされた例外は例外の1つにすぎないため、どの例外がキャッチされるかを予測することはできません。</span><span class="sxs-lookup"><span data-stu-id="159a0-212">When you await such a task, the caught exception is only one of the exceptions, and you can't predict which exception will be caught.</span></span> <span data-ttu-id="159a0-213">例については、このトピックの後半で説明します。</span><span class="sxs-lookup"><span data-stu-id="159a0-213">An example is provided later in this topic.</span></span>

<span data-ttu-id="159a0-214">`Await` 式は、`Catch` ブロックまたは `Finally` ブロック内には指定できません。</span><span class="sxs-lookup"><span data-stu-id="159a0-214">An `Await` expression can't be inside a `Catch` block or `Finally` block.</span></span>

## <a name="iterators"></a><span data-ttu-id="159a0-215">Iterators</span><span class="sxs-lookup"><span data-stu-id="159a0-215">Iterators</span></span>

<span data-ttu-id="159a0-216">反復子メソッドまたは`Get`アクセサーは、コレクションに対するカスタム イテレーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="159a0-216">An iterator function or `Get` accessor performs a custom iteration over a collection.</span></span> <span data-ttu-id="159a0-217">反復子は[Yield](yield-statement.md)ステートメントを使用して、コレクションの各要素を一度に 1 つずつ返します。</span><span class="sxs-lookup"><span data-stu-id="159a0-217">An iterator uses a [Yield](yield-statement.md) statement to return each element of the collection one at a time.</span></span> <span data-ttu-id="159a0-218">[For Each...Next ステートメント](for-each-next-statement.md)を使用して反復子メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="159a0-218">You call an iterator function by using a [For Each...Next Statement](for-each-next-statement.md).</span></span>

<span data-ttu-id="159a0-219">`Yield`は`Try`ブロック内に置くことができます。</span><span class="sxs-lookup"><span data-stu-id="159a0-219">A `Yield` statement can be inside a `Try` block.</span></span> <span data-ttu-id="159a0-220">`Yield`ステートメントを含む`Try`ブロックは、`Catch`ブロックを持つことができ、そして、`Finally`ブロックを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="159a0-220">A `Try` block that contains a `Yield` statement can have `Catch` blocks, and can have a `Finally` block.</span></span> <span data-ttu-id="159a0-221">例については、[反復子](../../programming-guide/concepts/iterators.md)の`Try`ブロックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="159a0-221">See the "Try Blocks in Visual Basic" section of [Iterators](../../programming-guide/concepts/iterators.md) for an example.</span></span>

<span data-ttu-id="159a0-222">`Yield`ステートメントは、`Catch`ブロックまたは`Finally`ブロック内で使用できません。</span><span class="sxs-lookup"><span data-stu-id="159a0-222">A `Yield` statement cannot be inside a `Catch` block or a `Finally` block.</span></span>

<span data-ttu-id="159a0-223">`For Each`本体 (反復子メソッドの外側)が例外をスローした場合、反復子メソッド内の`Catch`ブロックは実行されませんが、反復子メソッド内の`Finally`ブロックは実行されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-223">If the `For Each` body (outside of the iterator function) throws an exception, a `Catch` block in the iterator function is not executed, but a `Finally` block in the iterator function is executed.</span></span> <span data-ttu-id="159a0-224">反復子メソッド内の`Catch`ブロックは、反復子メソッド内で発生する例外のみをキャッチします。</span><span class="sxs-lookup"><span data-stu-id="159a0-224">A `Catch` block inside an iterator function catches only exceptions that occur inside the iterator function.</span></span>

## <a name="partial-trust-situations"></a><span data-ttu-id="159a0-225">部分信頼の状況</span><span class="sxs-lookup"><span data-stu-id="159a0-225">Partial-trust situations</span></span>

<span data-ttu-id="159a0-226">部分的に信頼された状況 (ネットワーク共有でホストされているアプリケーションなど) では、`Try...Catch...Finally` は、呼び出しを含むメソッドが呼び出される前に発生したセキュリティ例外をキャッチしません。</span><span class="sxs-lookup"><span data-stu-id="159a0-226">In partial-trust situations, such as an application hosted on a network share, `Try...Catch...Finally` does not catch security exceptions that occur before the method that contains the call is invoked.</span></span> <span data-ttu-id="159a0-227">次の例では、サーバー共有に配置し、そこから実行すると、"SecurityException: Request Failed" というエラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-227">The following example, when you put it on a server share and run from there, produces the error "System.Security.SecurityException: Request Failed."</span></span> <span data-ttu-id="159a0-228">セキュリティ例外の詳細については、<xref:System.Security.SecurityException> クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="159a0-228">For more information about security exceptions, see the <xref:System.Security.SecurityException> class.</span></span>

[!code-vb[VbVbalrStatements#85](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#85)]

<span data-ttu-id="159a0-229">このような部分信頼の場合は、`Process.Start` ステートメントを別の `Sub`に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="159a0-229">In such a partial-trust situation, you have to put the `Process.Start` statement in a separate `Sub`.</span></span> <span data-ttu-id="159a0-230">`Sub` の最初の呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="159a0-230">The initial call to the `Sub` will fail.</span></span> <span data-ttu-id="159a0-231">これにより、`Process.Start` を含む `Sub` が開始され、セキュリティ例外が生成される前に、`Try...Catch` をキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="159a0-231">This enables `Try...Catch` to catch it before the `Sub` that contains `Process.Start` is started and the security exception produced.</span></span>

## <a name="examples"></a><span data-ttu-id="159a0-232">使用例</span><span class="sxs-lookup"><span data-stu-id="159a0-232">Examples</span></span>

### <a name="the-structure-of-trycatchfinally"></a><span data-ttu-id="159a0-233">Try...Catch...Finallyの構造</span><span class="sxs-lookup"><span data-stu-id="159a0-233">The structure of Try...Catch...Finally</span></span>

<span data-ttu-id="159a0-234">次の例は`Try...Catch...Finally`ステートメントの構造を示しています。</span><span class="sxs-lookup"><span data-stu-id="159a0-234">The following example illustrates the structure of the `Try...Catch...Finally` statement.</span></span>

[!code-vb[VbVbalrStatements#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#86)]  

### <a name="exception-in-a-method-called-from-a-try-block"></a><span data-ttu-id="159a0-235">Try ブロックから呼び出されたメソッドで例外が発生しました</span><span class="sxs-lookup"><span data-stu-id="159a0-235">Exception in a method called from a Try block</span></span>

<span data-ttu-id="159a0-236">次の例では、`CreateException` メソッドによって `NullReferenceException`がスローされます。</span><span class="sxs-lookup"><span data-stu-id="159a0-236">In the following example, the `CreateException` method throws a `NullReferenceException`.</span></span> <span data-ttu-id="159a0-237">例外を生成するコードが `Try` ブロックに含まれていません。</span><span class="sxs-lookup"><span data-stu-id="159a0-237">The code that generates the exception is not in a `Try` block.</span></span> <span data-ttu-id="159a0-238">したがって、`CreateException` メソッドは例外を処理しません。</span><span class="sxs-lookup"><span data-stu-id="159a0-238">Therefore, the `CreateException` method does not handle the exception.</span></span> <span data-ttu-id="159a0-239">`RunSample` メソッドは、`CreateException` メソッドの呼び出しが `Try` ブロック内にあるため、例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="159a0-239">The `RunSample` method does handle the exception because the call to the `CreateException` method is in a `Try` block.</span></span>

<span data-ttu-id="159a0-240">この例には、いくつかの種類の例外の `Catch` ステートメントが含まれており、最も一般的なものから順に説明されています。</span><span class="sxs-lookup"><span data-stu-id="159a0-240">The example includes `Catch` statements for several types of exceptions, ordered from the most specific to the most general.</span></span>

[!code-vb[VbVbalrStatements#91](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#91)]

### <a name="the-catch-when-statement"></a><span data-ttu-id="159a0-241">Catch When ステートメント</span><span class="sxs-lookup"><span data-stu-id="159a0-241">The Catch When statement</span></span>

<span data-ttu-id="159a0-242">次の例では、`Catch When` ステートメントを使用して条件式をフィルター処理する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="159a0-242">The following example shows how to use a `Catch When` statement to filter on a conditional expression.</span></span> <span data-ttu-id="159a0-243">条件式が `True`と評価された場合、`Catch` ブロック内のコードが実行されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-243">If the conditional expression evaluates to `True`, the code in the `Catch` block runs.</span></span>

[!code-vb[VbVbalrStatements#92](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#92)]

### <a name="nested-try-statements"></a><span data-ttu-id="159a0-244">入れ子になった Try ステートメント</span><span class="sxs-lookup"><span data-stu-id="159a0-244">Nested Try statements</span></span>

<span data-ttu-id="159a0-245">次の例では、`Try` ブロックに含まれる `Try…Catch` ステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="159a0-245">The following example has a `Try…Catch` statement that is contained in a `Try` block.</span></span> <span data-ttu-id="159a0-246">内部 `Catch` ブロックは、`InnerException` プロパティが元の例外に設定されている例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="159a0-246">The inner `Catch` block throws an exception that has its `InnerException` property set to the original exception.</span></span> <span data-ttu-id="159a0-247">外側の `Catch` ブロックは、独自の例外と内部例外を報告します。</span><span class="sxs-lookup"><span data-stu-id="159a0-247">The outer `Catch` block reports its own exception and the inner exception.</span></span>

[!code-vb[VbVbalrStatements#93](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrStatements/VB/Class1.vb#93)]

### <a name="exception-handling-for-async-methods"></a><span data-ttu-id="159a0-248">非同期メソッドの例外処理</span><span class="sxs-lookup"><span data-stu-id="159a0-248">Exception handling for async methods</span></span>

<span data-ttu-id="159a0-249">次の例では、非同期メソッドの例外処理を示します。</span><span class="sxs-lookup"><span data-stu-id="159a0-249">The following example illustrates exception handling for async methods.</span></span> <span data-ttu-id="159a0-250">非同期タスクに適用される例外をキャッチするために、`Await` 式は呼び出し元の `Try` ブロックにあり、例外は `Catch` ブロックでキャッチされます。</span><span class="sxs-lookup"><span data-stu-id="159a0-250">To catch an exception that applies to an async task, the `Await` expression is in a `Try` block of the caller, and the exception is caught in the `Catch` block.</span></span>

<span data-ttu-id="159a0-251">例外処理を示すために、この例の `Throw New Exception` 行のコメントを解除します。</span><span class="sxs-lookup"><span data-stu-id="159a0-251">Uncomment the `Throw New Exception` line in the example to demonstrate exception handling.</span></span> <span data-ttu-id="159a0-252">例外は `Catch` ブロックでキャッチされ、タスクの `IsFaulted` プロパティは `True`に設定され、タスクの `Exception.InnerException` プロパティは例外に設定されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-252">The exception is caught in the `Catch` block, the task's `IsFaulted` property is set to `True`, and the task's `Exception.InnerException` property is set to the exception.</span></span>

<span data-ttu-id="159a0-253">`Throw New OperationCancelledException` 行のコメントを解除して、非同期処理を取り消したときに何が起こるかを示します。</span><span class="sxs-lookup"><span data-stu-id="159a0-253">Uncomment the `Throw New OperationCancelledException` line to demonstrate what happens when you cancel an asynchronous process.</span></span> <span data-ttu-id="159a0-254">例外は `Catch` ブロックでキャッチされ、タスクの `IsCanceled` プロパティは `True`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-254">The exception is caught in the `Catch` block, and the task's `IsCanceled` property is set to `True`.</span></span> <span data-ttu-id="159a0-255">ただし、この例には適用されない条件がある場合、`IsFaulted` は `True` に設定され `IsCanceled` が `False`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="159a0-255">However, under some conditions that don't apply to this example, `IsFaulted` is set to `True` and `IsCanceled` is set to `False`.</span></span>

[!code-vb[csAsyncExceptions#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#1)]

### <a name="handling-multiple-exceptions-in-async-methods"></a><span data-ttu-id="159a0-256">非同期メソッドでの複数の例外の処理</span><span class="sxs-lookup"><span data-stu-id="159a0-256">Handling multiple exceptions in async methods</span></span>

<span data-ttu-id="159a0-257">次の例では、複数のタスクで複数の例外が発生する可能性がある例外処理について説明します。</span><span class="sxs-lookup"><span data-stu-id="159a0-257">The following example illustrates exception handling where multiple tasks can result in multiple exceptions.</span></span> <span data-ttu-id="159a0-258">`Try` ブロックには、返される <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> タスクの `Await` 式が含まれています。</span><span class="sxs-lookup"><span data-stu-id="159a0-258">The `Try` block has the `Await` expression for the task that <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> returned.</span></span> <span data-ttu-id="159a0-259"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> が適用される3つのタスクが完了すると、タスクが完了します。</span><span class="sxs-lookup"><span data-stu-id="159a0-259">The task is complete when the three tasks to which <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> is applied are complete.</span></span>

<span data-ttu-id="159a0-260">3 つのタスクでそれぞれ例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="159a0-260">Each of the three tasks causes an exception.</span></span> <span data-ttu-id="159a0-261">`Catch` ブロックは、返される `Task.WhenAll` タスクの `Exception.InnerExceptions` プロパティで検出された例外を反復処理します。</span><span class="sxs-lookup"><span data-stu-id="159a0-261">The `Catch` block iterates through the exceptions, which are found in the `Exception.InnerExceptions` property of the task that `Task.WhenAll` returned.</span></span>

[!code-vb[csAsyncExceptions#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/csasyncexceptions/vb/class1.vb#3)]

## <a name="see-also"></a><span data-ttu-id="159a0-262">関連項目</span><span class="sxs-lookup"><span data-stu-id="159a0-262">See also</span></span>

- <xref:Microsoft.VisualBasic.Information.Err%2A>
- <xref:System.Exception>
- [<span data-ttu-id="159a0-263">Exit ステートメント</span><span class="sxs-lookup"><span data-stu-id="159a0-263">Exit Statement</span></span>](exit-statement.md)
- [<span data-ttu-id="159a0-264">On Error ステートメント</span><span class="sxs-lookup"><span data-stu-id="159a0-264">On Error Statement</span></span>](on-error-statement.md)
- [<span data-ttu-id="159a0-265">コード スニペットを使用するためのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="159a0-265">Best Practices for Using Code Snippets</span></span>](/visualstudio/ide/best-practices-for-using-code-snippets)
- [<span data-ttu-id="159a0-266">例外処理</span><span class="sxs-lookup"><span data-stu-id="159a0-266">Exception Handling</span></span>](../../../standard/parallel-programming/exception-handling-task-parallel-library.md)
- [<span data-ttu-id="159a0-267">Throw ステートメント</span><span class="sxs-lookup"><span data-stu-id="159a0-267">Throw Statement</span></span>](throw-statement.md)
