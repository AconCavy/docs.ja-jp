---
title: 信頼性の規則 (コード分析)
description: コード分析の信頼性の規則について説明します。
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2020
ms.locfileid: "96591772"
---
# <a name="reliability-rules"></a><span data-ttu-id="05b3d-103">信頼性の規則</span><span class="sxs-lookup"><span data-stu-id="05b3d-103">Reliability rules</span></span>

<span data-ttu-id="05b3d-104">信頼性規則は、正しいメモリやスレッドの使用など、ライブラリとアプリケーションの信頼性をサポートします。</span><span class="sxs-lookup"><span data-stu-id="05b3d-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="05b3d-105">信頼性の規則は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="05b3d-105">The reliability rules include:</span></span>

|<span data-ttu-id="05b3d-106">ルール</span><span class="sxs-lookup"><span data-stu-id="05b3d-106">Rule</span></span>|<span data-ttu-id="05b3d-107">説明</span><span class="sxs-lookup"><span data-stu-id="05b3d-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="05b3d-108">CA2000:スコープを失う前にオブジェクトを破棄</span><span class="sxs-lookup"><span data-stu-id="05b3d-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="05b3d-109">例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトを明示的に破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="05b3d-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="05b3d-110">CA2002:弱い ID を伴うオブジェクト上でロックしません</span><span class="sxs-lookup"><span data-stu-id="05b3d-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="05b3d-111">アプリケーション ドメインの境界を越えてオブジェクトに直接アクセスできる場合、そのオブジェクトの ID は不十分と表現されます。</span><span class="sxs-lookup"><span data-stu-id="05b3d-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="05b3d-112">スレッドで ID が不十分なオブジェクトをロックしようとすると、ブロックされることがあります。たとえば、異なるアプリケーション ドメインの別スレッドで、既に同じオブジェクトがロックされている場合です。</span><span class="sxs-lookup"><span data-stu-id="05b3d-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="05b3d-113">CA2007:タスクを直接待機しないでください</span><span class="sxs-lookup"><span data-stu-id="05b3d-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="05b3d-114">非同期メソッドは[awaits](../../../csharp/language-reference/operators/await.md) 、を <xref:System.Threading.Tasks.Task> 直接待機します。</span><span class="sxs-lookup"><span data-stu-id="05b3d-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="05b3d-115">CA2008:TaskScheduler を渡さずにタスクを作成しない</span><span class="sxs-lookup"><span data-stu-id="05b3d-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="05b3d-116">タスクの作成または継続操作で、パラメーターを指定しないメソッドオーバーロードが使用さ <xref:System.Threading.Tasks.TaskScheduler> れています。</span><span class="sxs-lookup"><span data-stu-id="05b3d-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="05b3d-117">CA2009: ImmutableCollection 値で ToImmutableCollection を呼び出さないでください</span><span class="sxs-lookup"><span data-stu-id="05b3d-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="05b3d-118">`ToImmutable` メソッドは、名前空間から変更できないコレクションで不必要に呼び出されました <xref:System.Collections.Immutable> 。</span><span class="sxs-lookup"><span data-stu-id="05b3d-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="05b3d-119">CA2011: セッター内でプロパティを割り当てません</span><span class="sxs-lookup"><span data-stu-id="05b3d-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="05b3d-120">プロパティに、独自の [set アクセサー](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)内で誤って値が割り当てられました。</span><span class="sxs-lookup"><span data-stu-id="05b3d-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="05b3d-121">CA2012: ValueTask を正しく使用する必要があります</span><span class="sxs-lookup"><span data-stu-id="05b3d-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="05b3d-122">メンバーの呼び出しから返される ValueTasks は、直接待機することを意図しています。</span><span class="sxs-lookup"><span data-stu-id="05b3d-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="05b3d-123">ValueTask を複数回使用しようとするか、完了する前に1つの結果に直接アクセスすると、例外または破損が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05b3d-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="05b3d-124">このような ValueTask を無視すると、機能的なバグが示され、パフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05b3d-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="05b3d-125">CA2013: 値の型と共に ReferenceEquals を使用しないでください</span><span class="sxs-lookup"><span data-stu-id="05b3d-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="05b3d-126">を使用して値を比較するときに <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> 、obja と Obja が値型の場合、メソッドに渡される前にボックス化され <xref:System.Object.ReferenceEquals%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="05b3d-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="05b3d-127">これは、objA と Obja の両方が値型の同じインスタンスを表している場合でも、 <xref:System.Object.ReferenceEquals%2A> メソッドは false を返すことを意味します。</span><span class="sxs-lookup"><span data-stu-id="05b3d-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="05b3d-128">CA2014: ループで stackalloc を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="05b3d-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="05b3d-129">Stackalloc によって割り当てられるスタック領域は、現在のメソッドの呼び出しの最後にのみ解放されます。</span><span class="sxs-lookup"><span data-stu-id="05b3d-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="05b3d-130">ループでこれを使用すると、スタックが無制限に増加し、最終的にスタックオーバーフロー状態になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05b3d-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="05b3d-131">CA2015: MemoryManager T から派生した型に対してファイナライザーを定義しません &lt;&gt;</span><span class="sxs-lookup"><span data-stu-id="05b3d-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="05b3d-132">から派生した型にファイナライザーを追加する <xref:System.Buffers.MemoryManager%601> と、メモリがによってまだ使用されている間は解放される可能性があり <xref:System.Span%601> ます。</span><span class="sxs-lookup"><span data-stu-id="05b3d-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="05b3d-133">CA2016:CancellationToken パラメーターを 1 つのメソッドに転送する</span><span class="sxs-lookup"><span data-stu-id="05b3d-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="05b3d-134">操作の `CancellationToken` キャンセル通知が適切に反映されるように、またはトークンを意図的に伝達し `CancellationToken.None` ないことを示すために明示的に渡すメソッドにパラメーターを転送します。</span><span class="sxs-lookup"><span data-stu-id="05b3d-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
